/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Attribute, ChangeDetectorRef, ContentChildren, Directive, ElementRef, EventEmitter, forwardRef, Inject, Input, Output, QueryList, TemplateRef } from '@angular/core';
import { isDefined } from '../util/util';
import { NgbNavConfig } from './nav-config';
/** @type {?} */
import * as ɵngcc0 from '@angular/core';

const _c0 = ["href", ""];
const isValidNavId = (/**
 * @param {?} id
 * @return {?}
 */
(id) => isDefined(id) && id !== '');
const ɵ0 = isValidNavId;
/** @type {?} */
let navCounter = 0;
/**
 * Context passed to the nav content template.
 *
 * See [this demo](#/components/nav/examples#keep-content) as the example.
 *
 * \@since 5.2.0
 * @record
 */
export function NgbNavContentContext() { }
if (false) {
    /**
     * If `true`, current nav content is visible and active
     * @type {?}
     */
    NgbNavContentContext.prototype.$implicit;
}
/**
 * This directive must be used to wrap content to be displayed in the nav.
 *
 * \@since 5.2.0
 */
export class NgbNavContent {
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NgbNavContent.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbNavContent, selectors: [["ng-template", "ngbNavContent", ""]], factory: function NgbNavContent_Factory(t) { return new (t || NgbNavContent)(ɵngcc0.ɵɵdirectiveInject(TemplateRef)); } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbNavContent, [{
        type: Directive,
        args: [{ selector: 'ng-template[ngbNavContent]' }]
    }], function () { return [{ type: TemplateRef }]; }, { constructor: [], templateRef: [] });
/** @nocollapse */
NgbNavContent.ctorParameters = () => [
    { type: TemplateRef }
];
if (false) {
    /** @type {?} */
    NgbNavContent.prototype.templateRef;
}
/**
 * The directive used to group nav link and related nav content. As well as set nav identifier and some options.
 *
 * \@since 5.2.0
 */
export class NgbNavItem {
    /**
     * @param {?} nav
     * @param {?} elementRef
     */
    constructor(nav, elementRef) {
        this.elementRef = elementRef;
        /**
         * If `true`, the current nav item is disabled and can't be toggled by user.
         *
         * Nevertheless disabled nav can be selected programmatically via the `.select()` method and the `[activeId]` binding.
         */
        this.disabled = false;
        // TODO: cf https://github.com/angular/angular/issues/30106
        this._nav = nav;
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        // We are using @ContentChildren instead of @ContentChild as in the Angular version being used
        // only @ContentChildren allows us to specify the {descendants: false} option.
        // Without {descendants: false} we are hitting bugs described in:
        // https://github.com/ng-bootstrap/ng-bootstrap/issues/2240
        this.contentTpl = this.contentTpls.first;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!isDefined(this.domId)) {
            this.domId = `ngb-nav-${navCounter++}`;
        }
    }
    /**
     * @return {?}
     */
    get active() { return this._nav.activeId === this.id; }
    /**
     * @return {?}
     */
    get id() { return isValidNavId(this._id) ? this._id : this.domId; }
    /**
     * @return {?}
     */
    get panelDomId() { return `${this.domId}-panel`; }
    /**
     * @return {?}
     */
    isPanelInDom() {
        return (isDefined(this.destroyOnHide) ? !this.destroyOnHide : !this._nav.destroyOnHide) || this.active;
    }
}
NgbNavItem.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbNavItem, selectors: [["", "ngbNavItem", ""]], factory: function NgbNavItem_Factory(t) { return new (t || NgbNavItem)(ɵngcc0.ɵɵdirectiveInject(forwardRef(( /**
                     * @return {?}
                     */() => NgbNav))), ɵngcc0.ɵɵdirectiveInject(ElementRef)); }, contentQueries: function NgbNavItem_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbNavContent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.contentTpls = _t);
    } }, hostBindings: function NgbNavItem_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(1);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("nav-item", true);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { disabled: "disabled", domId: "domId", destroyOnHide: "destroyOnHide", _id: ["ngbNavItem", "_id"] }, exportAs: ["ngbNavItem"] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbNavItem, [{
        type: Directive,
        args: [{ selector: '[ngbNavItem]', exportAs: 'ngbNavItem', host: { '[class.nav-item]': 'true' } }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [forwardRef(( /**
                                     * @return {?}
                                     */() => NgbNav))]
            }] }, { type: ElementRef }]; }, { constructor: [], elementRef: [], disabled: [{
            type: Input
        }], _nav: [], ngAfterContentChecked: [], contentTpl: [], ngOnInit: [], domId: [{
            type: Input
        }], active: [], id: [], panelDomId: [], isPanelInDom: [], destroyOnHide: [{
            type: Input
        }], _id: [{
            type: Input,
            args: ['ngbNavItem']
        }], contentTpls: [{
            type: ContentChildren,
            args: [NgbNavContent, { descendants: false }]
        }] });
/** @nocollapse */
NgbNavItem.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => NgbNav)),] }] },
    { type: ElementRef }
];
NgbNavItem.propDecorators = {
    destroyOnHide: [{ type: Input }],
    disabled: [{ type: Input }],
    domId: [{ type: Input }],
    _id: [{ type: Input, args: ['ngbNavItem',] }],
    contentTpls: [{ type: ContentChildren, args: [NgbNavContent, { descendants: false },] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgbNavItem.prototype._nav;
    /**
     * If `true`, non-active current nav item content will be removed from DOM
     * Otherwise it will just be hidden
     * @type {?}
     */
    NgbNavItem.prototype.destroyOnHide;
    /**
     * If `true`, the current nav item is disabled and can't be toggled by user.
     *
     * Nevertheless disabled nav can be selected programmatically via the `.select()` method and the `[activeId]` binding.
     * @type {?}
     */
    NgbNavItem.prototype.disabled;
    /**
     * The id used for the DOM elements.
     * Must be unique inside the document in case you have multiple `ngbNav`s on the page.
     *
     * Autogenerated as `ngb-nav-XXX` if not provided.
     * @type {?}
     */
    NgbNavItem.prototype.domId;
    /**
     * The id used as a model for active nav.
     * It can be anything, but must be unique inside one `ngbNav`.
     *
     * The only limitation is that it is not possible to have the `''` (empty string) as id,
     * because ` ngbNavItem `, `ngbNavItem=''` and `[ngbNavItem]="''"` are indistinguishable
     * @type {?}
     */
    NgbNavItem.prototype._id;
    /** @type {?} */
    NgbNavItem.prototype.contentTpl;
    /** @type {?} */
    NgbNavItem.prototype.contentTpls;
    /** @type {?} */
    NgbNavItem.prototype.elementRef;
}
/**
 * A nav directive that helps with implementing tabbed navigation components.
 *
 * \@since 5.2.0
 */
export class NgbNav {
    /**
     * @param {?} role
     * @param {?} config
     * @param {?} _cd
     */
    constructor(role, config, _cd) {
        this.role = role;
        this._cd = _cd;
        /**
         * The event emitted after the active nav changes
         * The payload of the event is the newly active nav id
         *
         * If you want to prevent nav change, you should use `(navChange)` event
         */
        this.activeIdChange = new EventEmitter();
        /**
         * The nav change event emitted right before the nav change happens on user click.
         *
         * This event won't be emitted if nav is changed programmatically via `[activeId]` or `.select()`.
         *
         * See [`NgbNavChangeEvent`](#/components/nav/api#NgbNavChangeEvent) for payload details.
         */
        this.navChange = new EventEmitter();
        this.destroyOnHide = config.destroyOnHide;
        this.orientation = config.orientation;
        this.roles = config.roles;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    click(item) {
        if (!item.disabled) {
            this._updateActiveId(item.id);
        }
    }
    /**
     * Selects the nav with the given id and shows its associated pane.
     * Any other nav that was previously selected becomes unselected and its associated pane is hidden.
     * @param {?} id
     * @return {?}
     */
    select(id) { this._updateActiveId(id, false); }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (!isDefined(this.activeId)) {
            /** @type {?} */
            const nextId = this.items.first ? this.items.first.id : null;
            if (isValidNavId(nextId)) {
                this._updateActiveId(nextId, false);
                this._cd.detectChanges();
            }
        }
    }
    /**
     * @private
     * @param {?} nextId
     * @param {?=} emitNavChange
     * @return {?}
     */
    _updateActiveId(nextId, emitNavChange = true) {
        if (this.activeId !== nextId) {
            /** @type {?} */
            let defaultPrevented = false;
            if (emitNavChange) {
                this.navChange.emit({ activeId: this.activeId, nextId, preventDefault: (/**
                     * @return {?}
                     */
                    () => { defaultPrevented = true; }) });
            }
            if (!defaultPrevented) {
                this.activeId = nextId;
                this.activeIdChange.emit(nextId);
            }
        }
    }
}
NgbNav.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbNav, selectors: [["", "ngbNav", ""]], factory: function NgbNav_Factory(t) { return new (t || NgbNav)(ɵngcc0.ɵɵinjectAttribute('role'), ɵngcc0.ɵɵdirectiveInject(NgbNavConfig), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef)); }, contentQueries: function NgbNav_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbNavItem, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.items = _t);
    } }, hostBindings: function NgbNav_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(4);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-orientation", ctx.orientation === "vertical" && ctx.roles === "tablist" ? "vertical" : undefined)("role", ctx.role ? ctx.role : ctx.roles ? "tablist" : undefined);
        ɵngcc0.ɵɵclassProp("nav", true);
        ɵngcc0.ɵɵclassProp("flex-column", ctx.orientation === "vertical");
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { destroyOnHide: "destroyOnHide", orientation: "orientation", roles: "roles", activeId: "activeId" }, outputs: { activeIdChange: "activeIdChange", navChange: "navChange" }, exportAs: ["ngbNav"] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbNav, [{
        type: Directive,
        args: [{
                selector: '[ngbNav]',
                exportAs: 'ngbNav',
                host: {
                    '[class.nav]': 'true',
                    '[class.flex-column]': `orientation === 'vertical'`,
                    '[attr.aria-orientation]': `orientation === 'vertical' && roles === 'tablist' ? 'vertical' : undefined`,
                    '[attr.role]': `role ? role : roles ? 'tablist' : undefined`
                }
            }]
    }], function () { return [{ type: String, decorators: [{
                type: Attribute,
                args: ['role']
            }] }, { type: NgbNavConfig }, { type: ChangeDetectorRef }]; }, { constructor: [], role: [], _cd: [], activeIdChange: [{
            type: Output
        }], navChange: [{
            type: Output
        }], destroyOnHide: [{
            type: Input
        }], orientation: [{
            type: Input
        }], roles: [{
            type: Input
        }], click: [], select: [], ngAfterContentInit: [], _updateActiveId: [], activeId: [{
            type: Input
        }], items: [{
            type: ContentChildren,
            args: [NgbNavItem]
        }] });
/** @nocollapse */
NgbNav.ctorParameters = () => [
    { type: String, decorators: [{ type: Attribute, args: ['role',] }] },
    { type: NgbNavConfig },
    { type: ChangeDetectorRef }
];
NgbNav.propDecorators = {
    activeId: [{ type: Input }],
    activeIdChange: [{ type: Output }],
    destroyOnHide: [{ type: Input }],
    orientation: [{ type: Input }],
    roles: [{ type: Input }],
    items: [{ type: ContentChildren, args: [NgbNavItem,] }],
    navChange: [{ type: Output }]
};
if (false) {
    /**
     * The id of the nav that should be active
     *
     * You could also use the `.select()` method and the `(navChange)` event
     * @type {?}
     */
    NgbNav.prototype.activeId;
    /**
     * The event emitted after the active nav changes
     * The payload of the event is the newly active nav id
     *
     * If you want to prevent nav change, you should use `(navChange)` event
     * @type {?}
     */
    NgbNav.prototype.activeIdChange;
    /**
     * If `true`, non-active nav content will be removed from DOM
     * Otherwise it will just be hidden
     * @type {?}
     */
    NgbNav.prototype.destroyOnHide;
    /**
     * The orientation of navs.
     *
     * Using `vertical` will also add the `aria-orientation` attribute
     * @type {?}
     */
    NgbNav.prototype.orientation;
    /**
     * Role attribute generating strategy:
     * - `false` - no role attributes will be generated
     * - `'tablist'` - 'tablist', 'tab' and 'tabpanel' will be generated (default)
     * @type {?}
     */
    NgbNav.prototype.roles;
    /** @type {?} */
    NgbNav.prototype.items;
    /**
     * The nav change event emitted right before the nav change happens on user click.
     *
     * This event won't be emitted if nav is changed programmatically via `[activeId]` or `.select()`.
     *
     * See [`NgbNavChangeEvent`](#/components/nav/api#NgbNavChangeEvent) for payload details.
     * @type {?}
     */
    NgbNav.prototype.navChange;
    /** @type {?} */
    NgbNav.prototype.role;
    /**
     * @type {?}
     * @private
     */
    NgbNav.prototype._cd;
}
/**
 * A directive to put on the nav link.
 *
 * \@since 5.2.0
 */
export class NgbNavLink {
    /**
     * @param {?} role
     * @param {?} navItem
     * @param {?} nav
     */
    constructor(role, navItem, nav) {
        this.role = role;
        this.navItem = navItem;
        this.nav = nav;
    }
    /**
     * @return {?}
     */
    hasNavItemClass() {
        // with alternative markup we have to add `.nav-item` class, because `ngbNavItem` is on the ng-container
        return this.navItem.elementRef.nativeElement.nodeType === Node.COMMENT_NODE;
    }
}
NgbNavLink.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbNavLink, selectors: [["a", "ngbNavLink", ""]], factory: function NgbNavLink_Factory(t) { return new (t || NgbNavLink)(ɵngcc0.ɵɵinjectAttribute('role'), ɵngcc0.ɵɵdirectiveInject(NgbNavItem), ɵngcc0.ɵɵdirectiveInject(NgbNav)); }, hostBindings: function NgbNavLink_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(10);
        ɵngcc0.ɵɵlistener("click", function NgbNavLink_click_HostBindingHandler($event) { ctx.nav.click(ctx.navItem); return $event.preventDefault(); });
        ɵngcc0.ɵɵelementHostAttrs(_c0);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("id", ctx.navItem.domId);
        ɵngcc0.ɵɵattribute("role", ctx.role ? ctx.role : ctx.nav.roles ? "tab" : undefined)("tabindex", ctx.navItem.disabled ? 0 - 1 : undefined)("aria-controls", ctx.navItem.isPanelInDom() ? ctx.navItem.panelDomId : null)("aria-selected", ctx.navItem.active)("aria-disabled", ctx.navItem.disabled);
        ɵngcc0.ɵɵclassProp("nav-link", true);
        ɵngcc0.ɵɵclassProp("nav-item", ctx.hasNavItemClass());
        ɵngcc0.ɵɵclassProp("active", ctx.navItem.active);
        ɵngcc0.ɵɵclassProp("disabled", ctx.navItem.disabled);
        ɵngcc0.ɵɵstylingApply();
    } } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbNavLink, [{
        type: Directive,
        args: [{
                selector: 'a[ngbNavLink]',
                host: {
                    '[id]': 'navItem.domId',
                    '[class.nav-link]': 'true',
                    '[class.nav-item]': 'hasNavItemClass()',
                    '[attr.role]': `role ? role : nav.roles ? 'tab' : undefined`,
                    'href': '',
                    '[class.active]': 'navItem.active',
                    '[class.disabled]': 'navItem.disabled',
                    '[attr.tabindex]': 'navItem.disabled ? -1 : undefined',
                    '[attr.aria-controls]': 'navItem.isPanelInDom() ? navItem.panelDomId : null',
                    '[attr.aria-selected]': 'navItem.active',
                    '[attr.aria-disabled]': 'navItem.disabled',
                    '(click)': 'nav.click(navItem); $event.preventDefault()'
                }
            }]
    }], function () { return [{ type: String, decorators: [{
                type: Attribute,
                args: ['role']
            }] }, { type: NgbNavItem }, { type: NgbNav }]; }, { constructor: [], role: [], navItem: [], nav: [], hasNavItemClass: [] });
/** @nocollapse */
NgbNavLink.ctorParameters = () => [
    { type: String, decorators: [{ type: Attribute, args: ['role',] }] },
    { type: NgbNavItem },
    { type: NgbNav }
];
if (false) {
    /** @type {?} */
    NgbNavLink.prototype.role;
    /** @type {?} */
    NgbNavLink.prototype.navItem;
    /** @type {?} */
    NgbNavLink.prototype.nav;
}
/**
 * The payload of the change event emitted right before the nav change happens on user click.
 *
 * This event won't be emitted if nav is changed programmatically via `[activeId]` or `.select()`.
 *
 * \@since 5.2.0
 * @record
 */
export function NgbNavChangeEvent() { }
if (false) {
    /**
     * Id of the currently active nav.
     * @type {?}
     */
    NgbNavChangeEvent.prototype.activeId;
    /**
     * Id of the newly selected nav.
     * @type {?}
     */
    NgbNavChangeEvent.prototype.nextId;
    /**
     * Function that will prevent nav change if called.
     * @type {?}
     */
    NgbNavChangeEvent.prototype.preventDefault;
}
export { ɵ0 };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQG5nLWJvb3RzdHJhcC9uZy1ib290c3RyYXAvZXNtMjAxNS9uYXYvbmF2LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztBQVFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9DQyw4RkFHQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrRUQsYUFHQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0ErSUQsYUFZQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E4RkQsdUlBbUJDIiwiZmlsZSI6Im5hdi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGNvbnN0YW50UHJvcGVydHksZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxuaW1wb3J0IHsgQXR0cmlidXRlLCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSW5qZWN0LCBJbnB1dCwgT3V0cHV0LCBRdWVyeUxpc3QsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IGlzRGVmaW5lZCB9IGZyb20gJy4uL3V0aWwvdXRpbCc7XHJcbmltcG9ydCB7IE5nYk5hdkNvbmZpZyB9IGZyb20gJy4vbmF2LWNvbmZpZyc7XHJcbi8qKiBAdHlwZSB7P30gKi9cclxuY29uc3QgaXNWYWxpZE5hdklkID0gKC8qKlxyXG4gKiBAcGFyYW0gez99IGlkXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG4oaWQpID0+IGlzRGVmaW5lZChpZCkgJiYgaWQgIT09ICcnKTtcclxuY29uc3QgybUwID0gaXNWYWxpZE5hdklkO1xyXG4vKiogQHR5cGUgez99ICovXHJcbmxldCBuYXZDb3VudGVyID0gMDtcclxuLyoqXHJcbiAqIENvbnRleHQgcGFzc2VkIHRvIHRoZSBuYXYgY29udGVudCB0ZW1wbGF0ZS5cclxuICpcclxuICogU2VlIFt0aGlzIGRlbW9dKCMvY29tcG9uZW50cy9uYXYvZXhhbXBsZXMja2VlcC1jb250ZW50KSBhcyB0aGUgZXhhbXBsZS5cclxuICpcclxuICogXFxAc2luY2UgNS4yLjBcclxuICogQHJlY29yZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE5nYk5hdkNvbnRlbnRDb250ZXh0KCkgeyB9XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBgdHJ1ZWAsIGN1cnJlbnQgbmF2IGNvbnRlbnQgaXMgdmlzaWJsZSBhbmQgYWN0aXZlXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiTmF2Q29udGVudENvbnRleHQucHJvdG90eXBlLiRpbXBsaWNpdDtcclxufVxyXG4vKipcclxuICogVGhpcyBkaXJlY3RpdmUgbXVzdCBiZSB1c2VkIHRvIHdyYXAgY29udGVudCB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIG5hdi5cclxuICpcclxuICogXFxAc2luY2UgNS4yLjBcclxuICovXHJcbmV4cG9ydCBjbGFzcyBOZ2JOYXZDb250ZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSB0ZW1wbGF0ZVJlZlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcclxuICAgIH1cclxufVxyXG5OZ2JOYXZDb250ZW50LmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICduZy10ZW1wbGF0ZVtuZ2JOYXZDb250ZW50XScgfSxdIH1cclxuXTtcclxuLyoqIEBub2NvbGxhcHNlICovXHJcbk5nYk5hdkNvbnRlbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXHJcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmIH1cclxuXTtcclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JOYXZDb250ZW50LnByb3RvdHlwZS50ZW1wbGF0ZVJlZjtcclxufVxyXG4vKipcclxuICogVGhlIGRpcmVjdGl2ZSB1c2VkIHRvIGdyb3VwIG5hdiBsaW5rIGFuZCByZWxhdGVkIG5hdiBjb250ZW50LiBBcyB3ZWxsIGFzIHNldCBuYXYgaWRlbnRpZmllciBhbmQgc29tZSBvcHRpb25zLlxyXG4gKlxyXG4gKiBcXEBzaW5jZSA1LjIuMFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE5nYk5hdkl0ZW0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5hdlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50UmVmXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hdiwgZWxlbWVudFJlZikge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgYHRydWVgLCB0aGUgY3VycmVudCBuYXYgaXRlbSBpcyBkaXNhYmxlZCBhbmQgY2FuJ3QgYmUgdG9nZ2xlZCBieSB1c2VyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogTmV2ZXJ0aGVsZXNzIGRpc2FibGVkIG5hdiBjYW4gYmUgc2VsZWN0ZWQgcHJvZ3JhbW1hdGljYWxseSB2aWEgdGhlIGAuc2VsZWN0KClgIG1ldGhvZCBhbmQgdGhlIGBbYWN0aXZlSWRdYCBiaW5kaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAvLyBUT0RPOiBjZiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8zMDEwNlxyXG4gICAgICAgIHRoaXMuX25hdiA9IG5hdjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgbmdBZnRlckNvbnRlbnRDaGVja2VkKCkge1xyXG4gICAgICAgIC8vIFdlIGFyZSB1c2luZyBAQ29udGVudENoaWxkcmVuIGluc3RlYWQgb2YgQENvbnRlbnRDaGlsZCBhcyBpbiB0aGUgQW5ndWxhciB2ZXJzaW9uIGJlaW5nIHVzZWRcclxuICAgICAgICAvLyBvbmx5IEBDb250ZW50Q2hpbGRyZW4gYWxsb3dzIHVzIHRvIHNwZWNpZnkgdGhlIHtkZXNjZW5kYW50czogZmFsc2V9IG9wdGlvbi5cclxuICAgICAgICAvLyBXaXRob3V0IHtkZXNjZW5kYW50czogZmFsc2V9IHdlIGFyZSBoaXR0aW5nIGJ1Z3MgZGVzY3JpYmVkIGluOlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uZy1ib290c3RyYXAvbmctYm9vdHN0cmFwL2lzc3Vlcy8yMjQwXHJcbiAgICAgICAgdGhpcy5jb250ZW50VHBsID0gdGhpcy5jb250ZW50VHBscy5maXJzdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgbmdPbkluaXQoKSB7XHJcbiAgICAgICAgaWYgKCFpc0RlZmluZWQodGhpcy5kb21JZCkpIHtcclxuICAgICAgICAgICAgdGhpcy5kb21JZCA9IGBuZ2ItbmF2LSR7bmF2Q291bnRlcisrfWA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBnZXQgYWN0aXZlKCkgeyByZXR1cm4gdGhpcy5fbmF2LmFjdGl2ZUlkID09PSB0aGlzLmlkOyB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGdldCBpZCgpIHsgcmV0dXJuIGlzVmFsaWROYXZJZCh0aGlzLl9pZCkgPyB0aGlzLl9pZCA6IHRoaXMuZG9tSWQ7IH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZ2V0IHBhbmVsRG9tSWQoKSB7IHJldHVybiBgJHt0aGlzLmRvbUlkfS1wYW5lbGA7IH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgaXNQYW5lbEluRG9tKCkge1xyXG4gICAgICAgIHJldHVybiAoaXNEZWZpbmVkKHRoaXMuZGVzdHJveU9uSGlkZSkgPyAhdGhpcy5kZXN0cm95T25IaWRlIDogIXRoaXMuX25hdi5kZXN0cm95T25IaWRlKSB8fCB0aGlzLmFjdGl2ZTtcclxuICAgIH1cclxufVxyXG5OZ2JOYXZJdGVtLmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdiTmF2SXRlbV0nLCBleHBvcnRBczogJ25nYk5hdkl0ZW0nLCBob3N0OiB7ICdbY2xhc3MubmF2LWl0ZW1dJzogJ3RydWUnIH0gfSxdIH1cclxuXTtcclxuLyoqIEBub2NvbGxhcHNlICovXHJcbk5nYk5hdkl0ZW0uY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXHJcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbZm9yd2FyZFJlZigoLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAoKSA9PiBOZ2JOYXYpKSxdIH1dIH0sXHJcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfVxyXG5dO1xyXG5OZ2JOYXZJdGVtLnByb3BEZWNvcmF0b3JzID0ge1xyXG4gICAgZGVzdHJveU9uSGlkZTogW3sgdHlwZTogSW5wdXQgfV0sXHJcbiAgICBkaXNhYmxlZDogW3sgdHlwZTogSW5wdXQgfV0sXHJcbiAgICBkb21JZDogW3sgdHlwZTogSW5wdXQgfV0sXHJcbiAgICBfaWQ6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ25nYk5hdkl0ZW0nLF0gfV0sXHJcbiAgICBjb250ZW50VHBsczogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTmdiTmF2Q29udGVudCwgeyBkZXNjZW5kYW50czogZmFsc2UgfSxdIH1dXHJcbn07XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIE5nYk5hdkl0ZW0ucHJvdG90eXBlLl9uYXY7XHJcbiAgICAvKipcclxuICAgICAqIElmIGB0cnVlYCwgbm9uLWFjdGl2ZSBjdXJyZW50IG5hdiBpdGVtIGNvbnRlbnQgd2lsbCBiZSByZW1vdmVkIGZyb20gRE9NXHJcbiAgICAgKiBPdGhlcndpc2UgaXQgd2lsbCBqdXN0IGJlIGhpZGRlblxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYk5hdkl0ZW0ucHJvdG90eXBlLmRlc3Ryb3lPbkhpZGU7XHJcbiAgICAvKipcclxuICAgICAqIElmIGB0cnVlYCwgdGhlIGN1cnJlbnQgbmF2IGl0ZW0gaXMgZGlzYWJsZWQgYW5kIGNhbid0IGJlIHRvZ2dsZWQgYnkgdXNlci5cclxuICAgICAqXHJcbiAgICAgKiBOZXZlcnRoZWxlc3MgZGlzYWJsZWQgbmF2IGNhbiBiZSBzZWxlY3RlZCBwcm9ncmFtbWF0aWNhbGx5IHZpYSB0aGUgYC5zZWxlY3QoKWAgbWV0aG9kIGFuZCB0aGUgYFthY3RpdmVJZF1gIGJpbmRpbmcuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiTmF2SXRlbS5wcm90b3R5cGUuZGlzYWJsZWQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpZCB1c2VkIGZvciB0aGUgRE9NIGVsZW1lbnRzLlxyXG4gICAgICogTXVzdCBiZSB1bmlxdWUgaW5zaWRlIHRoZSBkb2N1bWVudCBpbiBjYXNlIHlvdSBoYXZlIG11bHRpcGxlIGBuZ2JOYXZgcyBvbiB0aGUgcGFnZS5cclxuICAgICAqXHJcbiAgICAgKiBBdXRvZ2VuZXJhdGVkIGFzIGBuZ2ItbmF2LVhYWGAgaWYgbm90IHByb3ZpZGVkLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYk5hdkl0ZW0ucHJvdG90eXBlLmRvbUlkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaWQgdXNlZCBhcyBhIG1vZGVsIGZvciBhY3RpdmUgbmF2LlxyXG4gICAgICogSXQgY2FuIGJlIGFueXRoaW5nLCBidXQgbXVzdCBiZSB1bmlxdWUgaW5zaWRlIG9uZSBgbmdiTmF2YC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgb25seSBsaW1pdGF0aW9uIGlzIHRoYXQgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGhhdmUgdGhlIGAnJ2AgKGVtcHR5IHN0cmluZykgYXMgaWQsXHJcbiAgICAgKiBiZWNhdXNlIGAgbmdiTmF2SXRlbSBgLCBgbmdiTmF2SXRlbT0nJ2AgYW5kIGBbbmdiTmF2SXRlbV09XCInJ1wiYCBhcmUgaW5kaXN0aW5ndWlzaGFibGVcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JOYXZJdGVtLnByb3RvdHlwZS5faWQ7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JOYXZJdGVtLnByb3RvdHlwZS5jb250ZW50VHBsO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgTmdiTmF2SXRlbS5wcm90b3R5cGUuY29udGVudFRwbHM7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JOYXZJdGVtLnByb3RvdHlwZS5lbGVtZW50UmVmO1xyXG59XHJcbi8qKlxyXG4gKiBBIG5hdiBkaXJlY3RpdmUgdGhhdCBoZWxwcyB3aXRoIGltcGxlbWVudGluZyB0YWJiZWQgbmF2aWdhdGlvbiBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBcXEBzaW5jZSA1LjIuMFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE5nYk5hdiB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcm9sZVxyXG4gICAgICogQHBhcmFtIHs/fSBjb25maWdcclxuICAgICAqIEBwYXJhbSB7P30gX2NkXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHJvbGUsIGNvbmZpZywgX2NkKSB7XHJcbiAgICAgICAgdGhpcy5yb2xlID0gcm9sZTtcclxuICAgICAgICB0aGlzLl9jZCA9IF9jZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZXZlbnQgZW1pdHRlZCBhZnRlciB0aGUgYWN0aXZlIG5hdiBjaGFuZ2VzXHJcbiAgICAgICAgICogVGhlIHBheWxvYWQgb2YgdGhlIGV2ZW50IGlzIHRoZSBuZXdseSBhY3RpdmUgbmF2IGlkXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBJZiB5b3Ugd2FudCB0byBwcmV2ZW50IG5hdiBjaGFuZ2UsIHlvdSBzaG91bGQgdXNlIGAobmF2Q2hhbmdlKWAgZXZlbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjdGl2ZUlkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBuYXYgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgcmlnaHQgYmVmb3JlIHRoZSBuYXYgY2hhbmdlIGhhcHBlbnMgb24gdXNlciBjbGljay5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgZXZlbnQgd29uJ3QgYmUgZW1pdHRlZCBpZiBuYXYgaXMgY2hhbmdlZCBwcm9ncmFtbWF0aWNhbGx5IHZpYSBgW2FjdGl2ZUlkXWAgb3IgYC5zZWxlY3QoKWAuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBTZWUgW2BOZ2JOYXZDaGFuZ2VFdmVudGBdKCMvY29tcG9uZW50cy9uYXYvYXBpI05nYk5hdkNoYW5nZUV2ZW50KSBmb3IgcGF5bG9hZCBkZXRhaWxzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubmF2Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuZGVzdHJveU9uSGlkZSA9IGNvbmZpZy5kZXN0cm95T25IaWRlO1xyXG4gICAgICAgIHRoaXMub3JpZW50YXRpb24gPSBjb25maWcub3JpZW50YXRpb247XHJcbiAgICAgICAgdGhpcy5yb2xlcyA9IGNvbmZpZy5yb2xlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBpdGVtXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBjbGljayhpdGVtKSB7XHJcbiAgICAgICAgaWYgKCFpdGVtLmRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZUlkKGl0ZW0uaWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0cyB0aGUgbmF2IHdpdGggdGhlIGdpdmVuIGlkIGFuZCBzaG93cyBpdHMgYXNzb2NpYXRlZCBwYW5lLlxyXG4gICAgICogQW55IG90aGVyIG5hdiB0aGF0IHdhcyBwcmV2aW91c2x5IHNlbGVjdGVkIGJlY29tZXMgdW5zZWxlY3RlZCBhbmQgaXRzIGFzc29jaWF0ZWQgcGFuZSBpcyBoaWRkZW4uXHJcbiAgICAgKiBAcGFyYW0gez99IGlkXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBzZWxlY3QoaWQpIHsgdGhpcy5fdXBkYXRlQWN0aXZlSWQoaWQsIGZhbHNlKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XHJcbiAgICAgICAgaWYgKCFpc0RlZmluZWQodGhpcy5hY3RpdmVJZCkpIHtcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0SWQgPSB0aGlzLml0ZW1zLmZpcnN0ID8gdGhpcy5pdGVtcy5maXJzdC5pZCA6IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkTmF2SWQobmV4dElkKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQWN0aXZlSWQobmV4dElkLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jZC5kZXRlY3RDaGFuZ2VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IG5leHRJZFxyXG4gICAgICogQHBhcmFtIHs/PX0gZW1pdE5hdkNoYW5nZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgX3VwZGF0ZUFjdGl2ZUlkKG5leHRJZCwgZW1pdE5hdkNoYW5nZSA9IHRydWUpIHtcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmVJZCAhPT0gbmV4dElkKSB7XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgbGV0IGRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKGVtaXROYXZDaGFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubmF2Q2hhbmdlLmVtaXQoeyBhY3RpdmVJZDogdGhpcy5hY3RpdmVJZCwgbmV4dElkLCBwcmV2ZW50RGVmYXVsdDogKC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4geyBkZWZhdWx0UHJldmVudGVkID0gdHJ1ZTsgfSkgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUlkID0gbmV4dElkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVJZENoYW5nZS5lbWl0KG5leHRJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuTmdiTmF2LmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcclxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25nYk5hdl0nLFxyXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICduZ2JOYXYnLFxyXG4gICAgICAgICAgICAgICAgaG9zdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubmF2XSc6ICd0cnVlJyxcclxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLmZsZXgtY29sdW1uXSc6IGBvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJ2AsXHJcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtb3JpZW50YXRpb25dJzogYG9yaWVudGF0aW9uID09PSAndmVydGljYWwnICYmIHJvbGVzID09PSAndGFibGlzdCcgPyAndmVydGljYWwnIDogdW5kZWZpbmVkYCxcclxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIucm9sZV0nOiBgcm9sZSA/IHJvbGUgOiByb2xlcyA/ICd0YWJsaXN0JyA6IHVuZGVmaW5lZGAsXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXSB9XHJcbl07XHJcbi8qKiBAbm9jb2xsYXBzZSAqL1xyXG5OZ2JOYXYuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXHJcbiAgICB7IHR5cGU6IFN0cmluZywgZGVjb3JhdG9yczogW3sgdHlwZTogQXR0cmlidXRlLCBhcmdzOiBbJ3JvbGUnLF0gfV0gfSxcclxuICAgIHsgdHlwZTogTmdiTmF2Q29uZmlnIH0sXHJcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH1cclxuXTtcclxuTmdiTmF2LnByb3BEZWNvcmF0b3JzID0ge1xyXG4gICAgYWN0aXZlSWQ6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgYWN0aXZlSWRDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcclxuICAgIGRlc3Ryb3lPbkhpZGU6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgb3JpZW50YXRpb246IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgcm9sZXM6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgaXRlbXM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW05nYk5hdkl0ZW0sXSB9XSxcclxuICAgIG5hdkNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dXHJcbn07XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaWQgb2YgdGhlIG5hdiB0aGF0IHNob3VsZCBiZSBhY3RpdmVcclxuICAgICAqXHJcbiAgICAgKiBZb3UgY291bGQgYWxzbyB1c2UgdGhlIGAuc2VsZWN0KClgIG1ldGhvZCBhbmQgdGhlIGAobmF2Q2hhbmdlKWAgZXZlbnRcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JOYXYucHJvdG90eXBlLmFjdGl2ZUlkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZXZlbnQgZW1pdHRlZCBhZnRlciB0aGUgYWN0aXZlIG5hdiBjaGFuZ2VzXHJcbiAgICAgKiBUaGUgcGF5bG9hZCBvZiB0aGUgZXZlbnQgaXMgdGhlIG5ld2x5IGFjdGl2ZSBuYXYgaWRcclxuICAgICAqXHJcbiAgICAgKiBJZiB5b3Ugd2FudCB0byBwcmV2ZW50IG5hdiBjaGFuZ2UsIHlvdSBzaG91bGQgdXNlIGAobmF2Q2hhbmdlKWAgZXZlbnRcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JOYXYucHJvdG90eXBlLmFjdGl2ZUlkQ2hhbmdlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBgdHJ1ZWAsIG5vbi1hY3RpdmUgbmF2IGNvbnRlbnQgd2lsbCBiZSByZW1vdmVkIGZyb20gRE9NXHJcbiAgICAgKiBPdGhlcndpc2UgaXQgd2lsbCBqdXN0IGJlIGhpZGRlblxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYk5hdi5wcm90b3R5cGUuZGVzdHJveU9uSGlkZTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9yaWVudGF0aW9uIG9mIG5hdnMuXHJcbiAgICAgKlxyXG4gICAgICogVXNpbmcgYHZlcnRpY2FsYCB3aWxsIGFsc28gYWRkIHRoZSBgYXJpYS1vcmllbnRhdGlvbmAgYXR0cmlidXRlXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiTmF2LnByb3RvdHlwZS5vcmllbnRhdGlvbjtcclxuICAgIC8qKlxyXG4gICAgICogUm9sZSBhdHRyaWJ1dGUgZ2VuZXJhdGluZyBzdHJhdGVneTpcclxuICAgICAqIC0gYGZhbHNlYCAtIG5vIHJvbGUgYXR0cmlidXRlcyB3aWxsIGJlIGdlbmVyYXRlZFxyXG4gICAgICogLSBgJ3RhYmxpc3QnYCAtICd0YWJsaXN0JywgJ3RhYicgYW5kICd0YWJwYW5lbCcgd2lsbCBiZSBnZW5lcmF0ZWQgKGRlZmF1bHQpXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiTmF2LnByb3RvdHlwZS5yb2xlcztcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE5nYk5hdi5wcm90b3R5cGUuaXRlbXM7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYXYgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgcmlnaHQgYmVmb3JlIHRoZSBuYXYgY2hhbmdlIGhhcHBlbnMgb24gdXNlciBjbGljay5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGV2ZW50IHdvbid0IGJlIGVtaXR0ZWQgaWYgbmF2IGlzIGNoYW5nZWQgcHJvZ3JhbW1hdGljYWxseSB2aWEgYFthY3RpdmVJZF1gIG9yIGAuc2VsZWN0KClgLlxyXG4gICAgICpcclxuICAgICAqIFNlZSBbYE5nYk5hdkNoYW5nZUV2ZW50YF0oIy9jb21wb25lbnRzL25hdi9hcGkjTmdiTmF2Q2hhbmdlRXZlbnQpIGZvciBwYXlsb2FkIGRldGFpbHMuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiTmF2LnByb3RvdHlwZS5uYXZDaGFuZ2U7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JOYXYucHJvdG90eXBlLnJvbGU7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgTmdiTmF2LnByb3RvdHlwZS5fY2Q7XHJcbn1cclxuLyoqXHJcbiAqIEEgZGlyZWN0aXZlIHRvIHB1dCBvbiB0aGUgbmF2IGxpbmsuXHJcbiAqXHJcbiAqIFxcQHNpbmNlIDUuMi4wXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTmdiTmF2TGluayB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcm9sZVxyXG4gICAgICogQHBhcmFtIHs/fSBuYXZJdGVtXHJcbiAgICAgKiBAcGFyYW0gez99IG5hdlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihyb2xlLCBuYXZJdGVtLCBuYXYpIHtcclxuICAgICAgICB0aGlzLnJvbGUgPSByb2xlO1xyXG4gICAgICAgIHRoaXMubmF2SXRlbSA9IG5hdkl0ZW07XHJcbiAgICAgICAgdGhpcy5uYXYgPSBuYXY7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGhhc05hdkl0ZW1DbGFzcygpIHtcclxuICAgICAgICAvLyB3aXRoIGFsdGVybmF0aXZlIG1hcmt1cCB3ZSBoYXZlIHRvIGFkZCBgLm5hdi1pdGVtYCBjbGFzcywgYmVjYXVzZSBgbmdiTmF2SXRlbWAgaXMgb24gdGhlIG5nLWNvbnRhaW5lclxyXG4gICAgICAgIHJldHVybiB0aGlzLm5hdkl0ZW0uZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkNPTU1FTlRfTk9ERTtcclxuICAgIH1cclxufVxyXG5OZ2JOYXZMaW5rLmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcclxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYVtuZ2JOYXZMaW5rXScsXHJcbiAgICAgICAgICAgICAgICBob3N0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ1tpZF0nOiAnbmF2SXRlbS5kb21JZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5uYXYtbGlua10nOiAndHJ1ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5uYXYtaXRlbV0nOiAnaGFzTmF2SXRlbUNsYXNzKCknLFxyXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5yb2xlXSc6IGByb2xlID8gcm9sZSA6IG5hdi5yb2xlcyA/ICd0YWInIDogdW5kZWZpbmVkYCxcclxuICAgICAgICAgICAgICAgICAgICAnaHJlZic6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MuYWN0aXZlXSc6ICduYXZJdGVtLmFjdGl2ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5kaXNhYmxlZF0nOiAnbmF2SXRlbS5kaXNhYmxlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLnRhYmluZGV4XSc6ICduYXZJdGVtLmRpc2FibGVkID8gLTEgOiB1bmRlZmluZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWNvbnRyb2xzXSc6ICduYXZJdGVtLmlzUGFuZWxJbkRvbSgpID8gbmF2SXRlbS5wYW5lbERvbUlkIDogbnVsbCcsXHJcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtc2VsZWN0ZWRdJzogJ25hdkl0ZW0uYWN0aXZlJyxcclxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1kaXNhYmxlZF0nOiAnbmF2SXRlbS5kaXNhYmxlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgJyhjbGljayknOiAnbmF2LmNsaWNrKG5hdkl0ZW0pOyAkZXZlbnQucHJldmVudERlZmF1bHQoKSdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxdIH1cclxuXTtcclxuLyoqIEBub2NvbGxhcHNlICovXHJcbk5nYk5hdkxpbmsuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXHJcbiAgICB7IHR5cGU6IFN0cmluZywgZGVjb3JhdG9yczogW3sgdHlwZTogQXR0cmlidXRlLCBhcmdzOiBbJ3JvbGUnLF0gfV0gfSxcclxuICAgIHsgdHlwZTogTmdiTmF2SXRlbSB9LFxyXG4gICAgeyB0eXBlOiBOZ2JOYXYgfVxyXG5dO1xyXG5pZiAoZmFsc2UpIHtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE5nYk5hdkxpbmsucHJvdG90eXBlLnJvbGU7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JOYXZMaW5rLnByb3RvdHlwZS5uYXZJdGVtO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgTmdiTmF2TGluay5wcm90b3R5cGUubmF2O1xyXG59XHJcbi8qKlxyXG4gKiBUaGUgcGF5bG9hZCBvZiB0aGUgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgcmlnaHQgYmVmb3JlIHRoZSBuYXYgY2hhbmdlIGhhcHBlbnMgb24gdXNlciBjbGljay5cclxuICpcclxuICogVGhpcyBldmVudCB3b24ndCBiZSBlbWl0dGVkIGlmIG5hdiBpcyBjaGFuZ2VkIHByb2dyYW1tYXRpY2FsbHkgdmlhIGBbYWN0aXZlSWRdYCBvciBgLnNlbGVjdCgpYC5cclxuICpcclxuICogXFxAc2luY2UgNS4yLjBcclxuICogQHJlY29yZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE5nYk5hdkNoYW5nZUV2ZW50KCkgeyB9XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBuYXYuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiTmF2Q2hhbmdlRXZlbnQucHJvdG90eXBlLmFjdGl2ZUlkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZCBvZiB0aGUgbmV3bHkgc2VsZWN0ZWQgbmF2LlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYk5hdkNoYW5nZUV2ZW50LnByb3RvdHlwZS5uZXh0SWQ7XHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRoYXQgd2lsbCBwcmV2ZW50IG5hdiBjaGFuZ2UgaWYgY2FsbGVkLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYk5hdkNoYW5nZUV2ZW50LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdDtcclxufVxyXG5leHBvcnQgeyDJtTAgfTtcciJdfQ==