/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectorRef, ContentChild, ContentChildren, Directive, ElementRef, EventEmitter, forwardRef, Inject, Input, NgZone, Output, QueryList, Renderer2, Optional } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { fromEvent, Subject } from 'rxjs';
import { take } from 'rxjs/operators';
import { positionElements } from '../util/positioning';
import { ngbAutoClose } from '../util/autoclose';
import { Key } from '../util/key';
import { NgbDropdownConfig } from './dropdown-config';
import * as ɵngcc0 from '@angular/core';

const _c0 = [1, "dropdown-item"];
const _c1 = ["aria-haspopup", "true", 1, "dropdown-toggle"];
export class NgbNavbar {
}
NgbNavbar.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbNavbar, selectors: [["", 8, "navbar"]], factory: function NgbNavbar_Factory(t) { return new (t || NgbNavbar)(); } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbNavbar, [{
        type: Directive,
        args: [{ selector: '.navbar' }]
    }], null, null);
/**
 * A directive you should put on a dropdown item to enable keyboard navigation.
 * Arrow keys will move focus between items marked with this directive.
 *
 * \@since 4.1.0
 */
export class NgbDropdownItem {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this._disabled = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = (/** @type {?} */ (value)) === '' || value === true; // accept an empty attribute as true
    }
    /**
     * @return {?}
     */
    get disabled() { return this._disabled; }
}
NgbDropdownItem.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbDropdownItem, selectors: [["", "ngbDropdownItem", ""]], factory: function NgbDropdownItem_Factory(t) { return new (t || NgbDropdownItem)(ɵngcc0.ɵɵdirectiveInject(ElementRef)); }, hostBindings: function NgbDropdownItem_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(1);
        ɵngcc0.ɵɵelementHostAttrs(_c0);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("disabled", ctx.disabled);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { disabled: "disabled" } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbDropdownItem, [{
        type: Directive,
        args: [{ selector: '[ngbDropdownItem]', host: { 'class': 'dropdown-item', '[class.disabled]': 'disabled' } }]
    }], function () { return [{ type: ElementRef }]; }, { constructor: [], elementRef: [], _disabled: [], disabled: [{
            type: Input
        }], disabled: [] });
/** @nocollapse */
NgbDropdownItem.ctorParameters = () => [
    { type: ElementRef }
];
NgbDropdownItem.propDecorators = {
    disabled: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgbDropdownItem.prototype._disabled;
    /** @type {?} */
    NgbDropdownItem.prototype.elementRef;
}
/**
 * A directive that wraps dropdown menu content and dropdown items.
 */
export class NgbDropdownMenu {
    /**
     * @param {?} dropdown
     */
    constructor(dropdown) {
        this.dropdown = dropdown;
        this.placement = 'bottom';
        this.isOpen = false;
    }
}
NgbDropdownMenu.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbDropdownMenu, selectors: [["", "ngbDropdownMenu", ""]], factory: function NgbDropdownMenu_Factory(t) { return new (t || NgbDropdownMenu)(ɵngcc0.ɵɵdirectiveInject(forwardRef(( /**
                     * @return {?}
                     */() => NgbDropdown)))); }, contentQueries: function NgbDropdownMenu_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbDropdownItem, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.menuItems = _t);
    } }, hostBindings: function NgbDropdownMenu_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(3);
        ɵngcc0.ɵɵlistener("keydown.ArrowUp", function NgbDropdownMenu_keydown_ArrowUp_HostBindingHandler($event) { return ctx.dropdown.onKeyDown($event); });
        ɵngcc0.ɵɵlistener("keydown.ArrowDown", function NgbDropdownMenu_keydown_ArrowDown_HostBindingHandler($event) { return ctx.dropdown.onKeyDown($event); });
        ɵngcc0.ɵɵlistener("keydown.Home", function NgbDropdownMenu_keydown_Home_HostBindingHandler($event) { return ctx.dropdown.onKeyDown($event); });
        ɵngcc0.ɵɵlistener("keydown.End", function NgbDropdownMenu_keydown_End_HostBindingHandler($event) { return ctx.dropdown.onKeyDown($event); });
        ɵngcc0.ɵɵlistener("keydown.Enter", function NgbDropdownMenu_keydown_Enter_HostBindingHandler($event) { return ctx.dropdown.onKeyDown($event); });
        ɵngcc0.ɵɵlistener("keydown.Space", function NgbDropdownMenu_keydown_Space_HostBindingHandler($event) { return ctx.dropdown.onKeyDown($event); });
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("x-placement", ctx.placement);
        ɵngcc0.ɵɵclassProp("dropdown-menu", true);
        ɵngcc0.ɵɵclassProp("show", ctx.dropdown.isOpen());
        ɵngcc0.ɵɵstylingApply();
    } } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbDropdownMenu, [{
        type: Directive,
        args: [{
                selector: '[ngbDropdownMenu]',
                host: {
                    '[class.dropdown-menu]': 'true',
                    '[class.show]': 'dropdown.isOpen()',
                    '[attr.x-placement]': 'placement',
                    '(keydown.ArrowUp)': 'dropdown.onKeyDown($event)',
                    '(keydown.ArrowDown)': 'dropdown.onKeyDown($event)',
                    '(keydown.Home)': 'dropdown.onKeyDown($event)',
                    '(keydown.End)': 'dropdown.onKeyDown($event)',
                    '(keydown.Enter)': 'dropdown.onKeyDown($event)',
                    '(keydown.Space)': 'dropdown.onKeyDown($event)'
                }
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [forwardRef(( /**
                                     * @return {?}
                                     */() => NgbDropdown))]
            }] }]; }, { constructor: [], dropdown: [], placement: [], isOpen: [], menuItems: [{
            type: ContentChildren,
            args: [NgbDropdownItem]
        }] });
/** @nocollapse */
NgbDropdownMenu.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => NgbDropdown)),] }] }
];
NgbDropdownMenu.propDecorators = {
    menuItems: [{ type: ContentChildren, args: [NgbDropdownItem,] }]
};
if (false) {
    /** @type {?} */
    NgbDropdownMenu.prototype.placement;
    /** @type {?} */
    NgbDropdownMenu.prototype.isOpen;
    /** @type {?} */
    NgbDropdownMenu.prototype.menuItems;
    /** @type {?} */
    NgbDropdownMenu.prototype.dropdown;
}
/**
 * A directive to mark an element to which dropdown menu will be anchored.
 *
 * This is a simple version of the `NgbDropdownToggle` directive.
 * It plays the same role, but doesn't listen to click events to toggle dropdown menu thus enabling support
 * for events other than click.
 *
 * \@since 1.1.0
 */
export class NgbDropdownAnchor {
    /**
     * @param {?} dropdown
     * @param {?} _elementRef
     */
    constructor(dropdown, _elementRef) {
        this.dropdown = dropdown;
        this._elementRef = _elementRef;
        this.anchorEl = _elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    getNativeElement() { return this._elementRef.nativeElement; }
}
NgbDropdownAnchor.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbDropdownAnchor, selectors: [["", "ngbDropdownAnchor", ""]], factory: function NgbDropdownAnchor_Factory(t) { return new (t || NgbDropdownAnchor)(ɵngcc0.ɵɵdirectiveInject(forwardRef(( /**
                     * @return {?}
                     */() => NgbDropdown))), ɵngcc0.ɵɵdirectiveInject(ElementRef)); }, hostBindings: function NgbDropdownAnchor_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(1);
        ɵngcc0.ɵɵelementHostAttrs(_c1);
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-expanded", ctx.dropdown.isOpen());
    } } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbDropdownAnchor, [{
        type: Directive,
        args: [{
                selector: '[ngbDropdownAnchor]',
                host: { 'class': 'dropdown-toggle', 'aria-haspopup': 'true', '[attr.aria-expanded]': 'dropdown.isOpen()' }
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [forwardRef(( /**
                                     * @return {?}
                                     */() => NgbDropdown))]
            }] }, { type: ElementRef }]; }, { constructor: [], dropdown: [], _elementRef: [], anchorEl: [], getNativeElement: [] });
/** @nocollapse */
NgbDropdownAnchor.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => NgbDropdown)),] }] },
    { type: ElementRef }
];
if (false) {
    /** @type {?} */
    NgbDropdownAnchor.prototype.anchorEl;
    /** @type {?} */
    NgbDropdownAnchor.prototype.dropdown;
    /**
     * @type {?}
     * @private
     */
    NgbDropdownAnchor.prototype._elementRef;
}
/**
 * A directive to mark an element that will toggle dropdown via the `click` event.
 *
 * You can also use `NgbDropdownAnchor` as an alternative.
 */
export class NgbDropdownToggle extends NgbDropdownAnchor {
    /**
     * @param {?} dropdown
     * @param {?} elementRef
     */
    constructor(dropdown, elementRef) {
        super(dropdown, elementRef);
    }
}
NgbDropdownToggle.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbDropdownToggle, selectors: [["", "ngbDropdownToggle", ""]], factory: function NgbDropdownToggle_Factory(t) { return new (t || NgbDropdownToggle)(ɵngcc0.ɵɵdirectiveInject(forwardRef(( /**
                     * @return {?}
                     */() => NgbDropdown))), ɵngcc0.ɵɵdirectiveInject(ElementRef)); }, hostBindings: function NgbDropdownToggle_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(1);
        ɵngcc0.ɵɵlistener("click", function NgbDropdownToggle_click_HostBindingHandler($event) { return ctx.dropdown.toggle(); });
        ɵngcc0.ɵɵlistener("keydown.ArrowUp", function NgbDropdownToggle_keydown_ArrowUp_HostBindingHandler($event) { return ctx.dropdown.onKeyDown($event); });
        ɵngcc0.ɵɵlistener("keydown.ArrowDown", function NgbDropdownToggle_keydown_ArrowDown_HostBindingHandler($event) { return ctx.dropdown.onKeyDown($event); });
        ɵngcc0.ɵɵlistener("keydown.Home", function NgbDropdownToggle_keydown_Home_HostBindingHandler($event) { return ctx.dropdown.onKeyDown($event); });
        ɵngcc0.ɵɵlistener("keydown.End", function NgbDropdownToggle_keydown_End_HostBindingHandler($event) { return ctx.dropdown.onKeyDown($event); });
        ɵngcc0.ɵɵelementHostAttrs(_c1);
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-expanded", ctx.dropdown.isOpen());
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NgbDropdownAnchor, useExisting: forwardRef(( /**
                         * @return {?}
                         */() => NgbDropdownToggle)) }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbDropdownToggle, [{
        type: Directive,
        args: [{
                selector: '[ngbDropdownToggle]',
                host: {
                    'class': 'dropdown-toggle',
                    'aria-haspopup': 'true',
                    '[attr.aria-expanded]': 'dropdown.isOpen()',
                    '(click)': 'dropdown.toggle()',
                    '(keydown.ArrowUp)': 'dropdown.onKeyDown($event)',
                    '(keydown.ArrowDown)': 'dropdown.onKeyDown($event)',
                    '(keydown.Home)': 'dropdown.onKeyDown($event)',
                    '(keydown.End)': 'dropdown.onKeyDown($event)'
                },
                providers: [{ provide: NgbDropdownAnchor, useExisting: forwardRef(( /**
                                 * @return {?}
                                 */() => NgbDropdownToggle)) }]
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [forwardRef(( /**
                                     * @return {?}
                                     */() => NgbDropdown))]
            }] }, { type: ElementRef }]; }, { constructor: [] });
/** @nocollapse */
NgbDropdownToggle.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => NgbDropdown)),] }] },
    { type: ElementRef }
];
/**
 * A directive that provides contextual overlays for displaying lists of links and more.
 */
export class NgbDropdown {
    /**
     * @param {?} _changeDetector
     * @param {?} config
     * @param {?} _document
     * @param {?} _ngZone
     * @param {?} _elementRef
     * @param {?} _renderer
     * @param {?} ngbNavbar
     */
    constructor(_changeDetector, config, _document, _ngZone, _elementRef, _renderer, ngbNavbar) {
        this._changeDetector = _changeDetector;
        this._document = _document;
        this._ngZone = _ngZone;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._closed$ = new Subject();
        /**
         * Defines whether or not the dropdown menu is opened initially.
         */
        this._open = false;
        /**
         * An event fired when the dropdown is opened or closed.
         *
         * The event payload is a `boolean`:
         * * `true` - the dropdown was opened
         * * `false` - the dropdown was closed
         */
        this.openChange = new EventEmitter();
        this.placement = config.placement;
        this.container = config.container;
        this.autoClose = config.autoClose;
        this.display = ngbNavbar ? 'static' : 'dynamic';
        this._zoneSubscription = _ngZone.onStable.subscribe((/**
         * @return {?}
         */
        () => { this._positionMenu(); }));
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._ngZone.onStable.pipe(take(1)).subscribe((/**
         * @return {?}
         */
        () => {
            this._applyPlacementClasses();
            if (this._open) {
                this._setCloseHandlers();
            }
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.container && this._open) {
            this._applyContainer(this.container);
        }
        if (changes.placement && !changes.placement.isFirstChange) {
            this._applyPlacementClasses();
        }
    }
    /**
     * Checks if the dropdown menu is open.
     * @return {?}
     */
    isOpen() { return this._open; }
    /**
     * Opens the dropdown menu.
     * @return {?}
     */
    open() {
        if (!this._open) {
            this._open = true;
            this._applyContainer(this.container);
            this.openChange.emit(true);
            this._setCloseHandlers();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _setCloseHandlers() {
        /** @type {?} */
        const anchor = this._anchor;
        ngbAutoClose(this._ngZone, this._document, this.autoClose, (/**
         * @return {?}
         */
        () => this.close()), this._closed$, this._menu ? [this._menuElement.nativeElement] : [], anchor ? [anchor.getNativeElement()] : [], '.dropdown-item,.dropdown-divider');
    }
    /**
     * Closes the dropdown menu.
     * @return {?}
     */
    close() {
        if (this._open) {
            this._open = false;
            this._resetContainer();
            this._closed$.next();
            this.openChange.emit(false);
            this._changeDetector.markForCheck();
        }
    }
    /**
     * Toggles the dropdown menu.
     * @return {?}
     */
    toggle() {
        if (this.isOpen()) {
            this.close();
        }
        else {
            this.open();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._resetContainer();
        this._closed$.next();
        this._zoneSubscription.unsubscribe();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        // tslint:disable-next-line:deprecation
        /** @type {?} */
        const key = event.which;
        /** @type {?} */
        const itemElements = this._getMenuElements();
        /** @type {?} */
        let position = -1;
        /** @type {?} */
        let isEventFromItems = false;
        /** @type {?} */
        let itemElement = null;
        /** @type {?} */
        const isEventFromToggle = this._isEventFromToggle(event);
        if (!isEventFromToggle && itemElements.length) {
            itemElements.forEach((/**
             * @param {?} item
             * @param {?} index
             * @return {?}
             */
            (item, index) => {
                if (item.contains((/** @type {?} */ (event.target)))) {
                    isEventFromItems = true;
                    itemElement = item;
                }
                if (item === this._document.activeElement) {
                    position = index;
                }
            }));
        }
        // closing on Enter / Space
        if (key === Key.Space || key === Key.Enter) {
            if (isEventFromItems && (this.autoClose === true || this.autoClose === 'inside')) {
                // Item is either a button or a link, so click will be triggered by the browser on Enter or Space.
                // So we have to register a one-time click handler that will fire after any user defined click handlers
                // to close the dropdown
                fromEvent(itemElement, 'click').pipe(take(1)).subscribe((/**
                 * @return {?}
                 */
                () => this.close()));
            }
            return;
        }
        // opening / navigating
        if (isEventFromToggle || isEventFromItems) {
            this.open();
            if (itemElements.length) {
                switch (key) {
                    case Key.ArrowDown:
                        position = Math.min(position + 1, itemElements.length - 1);
                        break;
                    case Key.ArrowUp:
                        if (this._isDropup() && position === -1) {
                            position = itemElements.length - 1;
                            break;
                        }
                        position = Math.max(position - 1, 0);
                        break;
                    case Key.Home:
                        position = 0;
                        break;
                    case Key.End:
                        position = itemElements.length - 1;
                        break;
                }
                itemElements[position].focus();
            }
            event.preventDefault();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _isDropup() { return this._elementRef.nativeElement.classList.contains('dropup'); }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    _isEventFromToggle(event) {
        return this._anchor.getNativeElement().contains((/** @type {?} */ (event.target)));
    }
    /**
     * @private
     * @return {?}
     */
    _getMenuElements() {
        /** @type {?} */
        const menu = this._menu;
        if (menu == null) {
            return [];
        }
        return menu.menuItems.filter((/**
         * @param {?} item
         * @return {?}
         */
        item => !item.disabled)).map((/**
         * @param {?} item
         * @return {?}
         */
        item => item.elementRef.nativeElement));
    }
    /**
     * @private
     * @return {?}
     */
    _positionMenu() {
        /** @type {?} */
        const menu = this._menu;
        if (this.isOpen() && menu) {
            this._applyPlacementClasses(this.display === 'dynamic' ?
                positionElements(this._anchor.anchorEl, this._bodyContainer || this._menuElement.nativeElement, this.placement, this.container === 'body') :
                this._getFirstPlacement(this.placement));
        }
    }
    /**
     * @private
     * @param {?} placement
     * @return {?}
     */
    _getFirstPlacement(placement) {
        return Array.isArray(placement) ? placement[0] : (/** @type {?} */ (placement.split(' ')[0]));
    }
    /**
     * @private
     * @return {?}
     */
    _resetContainer() {
        /** @type {?} */
        const renderer = this._renderer;
        /** @type {?} */
        const menuElement = this._menuElement;
        if (menuElement) {
            /** @type {?} */
            const dropdownElement = this._elementRef.nativeElement;
            /** @type {?} */
            const dropdownMenuElement = menuElement.nativeElement;
            renderer.appendChild(dropdownElement, dropdownMenuElement);
            renderer.removeStyle(dropdownMenuElement, 'position');
            renderer.removeStyle(dropdownMenuElement, 'transform');
        }
        if (this._bodyContainer) {
            renderer.removeChild(this._document.body, this._bodyContainer);
            this._bodyContainer = null;
        }
    }
    /**
     * @private
     * @param {?=} container
     * @return {?}
     */
    _applyContainer(container = null) {
        this._resetContainer();
        if (container === 'body') {
            /** @type {?} */
            const renderer = this._renderer;
            /** @type {?} */
            const dropdownMenuElement = this._menuElement.nativeElement;
            /** @type {?} */
            const bodyContainer = this._bodyContainer = this._bodyContainer || renderer.createElement('div');
            // Override some styles to have the positionning working
            renderer.setStyle(bodyContainer, 'position', 'absolute');
            renderer.setStyle(dropdownMenuElement, 'position', 'static');
            renderer.setStyle(bodyContainer, 'z-index', '1050');
            renderer.appendChild(bodyContainer, dropdownMenuElement);
            renderer.appendChild(this._document.body, bodyContainer);
        }
    }
    /**
     * @private
     * @param {?=} placement
     * @return {?}
     */
    _applyPlacementClasses(placement) {
        /** @type {?} */
        const menu = this._menu;
        if (menu) {
            if (!placement) {
                placement = this._getFirstPlacement(this.placement);
            }
            /** @type {?} */
            const renderer = this._renderer;
            /** @type {?} */
            const dropdownElement = this._elementRef.nativeElement;
            // remove the current placement classes
            renderer.removeClass(dropdownElement, 'dropup');
            renderer.removeClass(dropdownElement, 'dropdown');
            menu.placement = this.display === 'static' ? null : placement;
            /*
                  * apply the new placement
                  * in case of top use up-arrow or down-arrow otherwise
                  */
            /** @type {?} */
            const dropdownClass = placement.search('^top') !== -1 ? 'dropup' : 'dropdown';
            renderer.addClass(dropdownElement, dropdownClass);
            /** @type {?} */
            const bodyContainer = this._bodyContainer;
            if (bodyContainer) {
                renderer.removeClass(bodyContainer, 'dropup');
                renderer.removeClass(bodyContainer, 'dropdown');
                renderer.addClass(bodyContainer, dropdownClass);
            }
        }
    }
}
NgbDropdown.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbDropdown, selectors: [["", "ngbDropdown", ""]], factory: function NgbDropdown_Factory(t) { return new (t || NgbDropdown)(ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NgbDropdownConfig), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(NgbNavbar, 8)); }, contentQueries: function NgbDropdown_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbDropdownMenu, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbDropdownMenu, true, ElementRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbDropdownAnchor, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx._menu = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx._menuElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx._anchor = _t.first);
    } }, hostBindings: function NgbDropdown_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(1);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("show", ctx.isOpen());
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { _open: ["open", "_open"], placement: "placement", container: "container", autoClose: "autoClose", display: "display" }, outputs: { openChange: "openChange" }, exportAs: ["ngbDropdown"], features: [ɵngcc0.ɵɵNgOnChangesFeature()] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbDropdown, [{
        type: Directive,
        args: [{ selector: '[ngbDropdown]', exportAs: 'ngbDropdown', host: { '[class.show]': 'isOpen()' } }]
    }], function () { return [{ type: ChangeDetectorRef }, { type: NgbDropdownConfig }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: NgZone }, { type: ElementRef }, { type: Renderer2 }, { type: NgbNavbar, decorators: [{
                type: Optional
            }] }]; }, { constructor: [], _changeDetector: [], _document: [], _ngZone: [], _elementRef: [], _renderer: [], _closed$: [], _open: [{
            type: Input,
            args: ['open']
        }], openChange: [{
            type: Output
        }], placement: [{
            type: Input
        }], container: [{
            type: Input
        }], autoClose: [{
            type: Input
        }], display: [{
            type: Input
        }], _zoneSubscription: [], ngAfterContentInit: [], ngOnChanges: [], isOpen: [], open: [], _setCloseHandlers: [], close: [], toggle: [], ngOnDestroy: [], onKeyDown: [], _isDropup: [], _isEventFromToggle: [], _getMenuElements: [], _positionMenu: [], _getFirstPlacement: [], _resetContainer: [], _bodyContainer: [], _applyContainer: [], _applyPlacementClasses: [], _menu: [{
            type: ContentChild,
            args: [NgbDropdownMenu, { static: false }]
        }], _menuElement: [{
            type: ContentChild,
            args: [NgbDropdownMenu, { read: ElementRef, static: false }]
        }], _anchor: [{
            type: ContentChild,
            args: [NgbDropdownAnchor, { static: false }]
        }] });
/** @nocollapse */
NgbDropdown.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgbDropdownConfig },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: NgZone },
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgbNavbar, decorators: [{ type: Optional }] }
];
NgbDropdown.propDecorators = {
    _menu: [{ type: ContentChild, args: [NgbDropdownMenu, { static: false },] }],
    _menuElement: [{ type: ContentChild, args: [NgbDropdownMenu, { read: ElementRef, static: false },] }],
    _anchor: [{ type: ContentChild, args: [NgbDropdownAnchor, { static: false },] }],
    autoClose: [{ type: Input }],
    _open: [{ type: Input, args: ['open',] }],
    placement: [{ type: Input }],
    container: [{ type: Input }],
    display: [{ type: Input }],
    openChange: [{ type: Output }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgbDropdown.prototype._closed$;
    /**
     * @type {?}
     * @private
     */
    NgbDropdown.prototype._zoneSubscription;
    /**
     * @type {?}
     * @private
     */
    NgbDropdown.prototype._bodyContainer;
    /**
     * @type {?}
     * @private
     */
    NgbDropdown.prototype._menu;
    /**
     * @type {?}
     * @private
     */
    NgbDropdown.prototype._menuElement;
    /**
     * @type {?}
     * @private
     */
    NgbDropdown.prototype._anchor;
    /**
     * Indicates whether the dropdown should be closed when clicking one of dropdown items or pressing ESC.
     *
     * * `true` - the dropdown will close on both outside and inside (menu) clicks.
     * * `false` - the dropdown can only be closed manually via `close()` or `toggle()` methods.
     * * `"inside"` - the dropdown will close on inside menu clicks, but not outside clicks.
     * * `"outside"` - the dropdown will close only on the outside clicks and not on menu clicks.
     * @type {?}
     */
    NgbDropdown.prototype.autoClose;
    /**
     * Defines whether or not the dropdown menu is opened initially.
     * @type {?}
     */
    NgbDropdown.prototype._open;
    /**
     * The preferred placement of the dropdown.
     *
     * Possible values are `"top"`, `"top-left"`, `"top-right"`, `"bottom"`, `"bottom-left"`,
     * `"bottom-right"`, `"left"`, `"left-top"`, `"left-bottom"`, `"right"`, `"right-top"`,
     * `"right-bottom"`
     *
     * Accepts an array of strings or a string with space separated possible values.
     *
     * The default order of preference is `"bottom-left bottom-right top-left top-right"`
     *
     * Please see the [positioning overview](#/positioning) for more details.
     * @type {?}
     */
    NgbDropdown.prototype.placement;
    /**
     * A selector specifying the element the dropdown should be appended to.
     * Currently only supports "body".
     *
     * \@since 4.1.0
     * @type {?}
     */
    NgbDropdown.prototype.container;
    /**
     * Enable or disable the dynamic positioning. The default value is dynamic unless the dropdown is used
     * inside a Bootstrap navbar. If you need custom placement for a dropdown in a navbar, set it to
     * dynamic explicitly. See the [positioning of dropdown](#/positioning#dropdown)
     * and the [navbar demo](/#/components/dropdown/examples#navbar) for more details.
     *
     * \@since 4.2.0
     * @type {?}
     */
    NgbDropdown.prototype.display;
    /**
     * An event fired when the dropdown is opened or closed.
     *
     * The event payload is a `boolean`:
     * * `true` - the dropdown was opened
     * * `false` - the dropdown was closed
     * @type {?}
     */
    NgbDropdown.prototype.openChange;
    /**
     * @type {?}
     * @private
     */
    NgbDropdown.prototype._changeDetector;
    /**
     * @type {?}
     * @private
     */
    NgbDropdown.prototype._document;
    /**
     * @type {?}
     * @private
     */
    NgbDropdown.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    NgbDropdown.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    NgbDropdown.prototype._renderer;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQG5nLWJvb3RzdHJhcC9uZy1ib290c3RyYXAvZXNtMjAxNS9kcm9wZG93bi9kcm9wZG93bi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7OztBQVlBOzs7Ozs7Q0FDQyxtQkFHQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTBCRCwyQkFHQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTZCRCxhQWdCQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTRDRCxtSUFNQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUNELGdFQW1CQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTJWRCxhQUdDIiwiZmlsZSI6ImRyb3Bkb3duLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxyXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsY29uc3RhbnRQcm9wZXJ0eSxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXHJcbiAqL1xyXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgQ29udGVudENoaWxkLCBDb250ZW50Q2hpbGRyZW4sIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBmb3J3YXJkUmVmLCBJbmplY3QsIElucHV0LCBOZ1pvbmUsIE91dHB1dCwgUXVlcnlMaXN0LCBSZW5kZXJlcjIsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgZnJvbUV2ZW50LCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHRha2UgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IHBvc2l0aW9uRWxlbWVudHMgfSBmcm9tICcuLi91dGlsL3Bvc2l0aW9uaW5nJztcclxuaW1wb3J0IHsgbmdiQXV0b0Nsb3NlIH0gZnJvbSAnLi4vdXRpbC9hdXRvY2xvc2UnO1xyXG5pbXBvcnQgeyBLZXkgfSBmcm9tICcuLi91dGlsL2tleSc7XHJcbmltcG9ydCB7IE5nYkRyb3Bkb3duQ29uZmlnIH0gZnJvbSAnLi9kcm9wZG93bi1jb25maWcnO1xyXG5leHBvcnQgY2xhc3MgTmdiTmF2YmFyIHtcclxufVxyXG5OZ2JOYXZiYXIuZGVjb3JhdG9ycyA9IFtcclxuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJy5uYXZiYXInIH0sXSB9XHJcbl07XHJcbi8qKlxyXG4gKiBBIGRpcmVjdGl2ZSB5b3Ugc2hvdWxkIHB1dCBvbiBhIGRyb3Bkb3duIGl0ZW0gdG8gZW5hYmxlIGtleWJvYXJkIG5hdmlnYXRpb24uXHJcbiAqIEFycm93IGtleXMgd2lsbCBtb3ZlIGZvY3VzIGJldHdlZW4gaXRlbXMgbWFya2VkIHdpdGggdGhpcyBkaXJlY3RpdmUuXHJcbiAqXHJcbiAqIFxcQHNpbmNlIDQuMS4wXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTmdiRHJvcGRvd25JdGVtIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50UmVmXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWYpIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xyXG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gKC8qKiBAdHlwZSB7P30gKi8gKHZhbHVlKSkgPT09ICcnIHx8IHZhbHVlID09PSB0cnVlOyAvLyBhY2NlcHQgYW4gZW1wdHkgYXR0cmlidXRlIGFzIHRydWVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZ2V0IGRpc2FibGVkKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7IH1cclxufVxyXG5OZ2JEcm9wZG93bkl0ZW0uZGVjb3JhdG9ycyA9IFtcclxuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ2JEcm9wZG93bkl0ZW1dJywgaG9zdDogeyAnY2xhc3MnOiAnZHJvcGRvd24taXRlbScsICdbY2xhc3MuZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyB9IH0sXSB9XHJcbl07XHJcbi8qKiBAbm9jb2xsYXBzZSAqL1xyXG5OZ2JEcm9wZG93bkl0ZW0uY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXHJcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfVxyXG5dO1xyXG5OZ2JEcm9wZG93bkl0ZW0ucHJvcERlY29yYXRvcnMgPSB7XHJcbiAgICBkaXNhYmxlZDogW3sgdHlwZTogSW5wdXQgfV1cclxufTtcclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgTmdiRHJvcGRvd25JdGVtLnByb3RvdHlwZS5fZGlzYWJsZWQ7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JEcm9wZG93bkl0ZW0ucHJvdG90eXBlLmVsZW1lbnRSZWY7XHJcbn1cclxuLyoqXHJcbiAqIEEgZGlyZWN0aXZlIHRoYXQgd3JhcHMgZHJvcGRvd24gbWVudSBjb250ZW50IGFuZCBkcm9wZG93biBpdGVtcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBOZ2JEcm9wZG93bk1lbnUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGRyb3Bkb3duXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGRyb3Bkb3duKSB7XHJcbiAgICAgICAgdGhpcy5kcm9wZG93biA9IGRyb3Bkb3duO1xyXG4gICAgICAgIHRoaXMucGxhY2VtZW50ID0gJ2JvdHRvbSc7XHJcbiAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5OZ2JEcm9wZG93bk1lbnUuZGVjb3JhdG9ycyA9IFtcclxuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmdiRHJvcGRvd25NZW51XScsXHJcbiAgICAgICAgICAgICAgICBob3N0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5kcm9wZG93bi1tZW51XSc6ICd0cnVlJyxcclxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLnNob3ddJzogJ2Ryb3Bkb3duLmlzT3BlbigpJyxcclxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIueC1wbGFjZW1lbnRdJzogJ3BsYWNlbWVudCcsXHJcbiAgICAgICAgICAgICAgICAgICAgJyhrZXlkb3duLkFycm93VXApJzogJ2Ryb3Bkb3duLm9uS2V5RG93bigkZXZlbnQpJyxcclxuICAgICAgICAgICAgICAgICAgICAnKGtleWRvd24uQXJyb3dEb3duKSc6ICdkcm9wZG93bi5vbktleURvd24oJGV2ZW50KScsXHJcbiAgICAgICAgICAgICAgICAgICAgJyhrZXlkb3duLkhvbWUpJzogJ2Ryb3Bkb3duLm9uS2V5RG93bigkZXZlbnQpJyxcclxuICAgICAgICAgICAgICAgICAgICAnKGtleWRvd24uRW5kKSc6ICdkcm9wZG93bi5vbktleURvd24oJGV2ZW50KScsXHJcbiAgICAgICAgICAgICAgICAgICAgJyhrZXlkb3duLkVudGVyKSc6ICdkcm9wZG93bi5vbktleURvd24oJGV2ZW50KScsXHJcbiAgICAgICAgICAgICAgICAgICAgJyhrZXlkb3duLlNwYWNlKSc6ICdkcm9wZG93bi5vbktleURvd24oJGV2ZW50KSdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxdIH1cclxuXTtcclxuLyoqIEBub2NvbGxhcHNlICovXHJcbk5nYkRyb3Bkb3duTWVudS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcclxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtmb3J3YXJkUmVmKCgvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICgpID0+IE5nYkRyb3Bkb3duKSksXSB9XSB9XHJcbl07XHJcbk5nYkRyb3Bkb3duTWVudS5wcm9wRGVjb3JhdG9ycyA9IHtcclxuICAgIG1lbnVJdGVtczogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTmdiRHJvcGRvd25JdGVtLF0gfV1cclxufTtcclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JEcm9wZG93bk1lbnUucHJvdG90eXBlLnBsYWNlbWVudDtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE5nYkRyb3Bkb3duTWVudS5wcm90b3R5cGUuaXNPcGVuO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgTmdiRHJvcGRvd25NZW51LnByb3RvdHlwZS5tZW51SXRlbXM7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JEcm9wZG93bk1lbnUucHJvdG90eXBlLmRyb3Bkb3duO1xyXG59XHJcbi8qKlxyXG4gKiBBIGRpcmVjdGl2ZSB0byBtYXJrIGFuIGVsZW1lbnQgdG8gd2hpY2ggZHJvcGRvd24gbWVudSB3aWxsIGJlIGFuY2hvcmVkLlxyXG4gKlxyXG4gKiBUaGlzIGlzIGEgc2ltcGxlIHZlcnNpb24gb2YgdGhlIGBOZ2JEcm9wZG93blRvZ2dsZWAgZGlyZWN0aXZlLlxyXG4gKiBJdCBwbGF5cyB0aGUgc2FtZSByb2xlLCBidXQgZG9lc24ndCBsaXN0ZW4gdG8gY2xpY2sgZXZlbnRzIHRvIHRvZ2dsZSBkcm9wZG93biBtZW51IHRodXMgZW5hYmxpbmcgc3VwcG9ydFxyXG4gKiBmb3IgZXZlbnRzIG90aGVyIHRoYW4gY2xpY2suXHJcbiAqXHJcbiAqIFxcQHNpbmNlIDEuMS4wXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTmdiRHJvcGRvd25BbmNob3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGRyb3Bkb3duXHJcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGRyb3Bkb3duLCBfZWxlbWVudFJlZikge1xyXG4gICAgICAgIHRoaXMuZHJvcGRvd24gPSBkcm9wZG93bjtcclxuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XHJcbiAgICAgICAgdGhpcy5hbmNob3JFbCA9IF9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGdldE5hdGl2ZUVsZW1lbnQoKSB7IHJldHVybiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7IH1cclxufVxyXG5OZ2JEcm9wZG93bkFuY2hvci5kZWNvcmF0b3JzID0gW1xyXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tuZ2JEcm9wZG93bkFuY2hvcl0nLFxyXG4gICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnZHJvcGRvd24tdG9nZ2xlJywgJ2FyaWEtaGFzcG9wdXAnOiAndHJ1ZScsICdbYXR0ci5hcmlhLWV4cGFuZGVkXSc6ICdkcm9wZG93bi5pc09wZW4oKScgfVxyXG4gICAgICAgICAgICB9LF0gfVxyXG5dO1xyXG4vKiogQG5vY29sbGFwc2UgKi9cclxuTmdiRHJvcGRvd25BbmNob3IuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXHJcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbZm9yd2FyZFJlZigoLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAoKSA9PiBOZ2JEcm9wZG93bikpLF0gfV0gfSxcclxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9XHJcbl07XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgTmdiRHJvcGRvd25BbmNob3IucHJvdG90eXBlLmFuY2hvckVsO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgTmdiRHJvcGRvd25BbmNob3IucHJvdG90eXBlLmRyb3Bkb3duO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIE5nYkRyb3Bkb3duQW5jaG9yLnByb3RvdHlwZS5fZWxlbWVudFJlZjtcclxufVxyXG4vKipcclxuICogQSBkaXJlY3RpdmUgdG8gbWFyayBhbiBlbGVtZW50IHRoYXQgd2lsbCB0b2dnbGUgZHJvcGRvd24gdmlhIHRoZSBgY2xpY2tgIGV2ZW50LlxyXG4gKlxyXG4gKiBZb3UgY2FuIGFsc28gdXNlIGBOZ2JEcm9wZG93bkFuY2hvcmAgYXMgYW4gYWx0ZXJuYXRpdmUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTmdiRHJvcGRvd25Ub2dnbGUgZXh0ZW5kcyBOZ2JEcm9wZG93bkFuY2hvciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZHJvcGRvd25cclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFJlZlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihkcm9wZG93biwgZWxlbWVudFJlZikge1xyXG4gICAgICAgIHN1cGVyKGRyb3Bkb3duLCBlbGVtZW50UmVmKTtcclxuICAgIH1cclxufVxyXG5OZ2JEcm9wZG93blRvZ2dsZS5kZWNvcmF0b3JzID0gW1xyXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tuZ2JEcm9wZG93blRvZ2dsZV0nLFxyXG4gICAgICAgICAgICAgICAgaG9zdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdkcm9wZG93bi10b2dnbGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICdhcmlhLWhhc3BvcHVwJzogJ3RydWUnLFxyXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWV4cGFuZGVkXSc6ICdkcm9wZG93bi5pc09wZW4oKScsXHJcbiAgICAgICAgICAgICAgICAgICAgJyhjbGljayknOiAnZHJvcGRvd24udG9nZ2xlKCknLFxyXG4gICAgICAgICAgICAgICAgICAgICcoa2V5ZG93bi5BcnJvd1VwKSc6ICdkcm9wZG93bi5vbktleURvd24oJGV2ZW50KScsXHJcbiAgICAgICAgICAgICAgICAgICAgJyhrZXlkb3duLkFycm93RG93biknOiAnZHJvcGRvd24ub25LZXlEb3duKCRldmVudCknLFxyXG4gICAgICAgICAgICAgICAgICAgICcoa2V5ZG93bi5Ib21lKSc6ICdkcm9wZG93bi5vbktleURvd24oJGV2ZW50KScsXHJcbiAgICAgICAgICAgICAgICAgICAgJyhrZXlkb3duLkVuZCknOiAnZHJvcGRvd24ub25LZXlEb3duKCRldmVudCknXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBOZ2JEcm9wZG93bkFuY2hvciwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4gTmdiRHJvcGRvd25Ub2dnbGUpKSB9XVxyXG4gICAgICAgICAgICB9LF0gfVxyXG5dO1xyXG4vKiogQG5vY29sbGFwc2UgKi9cclxuTmdiRHJvcGRvd25Ub2dnbGUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXHJcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbZm9yd2FyZFJlZigoLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAoKSA9PiBOZ2JEcm9wZG93bikpLF0gfV0gfSxcclxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9XHJcbl07XHJcbi8qKlxyXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IHByb3ZpZGVzIGNvbnRleHR1YWwgb3ZlcmxheXMgZm9yIGRpc3BsYXlpbmcgbGlzdHMgb2YgbGlua3MgYW5kIG1vcmUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTmdiRHJvcGRvd24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IF9jaGFuZ2VEZXRlY3RvclxyXG4gICAgICogQHBhcmFtIHs/fSBjb25maWdcclxuICAgICAqIEBwYXJhbSB7P30gX2RvY3VtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IF9uZ1pvbmVcclxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcclxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXHJcbiAgICAgKiBAcGFyYW0gez99IG5nYk5hdmJhclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfY2hhbmdlRGV0ZWN0b3IsIGNvbmZpZywgX2RvY3VtZW50LCBfbmdab25lLCBfZWxlbWVudFJlZiwgX3JlbmRlcmVyLCBuZ2JOYXZiYXIpIHtcclxuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvciA9IF9jaGFuZ2VEZXRlY3RvcjtcclxuICAgICAgICB0aGlzLl9kb2N1bWVudCA9IF9kb2N1bWVudDtcclxuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcclxuICAgICAgICB0aGlzLl9jbG9zZWQkID0gbmV3IFN1YmplY3QoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBkcm9wZG93biBtZW51IGlzIG9wZW5lZCBpbml0aWFsbHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fb3BlbiA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGV2ZW50IGZpcmVkIHdoZW4gdGhlIGRyb3Bkb3duIGlzIG9wZW5lZCBvciBjbG9zZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGUgZXZlbnQgcGF5bG9hZCBpcyBhIGBib29sZWFuYDpcclxuICAgICAgICAgKiAqIGB0cnVlYCAtIHRoZSBkcm9wZG93biB3YXMgb3BlbmVkXHJcbiAgICAgICAgICogKiBgZmFsc2VgIC0gdGhlIGRyb3Bkb3duIHdhcyBjbG9zZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9wZW5DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5wbGFjZW1lbnQgPSBjb25maWcucGxhY2VtZW50O1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29uZmlnLmNvbnRhaW5lcjtcclxuICAgICAgICB0aGlzLmF1dG9DbG9zZSA9IGNvbmZpZy5hdXRvQ2xvc2U7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5ID0gbmdiTmF2YmFyID8gJ3N0YXRpYycgOiAnZHluYW1pYyc7XHJcbiAgICAgICAgdGhpcy5fem9uZVN1YnNjcmlwdGlvbiA9IF9uZ1pvbmUub25TdGFibGUuc3Vic2NyaWJlKCgvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgICgpID0+IHsgdGhpcy5fcG9zaXRpb25NZW51KCk7IH0pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xyXG4gICAgICAgIHRoaXMuX25nWm9uZS5vblN0YWJsZS5waXBlKHRha2UoMSkpLnN1YnNjcmliZSgoLyoqXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5UGxhY2VtZW50Q2xhc3NlcygpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fb3Blbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2xvc2VIYW5kbGVycygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcclxuICAgICAgICBpZiAoY2hhbmdlcy5jb250YWluZXIgJiYgdGhpcy5fb3Blbikge1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseUNvbnRhaW5lcih0aGlzLmNvbnRhaW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzLnBsYWNlbWVudCAmJiAhY2hhbmdlcy5wbGFjZW1lbnQuaXNGaXJzdENoYW5nZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseVBsYWNlbWVudENsYXNzZXMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiB0aGUgZHJvcGRvd24gbWVudSBpcyBvcGVuLlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgaXNPcGVuKCkgeyByZXR1cm4gdGhpcy5fb3BlbjsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyB0aGUgZHJvcGRvd24gbWVudS5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIG9wZW4oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9vcGVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29wZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseUNvbnRhaW5lcih0aGlzLmNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIHRoaXMub3BlbkNoYW5nZS5lbWl0KHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDbG9zZUhhbmRsZXJzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgX3NldENsb3NlSGFuZGxlcnMoKSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuX2FuY2hvcjtcclxuICAgICAgICBuZ2JBdXRvQ2xvc2UodGhpcy5fbmdab25lLCB0aGlzLl9kb2N1bWVudCwgdGhpcy5hdXRvQ2xvc2UsICgvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgICgpID0+IHRoaXMuY2xvc2UoKSksIHRoaXMuX2Nsb3NlZCQsIHRoaXMuX21lbnUgPyBbdGhpcy5fbWVudUVsZW1lbnQubmF0aXZlRWxlbWVudF0gOiBbXSwgYW5jaG9yID8gW2FuY2hvci5nZXROYXRpdmVFbGVtZW50KCldIDogW10sICcuZHJvcGRvd24taXRlbSwuZHJvcGRvd24tZGl2aWRlcicpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXMgdGhlIGRyb3Bkb3duIG1lbnUuXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fb3Blbikge1xyXG4gICAgICAgICAgICB0aGlzLl9vcGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0Q29udGFpbmVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlZCQubmV4dCgpO1xyXG4gICAgICAgICAgICB0aGlzLm9wZW5DaGFuZ2UuZW1pdChmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVG9nZ2xlcyB0aGUgZHJvcGRvd24gbWVudS5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIHRvZ2dsZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc09wZW4oKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9wZW4oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIG5nT25EZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX3Jlc2V0Q29udGFpbmVyKCk7XHJcbiAgICAgICAgdGhpcy5fY2xvc2VkJC5uZXh0KCk7XHJcbiAgICAgICAgdGhpcy5fem9uZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBvbktleURvd24oZXZlbnQpIHtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6ZGVwcmVjYXRpb25cclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgY29uc3Qga2V5ID0gZXZlbnQud2hpY2g7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIGNvbnN0IGl0ZW1FbGVtZW50cyA9IHRoaXMuX2dldE1lbnVFbGVtZW50cygpO1xyXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICBsZXQgcG9zaXRpb24gPSAtMTtcclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgbGV0IGlzRXZlbnRGcm9tSXRlbXMgPSBmYWxzZTtcclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgbGV0IGl0ZW1FbGVtZW50ID0gbnVsbDtcclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgY29uc3QgaXNFdmVudEZyb21Ub2dnbGUgPSB0aGlzLl9pc0V2ZW50RnJvbVRvZ2dsZShldmVudCk7XHJcbiAgICAgICAgaWYgKCFpc0V2ZW50RnJvbVRvZ2dsZSAmJiBpdGVtRWxlbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGl0ZW1FbGVtZW50cy5mb3JFYWNoKCgvKipcclxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBpdGVtXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gaW5kZXhcclxuICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIChpdGVtLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29udGFpbnMoKC8qKiBAdHlwZSB7P30gKi8gKGV2ZW50LnRhcmdldCkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzRXZlbnRGcm9tSXRlbXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1FbGVtZW50ID0gaXRlbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9kb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjbG9zaW5nIG9uIEVudGVyIC8gU3BhY2VcclxuICAgICAgICBpZiAoa2V5ID09PSBLZXkuU3BhY2UgfHwga2V5ID09PSBLZXkuRW50ZXIpIHtcclxuICAgICAgICAgICAgaWYgKGlzRXZlbnRGcm9tSXRlbXMgJiYgKHRoaXMuYXV0b0Nsb3NlID09PSB0cnVlIHx8IHRoaXMuYXV0b0Nsb3NlID09PSAnaW5zaWRlJykpIHtcclxuICAgICAgICAgICAgICAgIC8vIEl0ZW0gaXMgZWl0aGVyIGEgYnV0dG9uIG9yIGEgbGluaywgc28gY2xpY2sgd2lsbCBiZSB0cmlnZ2VyZWQgYnkgdGhlIGJyb3dzZXIgb24gRW50ZXIgb3IgU3BhY2UuXHJcbiAgICAgICAgICAgICAgICAvLyBTbyB3ZSBoYXZlIHRvIHJlZ2lzdGVyIGEgb25lLXRpbWUgY2xpY2sgaGFuZGxlciB0aGF0IHdpbGwgZmlyZSBhZnRlciBhbnkgdXNlciBkZWZpbmVkIGNsaWNrIGhhbmRsZXJzXHJcbiAgICAgICAgICAgICAgICAvLyB0byBjbG9zZSB0aGUgZHJvcGRvd25cclxuICAgICAgICAgICAgICAgIGZyb21FdmVudChpdGVtRWxlbWVudCwgJ2NsaWNrJykucGlwZSh0YWtlKDEpKS5zdWJzY3JpYmUoKC8qKlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgKCkgPT4gdGhpcy5jbG9zZSgpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvcGVuaW5nIC8gbmF2aWdhdGluZ1xyXG4gICAgICAgIGlmIChpc0V2ZW50RnJvbVRvZ2dsZSB8fCBpc0V2ZW50RnJvbUl0ZW1zKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xyXG4gICAgICAgICAgICBpZiAoaXRlbUVsZW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEtleS5BcnJvd0Rvd246XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gTWF0aC5taW4ocG9zaXRpb24gKyAxLCBpdGVtRWxlbWVudHMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2V5LkFycm93VXA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0Ryb3B1cCgpICYmIHBvc2l0aW9uID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBpdGVtRWxlbWVudHMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gTWF0aC5tYXgocG9zaXRpb24gLSAxLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLZXkuSG9tZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEtleS5FbmQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gaXRlbUVsZW1lbnRzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaXRlbUVsZW1lbnRzW3Bvc2l0aW9uXS5mb2N1cygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgX2lzRHJvcHVwKCkgeyByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZHJvcHVwJyk7IH1cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIF9pc0V2ZW50RnJvbVRvZ2dsZShldmVudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hbmNob3IuZ2V0TmF0aXZlRWxlbWVudCgpLmNvbnRhaW5zKCgvKiogQHR5cGUgez99ICovIChldmVudC50YXJnZXQpKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBfZ2V0TWVudUVsZW1lbnRzKCkge1xyXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICBjb25zdCBtZW51ID0gdGhpcy5fbWVudTtcclxuICAgICAgICBpZiAobWVudSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1lbnUubWVudUl0ZW1zLmZpbHRlcigoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBpdGVtXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICBpdGVtID0+ICFpdGVtLmRpc2FibGVkKSkubWFwKCgvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IGl0ZW1cclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGl0ZW0gPT4gaXRlbS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIF9wb3NpdGlvbk1lbnUoKSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIGNvbnN0IG1lbnUgPSB0aGlzLl9tZW51O1xyXG4gICAgICAgIGlmICh0aGlzLmlzT3BlbigpICYmIG1lbnUpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlQbGFjZW1lbnRDbGFzc2VzKHRoaXMuZGlzcGxheSA9PT0gJ2R5bmFtaWMnID9cclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uRWxlbWVudHModGhpcy5fYW5jaG9yLmFuY2hvckVsLCB0aGlzLl9ib2R5Q29udGFpbmVyIHx8IHRoaXMuX21lbnVFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIHRoaXMucGxhY2VtZW50LCB0aGlzLmNvbnRhaW5lciA9PT0gJ2JvZHknKSA6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRGaXJzdFBsYWNlbWVudCh0aGlzLnBsYWNlbWVudCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7P30gcGxhY2VtZW50XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBfZ2V0Rmlyc3RQbGFjZW1lbnQocGxhY2VtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocGxhY2VtZW50KSA/IHBsYWNlbWVudFswXSA6ICgvKiogQHR5cGUgez99ICovIChwbGFjZW1lbnQuc3BsaXQoJyAnKVswXSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgX3Jlc2V0Q29udGFpbmVyKCkge1xyXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xyXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICBjb25zdCBtZW51RWxlbWVudCA9IHRoaXMuX21lbnVFbGVtZW50O1xyXG4gICAgICAgIGlmIChtZW51RWxlbWVudCkge1xyXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgIGNvbnN0IGRyb3Bkb3duRWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICBjb25zdCBkcm9wZG93bk1lbnVFbGVtZW50ID0gbWVudUVsZW1lbnQubmF0aXZlRWxlbWVudDtcclxuICAgICAgICAgICAgcmVuZGVyZXIuYXBwZW5kQ2hpbGQoZHJvcGRvd25FbGVtZW50LCBkcm9wZG93bk1lbnVFbGVtZW50KTtcclxuICAgICAgICAgICAgcmVuZGVyZXIucmVtb3ZlU3R5bGUoZHJvcGRvd25NZW51RWxlbWVudCwgJ3Bvc2l0aW9uJyk7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbW92ZVN0eWxlKGRyb3Bkb3duTWVudUVsZW1lbnQsICd0cmFuc2Zvcm0nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2JvZHlDb250YWluZXIpIHtcclxuICAgICAgICAgICAgcmVuZGVyZXIucmVtb3ZlQ2hpbGQodGhpcy5fZG9jdW1lbnQuYm9keSwgdGhpcy5fYm9keUNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvZHlDb250YWluZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRhaW5lclxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgX2FwcGx5Q29udGFpbmVyKGNvbnRhaW5lciA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLl9yZXNldENvbnRhaW5lcigpO1xyXG4gICAgICAgIGlmIChjb250YWluZXIgPT09ICdib2R5Jykge1xyXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgY29uc3QgZHJvcGRvd25NZW51RWxlbWVudCA9IHRoaXMuX21lbnVFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgY29uc3QgYm9keUNvbnRhaW5lciA9IHRoaXMuX2JvZHlDb250YWluZXIgPSB0aGlzLl9ib2R5Q29udGFpbmVyIHx8IHJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICAvLyBPdmVycmlkZSBzb21lIHN0eWxlcyB0byBoYXZlIHRoZSBwb3NpdGlvbm5pbmcgd29ya2luZ1xyXG4gICAgICAgICAgICByZW5kZXJlci5zZXRTdHlsZShib2R5Q29udGFpbmVyLCAncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcclxuICAgICAgICAgICAgcmVuZGVyZXIuc2V0U3R5bGUoZHJvcGRvd25NZW51RWxlbWVudCwgJ3Bvc2l0aW9uJywgJ3N0YXRpYycpO1xyXG4gICAgICAgICAgICByZW5kZXJlci5zZXRTdHlsZShib2R5Q29udGFpbmVyLCAnei1pbmRleCcsICcxMDUwJyk7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLmFwcGVuZENoaWxkKGJvZHlDb250YWluZXIsIGRyb3Bkb3duTWVudUVsZW1lbnQpO1xyXG4gICAgICAgICAgICByZW5kZXJlci5hcHBlbmRDaGlsZCh0aGlzLl9kb2N1bWVudC5ib2R5LCBib2R5Q29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gez89fSBwbGFjZW1lbnRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIF9hcHBseVBsYWNlbWVudENsYXNzZXMocGxhY2VtZW50KSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIGNvbnN0IG1lbnUgPSB0aGlzLl9tZW51O1xyXG4gICAgICAgIGlmIChtZW51KSB7XHJcbiAgICAgICAgICAgIGlmICghcGxhY2VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSB0aGlzLl9nZXRGaXJzdFBsYWNlbWVudCh0aGlzLnBsYWNlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xyXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgIGNvbnN0IGRyb3Bkb3duRWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IHBsYWNlbWVudCBjbGFzc2VzXHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbW92ZUNsYXNzKGRyb3Bkb3duRWxlbWVudCwgJ2Ryb3B1cCcpO1xyXG4gICAgICAgICAgICByZW5kZXJlci5yZW1vdmVDbGFzcyhkcm9wZG93bkVsZW1lbnQsICdkcm9wZG93bicpO1xyXG4gICAgICAgICAgICBtZW51LnBsYWNlbWVudCA9IHRoaXMuZGlzcGxheSA9PT0gJ3N0YXRpYycgPyBudWxsIDogcGxhY2VtZW50O1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAqIGFwcGx5IHRoZSBuZXcgcGxhY2VtZW50XHJcbiAgICAgICAgICAgICAgICAgICogaW4gY2FzZSBvZiB0b3AgdXNlIHVwLWFycm93IG9yIGRvd24tYXJyb3cgb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgY29uc3QgZHJvcGRvd25DbGFzcyA9IHBsYWNlbWVudC5zZWFyY2goJ150b3AnKSAhPT0gLTEgPyAnZHJvcHVwJyA6ICdkcm9wZG93bic7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLmFkZENsYXNzKGRyb3Bkb3duRWxlbWVudCwgZHJvcGRvd25DbGFzcyk7XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgY29uc3QgYm9keUNvbnRhaW5lciA9IHRoaXMuX2JvZHlDb250YWluZXI7XHJcbiAgICAgICAgICAgIGlmIChib2R5Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5yZW1vdmVDbGFzcyhib2R5Q29udGFpbmVyLCAnZHJvcHVwJyk7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5yZW1vdmVDbGFzcyhib2R5Q29udGFpbmVyLCAnZHJvcGRvd24nKTtcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmFkZENsYXNzKGJvZHlDb250YWluZXIsIGRyb3Bkb3duQ2xhc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbk5nYkRyb3Bkb3duLmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdiRHJvcGRvd25dJywgZXhwb3J0QXM6ICduZ2JEcm9wZG93bicsIGhvc3Q6IHsgJ1tjbGFzcy5zaG93XSc6ICdpc09wZW4oKScgfSB9LF0gfVxyXG5dO1xyXG4vKiogQG5vY29sbGFwc2UgKi9cclxuTmdiRHJvcGRvd24uY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXHJcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXHJcbiAgICB7IHR5cGU6IE5nYkRyb3Bkb3duQ29uZmlnIH0sXHJcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbRE9DVU1FTlQsXSB9XSB9LFxyXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcclxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxyXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcclxuICAgIHsgdHlwZTogTmdiTmF2YmFyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9XHJcbl07XHJcbk5nYkRyb3Bkb3duLnByb3BEZWNvcmF0b3JzID0ge1xyXG4gICAgX21lbnU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW05nYkRyb3Bkb3duTWVudSwgeyBzdGF0aWM6IGZhbHNlIH0sXSB9XSxcclxuICAgIF9tZW51RWxlbWVudDogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbTmdiRHJvcGRvd25NZW51LCB7IHJlYWQ6IEVsZW1lbnRSZWYsIHN0YXRpYzogZmFsc2UgfSxdIH1dLFxyXG4gICAgX2FuY2hvcjogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbTmdiRHJvcGRvd25BbmNob3IsIHsgc3RhdGljOiBmYWxzZSB9LF0gfV0sXHJcbiAgICBhdXRvQ2xvc2U6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgX29wZW46IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ29wZW4nLF0gfV0sXHJcbiAgICBwbGFjZW1lbnQ6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgY29udGFpbmVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcclxuICAgIGRpc3BsYXk6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgb3BlbkNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dXHJcbn07XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIE5nYkRyb3Bkb3duLnByb3RvdHlwZS5fY2xvc2VkJDtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBOZ2JEcm9wZG93bi5wcm90b3R5cGUuX3pvbmVTdWJzY3JpcHRpb247XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgTmdiRHJvcGRvd24ucHJvdG90eXBlLl9ib2R5Q29udGFpbmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIE5nYkRyb3Bkb3duLnByb3RvdHlwZS5fbWVudTtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBOZ2JEcm9wZG93bi5wcm90b3R5cGUuX21lbnVFbGVtZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIE5nYkRyb3Bkb3duLnByb3RvdHlwZS5fYW5jaG9yO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJvcGRvd24gc2hvdWxkIGJlIGNsb3NlZCB3aGVuIGNsaWNraW5nIG9uZSBvZiBkcm9wZG93biBpdGVtcyBvciBwcmVzc2luZyBFU0MuXHJcbiAgICAgKlxyXG4gICAgICogKiBgdHJ1ZWAgLSB0aGUgZHJvcGRvd24gd2lsbCBjbG9zZSBvbiBib3RoIG91dHNpZGUgYW5kIGluc2lkZSAobWVudSkgY2xpY2tzLlxyXG4gICAgICogKiBgZmFsc2VgIC0gdGhlIGRyb3Bkb3duIGNhbiBvbmx5IGJlIGNsb3NlZCBtYW51YWxseSB2aWEgYGNsb3NlKClgIG9yIGB0b2dnbGUoKWAgbWV0aG9kcy5cclxuICAgICAqICogYFwiaW5zaWRlXCJgIC0gdGhlIGRyb3Bkb3duIHdpbGwgY2xvc2Ugb24gaW5zaWRlIG1lbnUgY2xpY2tzLCBidXQgbm90IG91dHNpZGUgY2xpY2tzLlxyXG4gICAgICogKiBgXCJvdXRzaWRlXCJgIC0gdGhlIGRyb3Bkb3duIHdpbGwgY2xvc2Ugb25seSBvbiB0aGUgb3V0c2lkZSBjbGlja3MgYW5kIG5vdCBvbiBtZW51IGNsaWNrcy5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JEcm9wZG93bi5wcm90b3R5cGUuYXV0b0Nsb3NlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBkcm9wZG93biBtZW51IGlzIG9wZW5lZCBpbml0aWFsbHkuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiRHJvcGRvd24ucHJvdG90eXBlLl9vcGVuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcHJlZmVycmVkIHBsYWNlbWVudCBvZiB0aGUgZHJvcGRvd24uXHJcbiAgICAgKlxyXG4gICAgICogUG9zc2libGUgdmFsdWVzIGFyZSBgXCJ0b3BcImAsIGBcInRvcC1sZWZ0XCJgLCBgXCJ0b3AtcmlnaHRcImAsIGBcImJvdHRvbVwiYCwgYFwiYm90dG9tLWxlZnRcImAsXHJcbiAgICAgKiBgXCJib3R0b20tcmlnaHRcImAsIGBcImxlZnRcImAsIGBcImxlZnQtdG9wXCJgLCBgXCJsZWZ0LWJvdHRvbVwiYCwgYFwicmlnaHRcImAsIGBcInJpZ2h0LXRvcFwiYCxcclxuICAgICAqIGBcInJpZ2h0LWJvdHRvbVwiYFxyXG4gICAgICpcclxuICAgICAqIEFjY2VwdHMgYW4gYXJyYXkgb2Ygc3RyaW5ncyBvciBhIHN0cmluZyB3aXRoIHNwYWNlIHNlcGFyYXRlZCBwb3NzaWJsZSB2YWx1ZXMuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGRlZmF1bHQgb3JkZXIgb2YgcHJlZmVyZW5jZSBpcyBgXCJib3R0b20tbGVmdCBib3R0b20tcmlnaHQgdG9wLWxlZnQgdG9wLXJpZ2h0XCJgXHJcbiAgICAgKlxyXG4gICAgICogUGxlYXNlIHNlZSB0aGUgW3Bvc2l0aW9uaW5nIG92ZXJ2aWV3XSgjL3Bvc2l0aW9uaW5nKSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRyb3Bkb3duLnByb3RvdHlwZS5wbGFjZW1lbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEEgc2VsZWN0b3Igc3BlY2lmeWluZyB0aGUgZWxlbWVudCB0aGUgZHJvcGRvd24gc2hvdWxkIGJlIGFwcGVuZGVkIHRvLlxyXG4gICAgICogQ3VycmVudGx5IG9ubHkgc3VwcG9ydHMgXCJib2R5XCIuXHJcbiAgICAgKlxyXG4gICAgICogXFxAc2luY2UgNC4xLjBcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JEcm9wZG93bi5wcm90b3R5cGUuY29udGFpbmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgZHluYW1pYyBwb3NpdGlvbmluZy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgZHluYW1pYyB1bmxlc3MgdGhlIGRyb3Bkb3duIGlzIHVzZWRcclxuICAgICAqIGluc2lkZSBhIEJvb3RzdHJhcCBuYXZiYXIuIElmIHlvdSBuZWVkIGN1c3RvbSBwbGFjZW1lbnQgZm9yIGEgZHJvcGRvd24gaW4gYSBuYXZiYXIsIHNldCBpdCB0b1xyXG4gICAgICogZHluYW1pYyBleHBsaWNpdGx5LiBTZWUgdGhlIFtwb3NpdGlvbmluZyBvZiBkcm9wZG93bl0oIy9wb3NpdGlvbmluZyNkcm9wZG93bilcclxuICAgICAqIGFuZCB0aGUgW25hdmJhciBkZW1vXSgvIy9jb21wb25lbnRzL2Ryb3Bkb3duL2V4YW1wbGVzI25hdmJhcikgZm9yIG1vcmUgZGV0YWlscy5cclxuICAgICAqXHJcbiAgICAgKiBcXEBzaW5jZSA0LjIuMFxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRyb3Bkb3duLnByb3RvdHlwZS5kaXNwbGF5O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBldmVudCBmaXJlZCB3aGVuIHRoZSBkcm9wZG93biBpcyBvcGVuZWQgb3IgY2xvc2VkLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBldmVudCBwYXlsb2FkIGlzIGEgYGJvb2xlYW5gOlxyXG4gICAgICogKiBgdHJ1ZWAgLSB0aGUgZHJvcGRvd24gd2FzIG9wZW5lZFxyXG4gICAgICogKiBgZmFsc2VgIC0gdGhlIGRyb3Bkb3duIHdhcyBjbG9zZWRcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JEcm9wZG93bi5wcm90b3R5cGUub3BlbkNoYW5nZTtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBOZ2JEcm9wZG93bi5wcm90b3R5cGUuX2NoYW5nZURldGVjdG9yO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIE5nYkRyb3Bkb3duLnByb3RvdHlwZS5fZG9jdW1lbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgTmdiRHJvcGRvd24ucHJvdG90eXBlLl9uZ1pvbmU7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgTmdiRHJvcGRvd24ucHJvdG90eXBlLl9lbGVtZW50UmVmO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIE5nYkRyb3Bkb3duLnByb3RvdHlwZS5fcmVuZGVyZXI7XHJcbn1cciJdfQ==