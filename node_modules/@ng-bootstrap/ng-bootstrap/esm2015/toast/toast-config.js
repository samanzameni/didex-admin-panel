/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
/**
 * Interface used to type all toast config options. See `NgbToastConfig`.
 *
 * \@since 5.0.0
 * @record
 */
import * as ɵngcc0 from '@angular/core';
export function NgbToastOptions() { }
if (false) {
    /**
     * Specify if the toast component should emit the `hide()` output
     * after a certain `delay` in ms.
     * @type {?|undefined}
     */
    NgbToastOptions.prototype.autohide;
    /**
     * Delay in ms after which the `hide()` output should be emitted.
     * @type {?|undefined}
     */
    NgbToastOptions.prototype.delay;
    /**
     * Type of aria-live attribute to be used.
     *
     * Could be one of these 2 values (as string):
     * - `polite` (default)
     * - `alert`
     * @type {?|undefined}
     */
    NgbToastOptions.prototype.ariaLive;
}
/**
 * Configuration service for the NgbToast component. You can inject this service, typically in your root component,
 * and customize the values of its properties in order to provide default values for all the toasts used in the
 * application.
 *
 * \@since 5.0.0
 */
export class NgbToastConfig {
    constructor() {
        this.autohide = true;
        this.delay = 500;
        this.ariaLive = 'polite';
    }
}
NgbToastConfig.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: NgbToastConfig, factory: function NgbToastConfig_Factory(t) { return new (t || NgbToastConfig)(); }, providedIn: 'root' });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbToastConfig, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, { constructor: [], autohide: [], delay: [], ariaLive: [] });
/** @nocollapse */ NgbToastConfig.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function NgbToastConfig_Factory() { return new NgbToastConfig(); }, token: NgbToastConfig, providedIn: "root" });
if (false) {
    /** @type {?} */
    NgbToastConfig.prototype.autohide;
    /** @type {?} */
    NgbToastConfig.prototype.delay;
    /** @type {?} */
    NgbToastConfig.prototype.ariaLive;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQG5nLWJvb3RzdHJhcC9uZy1ib290c3RyYXAvZXNtMjAxNS90b2FzdC90b2FzdC1jb25maWcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7QUFZQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQ0MsK0ZBR0MiLCJmaWxlIjoidG9hc3QtY29uZmlnLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxyXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsY29uc3RhbnRQcm9wZXJ0eSxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXHJcbiAqL1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCAqIGFzIGkwIGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XHJcbi8qKlxyXG4gKiBJbnRlcmZhY2UgdXNlZCB0byB0eXBlIGFsbCB0b2FzdCBjb25maWcgb3B0aW9ucy4gU2VlIGBOZ2JUb2FzdENvbmZpZ2AuXHJcbiAqXHJcbiAqIFxcQHNpbmNlIDUuMC4wXHJcbiAqIEByZWNvcmRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBOZ2JUb2FzdE9wdGlvbnMoKSB7IH1cclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZnkgaWYgdGhlIHRvYXN0IGNvbXBvbmVudCBzaG91bGQgZW1pdCB0aGUgYGhpZGUoKWAgb3V0cHV0XHJcbiAgICAgKiBhZnRlciBhIGNlcnRhaW4gYGRlbGF5YCBpbiBtcy5cclxuICAgICAqIEB0eXBlIHs/fHVuZGVmaW5lZH1cclxuICAgICAqL1xyXG4gICAgTmdiVG9hc3RPcHRpb25zLnByb3RvdHlwZS5hdXRvaGlkZTtcclxuICAgIC8qKlxyXG4gICAgICogRGVsYXkgaW4gbXMgYWZ0ZXIgd2hpY2ggdGhlIGBoaWRlKClgIG91dHB1dCBzaG91bGQgYmUgZW1pdHRlZC5cclxuICAgICAqIEB0eXBlIHs/fHVuZGVmaW5lZH1cclxuICAgICAqL1xyXG4gICAgTmdiVG9hc3RPcHRpb25zLnByb3RvdHlwZS5kZWxheTtcclxuICAgIC8qKlxyXG4gICAgICogVHlwZSBvZiBhcmlhLWxpdmUgYXR0cmlidXRlIHRvIGJlIHVzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQ291bGQgYmUgb25lIG9mIHRoZXNlIDIgdmFsdWVzIChhcyBzdHJpbmcpOlxyXG4gICAgICogLSBgcG9saXRlYCAoZGVmYXVsdClcclxuICAgICAqIC0gYGFsZXJ0YFxyXG4gICAgICogQHR5cGUgez98dW5kZWZpbmVkfVxyXG4gICAgICovXHJcbiAgICBOZ2JUb2FzdE9wdGlvbnMucHJvdG90eXBlLmFyaWFMaXZlO1xyXG59XHJcbi8qKlxyXG4gKiBDb25maWd1cmF0aW9uIHNlcnZpY2UgZm9yIHRoZSBOZ2JUb2FzdCBjb21wb25lbnQuIFlvdSBjYW4gaW5qZWN0IHRoaXMgc2VydmljZSwgdHlwaWNhbGx5IGluIHlvdXIgcm9vdCBjb21wb25lbnQsXHJcbiAqIGFuZCBjdXN0b21pemUgdGhlIHZhbHVlcyBvZiBpdHMgcHJvcGVydGllcyBpbiBvcmRlciB0byBwcm92aWRlIGRlZmF1bHQgdmFsdWVzIGZvciBhbGwgdGhlIHRvYXN0cyB1c2VkIGluIHRoZVxyXG4gKiBhcHBsaWNhdGlvbi5cclxuICpcclxuICogXFxAc2luY2UgNS4wLjBcclxuICovXHJcbmV4cG9ydCBjbGFzcyBOZ2JUb2FzdENvbmZpZyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmF1dG9oaWRlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRlbGF5ID0gNTAwO1xyXG4gICAgICAgIHRoaXMuYXJpYUxpdmUgPSAncG9saXRlJztcclxuICAgIH1cclxufVxyXG5OZ2JUb2FzdENvbmZpZy5kZWNvcmF0b3JzID0gW1xyXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlLCBhcmdzOiBbeyBwcm92aWRlZEluOiAncm9vdCcgfSxdIH1cclxuXTtcclxuLyoqIEBub2NvbGxhcHNlICovIE5nYlRvYXN0Q29uZmlnLm5nSW5qZWN0YWJsZURlZiA9IGkwLsm1ybVkZWZpbmVJbmplY3RhYmxlKHsgZmFjdG9yeTogZnVuY3Rpb24gTmdiVG9hc3RDb25maWdfRmFjdG9yeSgpIHsgcmV0dXJuIG5ldyBOZ2JUb2FzdENvbmZpZygpOyB9LCB0b2tlbjogTmdiVG9hc3RDb25maWcsIHByb3ZpZGVkSW46IFwicm9vdFwiIH0pO1xyXG5pZiAoZmFsc2UpIHtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE5nYlRvYXN0Q29uZmlnLnByb3RvdHlwZS5hdXRvaGlkZTtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE5nYlRvYXN0Q29uZmlnLnByb3RvdHlwZS5kZWxheTtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE5nYlRvYXN0Q29uZmlnLnByb3RvdHlwZS5hcmlhTGl2ZTtcclxufVxyIl19