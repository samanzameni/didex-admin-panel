/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Attribute, ChangeDetectorRef, ContentChildren, Directive, ElementRef, EventEmitter, forwardRef, Inject, Input, Output, QueryList, TemplateRef } from '@angular/core';
import { isDefined } from '../util/util';
import { NgbNavConfig } from './nav-config';
/** @type {?} */
import * as ɵngcc0 from '@angular/core';

const _c0 = ["href", ""];
var isValidNavId = (/**
 * @param {?} id
 * @return {?}
 */
function (id) { return isDefined(id) && id !== ''; });
var ɵ0 = isValidNavId;
/** @type {?} */
var navCounter = 0;
/**
 * Context passed to the nav content template.
 *
 * See [this demo](#/components/nav/examples#keep-content) as the example.
 *
 * \@since 5.2.0
 * @record
 */
export function NgbNavContentContext() { }
if (false) {
    /**
     * If `true`, current nav content is visible and active
     * @type {?}
     */
    NgbNavContentContext.prototype.$implicit;
}
/**
 * This directive must be used to wrap content to be displayed in the nav.
 *
 * \@since 5.2.0
 */
var NgbNavContent = /** @class */ (function () {
    function NgbNavContent(templateRef) {
        this.templateRef = templateRef;
    }
    /** @nocollapse */
    NgbNavContent.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
NgbNavContent.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbNavContent, selectors: [["ng-template", "ngbNavContent", ""]], factory: function NgbNavContent_Factory(t) { return new (t || NgbNavContent)(ɵngcc0.ɵɵdirectiveInject(TemplateRef)); } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbNavContent, [{
        type: Directive,
        args: [{ selector: 'ng-template[ngbNavContent]' }]
    }], function () { return [{ type: TemplateRef }]; }, { templateRef: [] });
    return NgbNavContent;
}());
export { NgbNavContent };
if (false) {
    /** @type {?} */
    NgbNavContent.prototype.templateRef;
}
/**
 * The directive used to group nav link and related nav content. As well as set nav identifier and some options.
 *
 * \@since 5.2.0
 */
var NgbNavItem = /** @class */ (function () {
    function NgbNavItem(nav, elementRef) {
        this.elementRef = elementRef;
        /**
         * If `true`, the current nav item is disabled and can't be toggled by user.
         *
         * Nevertheless disabled nav can be selected programmatically via the `.select()` method and the `[activeId]` binding.
         */
        this.disabled = false;
        // TODO: cf https://github.com/angular/angular/issues/30106
        this._nav = nav;
    }
    /**
     * @return {?}
     */
    NgbNavItem.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
        // We are using @ContentChildren instead of @ContentChild as in the Angular version being used
        // only @ContentChildren allows us to specify the {descendants: false} option.
        // Without {descendants: false} we are hitting bugs described in:
        // https://github.com/ng-bootstrap/ng-bootstrap/issues/2240
        this.contentTpl = this.contentTpls.first;
    };
    /**
     * @return {?}
     */
    NgbNavItem.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!isDefined(this.domId)) {
            this.domId = "ngb-nav-" + navCounter++;
        }
    };
    Object.defineProperty(NgbNavItem.prototype, "active", {
        get: /**
         * @return {?}
         */
        function () { return this._nav.activeId === this.id; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgbNavItem.prototype, "id", {
        get: /**
         * @return {?}
         */
        function () { return isValidNavId(this._id) ? this._id : this.domId; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgbNavItem.prototype, "panelDomId", {
        get: /**
         * @return {?}
         */
        function () { return this.domId + "-panel"; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NgbNavItem.prototype.isPanelInDom = /**
     * @return {?}
     */
    function () {
        return (isDefined(this.destroyOnHide) ? !this.destroyOnHide : !this._nav.destroyOnHide) || this.active;
    };
    /** @nocollapse */
    NgbNavItem.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [forwardRef((/**
                         * @return {?}
                         */
                        function () { return NgbNav; })),] }] },
        { type: ElementRef }
    ]; };
    NgbNavItem.propDecorators = {
        destroyOnHide: [{ type: Input }],
        disabled: [{ type: Input }],
        domId: [{ type: Input }],
        _id: [{ type: Input, args: ['ngbNavItem',] }],
        contentTpls: [{ type: ContentChildren, args: [NgbNavContent, { descendants: false },] }]
    };
NgbNavItem.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbNavItem, selectors: [["", "ngbNavItem", ""]], factory: function NgbNavItem_Factory(t) { return new (t || NgbNavItem)(ɵngcc0.ɵɵdirectiveInject(forwardRef(( /**
                     * @return {?}
                     */function () { return NgbNav; }))), ɵngcc0.ɵɵdirectiveInject(ElementRef)); }, contentQueries: function NgbNavItem_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbNavContent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.contentTpls = _t);
    } }, hostBindings: function NgbNavItem_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(1);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("nav-item", true);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { disabled: "disabled", domId: "domId", destroyOnHide: "destroyOnHide", _id: ["ngbNavItem", "_id"] }, exportAs: ["ngbNavItem"] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbNavItem, [{
        type: Directive,
        args: [{ selector: '[ngbNavItem]', exportAs: 'ngbNavItem', host: { '[class.nav-item]': 'true' } }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [forwardRef(( /**
                                     * @return {?}
                                     */function () { return NgbNav; }))]
            }] }, { type: ElementRef }]; }, { elementRef: [], disabled: [{
            type: Input
        }], _nav: [], ngAfterContentChecked: [], contentTpl: [], ngOnInit: [], domId: [{
            type: Input
        }], active: [], id: [], panelDomId: [], isPanelInDom: [], destroyOnHide: [{
            type: Input
        }], _id: [{
            type: Input,
            args: ['ngbNavItem']
        }], contentTpls: [{
            type: ContentChildren,
            args: [NgbNavContent, { descendants: false }]
        }] });
    return NgbNavItem;
}());
export { NgbNavItem };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgbNavItem.prototype._nav;
    /**
     * If `true`, non-active current nav item content will be removed from DOM
     * Otherwise it will just be hidden
     * @type {?}
     */
    NgbNavItem.prototype.destroyOnHide;
    /**
     * If `true`, the current nav item is disabled and can't be toggled by user.
     *
     * Nevertheless disabled nav can be selected programmatically via the `.select()` method and the `[activeId]` binding.
     * @type {?}
     */
    NgbNavItem.prototype.disabled;
    /**
     * The id used for the DOM elements.
     * Must be unique inside the document in case you have multiple `ngbNav`s on the page.
     *
     * Autogenerated as `ngb-nav-XXX` if not provided.
     * @type {?}
     */
    NgbNavItem.prototype.domId;
    /**
     * The id used as a model for active nav.
     * It can be anything, but must be unique inside one `ngbNav`.
     *
     * The only limitation is that it is not possible to have the `''` (empty string) as id,
     * because ` ngbNavItem `, `ngbNavItem=''` and `[ngbNavItem]="''"` are indistinguishable
     * @type {?}
     */
    NgbNavItem.prototype._id;
    /** @type {?} */
    NgbNavItem.prototype.contentTpl;
    /** @type {?} */
    NgbNavItem.prototype.contentTpls;
    /** @type {?} */
    NgbNavItem.prototype.elementRef;
}
/**
 * A nav directive that helps with implementing tabbed navigation components.
 *
 * \@since 5.2.0
 */
var NgbNav = /** @class */ (function () {
    function NgbNav(role, config, _cd) {
        this.role = role;
        this._cd = _cd;
        /**
         * The event emitted after the active nav changes
         * The payload of the event is the newly active nav id
         *
         * If you want to prevent nav change, you should use `(navChange)` event
         */
        this.activeIdChange = new EventEmitter();
        /**
         * The nav change event emitted right before the nav change happens on user click.
         *
         * This event won't be emitted if nav is changed programmatically via `[activeId]` or `.select()`.
         *
         * See [`NgbNavChangeEvent`](#/components/nav/api#NgbNavChangeEvent) for payload details.
         */
        this.navChange = new EventEmitter();
        this.destroyOnHide = config.destroyOnHide;
        this.orientation = config.orientation;
        this.roles = config.roles;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    NgbNav.prototype.click = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (!item.disabled) {
            this._updateActiveId(item.id);
        }
    };
    /**
     * Selects the nav with the given id and shows its associated pane.
     * Any other nav that was previously selected becomes unselected and its associated pane is hidden.
     */
    /**
     * Selects the nav with the given id and shows its associated pane.
     * Any other nav that was previously selected becomes unselected and its associated pane is hidden.
     * @param {?} id
     * @return {?}
     */
    NgbNav.prototype.select = /**
     * Selects the nav with the given id and shows its associated pane.
     * Any other nav that was previously selected becomes unselected and its associated pane is hidden.
     * @param {?} id
     * @return {?}
     */
    function (id) { this._updateActiveId(id, false); };
    /**
     * @return {?}
     */
    NgbNav.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        if (!isDefined(this.activeId)) {
            /** @type {?} */
            var nextId = this.items.first ? this.items.first.id : null;
            if (isValidNavId(nextId)) {
                this._updateActiveId(nextId, false);
                this._cd.detectChanges();
            }
        }
    };
    /**
     * @private
     * @param {?} nextId
     * @param {?=} emitNavChange
     * @return {?}
     */
    NgbNav.prototype._updateActiveId = /**
     * @private
     * @param {?} nextId
     * @param {?=} emitNavChange
     * @return {?}
     */
    function (nextId, emitNavChange) {
        if (emitNavChange === void 0) { emitNavChange = true; }
        if (this.activeId !== nextId) {
            /** @type {?} */
            var defaultPrevented_1 = false;
            if (emitNavChange) {
                this.navChange.emit({ activeId: this.activeId, nextId: nextId, preventDefault: (/**
                     * @return {?}
                     */
                    function () { defaultPrevented_1 = true; }) });
            }
            if (!defaultPrevented_1) {
                this.activeId = nextId;
                this.activeIdChange.emit(nextId);
            }
        }
    };
    /** @nocollapse */
    NgbNav.ctorParameters = function () { return [
        { type: String, decorators: [{ type: Attribute, args: ['role',] }] },
        { type: NgbNavConfig },
        { type: ChangeDetectorRef }
    ]; };
    NgbNav.propDecorators = {
        activeId: [{ type: Input }],
        activeIdChange: [{ type: Output }],
        destroyOnHide: [{ type: Input }],
        orientation: [{ type: Input }],
        roles: [{ type: Input }],
        items: [{ type: ContentChildren, args: [NgbNavItem,] }],
        navChange: [{ type: Output }]
    };
NgbNav.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbNav, selectors: [["", "ngbNav", ""]], factory: function NgbNav_Factory(t) { return new (t || NgbNav)(ɵngcc0.ɵɵinjectAttribute('role'), ɵngcc0.ɵɵdirectiveInject(NgbNavConfig), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef)); }, contentQueries: function NgbNav_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbNavItem, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.items = _t);
    } }, hostBindings: function NgbNav_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(4);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-orientation", ctx.orientation === "vertical" && ctx.roles === "tablist" ? "vertical" : undefined)("role", ctx.role ? ctx.role : ctx.roles ? "tablist" : undefined);
        ɵngcc0.ɵɵclassProp("nav", true);
        ɵngcc0.ɵɵclassProp("flex-column", ctx.orientation === "vertical");
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { destroyOnHide: "destroyOnHide", orientation: "orientation", roles: "roles", activeId: "activeId" }, outputs: { activeIdChange: "activeIdChange", navChange: "navChange" }, exportAs: ["ngbNav"] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbNav, [{
        type: Directive,
        args: [{
                selector: '[ngbNav]',
                exportAs: 'ngbNav',
                host: {
                    '[class.nav]': 'true',
                    '[class.flex-column]': "orientation === 'vertical'",
                    '[attr.aria-orientation]': "orientation === 'vertical' && roles === 'tablist' ? 'vertical' : undefined",
                    '[attr.role]': "role ? role : roles ? 'tablist' : undefined"
                }
            }]
    }], function () { return [{ type: String, decorators: [{
                type: Attribute,
                args: ['role']
            }] }, { type: NgbNavConfig }, { type: ChangeDetectorRef }]; }, { role: [], _cd: [], activeIdChange: [{
            type: Output
        }], navChange: [{
            type: Output
        }], destroyOnHide: [{
            type: Input
        }], orientation: [{
            type: Input
        }], roles: [{
            type: Input
        }], click: [], select: [], ngAfterContentInit: [], _updateActiveId: [], activeId: [{
            type: Input
        }], items: [{
            type: ContentChildren,
            args: [NgbNavItem]
        }] });
    return NgbNav;
}());
export { NgbNav };
if (false) {
    /**
     * The id of the nav that should be active
     *
     * You could also use the `.select()` method and the `(navChange)` event
     * @type {?}
     */
    NgbNav.prototype.activeId;
    /**
     * The event emitted after the active nav changes
     * The payload of the event is the newly active nav id
     *
     * If you want to prevent nav change, you should use `(navChange)` event
     * @type {?}
     */
    NgbNav.prototype.activeIdChange;
    /**
     * If `true`, non-active nav content will be removed from DOM
     * Otherwise it will just be hidden
     * @type {?}
     */
    NgbNav.prototype.destroyOnHide;
    /**
     * The orientation of navs.
     *
     * Using `vertical` will also add the `aria-orientation` attribute
     * @type {?}
     */
    NgbNav.prototype.orientation;
    /**
     * Role attribute generating strategy:
     * - `false` - no role attributes will be generated
     * - `'tablist'` - 'tablist', 'tab' and 'tabpanel' will be generated (default)
     * @type {?}
     */
    NgbNav.prototype.roles;
    /** @type {?} */
    NgbNav.prototype.items;
    /**
     * The nav change event emitted right before the nav change happens on user click.
     *
     * This event won't be emitted if nav is changed programmatically via `[activeId]` or `.select()`.
     *
     * See [`NgbNavChangeEvent`](#/components/nav/api#NgbNavChangeEvent) for payload details.
     * @type {?}
     */
    NgbNav.prototype.navChange;
    /** @type {?} */
    NgbNav.prototype.role;
    /**
     * @type {?}
     * @private
     */
    NgbNav.prototype._cd;
}
/**
 * A directive to put on the nav link.
 *
 * \@since 5.2.0
 */
var NgbNavLink = /** @class */ (function () {
    function NgbNavLink(role, navItem, nav) {
        this.role = role;
        this.navItem = navItem;
        this.nav = nav;
    }
    /**
     * @return {?}
     */
    NgbNavLink.prototype.hasNavItemClass = /**
     * @return {?}
     */
    function () {
        // with alternative markup we have to add `.nav-item` class, because `ngbNavItem` is on the ng-container
        return this.navItem.elementRef.nativeElement.nodeType === Node.COMMENT_NODE;
    };
    /** @nocollapse */
    NgbNavLink.ctorParameters = function () { return [
        { type: String, decorators: [{ type: Attribute, args: ['role',] }] },
        { type: NgbNavItem },
        { type: NgbNav }
    ]; };
NgbNavLink.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbNavLink, selectors: [["a", "ngbNavLink", ""]], factory: function NgbNavLink_Factory(t) { return new (t || NgbNavLink)(ɵngcc0.ɵɵinjectAttribute('role'), ɵngcc0.ɵɵdirectiveInject(NgbNavItem), ɵngcc0.ɵɵdirectiveInject(NgbNav)); }, hostBindings: function NgbNavLink_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(10);
        ɵngcc0.ɵɵlistener("click", function NgbNavLink_click_HostBindingHandler($event) { ctx.nav.click(ctx.navItem); return $event.preventDefault(); });
        ɵngcc0.ɵɵelementHostAttrs(_c0);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("id", ctx.navItem.domId);
        ɵngcc0.ɵɵattribute("role", ctx.role ? ctx.role : ctx.nav.roles ? "tab" : undefined)("tabindex", ctx.navItem.disabled ? 0 - 1 : undefined)("aria-controls", ctx.navItem.isPanelInDom() ? ctx.navItem.panelDomId : null)("aria-selected", ctx.navItem.active)("aria-disabled", ctx.navItem.disabled);
        ɵngcc0.ɵɵclassProp("nav-link", true);
        ɵngcc0.ɵɵclassProp("nav-item", ctx.hasNavItemClass());
        ɵngcc0.ɵɵclassProp("active", ctx.navItem.active);
        ɵngcc0.ɵɵclassProp("disabled", ctx.navItem.disabled);
        ɵngcc0.ɵɵstylingApply();
    } } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbNavLink, [{
        type: Directive,
        args: [{
                selector: 'a[ngbNavLink]',
                host: {
                    '[id]': 'navItem.domId',
                    '[class.nav-link]': 'true',
                    '[class.nav-item]': 'hasNavItemClass()',
                    '[attr.role]': "role ? role : nav.roles ? 'tab' : undefined",
                    'href': '',
                    '[class.active]': 'navItem.active',
                    '[class.disabled]': 'navItem.disabled',
                    '[attr.tabindex]': 'navItem.disabled ? -1 : undefined',
                    '[attr.aria-controls]': 'navItem.isPanelInDom() ? navItem.panelDomId : null',
                    '[attr.aria-selected]': 'navItem.active',
                    '[attr.aria-disabled]': 'navItem.disabled',
                    '(click)': 'nav.click(navItem); $event.preventDefault()'
                }
            }]
    }], function () { return [{ type: String, decorators: [{
                type: Attribute,
                args: ['role']
            }] }, { type: NgbNavItem }, { type: NgbNav }]; }, { role: [], navItem: [], nav: [], hasNavItemClass: [] });
    return NgbNavLink;
}());
export { NgbNavLink };
if (false) {
    /** @type {?} */
    NgbNavLink.prototype.role;
    /** @type {?} */
    NgbNavLink.prototype.navItem;
    /** @type {?} */
    NgbNavLink.prototype.nav;
}
/**
 * The payload of the change event emitted right before the nav change happens on user click.
 *
 * This event won't be emitted if nav is changed programmatically via `[activeId]` or `.select()`.
 *
 * \@since 5.2.0
 * @record
 */
export function NgbNavChangeEvent() { }
if (false) {
    /**
     * Id of the currently active nav.
     * @type {?}
     */
    NgbNavChangeEvent.prototype.activeId;
    /**
     * Id of the newly selected nav.
     * @type {?}
     */
    NgbNavChangeEvent.prototype.nextId;
    /**
     * Function that will prevent nav change if called.
     * @type {?}
     */
    NgbNavChangeEvent.prototype.preventDefault;
}
export { ɵ0 };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQG5nLWJvb3RzdHJhcC9uZy1ib290c3RyYXAvZXNtNS9uYXYvbmF2LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztBQVFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQWdDSyxBQUdDOzs7Ozs7Ozs7OEVBSUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQWlGSCxBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztjQWVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQXFKQSxBQVlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Y0FlQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQStFQSxBQW1CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1SEFNRyIsImZpbGUiOiJuYXYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbmltcG9ydCB7IEF0dHJpYnV0ZSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIGZvcndhcmRSZWYsIEluamVjdCwgSW5wdXQsIE91dHB1dCwgUXVlcnlMaXN0LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBpc0RlZmluZWQgfSBmcm9tICcuLi91dGlsL3V0aWwnO1xyXG5pbXBvcnQgeyBOZ2JOYXZDb25maWcgfSBmcm9tICcuL25hdi1jb25maWcnO1xyXG4vKiogQHR5cGUgez99ICovXHJcbnZhciBpc1ZhbGlkTmF2SWQgPSAoLyoqXHJcbiAqIEBwYXJhbSB7P30gaWRcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIChpZCkgeyByZXR1cm4gaXNEZWZpbmVkKGlkKSAmJiBpZCAhPT0gJyc7IH0pO1xyXG52YXIgybUwID0gaXNWYWxpZE5hdklkO1xyXG4vKiogQHR5cGUgez99ICovXHJcbnZhciBuYXZDb3VudGVyID0gMDtcclxuLyoqXHJcbiAqIENvbnRleHQgcGFzc2VkIHRvIHRoZSBuYXYgY29udGVudCB0ZW1wbGF0ZS5cclxuICpcclxuICogU2VlIFt0aGlzIGRlbW9dKCMvY29tcG9uZW50cy9uYXYvZXhhbXBsZXMja2VlcC1jb250ZW50KSBhcyB0aGUgZXhhbXBsZS5cclxuICpcclxuICogXFxAc2luY2UgNS4yLjBcclxuICogQHJlY29yZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE5nYk5hdkNvbnRlbnRDb250ZXh0KCkgeyB9XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBgdHJ1ZWAsIGN1cnJlbnQgbmF2IGNvbnRlbnQgaXMgdmlzaWJsZSBhbmQgYWN0aXZlXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiTmF2Q29udGVudENvbnRleHQucHJvdG90eXBlLiRpbXBsaWNpdDtcclxufVxyXG4vKipcclxuICogVGhpcyBkaXJlY3RpdmUgbXVzdCBiZSB1c2VkIHRvIHdyYXAgY29udGVudCB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIG5hdi5cclxuICpcclxuICogXFxAc2luY2UgNS4yLjBcclxuICovXHJcbnZhciBOZ2JOYXZDb250ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmdiTmF2Q29udGVudCh0ZW1wbGF0ZVJlZikge1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcclxuICAgIH1cclxuICAgIE5nYk5hdkNvbnRlbnQuZGVjb3JhdG9ycyA9IFtcclxuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICduZy10ZW1wbGF0ZVtuZ2JOYXZDb250ZW50XScgfSxdIH1cclxuICAgIF07XHJcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cclxuICAgIE5nYk5hdkNvbnRlbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXHJcbiAgICAgICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiB9XHJcbiAgICBdOyB9O1xyXG4gICAgcmV0dXJuIE5nYk5hdkNvbnRlbnQ7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IE5nYk5hdkNvbnRlbnQgfTtcclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JOYXZDb250ZW50LnByb3RvdHlwZS50ZW1wbGF0ZVJlZjtcclxufVxyXG4vKipcclxuICogVGhlIGRpcmVjdGl2ZSB1c2VkIHRvIGdyb3VwIG5hdiBsaW5rIGFuZCByZWxhdGVkIG5hdiBjb250ZW50LiBBcyB3ZWxsIGFzIHNldCBuYXYgaWRlbnRpZmllciBhbmQgc29tZSBvcHRpb25zLlxyXG4gKlxyXG4gKiBcXEBzaW5jZSA1LjIuMFxyXG4gKi9cclxudmFyIE5nYk5hdkl0ZW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZ2JOYXZJdGVtKG5hdiwgZWxlbWVudFJlZikge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgYHRydWVgLCB0aGUgY3VycmVudCBuYXYgaXRlbSBpcyBkaXNhYmxlZCBhbmQgY2FuJ3QgYmUgdG9nZ2xlZCBieSB1c2VyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogTmV2ZXJ0aGVsZXNzIGRpc2FibGVkIG5hdiBjYW4gYmUgc2VsZWN0ZWQgcHJvZ3JhbW1hdGljYWxseSB2aWEgdGhlIGAuc2VsZWN0KClgIG1ldGhvZCBhbmQgdGhlIGBbYWN0aXZlSWRdYCBiaW5kaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAvLyBUT0RPOiBjZiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8zMDEwNlxyXG4gICAgICAgIHRoaXMuX25hdiA9IG5hdjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdiTmF2SXRlbS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRDaGVja2VkID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gV2UgYXJlIHVzaW5nIEBDb250ZW50Q2hpbGRyZW4gaW5zdGVhZCBvZiBAQ29udGVudENoaWxkIGFzIGluIHRoZSBBbmd1bGFyIHZlcnNpb24gYmVpbmcgdXNlZFxyXG4gICAgICAgIC8vIG9ubHkgQENvbnRlbnRDaGlsZHJlbiBhbGxvd3MgdXMgdG8gc3BlY2lmeSB0aGUge2Rlc2NlbmRhbnRzOiBmYWxzZX0gb3B0aW9uLlxyXG4gICAgICAgIC8vIFdpdGhvdXQge2Rlc2NlbmRhbnRzOiBmYWxzZX0gd2UgYXJlIGhpdHRpbmcgYnVncyBkZXNjcmliZWQgaW46XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25nLWJvb3RzdHJhcC9uZy1ib290c3RyYXAvaXNzdWVzLzIyNDBcclxuICAgICAgICB0aGlzLmNvbnRlbnRUcGwgPSB0aGlzLmNvbnRlbnRUcGxzLmZpcnN0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdiTmF2SXRlbS5wcm90b3R5cGUubmdPbkluaXQgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIWlzRGVmaW5lZCh0aGlzLmRvbUlkKSkge1xyXG4gICAgICAgICAgICB0aGlzLmRvbUlkID0gXCJuZ2ItbmF2LVwiICsgbmF2Q291bnRlcisrO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdiTmF2SXRlbS5wcm90b3R5cGUsIFwiYWN0aXZlXCIsIHtcclxuICAgICAgICBnZXQ6IC8qKlxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbmF2LmFjdGl2ZUlkID09PSB0aGlzLmlkOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ2JOYXZJdGVtLnByb3RvdHlwZSwgXCJpZFwiLCB7XHJcbiAgICAgICAgZ2V0OiAvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVmFsaWROYXZJZCh0aGlzLl9pZCkgPyB0aGlzLl9pZCA6IHRoaXMuZG9tSWQ7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nYk5hdkl0ZW0ucHJvdG90eXBlLCBcInBhbmVsRG9tSWRcIiwge1xyXG4gICAgICAgIGdldDogLyoqXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRvbUlkICsgXCItcGFuZWxcIjsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nYk5hdkl0ZW0ucHJvdG90eXBlLmlzUGFuZWxJbkRvbSA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAoaXNEZWZpbmVkKHRoaXMuZGVzdHJveU9uSGlkZSkgPyAhdGhpcy5kZXN0cm95T25IaWRlIDogIXRoaXMuX25hdi5kZXN0cm95T25IaWRlKSB8fCB0aGlzLmFjdGl2ZTtcclxuICAgIH07XHJcbiAgICBOZ2JOYXZJdGVtLmRlY29yYXRvcnMgPSBbXHJcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW25nYk5hdkl0ZW1dJywgZXhwb3J0QXM6ICduZ2JOYXZJdGVtJywgaG9zdDogeyAnW2NsYXNzLm5hdi1pdGVtXSc6ICd0cnVlJyB9IH0sXSB9XHJcbiAgICBdO1xyXG4gICAgLyoqIEBub2NvbGxhcHNlICovXHJcbiAgICBOZ2JOYXZJdGVtLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtmb3J3YXJkUmVmKCgvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5nYk5hdjsgfSkpLF0gfV0gfSxcclxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfVxyXG4gICAgXTsgfTtcclxuICAgIE5nYk5hdkl0ZW0ucHJvcERlY29yYXRvcnMgPSB7XHJcbiAgICAgICAgZGVzdHJveU9uSGlkZTogW3sgdHlwZTogSW5wdXQgfV0sXHJcbiAgICAgICAgZGlzYWJsZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIGRvbUlkOiBbeyB0eXBlOiBJbnB1dCB9XSxcclxuICAgICAgICBfaWQ6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ25nYk5hdkl0ZW0nLF0gfV0sXHJcbiAgICAgICAgY29udGVudFRwbHM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW05nYk5hdkNvbnRlbnQsIHsgZGVzY2VuZGFudHM6IGZhbHNlIH0sXSB9XVxyXG4gICAgfTtcclxuICAgIHJldHVybiBOZ2JOYXZJdGVtO1xyXG59KCkpO1xyXG5leHBvcnQgeyBOZ2JOYXZJdGVtIH07XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIE5nYk5hdkl0ZW0ucHJvdG90eXBlLl9uYXY7XHJcbiAgICAvKipcclxuICAgICAqIElmIGB0cnVlYCwgbm9uLWFjdGl2ZSBjdXJyZW50IG5hdiBpdGVtIGNvbnRlbnQgd2lsbCBiZSByZW1vdmVkIGZyb20gRE9NXHJcbiAgICAgKiBPdGhlcndpc2UgaXQgd2lsbCBqdXN0IGJlIGhpZGRlblxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYk5hdkl0ZW0ucHJvdG90eXBlLmRlc3Ryb3lPbkhpZGU7XHJcbiAgICAvKipcclxuICAgICAqIElmIGB0cnVlYCwgdGhlIGN1cnJlbnQgbmF2IGl0ZW0gaXMgZGlzYWJsZWQgYW5kIGNhbid0IGJlIHRvZ2dsZWQgYnkgdXNlci5cclxuICAgICAqXHJcbiAgICAgKiBOZXZlcnRoZWxlc3MgZGlzYWJsZWQgbmF2IGNhbiBiZSBzZWxlY3RlZCBwcm9ncmFtbWF0aWNhbGx5IHZpYSB0aGUgYC5zZWxlY3QoKWAgbWV0aG9kIGFuZCB0aGUgYFthY3RpdmVJZF1gIGJpbmRpbmcuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiTmF2SXRlbS5wcm90b3R5cGUuZGlzYWJsZWQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpZCB1c2VkIGZvciB0aGUgRE9NIGVsZW1lbnRzLlxyXG4gICAgICogTXVzdCBiZSB1bmlxdWUgaW5zaWRlIHRoZSBkb2N1bWVudCBpbiBjYXNlIHlvdSBoYXZlIG11bHRpcGxlIGBuZ2JOYXZgcyBvbiB0aGUgcGFnZS5cclxuICAgICAqXHJcbiAgICAgKiBBdXRvZ2VuZXJhdGVkIGFzIGBuZ2ItbmF2LVhYWGAgaWYgbm90IHByb3ZpZGVkLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYk5hdkl0ZW0ucHJvdG90eXBlLmRvbUlkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaWQgdXNlZCBhcyBhIG1vZGVsIGZvciBhY3RpdmUgbmF2LlxyXG4gICAgICogSXQgY2FuIGJlIGFueXRoaW5nLCBidXQgbXVzdCBiZSB1bmlxdWUgaW5zaWRlIG9uZSBgbmdiTmF2YC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgb25seSBsaW1pdGF0aW9uIGlzIHRoYXQgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGhhdmUgdGhlIGAnJ2AgKGVtcHR5IHN0cmluZykgYXMgaWQsXHJcbiAgICAgKiBiZWNhdXNlIGAgbmdiTmF2SXRlbSBgLCBgbmdiTmF2SXRlbT0nJ2AgYW5kIGBbbmdiTmF2SXRlbV09XCInJ1wiYCBhcmUgaW5kaXN0aW5ndWlzaGFibGVcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JOYXZJdGVtLnByb3RvdHlwZS5faWQ7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JOYXZJdGVtLnByb3RvdHlwZS5jb250ZW50VHBsO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgTmdiTmF2SXRlbS5wcm90b3R5cGUuY29udGVudFRwbHM7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JOYXZJdGVtLnByb3RvdHlwZS5lbGVtZW50UmVmO1xyXG59XHJcbi8qKlxyXG4gKiBBIG5hdiBkaXJlY3RpdmUgdGhhdCBoZWxwcyB3aXRoIGltcGxlbWVudGluZyB0YWJiZWQgbmF2aWdhdGlvbiBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBcXEBzaW5jZSA1LjIuMFxyXG4gKi9cclxudmFyIE5nYk5hdiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5nYk5hdihyb2xlLCBjb25maWcsIF9jZCkge1xyXG4gICAgICAgIHRoaXMucm9sZSA9IHJvbGU7XHJcbiAgICAgICAgdGhpcy5fY2QgPSBfY2Q7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGV2ZW50IGVtaXR0ZWQgYWZ0ZXIgdGhlIGFjdGl2ZSBuYXYgY2hhbmdlc1xyXG4gICAgICAgICAqIFRoZSBwYXlsb2FkIG9mIHRoZSBldmVudCBpcyB0aGUgbmV3bHkgYWN0aXZlIG5hdiBpZFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSWYgeW91IHdhbnQgdG8gcHJldmVudCBuYXYgY2hhbmdlLCB5b3Ugc2hvdWxkIHVzZSBgKG5hdkNoYW5nZSlgIGV2ZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hY3RpdmVJZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbmF2IGNoYW5nZSBldmVudCBlbWl0dGVkIHJpZ2h0IGJlZm9yZSB0aGUgbmF2IGNoYW5nZSBoYXBwZW5zIG9uIHVzZXIgY2xpY2suXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGlzIGV2ZW50IHdvbid0IGJlIGVtaXR0ZWQgaWYgbmF2IGlzIGNoYW5nZWQgcHJvZ3JhbW1hdGljYWxseSB2aWEgYFthY3RpdmVJZF1gIG9yIGAuc2VsZWN0KClgLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogU2VlIFtgTmdiTmF2Q2hhbmdlRXZlbnRgXSgjL2NvbXBvbmVudHMvbmF2L2FwaSNOZ2JOYXZDaGFuZ2VFdmVudCkgZm9yIHBheWxvYWQgZGV0YWlscy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm5hdkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmRlc3Ryb3lPbkhpZGUgPSBjb25maWcuZGVzdHJveU9uSGlkZTtcclxuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gY29uZmlnLm9yaWVudGF0aW9uO1xyXG4gICAgICAgIHRoaXMucm9sZXMgPSBjb25maWcucm9sZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gaXRlbVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdiTmF2LnByb3RvdHlwZS5jbGljayA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBpdGVtXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIGlmICghaXRlbS5kaXNhYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVBY3RpdmVJZChpdGVtLmlkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZWxlY3RzIHRoZSBuYXYgd2l0aCB0aGUgZ2l2ZW4gaWQgYW5kIHNob3dzIGl0cyBhc3NvY2lhdGVkIHBhbmUuXHJcbiAgICAgKiBBbnkgb3RoZXIgbmF2IHRoYXQgd2FzIHByZXZpb3VzbHkgc2VsZWN0ZWQgYmVjb21lcyB1bnNlbGVjdGVkIGFuZCBpdHMgYXNzb2NpYXRlZCBwYW5lIGlzIGhpZGRlbi5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZWxlY3RzIHRoZSBuYXYgd2l0aCB0aGUgZ2l2ZW4gaWQgYW5kIHNob3dzIGl0cyBhc3NvY2lhdGVkIHBhbmUuXHJcbiAgICAgKiBBbnkgb3RoZXIgbmF2IHRoYXQgd2FzIHByZXZpb3VzbHkgc2VsZWN0ZWQgYmVjb21lcyB1bnNlbGVjdGVkIGFuZCBpdHMgYXNzb2NpYXRlZCBwYW5lIGlzIGhpZGRlbi5cclxuICAgICAqIEBwYXJhbSB7P30gaWRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nYk5hdi5wcm90b3R5cGUuc2VsZWN0ID0gLyoqXHJcbiAgICAgKiBTZWxlY3RzIHRoZSBuYXYgd2l0aCB0aGUgZ2l2ZW4gaWQgYW5kIHNob3dzIGl0cyBhc3NvY2lhdGVkIHBhbmUuXHJcbiAgICAgKiBBbnkgb3RoZXIgbmF2IHRoYXQgd2FzIHByZXZpb3VzbHkgc2VsZWN0ZWQgYmVjb21lcyB1bnNlbGVjdGVkIGFuZCBpdHMgYXNzb2NpYXRlZCBwYW5lIGlzIGhpZGRlbi5cclxuICAgICAqIEBwYXJhbSB7P30gaWRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChpZCkgeyB0aGlzLl91cGRhdGVBY3RpdmVJZChpZCwgZmFsc2UpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JOYXYucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghaXNEZWZpbmVkKHRoaXMuYWN0aXZlSWQpKSB7XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgdmFyIG5leHRJZCA9IHRoaXMuaXRlbXMuZmlyc3QgPyB0aGlzLml0ZW1zLmZpcnN0LmlkIDogbnVsbDtcclxuICAgICAgICAgICAgaWYgKGlzVmFsaWROYXZJZChuZXh0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBY3RpdmVJZChuZXh0SWQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NkLmRldGVjdENoYW5nZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IG5leHRJZFxyXG4gICAgICogQHBhcmFtIHs/PX0gZW1pdE5hdkNoYW5nZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdiTmF2LnByb3RvdHlwZS5fdXBkYXRlQWN0aXZlSWQgPSAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IG5leHRJZFxyXG4gICAgICogQHBhcmFtIHs/PX0gZW1pdE5hdkNoYW5nZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG5leHRJZCwgZW1pdE5hdkNoYW5nZSkge1xyXG4gICAgICAgIGlmIChlbWl0TmF2Q2hhbmdlID09PSB2b2lkIDApIHsgZW1pdE5hdkNoYW5nZSA9IHRydWU7IH1cclxuICAgICAgICBpZiAodGhpcy5hY3RpdmVJZCAhPT0gbmV4dElkKSB7XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgdmFyIGRlZmF1bHRQcmV2ZW50ZWRfMSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoZW1pdE5hdkNoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uYXZDaGFuZ2UuZW1pdCh7IGFjdGl2ZUlkOiB0aGlzLmFjdGl2ZUlkLCBuZXh0SWQ6IG5leHRJZCwgcHJldmVudERlZmF1bHQ6ICgvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgZGVmYXVsdFByZXZlbnRlZF8xID0gdHJ1ZTsgfSkgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0UHJldmVudGVkXzEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlSWQgPSBuZXh0SWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUlkQ2hhbmdlLmVtaXQobmV4dElkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBOZ2JOYXYuZGVjb3JhdG9ycyA9IFtcclxuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tuZ2JOYXZdJyxcclxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ25nYk5hdicsXHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm5hdl0nOiAndHJ1ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdbY2xhc3MuZmxleC1jb2x1bW5dJzogXCJvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1vcmllbnRhdGlvbl0nOiBcIm9yaWVudGF0aW9uID09PSAndmVydGljYWwnICYmIHJvbGVzID09PSAndGFibGlzdCcgPyAndmVydGljYWwnIDogdW5kZWZpbmVkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdbYXR0ci5yb2xlXSc6IFwicm9sZSA/IHJvbGUgOiByb2xlcyA/ICd0YWJsaXN0JyA6IHVuZGVmaW5lZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXSB9XHJcbiAgICBdO1xyXG4gICAgLyoqIEBub2NvbGxhcHNlICovXHJcbiAgICBOZ2JOYXYuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXHJcbiAgICAgICAgeyB0eXBlOiBTdHJpbmcsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEF0dHJpYnV0ZSwgYXJnczogWydyb2xlJyxdIH1dIH0sXHJcbiAgICAgICAgeyB0eXBlOiBOZ2JOYXZDb25maWcgfSxcclxuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH1cclxuICAgIF07IH07XHJcbiAgICBOZ2JOYXYucHJvcERlY29yYXRvcnMgPSB7XHJcbiAgICAgICAgYWN0aXZlSWQ6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIGFjdGl2ZUlkQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXHJcbiAgICAgICAgZGVzdHJveU9uSGlkZTogW3sgdHlwZTogSW5wdXQgfV0sXHJcbiAgICAgICAgb3JpZW50YXRpb246IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIHJvbGVzOiBbeyB0eXBlOiBJbnB1dCB9XSxcclxuICAgICAgICBpdGVtczogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTmdiTmF2SXRlbSxdIH1dLFxyXG4gICAgICAgIG5hdkNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5nYk5hdjtcclxufSgpKTtcclxuZXhwb3J0IHsgTmdiTmF2IH07XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaWQgb2YgdGhlIG5hdiB0aGF0IHNob3VsZCBiZSBhY3RpdmVcclxuICAgICAqXHJcbiAgICAgKiBZb3UgY291bGQgYWxzbyB1c2UgdGhlIGAuc2VsZWN0KClgIG1ldGhvZCBhbmQgdGhlIGAobmF2Q2hhbmdlKWAgZXZlbnRcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JOYXYucHJvdG90eXBlLmFjdGl2ZUlkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZXZlbnQgZW1pdHRlZCBhZnRlciB0aGUgYWN0aXZlIG5hdiBjaGFuZ2VzXHJcbiAgICAgKiBUaGUgcGF5bG9hZCBvZiB0aGUgZXZlbnQgaXMgdGhlIG5ld2x5IGFjdGl2ZSBuYXYgaWRcclxuICAgICAqXHJcbiAgICAgKiBJZiB5b3Ugd2FudCB0byBwcmV2ZW50IG5hdiBjaGFuZ2UsIHlvdSBzaG91bGQgdXNlIGAobmF2Q2hhbmdlKWAgZXZlbnRcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JOYXYucHJvdG90eXBlLmFjdGl2ZUlkQ2hhbmdlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBgdHJ1ZWAsIG5vbi1hY3RpdmUgbmF2IGNvbnRlbnQgd2lsbCBiZSByZW1vdmVkIGZyb20gRE9NXHJcbiAgICAgKiBPdGhlcndpc2UgaXQgd2lsbCBqdXN0IGJlIGhpZGRlblxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYk5hdi5wcm90b3R5cGUuZGVzdHJveU9uSGlkZTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9yaWVudGF0aW9uIG9mIG5hdnMuXHJcbiAgICAgKlxyXG4gICAgICogVXNpbmcgYHZlcnRpY2FsYCB3aWxsIGFsc28gYWRkIHRoZSBgYXJpYS1vcmllbnRhdGlvbmAgYXR0cmlidXRlXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiTmF2LnByb3RvdHlwZS5vcmllbnRhdGlvbjtcclxuICAgIC8qKlxyXG4gICAgICogUm9sZSBhdHRyaWJ1dGUgZ2VuZXJhdGluZyBzdHJhdGVneTpcclxuICAgICAqIC0gYGZhbHNlYCAtIG5vIHJvbGUgYXR0cmlidXRlcyB3aWxsIGJlIGdlbmVyYXRlZFxyXG4gICAgICogLSBgJ3RhYmxpc3QnYCAtICd0YWJsaXN0JywgJ3RhYicgYW5kICd0YWJwYW5lbCcgd2lsbCBiZSBnZW5lcmF0ZWQgKGRlZmF1bHQpXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiTmF2LnByb3RvdHlwZS5yb2xlcztcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE5nYk5hdi5wcm90b3R5cGUuaXRlbXM7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYXYgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgcmlnaHQgYmVmb3JlIHRoZSBuYXYgY2hhbmdlIGhhcHBlbnMgb24gdXNlciBjbGljay5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGV2ZW50IHdvbid0IGJlIGVtaXR0ZWQgaWYgbmF2IGlzIGNoYW5nZWQgcHJvZ3JhbW1hdGljYWxseSB2aWEgYFthY3RpdmVJZF1gIG9yIGAuc2VsZWN0KClgLlxyXG4gICAgICpcclxuICAgICAqIFNlZSBbYE5nYk5hdkNoYW5nZUV2ZW50YF0oIy9jb21wb25lbnRzL25hdi9hcGkjTmdiTmF2Q2hhbmdlRXZlbnQpIGZvciBwYXlsb2FkIGRldGFpbHMuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiTmF2LnByb3RvdHlwZS5uYXZDaGFuZ2U7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JOYXYucHJvdG90eXBlLnJvbGU7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgTmdiTmF2LnByb3RvdHlwZS5fY2Q7XHJcbn1cclxuLyoqXHJcbiAqIEEgZGlyZWN0aXZlIHRvIHB1dCBvbiB0aGUgbmF2IGxpbmsuXHJcbiAqXHJcbiAqIFxcQHNpbmNlIDUuMi4wXHJcbiAqL1xyXG52YXIgTmdiTmF2TGluayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5nYk5hdkxpbmsocm9sZSwgbmF2SXRlbSwgbmF2KSB7XHJcbiAgICAgICAgdGhpcy5yb2xlID0gcm9sZTtcclxuICAgICAgICB0aGlzLm5hdkl0ZW0gPSBuYXZJdGVtO1xyXG4gICAgICAgIHRoaXMubmF2ID0gbmF2O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JOYXZMaW5rLnByb3RvdHlwZS5oYXNOYXZJdGVtQ2xhc3MgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyB3aXRoIGFsdGVybmF0aXZlIG1hcmt1cCB3ZSBoYXZlIHRvIGFkZCBgLm5hdi1pdGVtYCBjbGFzcywgYmVjYXVzZSBgbmdiTmF2SXRlbWAgaXMgb24gdGhlIG5nLWNvbnRhaW5lclxyXG4gICAgICAgIHJldHVybiB0aGlzLm5hdkl0ZW0uZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkNPTU1FTlRfTk9ERTtcclxuICAgIH07XHJcbiAgICBOZ2JOYXZMaW5rLmRlY29yYXRvcnMgPSBbXHJcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdhW25nYk5hdkxpbmtdJyxcclxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdbaWRdJzogJ25hdkl0ZW0uZG9tSWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm5hdi1saW5rXSc6ICd0cnVlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5uYXYtaXRlbV0nOiAnaGFzTmF2SXRlbUNsYXNzKCknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2F0dHIucm9sZV0nOiBcInJvbGUgPyByb2xlIDogbmF2LnJvbGVzID8gJ3RhYicgOiB1bmRlZmluZWRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hyZWYnOiAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5hY3RpdmVdJzogJ25hdkl0ZW0uYWN0aXZlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5kaXNhYmxlZF0nOiAnbmF2SXRlbS5kaXNhYmxlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdbYXR0ci50YWJpbmRleF0nOiAnbmF2SXRlbS5kaXNhYmxlZCA/IC0xIDogdW5kZWZpbmVkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtY29udHJvbHNdJzogJ25hdkl0ZW0uaXNQYW5lbEluRG9tKCkgPyBuYXZJdGVtLnBhbmVsRG9tSWQgOiBudWxsJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtc2VsZWN0ZWRdJzogJ25hdkl0ZW0uYWN0aXZlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtZGlzYWJsZWRdJzogJ25hdkl0ZW0uZGlzYWJsZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnKGNsaWNrKSc6ICduYXYuY2xpY2sobmF2SXRlbSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXSB9XHJcbiAgICBdO1xyXG4gICAgLyoqIEBub2NvbGxhcHNlICovXHJcbiAgICBOZ2JOYXZMaW5rLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgICAgIHsgdHlwZTogU3RyaW5nLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBBdHRyaWJ1dGUsIGFyZ3M6IFsncm9sZScsXSB9XSB9LFxyXG4gICAgICAgIHsgdHlwZTogTmdiTmF2SXRlbSB9LFxyXG4gICAgICAgIHsgdHlwZTogTmdiTmF2IH1cclxuICAgIF07IH07XHJcbiAgICByZXR1cm4gTmdiTmF2TGluaztcclxufSgpKTtcclxuZXhwb3J0IHsgTmdiTmF2TGluayB9O1xyXG5pZiAoZmFsc2UpIHtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE5nYk5hdkxpbmsucHJvdG90eXBlLnJvbGU7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JOYXZMaW5rLnByb3RvdHlwZS5uYXZJdGVtO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgTmdiTmF2TGluay5wcm90b3R5cGUubmF2O1xyXG59XHJcbi8qKlxyXG4gKiBUaGUgcGF5bG9hZCBvZiB0aGUgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgcmlnaHQgYmVmb3JlIHRoZSBuYXYgY2hhbmdlIGhhcHBlbnMgb24gdXNlciBjbGljay5cclxuICpcclxuICogVGhpcyBldmVudCB3b24ndCBiZSBlbWl0dGVkIGlmIG5hdiBpcyBjaGFuZ2VkIHByb2dyYW1tYXRpY2FsbHkgdmlhIGBbYWN0aXZlSWRdYCBvciBgLnNlbGVjdCgpYC5cclxuICpcclxuICogXFxAc2luY2UgNS4yLjBcclxuICogQHJlY29yZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE5nYk5hdkNoYW5nZUV2ZW50KCkgeyB9XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBuYXYuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiTmF2Q2hhbmdlRXZlbnQucHJvdG90eXBlLmFjdGl2ZUlkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZCBvZiB0aGUgbmV3bHkgc2VsZWN0ZWQgbmF2LlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYk5hdkNoYW5nZUV2ZW50LnByb3RvdHlwZS5uZXh0SWQ7XHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRoYXQgd2lsbCBwcmV2ZW50IG5hdiBjaGFuZ2UgaWYgY2FsbGVkLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYk5hdkNoYW5nZUV2ZW50LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdDtcclxufVxyXG5leHBvcnQgeyDJtTAgfTtcciJdfQ==