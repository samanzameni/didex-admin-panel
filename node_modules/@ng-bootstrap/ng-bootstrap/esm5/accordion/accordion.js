/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ContentChildren, Directive, EventEmitter, Host, Input, Optional, Output, QueryList, TemplateRef, ViewEncapsulation } from '@angular/core';
import { isString } from '../util/util';
import { NgbAccordionConfig } from './accordion-config';
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["role", "tablist", 1, "accordion"];
const _c1 = ["ngbPanelHeader", ""];
const _c2 = ["t", ""];
const _c3 = ["ngFor", "", 3, "ngForOf"];
const _c4 = [1, "btn", "btn-link", 3, "ngbPanelToggle"];
const _c5 = [3, "ngTemplateOutlet"];
function NgbAccordion_ng_template_0_ng_template_2_Template(rf, ctx) { }
function NgbAccordion_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", _c4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵtemplate(2, NgbAccordion_ng_template_0_ng_template_2_Template, 0, 0, "ng-template", _c5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const panel_r630 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngbPanelToggle", panel_r630);
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", panel_r630.title, "");
    ɵngcc0.ɵɵselect(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", panel_r630.titleTpl == null ? null : panel_r630.titleTpl.templateRef);
} }
const _c6 = ["role", "tab", 3, "id"];
const _c7 = [3, "ngTemplateOutlet", "ngTemplateOutletContext"];
const _c8 = ["role", "tabpanel", "class", "collapse", 3, "id", "show", 4, "ngIf"];
function NgbAccordion_ng_template_2_ng_template_2_Template(rf, ctx) { }
const _c9 = ["role", "tabpanel", 1, "collapse", 3, "id"];
const _c10 = [1, "card-body"];
function NgbAccordion_ng_template_2_div_3_ng_template_2_Template(rf, ctx) { }
function NgbAccordion_ng_template_2_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", _c9);
    ɵngcc0.ɵɵstyling();
    ɵngcc0.ɵɵelementStart(1, "div", _c10);
    ɵngcc0.ɵɵtemplate(2, NgbAccordion_ng_template_2_div_3_ng_template_2_Template, 0, 0, "ng-template", _c5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const panel_r632 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵclassProp("show", panel_r632.isOpen);
    ɵngcc0.ɵɵstylingApply();
    ɵngcc0.ɵɵpropertyInterpolate("id", panel_r632.id);
    ɵngcc0.ɵɵattribute("aria-labelledby", panel_r632.id + "-header");
    ɵngcc0.ɵɵselect(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", panel_r632.contentTpl == null ? null : panel_r632.contentTpl.templateRef);
} }
const _c11 = function (a0, a1) { return { $implicit: a0, opened: a1 }; };
function NgbAccordion_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵstyling();
    ɵngcc0.ɵɵelementStart(1, "div", _c6);
    ɵngcc0.ɵɵstyling();
    ɵngcc0.ɵɵtemplate(2, NgbAccordion_ng_template_2_ng_template_2_Template, 0, 0, "ng-template", _c7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, NgbAccordion_ng_template_2_div_3_Template, 3, 4, "div", _c8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const panel_r632 = ctx.$implicit;
    const ctx_r629 = ɵngcc0.ɵɵnextContext();
    const _r627 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵclassMap("card " + (panel_r632.cardClass || ""));
    ɵngcc0.ɵɵstylingApply();
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵclassMap("card-header " + (panel_r632.type ? "bg-" + panel_r632.type : ctx_r629.type ? "bg-" + ctx_r629.type : ""));
    ɵngcc0.ɵɵstylingApply();
    ɵngcc0.ɵɵpropertyInterpolate1("id", "", panel_r632.id, "-header");
    ɵngcc0.ɵɵselect(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", (panel_r632.headerTpl == null ? null : panel_r632.headerTpl.templateRef) || _r627)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(6, _c11, panel_r632, panel_r632.isOpen));
    ɵngcc0.ɵɵselect(3);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r629.destroyOnHide || panel_r632.isOpen);
} }
const _c12 = ["type", "button"];
var nextId = 0;
/**
 * The context for the [NgbPanelHeader](#/components/accordion/api#NgbPanelHeader) template
 *
 * \@since 4.1.0
 * @record
 */
export function NgbPanelHeaderContext() { }
if (false) {
    /**
     * `True` if current panel is opened
     * @type {?}
     */
    NgbPanelHeaderContext.prototype.opened;
}
/**
 * A directive that wraps an accordion panel header with any HTML markup and a toggling button
 * marked with [`NgbPanelToggle`](#/components/accordion/api#NgbPanelToggle).
 * See the [header customization demo](#/components/accordion/examples#header) for more details.
 *
 * You can also use [`NgbPanelTitle`](#/components/accordion/api#NgbPanelTitle) to customize only the panel title.
 *
 * \@since 4.1.0
 */
var NgbPanelHeader = /** @class */ (function () {
    function NgbPanelHeader(templateRef) {
        this.templateRef = templateRef;
    }
    /** @nocollapse */
    NgbPanelHeader.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
NgbPanelHeader.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbPanelHeader, selectors: [["ng-template", "ngbPanelHeader", ""]], factory: function NgbPanelHeader_Factory(t) { return new (t || NgbPanelHeader)(ɵngcc0.ɵɵdirectiveInject(TemplateRef)); } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbPanelHeader, [{
        type: Directive,
        args: [{ selector: 'ng-template[ngbPanelHeader]' }]
    }], function () { return [{ type: TemplateRef }]; }, { templateRef: [] });
    return NgbPanelHeader;
}());
export { NgbPanelHeader };
if (false) {
    /** @type {?} */
    NgbPanelHeader.prototype.templateRef;
}
/**
 * A directive that wraps only the panel title with HTML markup inside.
 *
 * You can also use [`NgbPanelHeader`](#/components/accordion/api#NgbPanelHeader) to customize the full panel header.
 */
var NgbPanelTitle = /** @class */ (function () {
    function NgbPanelTitle(templateRef) {
        this.templateRef = templateRef;
    }
    /** @nocollapse */
    NgbPanelTitle.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
NgbPanelTitle.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbPanelTitle, selectors: [["ng-template", "ngbPanelTitle", ""]], factory: function NgbPanelTitle_Factory(t) { return new (t || NgbPanelTitle)(ɵngcc0.ɵɵdirectiveInject(TemplateRef)); } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbPanelTitle, [{
        type: Directive,
        args: [{ selector: 'ng-template[ngbPanelTitle]' }]
    }], function () { return [{ type: TemplateRef }]; }, { templateRef: [] });
    return NgbPanelTitle;
}());
export { NgbPanelTitle };
if (false) {
    /** @type {?} */
    NgbPanelTitle.prototype.templateRef;
}
/**
 * A directive that wraps the accordion panel content.
 */
var NgbPanelContent = /** @class */ (function () {
    function NgbPanelContent(templateRef) {
        this.templateRef = templateRef;
    }
    /** @nocollapse */
    NgbPanelContent.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
NgbPanelContent.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbPanelContent, selectors: [["ng-template", "ngbPanelContent", ""]], factory: function NgbPanelContent_Factory(t) { return new (t || NgbPanelContent)(ɵngcc0.ɵɵdirectiveInject(TemplateRef)); } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbPanelContent, [{
        type: Directive,
        args: [{ selector: 'ng-template[ngbPanelContent]' }]
    }], function () { return [{ type: TemplateRef }]; }, { templateRef: [] });
    return NgbPanelContent;
}());
export { NgbPanelContent };
if (false) {
    /** @type {?} */
    NgbPanelContent.prototype.templateRef;
}
/**
 * A directive that wraps an individual accordion panel with title and collapsible content.
 */
var NgbPanel = /** @class */ (function () {
    function NgbPanel() {
        /**
         *  If `true`, the panel is disabled an can't be toggled.
         */
        this.disabled = false;
        /**
         *  An optional id for the panel that must be unique on the page.
         *
         *  If not provided, it will be auto-generated in the `ngb-panel-xxx` format.
         */
        this.id = "ngb-panel-" + nextId++;
        this.isOpen = false;
    }
    /**
     * @return {?}
     */
    NgbPanel.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
        // We are using @ContentChildren instead of @ContentChild as in the Angular version being used
        // only @ContentChildren allows us to specify the {descendants: false} option.
        // Without {descendants: false} we are hitting bugs described in:
        // https://github.com/ng-bootstrap/ng-bootstrap/issues/2240
        this.titleTpl = this.titleTpls.first;
        this.headerTpl = this.headerTpls.first;
        this.contentTpl = this.contentTpls.first;
    };
    NgbPanel.propDecorators = {
        disabled: [{ type: Input }],
        id: [{ type: Input }],
        title: [{ type: Input }],
        type: [{ type: Input }],
        cardClass: [{ type: Input }],
        titleTpls: [{ type: ContentChildren, args: [NgbPanelTitle, { descendants: false },] }],
        headerTpls: [{ type: ContentChildren, args: [NgbPanelHeader, { descendants: false },] }],
        contentTpls: [{ type: ContentChildren, args: [NgbPanelContent, { descendants: false },] }]
    };
NgbPanel.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbPanel, selectors: [["ngb-panel"]], factory: function NgbPanel_Factory(t) { return new (t || NgbPanel)(); }, contentQueries: function NgbPanel_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbPanelTitle, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbPanelHeader, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbPanelContent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.titleTpls = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.headerTpls = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.contentTpls = _t);
    } }, inputs: { disabled: "disabled", id: "id", title: "title", type: "type", cardClass: "cardClass" } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbPanel, [{
        type: Directive,
        args: [{ selector: 'ngb-panel' }]
    }], function () { return []; }, { disabled: [{
            type: Input
        }], id: [{
            type: Input
        }], isOpen: [], ngAfterContentChecked: [], titleTpl: [], headerTpl: [], contentTpl: [], title: [{
            type: Input
        }], type: [{
            type: Input
        }], cardClass: [{
            type: Input
        }], titleTpls: [{
            type: ContentChildren,
            args: [NgbPanelTitle, { descendants: false }]
        }], headerTpls: [{
            type: ContentChildren,
            args: [NgbPanelHeader, { descendants: false }]
        }], contentTpls: [{
            type: ContentChildren,
            args: [NgbPanelContent, { descendants: false }]
        }] });
    return NgbPanel;
}());
export { NgbPanel };
if (false) {
    /**
     *  If `true`, the panel is disabled an can't be toggled.
     * @type {?}
     */
    NgbPanel.prototype.disabled;
    /**
     *  An optional id for the panel that must be unique on the page.
     *
     *  If not provided, it will be auto-generated in the `ngb-panel-xxx` format.
     * @type {?}
     */
    NgbPanel.prototype.id;
    /** @type {?} */
    NgbPanel.prototype.isOpen;
    /**
     *  The panel title.
     *
     *  You can alternatively use [`NgbPanelTitle`](#/components/accordion/api#NgbPanelTitle) to set panel title.
     * @type {?}
     */
    NgbPanel.prototype.title;
    /**
     * Type of the current panel.
     *
     * Bootstrap provides styles for the following types: `'success'`, `'info'`, `'warning'`, `'danger'`, `'primary'`,
     * `'secondary'`, `'light'` and `'dark'`.
     * @type {?}
     */
    NgbPanel.prototype.type;
    /**
     * An optional class applied to the accordion card element that wraps both panel title and content.
     *
     * \@since 5.3.0
     * @type {?}
     */
    NgbPanel.prototype.cardClass;
    /** @type {?} */
    NgbPanel.prototype.titleTpl;
    /** @type {?} */
    NgbPanel.prototype.headerTpl;
    /** @type {?} */
    NgbPanel.prototype.contentTpl;
    /** @type {?} */
    NgbPanel.prototype.titleTpls;
    /** @type {?} */
    NgbPanel.prototype.headerTpls;
    /** @type {?} */
    NgbPanel.prototype.contentTpls;
}
/**
 * An event emitted right before toggling an accordion panel.
 * @record
 */
export function NgbPanelChangeEvent() { }
if (false) {
    /**
     * The id of the accordion panel that is being toggled.
     * @type {?}
     */
    NgbPanelChangeEvent.prototype.panelId;
    /**
     * The next state of the panel.
     *
     * `true` if it will be opened, `false` if closed.
     * @type {?}
     */
    NgbPanelChangeEvent.prototype.nextState;
    /**
     * Calling this function will prevent panel toggling.
     * @type {?}
     */
    NgbPanelChangeEvent.prototype.preventDefault;
}
/**
 * Accordion is a collection of collapsible panels (bootstrap cards).
 *
 * It can ensure only one panel is opened at a time and allows to customize panel
 * headers.
 */
var NgbAccordion = /** @class */ (function () {
    function NgbAccordion(config) {
        /**
         * An array or comma separated strings of panel ids that should be opened **initially**.
         *
         * For subsequent changes use methods like `expand()`, `collapse()`, etc. and
         * the `(panelChange)` event.
         */
        this.activeIds = [];
        /**
         * If `true`, panel content will be detached from DOM and not simply hidden when the panel is collapsed.
         */
        this.destroyOnHide = true;
        /**
         * Event emitted right before the panel toggle happens.
         *
         * See [NgbPanelChangeEvent](#/components/accordion/api#NgbPanelChangeEvent) for payload details.
         */
        this.panelChange = new EventEmitter();
        this.type = config.type;
        this.closeOtherPanels = config.closeOthers;
    }
    /**
     * Checks if a panel with a given id is expanded.
     */
    /**
     * Checks if a panel with a given id is expanded.
     * @param {?} panelId
     * @return {?}
     */
    NgbAccordion.prototype.isExpanded = /**
     * Checks if a panel with a given id is expanded.
     * @param {?} panelId
     * @return {?}
     */
    function (panelId) { return this.activeIds.indexOf(panelId) > -1; };
    /**
     * Expands a panel with a given id.
     *
     * Has no effect if the panel is already expanded or disabled.
     */
    /**
     * Expands a panel with a given id.
     *
     * Has no effect if the panel is already expanded or disabled.
     * @param {?} panelId
     * @return {?}
     */
    NgbAccordion.prototype.expand = /**
     * Expands a panel with a given id.
     *
     * Has no effect if the panel is already expanded or disabled.
     * @param {?} panelId
     * @return {?}
     */
    function (panelId) { this._changeOpenState(this._findPanelById(panelId), true); };
    /**
     * Expands all panels, if `[closeOthers]` is `false`.
     *
     * If `[closeOthers]` is `true`, it will expand the first panel, unless there is already a panel opened.
     */
    /**
     * Expands all panels, if `[closeOthers]` is `false`.
     *
     * If `[closeOthers]` is `true`, it will expand the first panel, unless there is already a panel opened.
     * @return {?}
     */
    NgbAccordion.prototype.expandAll = /**
     * Expands all panels, if `[closeOthers]` is `false`.
     *
     * If `[closeOthers]` is `true`, it will expand the first panel, unless there is already a panel opened.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.closeOtherPanels) {
            if (this.activeIds.length === 0 && this.panels.length) {
                this._changeOpenState(this.panels.first, true);
            }
        }
        else {
            this.panels.forEach((/**
             * @param {?} panel
             * @return {?}
             */
            function (panel) { return _this._changeOpenState(panel, true); }));
        }
    };
    /**
     * Collapses a panel with the given id.
     *
     * Has no effect if the panel is already collapsed or disabled.
     */
    /**
     * Collapses a panel with the given id.
     *
     * Has no effect if the panel is already collapsed or disabled.
     * @param {?} panelId
     * @return {?}
     */
    NgbAccordion.prototype.collapse = /**
     * Collapses a panel with the given id.
     *
     * Has no effect if the panel is already collapsed or disabled.
     * @param {?} panelId
     * @return {?}
     */
    function (panelId) { this._changeOpenState(this._findPanelById(panelId), false); };
    /**
     * Collapses all opened panels.
     */
    /**
     * Collapses all opened panels.
     * @return {?}
     */
    NgbAccordion.prototype.collapseAll = /**
     * Collapses all opened panels.
     * @return {?}
     */
    function () {
        var _this = this;
        this.panels.forEach((/**
         * @param {?} panel
         * @return {?}
         */
        function (panel) { _this._changeOpenState(panel, false); }));
    };
    /**
     * Toggles a panel with the given id.
     *
     * Has no effect if the panel is disabled.
     */
    /**
     * Toggles a panel with the given id.
     *
     * Has no effect if the panel is disabled.
     * @param {?} panelId
     * @return {?}
     */
    NgbAccordion.prototype.toggle = /**
     * Toggles a panel with the given id.
     *
     * Has no effect if the panel is disabled.
     * @param {?} panelId
     * @return {?}
     */
    function (panelId) {
        /** @type {?} */
        var panel = this._findPanelById(panelId);
        if (panel) {
            this._changeOpenState(panel, !panel.isOpen);
        }
    };
    /**
     * @return {?}
     */
    NgbAccordion.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // active id updates
        if (isString(this.activeIds)) {
            this.activeIds = this.activeIds.split(/\s*,\s*/);
        }
        // update panels open states
        this.panels.forEach((/**
         * @param {?} panel
         * @return {?}
         */
        function (panel) { return panel.isOpen = !panel.disabled && _this.activeIds.indexOf(panel.id) > -1; }));
        // closeOthers updates
        if (this.activeIds.length > 1 && this.closeOtherPanels) {
            this._closeOthers(this.activeIds[0]);
            this._updateActiveIds();
        }
    };
    /**
     * @private
     * @param {?} panel
     * @param {?} nextState
     * @return {?}
     */
    NgbAccordion.prototype._changeOpenState = /**
     * @private
     * @param {?} panel
     * @param {?} nextState
     * @return {?}
     */
    function (panel, nextState) {
        if (panel && !panel.disabled && panel.isOpen !== nextState) {
            /** @type {?} */
            var defaultPrevented_1 = false;
            this.panelChange.emit({ panelId: panel.id, nextState: nextState, preventDefault: (/**
                 * @return {?}
                 */
                function () { defaultPrevented_1 = true; }) });
            if (!defaultPrevented_1) {
                panel.isOpen = nextState;
                if (nextState && this.closeOtherPanels) {
                    this._closeOthers(panel.id);
                }
                this._updateActiveIds();
            }
        }
    };
    /**
     * @private
     * @param {?} panelId
     * @return {?}
     */
    NgbAccordion.prototype._closeOthers = /**
     * @private
     * @param {?} panelId
     * @return {?}
     */
    function (panelId) {
        this.panels.forEach((/**
         * @param {?} panel
         * @return {?}
         */
        function (panel) {
            if (panel.id !== panelId) {
                panel.isOpen = false;
            }
        }));
    };
    /**
     * @private
     * @param {?} panelId
     * @return {?}
     */
    NgbAccordion.prototype._findPanelById = /**
     * @private
     * @param {?} panelId
     * @return {?}
     */
    function (panelId) { return this.panels.find((/**
     * @param {?} p
     * @return {?}
     */
    function (p) { return p.id === panelId; })); };
    /**
     * @private
     * @return {?}
     */
    NgbAccordion.prototype._updateActiveIds = /**
     * @private
     * @return {?}
     */
    function () {
        this.activeIds = this.panels.filter((/**
         * @param {?} panel
         * @return {?}
         */
        function (panel) { return panel.isOpen && !panel.disabled; })).map((/**
         * @param {?} panel
         * @return {?}
         */
        function (panel) { return panel.id; }));
    };
    /** @nocollapse */
    NgbAccordion.ctorParameters = function () { return [
        { type: NgbAccordionConfig }
    ]; };
    NgbAccordion.propDecorators = {
        panels: [{ type: ContentChildren, args: [NgbPanel,] }],
        activeIds: [{ type: Input }],
        closeOtherPanels: [{ type: Input, args: ['closeOthers',] }],
        destroyOnHide: [{ type: Input }],
        type: [{ type: Input }],
        panelChange: [{ type: Output }]
    };
NgbAccordion.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: NgbAccordion, selectors: [["ngb-accordion"]], factory: function NgbAccordion_Factory(t) { return new (t || NgbAccordion)(ɵngcc0.ɵɵdirectiveInject(NgbAccordionConfig)); }, contentQueries: function NgbAccordion_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbPanel, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.panels = _t);
    } }, hostBindings: function NgbAccordion_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(1);
        ɵngcc0.ɵɵelementHostAttrs(_c0);
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-multiselectable", !ctx.closeOtherPanels);
    } }, inputs: { activeIds: "activeIds", destroyOnHide: "destroyOnHide", type: "type", closeOtherPanels: ["closeOthers", "closeOtherPanels"] }, outputs: { panelChange: "panelChange" }, exportAs: ["ngbAccordion"], consts: 3, vars: 1, template: function NgbAccordion_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NgbAccordion_ng_template_0_Template, 3, 3, "ng-template", _c1, _c2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, NgbAccordion_ng_template_2_Template, 4, 9, "ng-template", _c3);
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.panels);
    } }, directives: function () { return [NgbPanelHeader, ɵngcc1.NgForOf, NgbPanelToggle, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgIf]; }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbAccordion, [{
        type: Component,
        args: [{
                selector: 'ngb-accordion',
                exportAs: 'ngbAccordion',
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'accordion', 'role': 'tablist', '[attr.aria-multiselectable]': '!closeOtherPanels' },
                template: "\n    <ng-template #t ngbPanelHeader let-panel>\n      <button class=\"btn btn-link\" [ngbPanelToggle]=\"panel\">\n        {{panel.title}}<ng-template [ngTemplateOutlet]=\"panel.titleTpl?.templateRef\"></ng-template>\n      </button>\n    </ng-template>\n    <ng-template ngFor let-panel [ngForOf]=\"panels\">\n      <div [class]=\"'card ' + (panel.cardClass || '')\">\n        <div role=\"tab\" id=\"{{panel.id}}-header\" [class]=\"'card-header ' + (panel.type ? 'bg-'+panel.type: type ? 'bg-'+type : '')\">\n          <ng-template [ngTemplateOutlet]=\"panel.headerTpl?.templateRef || t\"\n                       [ngTemplateOutletContext]=\"{$implicit: panel, opened: panel.isOpen}\"></ng-template>\n        </div>\n        <div id=\"{{panel.id}}\" role=\"tabpanel\" [attr.aria-labelledby]=\"panel.id + '-header'\"\n             class=\"collapse\" [class.show]=\"panel.isOpen\" *ngIf=\"!destroyOnHide || panel.isOpen\">\n          <div class=\"card-body\">\n               <ng-template [ngTemplateOutlet]=\"panel.contentTpl?.templateRef\"></ng-template>\n          </div>\n        </div>\n      </div>\n    </ng-template>\n  "
            }]
    }], function () { return [{ type: NgbAccordionConfig }]; }, { activeIds: [{
            type: Input
        }], destroyOnHide: [{
            type: Input
        }], panelChange: [{
            type: Output
        }], type: [{
            type: Input
        }], closeOtherPanels: [{
            type: Input,
            args: ['closeOthers']
        }], isExpanded: [], expand: [], expandAll: [], collapse: [], collapseAll: [], toggle: [], ngAfterContentChecked: [], _changeOpenState: [], _closeOthers: [], _findPanelById: [], _updateActiveIds: [], panels: [{
            type: ContentChildren,
            args: [NgbPanel]
        }] });
    return NgbAccordion;
}());
export { NgbAccordion };
if (false) {
    /** @type {?} */
    NgbAccordion.prototype.panels;
    /**
     * An array or comma separated strings of panel ids that should be opened **initially**.
     *
     * For subsequent changes use methods like `expand()`, `collapse()`, etc. and
     * the `(panelChange)` event.
     * @type {?}
     */
    NgbAccordion.prototype.activeIds;
    /**
     *  If `true`, only one panel could be opened at a time.
     *
     *  Opening a new panel will close others.
     * @type {?}
     */
    NgbAccordion.prototype.closeOtherPanels;
    /**
     * If `true`, panel content will be detached from DOM and not simply hidden when the panel is collapsed.
     * @type {?}
     */
    NgbAccordion.prototype.destroyOnHide;
    /**
     * Type of panels.
     *
     * Bootstrap provides styles for the following types: `'success'`, `'info'`, `'warning'`, `'danger'`, `'primary'`,
     * `'secondary'`, `'light'` and `'dark'`.
     * @type {?}
     */
    NgbAccordion.prototype.type;
    /**
     * Event emitted right before the panel toggle happens.
     *
     * See [NgbPanelChangeEvent](#/components/accordion/api#NgbPanelChangeEvent) for payload details.
     * @type {?}
     */
    NgbAccordion.prototype.panelChange;
}
/**
 * A directive to put on a button that toggles panel opening and closing.
 *
 * To be used inside the [`NgbPanelHeader`](#/components/accordion/api#NgbPanelHeader)
 *
 * \@since 4.1.0
 */
var NgbPanelToggle = /** @class */ (function () {
    function NgbPanelToggle(accordion, panel) {
        this.accordion = accordion;
        this.panel = panel;
    }
    Object.defineProperty(NgbPanelToggle.prototype, "ngbPanelToggle", {
        set: /**
         * @param {?} panel
         * @return {?}
         */
        function (panel) {
            if (panel) {
                this.panel = panel;
            }
        },
        enumerable: true,
        configurable: true
    });
    /** @nocollapse */
    NgbPanelToggle.ctorParameters = function () { return [
        { type: NgbAccordion },
        { type: NgbPanel, decorators: [{ type: Optional }, { type: Host }] }
    ]; };
    NgbPanelToggle.propDecorators = {
        ngbPanelToggle: [{ type: Input }]
    };
NgbPanelToggle.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbPanelToggle, selectors: [["button", "ngbPanelToggle", ""]], factory: function NgbPanelToggle_Factory(t) { return new (t || NgbPanelToggle)(ɵngcc0.ɵɵdirectiveInject(NgbAccordion), ɵngcc0.ɵɵdirectiveInject(NgbPanel, 9)); }, hostBindings: function NgbPanelToggle_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(4);
        ɵngcc0.ɵɵlistener("click", function NgbPanelToggle_click_HostBindingHandler($event) { return ctx.accordion.toggle(ctx.panel.id); });
        ɵngcc0.ɵɵelementHostAttrs(_c12);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("disabled", ctx.panel.disabled);
        ɵngcc0.ɵɵattribute("aria-expanded", ctx.panel.isOpen)("aria-controls", ctx.panel.id);
        ɵngcc0.ɵɵclassProp("collapsed", !ctx.panel.isOpen);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { ngbPanelToggle: "ngbPanelToggle" } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbPanelToggle, [{
        type: Directive,
        args: [{
                selector: 'button[ngbPanelToggle]',
                host: {
                    'type': 'button',
                    '[disabled]': 'panel.disabled',
                    '[class.collapsed]': '!panel.isOpen',
                    '[attr.aria-expanded]': 'panel.isOpen',
                    '[attr.aria-controls]': 'panel.id',
                    '(click)': 'accordion.toggle(panel.id)'
                }
            }]
    }], function () { return [{ type: NgbAccordion }, { type: NgbPanel, decorators: [{
                type: Optional
            }, {
                type: Host
            }] }]; }, { accordion: [], panel: [], ngbPanelToggle: [{
            type: Input
        }] });
    return NgbPanelToggle;
}());
export { NgbPanelToggle };
if (false) {
    /** @type {?} */
    NgbPanelToggle.prototype.accordion;
    /** @type {?} */
    NgbPanelToggle.prototype.panel;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQG5nLWJvb3RzdHJhcC9uZy1ib290c3RyYXAvZXNtNS9hY2NvcmRpb24vYWNjb3JkaW9uLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0EyQkssQUFHQzs7Ozs7Ozs7OzhFQUlHOzs7Ozs7Ozs7Ozs7Ozs7O0tBZ0JKLEFBR0M7Ozs7Ozs7Ozs4RUFJRzs7Ozs7Ozs7Ozs7Ozs7S0FjSixBQUdDOzs7Ozs7Ozs7OEVBSUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQXVDSCxBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2NBVUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01Bd1ZBLEFBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2NBWUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FtRUMsQUFhRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2NBUUEiLCJmaWxlIjoiYWNjb3JkaW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxyXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsY29uc3RhbnRQcm9wZXJ0eSxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXHJcbiAqL1xyXG5pbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBFdmVudEVtaXR0ZXIsIEhvc3QsIElucHV0LCBPcHRpb25hbCwgT3V0cHV0LCBRdWVyeUxpc3QsIFRlbXBsYXRlUmVmLCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gJy4uL3V0aWwvdXRpbCc7XHJcbmltcG9ydCB7IE5nYkFjY29yZGlvbkNvbmZpZyB9IGZyb20gJy4vYWNjb3JkaW9uLWNvbmZpZyc7XHJcbi8qKiBAdHlwZSB7P30gKi9cclxudmFyIG5leHRJZCA9IDA7XHJcbi8qKlxyXG4gKiBUaGUgY29udGV4dCBmb3IgdGhlIFtOZ2JQYW5lbEhlYWRlcl0oIy9jb21wb25lbnRzL2FjY29yZGlvbi9hcGkjTmdiUGFuZWxIZWFkZXIpIHRlbXBsYXRlXHJcbiAqXHJcbiAqIFxcQHNpbmNlIDQuMS4wXHJcbiAqIEByZWNvcmRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBOZ2JQYW5lbEhlYWRlckNvbnRleHQoKSB7IH1cclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKipcclxuICAgICAqIGBUcnVlYCBpZiBjdXJyZW50IHBhbmVsIGlzIG9wZW5lZFxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYlBhbmVsSGVhZGVyQ29udGV4dC5wcm90b3R5cGUub3BlbmVkO1xyXG59XHJcbi8qKlxyXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IHdyYXBzIGFuIGFjY29yZGlvbiBwYW5lbCBoZWFkZXIgd2l0aCBhbnkgSFRNTCBtYXJrdXAgYW5kIGEgdG9nZ2xpbmcgYnV0dG9uXHJcbiAqIG1hcmtlZCB3aXRoIFtgTmdiUGFuZWxUb2dnbGVgXSgjL2NvbXBvbmVudHMvYWNjb3JkaW9uL2FwaSNOZ2JQYW5lbFRvZ2dsZSkuXHJcbiAqIFNlZSB0aGUgW2hlYWRlciBjdXN0b21pemF0aW9uIGRlbW9dKCMvY29tcG9uZW50cy9hY2NvcmRpb24vZXhhbXBsZXMjaGVhZGVyKSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3UgY2FuIGFsc28gdXNlIFtgTmdiUGFuZWxUaXRsZWBdKCMvY29tcG9uZW50cy9hY2NvcmRpb24vYXBpI05nYlBhbmVsVGl0bGUpIHRvIGN1c3RvbWl6ZSBvbmx5IHRoZSBwYW5lbCB0aXRsZS5cclxuICpcclxuICogXFxAc2luY2UgNC4xLjBcclxuICovXHJcbnZhciBOZ2JQYW5lbEhlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5nYlBhbmVsSGVhZGVyKHRlbXBsYXRlUmVmKSB7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xyXG4gICAgfVxyXG4gICAgTmdiUGFuZWxIZWFkZXIuZGVjb3JhdG9ycyA9IFtcclxuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICduZy10ZW1wbGF0ZVtuZ2JQYW5lbEhlYWRlcl0nIH0sXSB9XHJcbiAgICBdO1xyXG4gICAgLyoqIEBub2NvbGxhcHNlICovXHJcbiAgICBOZ2JQYW5lbEhlYWRlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcclxuICAgICAgICB7IHR5cGU6IFRlbXBsYXRlUmVmIH1cclxuICAgIF07IH07XHJcbiAgICByZXR1cm4gTmdiUGFuZWxIZWFkZXI7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IE5nYlBhbmVsSGVhZGVyIH07XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgTmdiUGFuZWxIZWFkZXIucHJvdG90eXBlLnRlbXBsYXRlUmVmO1xyXG59XHJcbi8qKlxyXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IHdyYXBzIG9ubHkgdGhlIHBhbmVsIHRpdGxlIHdpdGggSFRNTCBtYXJrdXAgaW5zaWRlLlxyXG4gKlxyXG4gKiBZb3UgY2FuIGFsc28gdXNlIFtgTmdiUGFuZWxIZWFkZXJgXSgjL2NvbXBvbmVudHMvYWNjb3JkaW9uL2FwaSNOZ2JQYW5lbEhlYWRlcikgdG8gY3VzdG9taXplIHRoZSBmdWxsIHBhbmVsIGhlYWRlci5cclxuICovXHJcbnZhciBOZ2JQYW5lbFRpdGxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmdiUGFuZWxUaXRsZSh0ZW1wbGF0ZVJlZikge1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcclxuICAgIH1cclxuICAgIE5nYlBhbmVsVGl0bGUuZGVjb3JhdG9ycyA9IFtcclxuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICduZy10ZW1wbGF0ZVtuZ2JQYW5lbFRpdGxlXScgfSxdIH1cclxuICAgIF07XHJcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cclxuICAgIE5nYlBhbmVsVGl0bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXHJcbiAgICAgICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiB9XHJcbiAgICBdOyB9O1xyXG4gICAgcmV0dXJuIE5nYlBhbmVsVGl0bGU7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IE5nYlBhbmVsVGl0bGUgfTtcclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JQYW5lbFRpdGxlLnByb3RvdHlwZS50ZW1wbGF0ZVJlZjtcclxufVxyXG4vKipcclxuICogQSBkaXJlY3RpdmUgdGhhdCB3cmFwcyB0aGUgYWNjb3JkaW9uIHBhbmVsIGNvbnRlbnQuXHJcbiAqL1xyXG52YXIgTmdiUGFuZWxDb250ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmdiUGFuZWxDb250ZW50KHRlbXBsYXRlUmVmKSB7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xyXG4gICAgfVxyXG4gICAgTmdiUGFuZWxDb250ZW50LmRlY29yYXRvcnMgPSBbXHJcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbmctdGVtcGxhdGVbbmdiUGFuZWxDb250ZW50XScgfSxdIH1cclxuICAgIF07XHJcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cclxuICAgIE5nYlBhbmVsQ29udGVudC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcclxuICAgICAgICB7IHR5cGU6IFRlbXBsYXRlUmVmIH1cclxuICAgIF07IH07XHJcbiAgICByZXR1cm4gTmdiUGFuZWxDb250ZW50O1xyXG59KCkpO1xyXG5leHBvcnQgeyBOZ2JQYW5lbENvbnRlbnQgfTtcclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JQYW5lbENvbnRlbnQucHJvdG90eXBlLnRlbXBsYXRlUmVmO1xyXG59XHJcbi8qKlxyXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IHdyYXBzIGFuIGluZGl2aWR1YWwgYWNjb3JkaW9uIHBhbmVsIHdpdGggdGl0bGUgYW5kIGNvbGxhcHNpYmxlIGNvbnRlbnQuXHJcbiAqL1xyXG52YXIgTmdiUGFuZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZ2JQYW5lbCgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAgSWYgYHRydWVgLCB0aGUgcGFuZWwgaXMgZGlzYWJsZWQgYW4gY2FuJ3QgYmUgdG9nZ2xlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogIEFuIG9wdGlvbmFsIGlkIGZvciB0aGUgcGFuZWwgdGhhdCBtdXN0IGJlIHVuaXF1ZSBvbiB0aGUgcGFnZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICBJZiBub3QgcHJvdmlkZWQsIGl0IHdpbGwgYmUgYXV0by1nZW5lcmF0ZWQgaW4gdGhlIGBuZ2ItcGFuZWwteHh4YCBmb3JtYXQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pZCA9IFwibmdiLXBhbmVsLVwiICsgbmV4dElkKys7XHJcbiAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdiUGFuZWwucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50Q2hlY2tlZCA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFdlIGFyZSB1c2luZyBAQ29udGVudENoaWxkcmVuIGluc3RlYWQgb2YgQENvbnRlbnRDaGlsZCBhcyBpbiB0aGUgQW5ndWxhciB2ZXJzaW9uIGJlaW5nIHVzZWRcclxuICAgICAgICAvLyBvbmx5IEBDb250ZW50Q2hpbGRyZW4gYWxsb3dzIHVzIHRvIHNwZWNpZnkgdGhlIHtkZXNjZW5kYW50czogZmFsc2V9IG9wdGlvbi5cclxuICAgICAgICAvLyBXaXRob3V0IHtkZXNjZW5kYW50czogZmFsc2V9IHdlIGFyZSBoaXR0aW5nIGJ1Z3MgZGVzY3JpYmVkIGluOlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uZy1ib290c3RyYXAvbmctYm9vdHN0cmFwL2lzc3Vlcy8yMjQwXHJcbiAgICAgICAgdGhpcy50aXRsZVRwbCA9IHRoaXMudGl0bGVUcGxzLmZpcnN0O1xyXG4gICAgICAgIHRoaXMuaGVhZGVyVHBsID0gdGhpcy5oZWFkZXJUcGxzLmZpcnN0O1xyXG4gICAgICAgIHRoaXMuY29udGVudFRwbCA9IHRoaXMuY29udGVudFRwbHMuZmlyc3Q7XHJcbiAgICB9O1xyXG4gICAgTmdiUGFuZWwuZGVjb3JhdG9ycyA9IFtcclxuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICduZ2ItcGFuZWwnIH0sXSB9XHJcbiAgICBdO1xyXG4gICAgTmdiUGFuZWwucHJvcERlY29yYXRvcnMgPSB7XHJcbiAgICAgICAgZGlzYWJsZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIGlkOiBbeyB0eXBlOiBJbnB1dCB9XSxcclxuICAgICAgICB0aXRsZTogW3sgdHlwZTogSW5wdXQgfV0sXHJcbiAgICAgICAgdHlwZTogW3sgdHlwZTogSW5wdXQgfV0sXHJcbiAgICAgICAgY2FyZENsYXNzOiBbeyB0eXBlOiBJbnB1dCB9XSxcclxuICAgICAgICB0aXRsZVRwbHM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW05nYlBhbmVsVGl0bGUsIHsgZGVzY2VuZGFudHM6IGZhbHNlIH0sXSB9XSxcclxuICAgICAgICBoZWFkZXJUcGxzOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtOZ2JQYW5lbEhlYWRlciwgeyBkZXNjZW5kYW50czogZmFsc2UgfSxdIH1dLFxyXG4gICAgICAgIGNvbnRlbnRUcGxzOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtOZ2JQYW5lbENvbnRlbnQsIHsgZGVzY2VuZGFudHM6IGZhbHNlIH0sXSB9XVxyXG4gICAgfTtcclxuICAgIHJldHVybiBOZ2JQYW5lbDtcclxufSgpKTtcclxuZXhwb3J0IHsgTmdiUGFuZWwgfTtcclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKipcclxuICAgICAqICBJZiBgdHJ1ZWAsIHRoZSBwYW5lbCBpcyBkaXNhYmxlZCBhbiBjYW4ndCBiZSB0b2dnbGVkLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYlBhbmVsLnByb3RvdHlwZS5kaXNhYmxlZDtcclxuICAgIC8qKlxyXG4gICAgICogIEFuIG9wdGlvbmFsIGlkIGZvciB0aGUgcGFuZWwgdGhhdCBtdXN0IGJlIHVuaXF1ZSBvbiB0aGUgcGFnZS5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgbm90IHByb3ZpZGVkLCBpdCB3aWxsIGJlIGF1dG8tZ2VuZXJhdGVkIGluIHRoZSBgbmdiLXBhbmVsLXh4eGAgZm9ybWF0LlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYlBhbmVsLnByb3RvdHlwZS5pZDtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE5nYlBhbmVsLnByb3RvdHlwZS5pc09wZW47XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgcGFuZWwgdGl0bGUuXHJcbiAgICAgKlxyXG4gICAgICogIFlvdSBjYW4gYWx0ZXJuYXRpdmVseSB1c2UgW2BOZ2JQYW5lbFRpdGxlYF0oIy9jb21wb25lbnRzL2FjY29yZGlvbi9hcGkjTmdiUGFuZWxUaXRsZSkgdG8gc2V0IHBhbmVsIHRpdGxlLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYlBhbmVsLnByb3RvdHlwZS50aXRsZTtcclxuICAgIC8qKlxyXG4gICAgICogVHlwZSBvZiB0aGUgY3VycmVudCBwYW5lbC5cclxuICAgICAqXHJcbiAgICAgKiBCb290c3RyYXAgcHJvdmlkZXMgc3R5bGVzIGZvciB0aGUgZm9sbG93aW5nIHR5cGVzOiBgJ3N1Y2Nlc3MnYCwgYCdpbmZvJ2AsIGAnd2FybmluZydgLCBgJ2RhbmdlcidgLCBgJ3ByaW1hcnknYCxcclxuICAgICAqIGAnc2Vjb25kYXJ5J2AsIGAnbGlnaHQnYCBhbmQgYCdkYXJrJ2AuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiUGFuZWwucHJvdG90eXBlLnR5cGU7XHJcbiAgICAvKipcclxuICAgICAqIEFuIG9wdGlvbmFsIGNsYXNzIGFwcGxpZWQgdG8gdGhlIGFjY29yZGlvbiBjYXJkIGVsZW1lbnQgdGhhdCB3cmFwcyBib3RoIHBhbmVsIHRpdGxlIGFuZCBjb250ZW50LlxyXG4gICAgICpcclxuICAgICAqIFxcQHNpbmNlIDUuMy4wXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiUGFuZWwucHJvdG90eXBlLmNhcmRDbGFzcztcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE5nYlBhbmVsLnByb3RvdHlwZS50aXRsZVRwbDtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE5nYlBhbmVsLnByb3RvdHlwZS5oZWFkZXJUcGw7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JQYW5lbC5wcm90b3R5cGUuY29udGVudFRwbDtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE5nYlBhbmVsLnByb3RvdHlwZS50aXRsZVRwbHM7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JQYW5lbC5wcm90b3R5cGUuaGVhZGVyVHBscztcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE5nYlBhbmVsLnByb3RvdHlwZS5jb250ZW50VHBscztcclxufVxyXG4vKipcclxuICogQW4gZXZlbnQgZW1pdHRlZCByaWdodCBiZWZvcmUgdG9nZ2xpbmcgYW4gYWNjb3JkaW9uIHBhbmVsLlxyXG4gKiBAcmVjb3JkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gTmdiUGFuZWxDaGFuZ2VFdmVudCgpIHsgfVxyXG5pZiAoZmFsc2UpIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGlkIG9mIHRoZSBhY2NvcmRpb24gcGFuZWwgdGhhdCBpcyBiZWluZyB0b2dnbGVkLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYlBhbmVsQ2hhbmdlRXZlbnQucHJvdG90eXBlLnBhbmVsSWQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuZXh0IHN0YXRlIG9mIHRoZSBwYW5lbC5cclxuICAgICAqXHJcbiAgICAgKiBgdHJ1ZWAgaWYgaXQgd2lsbCBiZSBvcGVuZWQsIGBmYWxzZWAgaWYgY2xvc2VkLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYlBhbmVsQ2hhbmdlRXZlbnQucHJvdG90eXBlLm5leHRTdGF0ZTtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIHdpbGwgcHJldmVudCBwYW5lbCB0b2dnbGluZy5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JQYW5lbENoYW5nZUV2ZW50LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdDtcclxufVxyXG4vKipcclxuICogQWNjb3JkaW9uIGlzIGEgY29sbGVjdGlvbiBvZiBjb2xsYXBzaWJsZSBwYW5lbHMgKGJvb3RzdHJhcCBjYXJkcykuXHJcbiAqXHJcbiAqIEl0IGNhbiBlbnN1cmUgb25seSBvbmUgcGFuZWwgaXMgb3BlbmVkIGF0IGEgdGltZSBhbmQgYWxsb3dzIHRvIGN1c3RvbWl6ZSBwYW5lbFxyXG4gKiBoZWFkZXJzLlxyXG4gKi9cclxudmFyIE5nYkFjY29yZGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5nYkFjY29yZGlvbihjb25maWcpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBhcnJheSBvciBjb21tYSBzZXBhcmF0ZWQgc3RyaW5ncyBvZiBwYW5lbCBpZHMgdGhhdCBzaG91bGQgYmUgb3BlbmVkICoqaW5pdGlhbGx5KiouXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBGb3Igc3Vic2VxdWVudCBjaGFuZ2VzIHVzZSBtZXRob2RzIGxpa2UgYGV4cGFuZCgpYCwgYGNvbGxhcHNlKClgLCBldGMuIGFuZFxyXG4gICAgICAgICAqIHRoZSBgKHBhbmVsQ2hhbmdlKWAgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hY3RpdmVJZHMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBgdHJ1ZWAsIHBhbmVsIGNvbnRlbnQgd2lsbCBiZSBkZXRhY2hlZCBmcm9tIERPTSBhbmQgbm90IHNpbXBseSBoaWRkZW4gd2hlbiB0aGUgcGFuZWwgaXMgY29sbGFwc2VkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGVzdHJveU9uSGlkZSA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCByaWdodCBiZWZvcmUgdGhlIHBhbmVsIHRvZ2dsZSBoYXBwZW5zLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogU2VlIFtOZ2JQYW5lbENoYW5nZUV2ZW50XSgjL2NvbXBvbmVudHMvYWNjb3JkaW9uL2FwaSNOZ2JQYW5lbENoYW5nZUV2ZW50KSBmb3IgcGF5bG9hZCBkZXRhaWxzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGFuZWxDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gY29uZmlnLnR5cGU7XHJcbiAgICAgICAgdGhpcy5jbG9zZU90aGVyUGFuZWxzID0gY29uZmlnLmNsb3NlT3RoZXJzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYSBwYW5lbCB3aXRoIGEgZ2l2ZW4gaWQgaXMgZXhwYW5kZWQuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGEgcGFuZWwgd2l0aCBhIGdpdmVuIGlkIGlzIGV4cGFuZGVkLlxyXG4gICAgICogQHBhcmFtIHs/fSBwYW5lbElkXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JBY2NvcmRpb24ucHJvdG90eXBlLmlzRXhwYW5kZWQgPSAvKipcclxuICAgICAqIENoZWNrcyBpZiBhIHBhbmVsIHdpdGggYSBnaXZlbiBpZCBpcyBleHBhbmRlZC5cclxuICAgICAqIEBwYXJhbSB7P30gcGFuZWxJZFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHBhbmVsSWQpIHsgcmV0dXJuIHRoaXMuYWN0aXZlSWRzLmluZGV4T2YocGFuZWxJZCkgPiAtMTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogRXhwYW5kcyBhIHBhbmVsIHdpdGggYSBnaXZlbiBpZC5cclxuICAgICAqXHJcbiAgICAgKiBIYXMgbm8gZWZmZWN0IGlmIHRoZSBwYW5lbCBpcyBhbHJlYWR5IGV4cGFuZGVkIG9yIGRpc2FibGVkLlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIEV4cGFuZHMgYSBwYW5lbCB3aXRoIGEgZ2l2ZW4gaWQuXHJcbiAgICAgKlxyXG4gICAgICogSGFzIG5vIGVmZmVjdCBpZiB0aGUgcGFuZWwgaXMgYWxyZWFkeSBleHBhbmRlZCBvciBkaXNhYmxlZC5cclxuICAgICAqIEBwYXJhbSB7P30gcGFuZWxJZFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdiQWNjb3JkaW9uLnByb3RvdHlwZS5leHBhbmQgPSAvKipcclxuICAgICAqIEV4cGFuZHMgYSBwYW5lbCB3aXRoIGEgZ2l2ZW4gaWQuXHJcbiAgICAgKlxyXG4gICAgICogSGFzIG5vIGVmZmVjdCBpZiB0aGUgcGFuZWwgaXMgYWxyZWFkeSBleHBhbmRlZCBvciBkaXNhYmxlZC5cclxuICAgICAqIEBwYXJhbSB7P30gcGFuZWxJZFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHBhbmVsSWQpIHsgdGhpcy5fY2hhbmdlT3BlblN0YXRlKHRoaXMuX2ZpbmRQYW5lbEJ5SWQocGFuZWxJZCksIHRydWUpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBhbmRzIGFsbCBwYW5lbHMsIGlmIGBbY2xvc2VPdGhlcnNdYCBpcyBgZmFsc2VgLlxyXG4gICAgICpcclxuICAgICAqIElmIGBbY2xvc2VPdGhlcnNdYCBpcyBgdHJ1ZWAsIGl0IHdpbGwgZXhwYW5kIHRoZSBmaXJzdCBwYW5lbCwgdW5sZXNzIHRoZXJlIGlzIGFscmVhZHkgYSBwYW5lbCBvcGVuZWQuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogRXhwYW5kcyBhbGwgcGFuZWxzLCBpZiBgW2Nsb3NlT3RoZXJzXWAgaXMgYGZhbHNlYC5cclxuICAgICAqXHJcbiAgICAgKiBJZiBgW2Nsb3NlT3RoZXJzXWAgaXMgYHRydWVgLCBpdCB3aWxsIGV4cGFuZCB0aGUgZmlyc3QgcGFuZWwsIHVubGVzcyB0aGVyZSBpcyBhbHJlYWR5IGEgcGFuZWwgb3BlbmVkLlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdiQWNjb3JkaW9uLnByb3RvdHlwZS5leHBhbmRBbGwgPSAvKipcclxuICAgICAqIEV4cGFuZHMgYWxsIHBhbmVscywgaWYgYFtjbG9zZU90aGVyc11gIGlzIGBmYWxzZWAuXHJcbiAgICAgKlxyXG4gICAgICogSWYgYFtjbG9zZU90aGVyc11gIGlzIGB0cnVlYCwgaXQgd2lsbCBleHBhbmQgdGhlIGZpcnN0IHBhbmVsLCB1bmxlc3MgdGhlcmUgaXMgYWxyZWFkeSBhIHBhbmVsIG9wZW5lZC5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLmNsb3NlT3RoZXJQYW5lbHMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlSWRzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLnBhbmVscy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZU9wZW5TdGF0ZSh0aGlzLnBhbmVscy5maXJzdCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFuZWxzLmZvckVhY2goKC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IHBhbmVsXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiAocGFuZWwpIHsgcmV0dXJuIF90aGlzLl9jaGFuZ2VPcGVuU3RhdGUocGFuZWwsIHRydWUpOyB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29sbGFwc2VzIGEgcGFuZWwgd2l0aCB0aGUgZ2l2ZW4gaWQuXHJcbiAgICAgKlxyXG4gICAgICogSGFzIG5vIGVmZmVjdCBpZiB0aGUgcGFuZWwgaXMgYWxyZWFkeSBjb2xsYXBzZWQgb3IgZGlzYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGFwc2VzIGEgcGFuZWwgd2l0aCB0aGUgZ2l2ZW4gaWQuXHJcbiAgICAgKlxyXG4gICAgICogSGFzIG5vIGVmZmVjdCBpZiB0aGUgcGFuZWwgaXMgYWxyZWFkeSBjb2xsYXBzZWQgb3IgZGlzYWJsZWQuXHJcbiAgICAgKiBAcGFyYW0gez99IHBhbmVsSWRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nYkFjY29yZGlvbi5wcm90b3R5cGUuY29sbGFwc2UgPSAvKipcclxuICAgICAqIENvbGxhcHNlcyBhIHBhbmVsIHdpdGggdGhlIGdpdmVuIGlkLlxyXG4gICAgICpcclxuICAgICAqIEhhcyBubyBlZmZlY3QgaWYgdGhlIHBhbmVsIGlzIGFscmVhZHkgY29sbGFwc2VkIG9yIGRpc2FibGVkLlxyXG4gICAgICogQHBhcmFtIHs/fSBwYW5lbElkXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAocGFuZWxJZCkgeyB0aGlzLl9jaGFuZ2VPcGVuU3RhdGUodGhpcy5fZmluZFBhbmVsQnlJZChwYW5lbElkKSwgZmFsc2UpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsYXBzZXMgYWxsIG9wZW5lZCBwYW5lbHMuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGFwc2VzIGFsbCBvcGVuZWQgcGFuZWxzLlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdiQWNjb3JkaW9uLnByb3RvdHlwZS5jb2xsYXBzZUFsbCA9IC8qKlxyXG4gICAgICogQ29sbGFwc2VzIGFsbCBvcGVuZWQgcGFuZWxzLlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5wYW5lbHMuZm9yRWFjaCgoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBwYW5lbFxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKHBhbmVsKSB7IF90aGlzLl9jaGFuZ2VPcGVuU3RhdGUocGFuZWwsIGZhbHNlKTsgfSkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVG9nZ2xlcyBhIHBhbmVsIHdpdGggdGhlIGdpdmVuIGlkLlxyXG4gICAgICpcclxuICAgICAqIEhhcyBubyBlZmZlY3QgaWYgdGhlIHBhbmVsIGlzIGRpc2FibGVkLlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIFRvZ2dsZXMgYSBwYW5lbCB3aXRoIHRoZSBnaXZlbiBpZC5cclxuICAgICAqXHJcbiAgICAgKiBIYXMgbm8gZWZmZWN0IGlmIHRoZSBwYW5lbCBpcyBkaXNhYmxlZC5cclxuICAgICAqIEBwYXJhbSB7P30gcGFuZWxJZFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdiQWNjb3JkaW9uLnByb3RvdHlwZS50b2dnbGUgPSAvKipcclxuICAgICAqIFRvZ2dsZXMgYSBwYW5lbCB3aXRoIHRoZSBnaXZlbiBpZC5cclxuICAgICAqXHJcbiAgICAgKiBIYXMgbm8gZWZmZWN0IGlmIHRoZSBwYW5lbCBpcyBkaXNhYmxlZC5cclxuICAgICAqIEBwYXJhbSB7P30gcGFuZWxJZFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHBhbmVsSWQpIHtcclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgdmFyIHBhbmVsID0gdGhpcy5fZmluZFBhbmVsQnlJZChwYW5lbElkKTtcclxuICAgICAgICBpZiAocGFuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlT3BlblN0YXRlKHBhbmVsLCAhcGFuZWwuaXNPcGVuKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JBY2NvcmRpb24ucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50Q2hlY2tlZCA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLy8gYWN0aXZlIGlkIHVwZGF0ZXNcclxuICAgICAgICBpZiAoaXNTdHJpbmcodGhpcy5hY3RpdmVJZHMpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSWRzID0gdGhpcy5hY3RpdmVJZHMuc3BsaXQoL1xccyosXFxzKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB1cGRhdGUgcGFuZWxzIG9wZW4gc3RhdGVzXHJcbiAgICAgICAgdGhpcy5wYW5lbHMuZm9yRWFjaCgoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBwYW5lbFxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKHBhbmVsKSB7IHJldHVybiBwYW5lbC5pc09wZW4gPSAhcGFuZWwuZGlzYWJsZWQgJiYgX3RoaXMuYWN0aXZlSWRzLmluZGV4T2YocGFuZWwuaWQpID4gLTE7IH0pKTtcclxuICAgICAgICAvLyBjbG9zZU90aGVycyB1cGRhdGVzXHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlSWRzLmxlbmd0aCA+IDEgJiYgdGhpcy5jbG9zZU90aGVyUGFuZWxzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlT3RoZXJzKHRoaXMuYWN0aXZlSWRzWzBdKTtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQWN0aXZlSWRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7P30gcGFuZWxcclxuICAgICAqIEBwYXJhbSB7P30gbmV4dFN0YXRlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JBY2NvcmRpb24ucHJvdG90eXBlLl9jaGFuZ2VPcGVuU3RhdGUgPSAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IHBhbmVsXHJcbiAgICAgKiBAcGFyYW0gez99IG5leHRTdGF0ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHBhbmVsLCBuZXh0U3RhdGUpIHtcclxuICAgICAgICBpZiAocGFuZWwgJiYgIXBhbmVsLmRpc2FibGVkICYmIHBhbmVsLmlzT3BlbiAhPT0gbmV4dFN0YXRlKSB7XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgdmFyIGRlZmF1bHRQcmV2ZW50ZWRfMSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnBhbmVsQ2hhbmdlLmVtaXQoeyBwYW5lbElkOiBwYW5lbC5pZCwgbmV4dFN0YXRlOiBuZXh0U3RhdGUsIHByZXZlbnREZWZhdWx0OiAoLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGRlZmF1bHRQcmV2ZW50ZWRfMSA9IHRydWU7IH0pIH0pO1xyXG4gICAgICAgICAgICBpZiAoIWRlZmF1bHRQcmV2ZW50ZWRfMSkge1xyXG4gICAgICAgICAgICAgICAgcGFuZWwuaXNPcGVuID0gbmV4dFN0YXRlO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRTdGF0ZSAmJiB0aGlzLmNsb3NlT3RoZXJQYW5lbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZU90aGVycyhwYW5lbC5pZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBY3RpdmVJZHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IHBhbmVsSWRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nYkFjY29yZGlvbi5wcm90b3R5cGUuX2Nsb3NlT3RoZXJzID0gLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSBwYW5lbElkXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAocGFuZWxJZCkge1xyXG4gICAgICAgIHRoaXMucGFuZWxzLmZvckVhY2goKC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFuZWxcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIChwYW5lbCkge1xyXG4gICAgICAgICAgICBpZiAocGFuZWwuaWQgIT09IHBhbmVsSWQpIHtcclxuICAgICAgICAgICAgICAgIHBhbmVsLmlzT3BlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7P30gcGFuZWxJZFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdiQWNjb3JkaW9uLnByb3RvdHlwZS5fZmluZFBhbmVsQnlJZCA9IC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7P30gcGFuZWxJZFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHBhbmVsSWQpIHsgcmV0dXJuIHRoaXMucGFuZWxzLmZpbmQoKC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBwXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5pZCA9PT0gcGFuZWxJZDsgfSkpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdiQWNjb3JkaW9uLnByb3RvdHlwZS5fdXBkYXRlQWN0aXZlSWRzID0gLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlSWRzID0gdGhpcy5wYW5lbHMuZmlsdGVyKCgvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IHBhbmVsXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiAocGFuZWwpIHsgcmV0dXJuIHBhbmVsLmlzT3BlbiAmJiAhcGFuZWwuZGlzYWJsZWQ7IH0pKS5tYXAoKC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFuZWxcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIChwYW5lbCkgeyByZXR1cm4gcGFuZWwuaWQ7IH0pKTtcclxuICAgIH07XHJcbiAgICBOZ2JBY2NvcmRpb24uZGVjb3JhdG9ycyA9IFtcclxuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25nYi1hY2NvcmRpb24nLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbmdiQWNjb3JkaW9uJyxcclxuICAgICAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ2FjY29yZGlvbicsICdyb2xlJzogJ3RhYmxpc3QnLCAnW2F0dHIuYXJpYS1tdWx0aXNlbGVjdGFibGVdJzogJyFjbG9zZU90aGVyUGFuZWxzJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmctdGVtcGxhdGUgI3QgbmdiUGFuZWxIZWFkZXIgbGV0LXBhbmVsPlxcbiAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCIgW25nYlBhbmVsVG9nZ2xlXT1cXFwicGFuZWxcXFwiPlxcbiAgICAgICAge3twYW5lbC50aXRsZX19PG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cXFwicGFuZWwudGl0bGVUcGw/LnRlbXBsYXRlUmVmXFxcIj48L25nLXRlbXBsYXRlPlxcbiAgICAgIDwvYnV0dG9uPlxcbiAgICA8L25nLXRlbXBsYXRlPlxcbiAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LXBhbmVsIFtuZ0Zvck9mXT1cXFwicGFuZWxzXFxcIj5cXG4gICAgICA8ZGl2IFtjbGFzc109XFxcIidjYXJkICcgKyAocGFuZWwuY2FyZENsYXNzIHx8ICcnKVxcXCI+XFxuICAgICAgICA8ZGl2IHJvbGU9XFxcInRhYlxcXCIgaWQ9XFxcInt7cGFuZWwuaWR9fS1oZWFkZXJcXFwiIFtjbGFzc109XFxcIidjYXJkLWhlYWRlciAnICsgKHBhbmVsLnR5cGUgPyAnYmctJytwYW5lbC50eXBlOiB0eXBlID8gJ2JnLScrdHlwZSA6ICcnKVxcXCI+XFxuICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdUZW1wbGF0ZU91dGxldF09XFxcInBhbmVsLmhlYWRlclRwbD8udGVtcGxhdGVSZWYgfHwgdFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XFxcInskaW1wbGljaXQ6IHBhbmVsLCBvcGVuZWQ6IHBhbmVsLmlzT3Blbn1cXFwiPjwvbmctdGVtcGxhdGU+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgaWQ9XFxcInt7cGFuZWwuaWR9fVxcXCIgcm9sZT1cXFwidGFicGFuZWxcXFwiIFthdHRyLmFyaWEtbGFiZWxsZWRieV09XFxcInBhbmVsLmlkICsgJy1oZWFkZXInXFxcIlxcbiAgICAgICAgICAgICBjbGFzcz1cXFwiY29sbGFwc2VcXFwiIFtjbGFzcy5zaG93XT1cXFwicGFuZWwuaXNPcGVuXFxcIiAqbmdJZj1cXFwiIWRlc3Ryb3lPbkhpZGUgfHwgcGFuZWwuaXNPcGVuXFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY2FyZC1ib2R5XFxcIj5cXG4gICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVxcXCJwYW5lbC5jb250ZW50VHBsPy50ZW1wbGF0ZVJlZlxcXCI+PC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9uZy10ZW1wbGF0ZT5cXG4gIFwiXHJcbiAgICAgICAgICAgICAgICB9XSB9XHJcbiAgICBdO1xyXG4gICAgLyoqIEBub2NvbGxhcHNlICovXHJcbiAgICBOZ2JBY2NvcmRpb24uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXHJcbiAgICAgICAgeyB0eXBlOiBOZ2JBY2NvcmRpb25Db25maWcgfVxyXG4gICAgXTsgfTtcclxuICAgIE5nYkFjY29yZGlvbi5wcm9wRGVjb3JhdG9ycyA9IHtcclxuICAgICAgICBwYW5lbHM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW05nYlBhbmVsLF0gfV0sXHJcbiAgICAgICAgYWN0aXZlSWRzOiBbeyB0eXBlOiBJbnB1dCB9XSxcclxuICAgICAgICBjbG9zZU90aGVyUGFuZWxzOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydjbG9zZU90aGVycycsXSB9XSxcclxuICAgICAgICBkZXN0cm95T25IaWRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcclxuICAgICAgICB0eXBlOiBbeyB0eXBlOiBJbnB1dCB9XSxcclxuICAgICAgICBwYW5lbENoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5nYkFjY29yZGlvbjtcclxufSgpKTtcclxuZXhwb3J0IHsgTmdiQWNjb3JkaW9uIH07XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgTmdiQWNjb3JkaW9uLnByb3RvdHlwZS5wYW5lbHM7XHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9yIGNvbW1hIHNlcGFyYXRlZCBzdHJpbmdzIG9mIHBhbmVsIGlkcyB0aGF0IHNob3VsZCBiZSBvcGVuZWQgKippbml0aWFsbHkqKi5cclxuICAgICAqXHJcbiAgICAgKiBGb3Igc3Vic2VxdWVudCBjaGFuZ2VzIHVzZSBtZXRob2RzIGxpa2UgYGV4cGFuZCgpYCwgYGNvbGxhcHNlKClgLCBldGMuIGFuZFxyXG4gICAgICogdGhlIGAocGFuZWxDaGFuZ2UpYCBldmVudC5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JBY2NvcmRpb24ucHJvdG90eXBlLmFjdGl2ZUlkcztcclxuICAgIC8qKlxyXG4gICAgICogIElmIGB0cnVlYCwgb25seSBvbmUgcGFuZWwgY291bGQgYmUgb3BlbmVkIGF0IGEgdGltZS5cclxuICAgICAqXHJcbiAgICAgKiAgT3BlbmluZyBhIG5ldyBwYW5lbCB3aWxsIGNsb3NlIG90aGVycy5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JBY2NvcmRpb24ucHJvdG90eXBlLmNsb3NlT3RoZXJQYW5lbHM7XHJcbiAgICAvKipcclxuICAgICAqIElmIGB0cnVlYCwgcGFuZWwgY29udGVudCB3aWxsIGJlIGRldGFjaGVkIGZyb20gRE9NIGFuZCBub3Qgc2ltcGx5IGhpZGRlbiB3aGVuIHRoZSBwYW5lbCBpcyBjb2xsYXBzZWQuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiQWNjb3JkaW9uLnByb3RvdHlwZS5kZXN0cm95T25IaWRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUeXBlIG9mIHBhbmVscy5cclxuICAgICAqXHJcbiAgICAgKiBCb290c3RyYXAgcHJvdmlkZXMgc3R5bGVzIGZvciB0aGUgZm9sbG93aW5nIHR5cGVzOiBgJ3N1Y2Nlc3MnYCwgYCdpbmZvJ2AsIGAnd2FybmluZydgLCBgJ2RhbmdlcidgLCBgJ3ByaW1hcnknYCxcclxuICAgICAqIGAnc2Vjb25kYXJ5J2AsIGAnbGlnaHQnYCBhbmQgYCdkYXJrJ2AuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiQWNjb3JkaW9uLnByb3RvdHlwZS50eXBlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCBlbWl0dGVkIHJpZ2h0IGJlZm9yZSB0aGUgcGFuZWwgdG9nZ2xlIGhhcHBlbnMuXHJcbiAgICAgKlxyXG4gICAgICogU2VlIFtOZ2JQYW5lbENoYW5nZUV2ZW50XSgjL2NvbXBvbmVudHMvYWNjb3JkaW9uL2FwaSNOZ2JQYW5lbENoYW5nZUV2ZW50KSBmb3IgcGF5bG9hZCBkZXRhaWxzLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYkFjY29yZGlvbi5wcm90b3R5cGUucGFuZWxDaGFuZ2U7XHJcbn1cclxuLyoqXHJcbiAqIEEgZGlyZWN0aXZlIHRvIHB1dCBvbiBhIGJ1dHRvbiB0aGF0IHRvZ2dsZXMgcGFuZWwgb3BlbmluZyBhbmQgY2xvc2luZy5cclxuICpcclxuICogVG8gYmUgdXNlZCBpbnNpZGUgdGhlIFtgTmdiUGFuZWxIZWFkZXJgXSgjL2NvbXBvbmVudHMvYWNjb3JkaW9uL2FwaSNOZ2JQYW5lbEhlYWRlcilcclxuICpcclxuICogXFxAc2luY2UgNC4xLjBcclxuICovXHJcbnZhciBOZ2JQYW5lbFRvZ2dsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5nYlBhbmVsVG9nZ2xlKGFjY29yZGlvbiwgcGFuZWwpIHtcclxuICAgICAgICB0aGlzLmFjY29yZGlvbiA9IGFjY29yZGlvbjtcclxuICAgICAgICB0aGlzLnBhbmVsID0gcGFuZWw7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdiUGFuZWxUb2dnbGUucHJvdG90eXBlLCBcIm5nYlBhbmVsVG9nZ2xlXCIsIHtcclxuICAgICAgICBzZXQ6IC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFuZWxcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIChwYW5lbCkge1xyXG4gICAgICAgICAgICBpZiAocGFuZWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFuZWwgPSBwYW5lbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTmdiUGFuZWxUb2dnbGUuZGVjb3JhdG9ycyA9IFtcclxuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2J1dHRvbltuZ2JQYW5lbFRvZ2dsZV0nLFxyXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYnV0dG9uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1tkaXNhYmxlZF0nOiAncGFuZWwuZGlzYWJsZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLmNvbGxhcHNlZF0nOiAnIXBhbmVsLmlzT3BlbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWV4cGFuZGVkXSc6ICdwYW5lbC5pc09wZW4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1jb250cm9sc10nOiAncGFuZWwuaWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnKGNsaWNrKSc6ICdhY2NvcmRpb24udG9nZ2xlKHBhbmVsLmlkKSdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LF0gfVxyXG4gICAgXTtcclxuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xyXG4gICAgTmdiUGFuZWxUb2dnbGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXHJcbiAgICAgICAgeyB0eXBlOiBOZ2JBY2NvcmRpb24gfSxcclxuICAgICAgICB7IHR5cGU6IE5nYlBhbmVsLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEhvc3QgfV0gfVxyXG4gICAgXTsgfTtcclxuICAgIE5nYlBhbmVsVG9nZ2xlLnByb3BEZWNvcmF0b3JzID0ge1xyXG4gICAgICAgIG5nYlBhbmVsVG9nZ2xlOiBbeyB0eXBlOiBJbnB1dCB9XVxyXG4gICAgfTtcclxuICAgIHJldHVybiBOZ2JQYW5lbFRvZ2dsZTtcclxufSgpKTtcclxuZXhwb3J0IHsgTmdiUGFuZWxUb2dnbGUgfTtcclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JQYW5lbFRvZ2dsZS5wcm90b3R5cGUuYWNjb3JkaW9uO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgTmdiUGFuZWxUb2dnbGUucHJvdG90eXBlLnBhbmVsO1xyXG59XHIiXX0=