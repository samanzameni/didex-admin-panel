/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { NgbCalendar } from './ngb-calendar';
import { NgbDate } from './ngb-date';
import { Injectable } from '@angular/core';
import { isInteger, toInteger } from '../util/util';
import { Subject } from 'rxjs';
import { buildMonths, checkDateInRange, checkMinBeforeMax, isChangedDate, isChangedMonth, isDateSelectable, generateSelectBoxYears, generateSelectBoxMonths, prevMonthDisabled, nextMonthDisabled } from './datepicker-tools';
import { filter } from 'rxjs/operators';
import { NgbDatepickerI18n } from './datepicker-i18n';
/**
 * @record
 */
import * as Éµngcc0 from '@angular/core';
export function DatepickerServiceInputs() { }
var NgbDatepickerService = /** @class */ (function () {
    function NgbDatepickerService(_calendar, _i18n) {
        var _this = this;
        this._calendar = _calendar;
        this._i18n = _i18n;
        this._VALIDATORS = {
            dayTemplateData: (/**
             * @param {?} dayTemplateData
             * @return {?}
             */
            function (dayTemplateData) {
                if (_this._state.dayTemplateData !== dayTemplateData) {
                    return { dayTemplateData: dayTemplateData };
                }
            }),
            displayMonths: (/**
             * @param {?} displayMonths
             * @return {?}
             */
            function (displayMonths) {
                displayMonths = toInteger(displayMonths);
                if (isInteger(displayMonths) && displayMonths > 0 && _this._state.displayMonths !== displayMonths) {
                    return { displayMonths: displayMonths };
                }
            }),
            disabled: (/**
             * @param {?} disabled
             * @return {?}
             */
            function (disabled) {
                if (_this._state.disabled !== disabled) {
                    return { disabled: disabled };
                }
            }),
            firstDayOfWeek: (/**
             * @param {?} firstDayOfWeek
             * @return {?}
             */
            function (firstDayOfWeek) {
                firstDayOfWeek = toInteger(firstDayOfWeek);
                if (isInteger(firstDayOfWeek) && firstDayOfWeek >= 0 && _this._state.firstDayOfWeek !== firstDayOfWeek) {
                    return { firstDayOfWeek: firstDayOfWeek };
                }
            }),
            focusVisible: (/**
             * @param {?} focusVisible
             * @return {?}
             */
            function (focusVisible) {
                if (_this._state.focusVisible !== focusVisible && !_this._state.disabled) {
                    return { focusVisible: focusVisible };
                }
            }),
            markDisabled: (/**
             * @param {?} markDisabled
             * @return {?}
             */
            function (markDisabled) {
                if (_this._state.markDisabled !== markDisabled) {
                    return { markDisabled: markDisabled };
                }
            }),
            maxDate: (/**
             * @param {?} date
             * @return {?}
             */
            function (date) {
                /** @type {?} */
                var maxDate = _this.toValidDate(date, null);
                if (isChangedDate(_this._state.maxDate, maxDate)) {
                    return { maxDate: maxDate };
                }
            }),
            minDate: (/**
             * @param {?} date
             * @return {?}
             */
            function (date) {
                /** @type {?} */
                var minDate = _this.toValidDate(date, null);
                if (isChangedDate(_this._state.minDate, minDate)) {
                    return { minDate: minDate };
                }
            }),
            navigation: (/**
             * @param {?} navigation
             * @return {?}
             */
            function (navigation) {
                if (_this._state.navigation !== navigation) {
                    return { navigation: navigation };
                }
            }),
            outsideDays: (/**
             * @param {?} outsideDays
             * @return {?}
             */
            function (outsideDays) {
                if (_this._state.outsideDays !== outsideDays) {
                    return { outsideDays: outsideDays };
                }
            })
        };
        this._model$ = new Subject();
        this._dateSelect$ = new Subject();
        this._state = {
            disabled: false,
            displayMonths: 1,
            firstDayOfWeek: 1,
            focusVisible: false,
            months: [],
            navigation: 'select',
            outsideDays: 'visible',
            prevDisabled: false,
            nextDisabled: false,
            selectBoxes: { years: [], months: [] },
            selectedDate: null
        };
    }
    Object.defineProperty(NgbDatepickerService.prototype, "model$", {
        get: /**
         * @return {?}
         */
        function () { return this._model$.pipe(filter((/**
         * @param {?} model
         * @return {?}
         */
        function (model) { return model.months.length > 0; }))); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgbDatepickerService.prototype, "dateSelect$", {
        get: /**
         * @return {?}
         */
        function () { return this._dateSelect$.pipe(filter((/**
         * @param {?} date
         * @return {?}
         */
        function (date) { return date !== null; }))); },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} options
     * @return {?}
     */
    NgbDatepickerService.prototype.set = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        var _this = this;
        /** @type {?} */
        var patch = Object.keys(options)
            .map((/**
         * @param {?} key
         * @return {?}
         */
        function (key) { return _this._VALIDATORS[key](options[key]); }))
            .reduce((/**
         * @param {?} obj
         * @param {?} part
         * @return {?}
         */
        function (obj, part) { return (tslib_1.__assign({}, obj, part)); }), {});
        if (Object.keys(patch).length > 0) {
            this._nextState(patch);
        }
    };
    /**
     * @param {?} date
     * @return {?}
     */
    NgbDatepickerService.prototype.focus = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        if (!this._state.disabled && this._calendar.isValid(date) && isChangedDate(this._state.focusDate, date)) {
            this._nextState({ focusDate: date });
        }
    };
    /**
     * @return {?}
     */
    NgbDatepickerService.prototype.focusSelect = /**
     * @return {?}
     */
    function () {
        if (isDateSelectable(this._state.focusDate, this._state)) {
            this.select(this._state.focusDate, { emitEvent: true });
        }
    };
    /**
     * @param {?} date
     * @return {?}
     */
    NgbDatepickerService.prototype.open = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        /** @type {?} */
        var firstDate = this.toValidDate(date, this._calendar.getToday());
        if (!this._state.disabled && (!this._state.firstDate || isChangedMonth(this._state.firstDate, date))) {
            this._nextState({ firstDate: firstDate });
        }
    };
    /**
     * @param {?} date
     * @param {?=} options
     * @return {?}
     */
    NgbDatepickerService.prototype.select = /**
     * @param {?} date
     * @param {?=} options
     * @return {?}
     */
    function (date, options) {
        if (options === void 0) { options = {}; }
        /** @type {?} */
        var selectedDate = this.toValidDate(date, null);
        if (!this._state.disabled) {
            if (isChangedDate(this._state.selectedDate, selectedDate)) {
                this._nextState({ selectedDate: selectedDate });
            }
            if (options.emitEvent && isDateSelectable(selectedDate, this._state)) {
                this._dateSelect$.next(selectedDate);
            }
        }
    };
    /**
     * @param {?} date
     * @param {?=} defaultValue
     * @return {?}
     */
    NgbDatepickerService.prototype.toValidDate = /**
     * @param {?} date
     * @param {?=} defaultValue
     * @return {?}
     */
    function (date, defaultValue) {
        /** @type {?} */
        var ngbDate = NgbDate.from(date);
        if (defaultValue === undefined) {
            defaultValue = this._calendar.getToday();
        }
        return this._calendar.isValid(ngbDate) ? ngbDate : defaultValue;
    };
    /**
     * @param {?} struct
     * @return {?}
     */
    NgbDatepickerService.prototype.getMonth = /**
     * @param {?} struct
     * @return {?}
     */
    function (struct) {
        var e_1, _a;
        try {
            for (var _b = tslib_1.__values(this._state.months), _c = _b.next(); !_c.done; _c = _b.next()) {
                var month = _c.value;
                if (struct.month === month.number && struct.year === month.year) {
                    return month;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        throw new Error("month " + struct.month + " of year " + struct.year + " not found");
    };
    /**
     * @private
     * @param {?} patch
     * @return {?}
     */
    NgbDatepickerService.prototype._nextState = /**
     * @private
     * @param {?} patch
     * @return {?}
     */
    function (patch) {
        /** @type {?} */
        var newState = this._updateState(patch);
        this._patchContexts(newState);
        this._state = newState;
        this._model$.next(this._state);
    };
    /**
     * @private
     * @param {?} state
     * @return {?}
     */
    NgbDatepickerService.prototype._patchContexts = /**
     * @private
     * @param {?} state
     * @return {?}
     */
    function (state) {
        var months = state.months, displayMonths = state.displayMonths, selectedDate = state.selectedDate, focusDate = state.focusDate, focusVisible = state.focusVisible, disabled = state.disabled, outsideDays = state.outsideDays;
        state.months.forEach((/**
         * @param {?} month
         * @return {?}
         */
        function (month) {
            month.weeks.forEach((/**
             * @param {?} week
             * @return {?}
             */
            function (week) {
                week.days.forEach((/**
                 * @param {?} day
                 * @return {?}
                 */
                function (day) {
                    // patch focus flag
                    if (focusDate) {
                        day.context.focused = focusDate.equals(day.date) && focusVisible;
                    }
                    // calculating tabindex
                    day.tabindex = !disabled && day.date.equals(focusDate) && focusDate.month === month.number ? 0 : -1;
                    // override context disabled
                    if (disabled === true) {
                        day.context.disabled = true;
                    }
                    // patch selection flag
                    if (selectedDate !== undefined) {
                        day.context.selected = selectedDate !== null && selectedDate.equals(day.date);
                    }
                    // visibility
                    if (month.number !== day.date.month) {
                        day.hidden = outsideDays === 'hidden' || outsideDays === 'collapsed' ||
                            (displayMonths > 1 && day.date.after(months[0].firstDate) &&
                                day.date.before(months[displayMonths - 1].lastDate));
                    }
                }));
            }));
        }));
    };
    /**
     * @private
     * @param {?} patch
     * @return {?}
     */
    NgbDatepickerService.prototype._updateState = /**
     * @private
     * @param {?} patch
     * @return {?}
     */
    function (patch) {
        // patching fields
        /** @type {?} */
        var state = Object.assign({}, this._state, patch);
        /** @type {?} */
        var startDate = state.firstDate;
        // min/max dates changed
        if ('minDate' in patch || 'maxDate' in patch) {
            checkMinBeforeMax(state.minDate, state.maxDate);
            state.focusDate = checkDateInRange(state.focusDate, state.minDate, state.maxDate);
            state.firstDate = checkDateInRange(state.firstDate, state.minDate, state.maxDate);
            startDate = state.focusDate;
        }
        // disabled
        if ('disabled' in patch) {
            state.focusVisible = false;
        }
        // initial rebuild via 'select()'
        if ('selectedDate' in patch && this._state.months.length === 0) {
            startDate = state.selectedDate;
        }
        // terminate early if only focus visibility was changed
        if ('focusVisible' in patch) {
            return state;
        }
        // focus date changed
        if ('focusDate' in patch) {
            state.focusDate = checkDateInRange(state.focusDate, state.minDate, state.maxDate);
            startDate = state.focusDate;
            // nothing to rebuild if only focus changed and it is still visible
            if (state.months.length !== 0 && !state.focusDate.before(state.firstDate) &&
                !state.focusDate.after(state.lastDate)) {
                return state;
            }
        }
        // first date changed
        if ('firstDate' in patch) {
            state.firstDate = checkDateInRange(state.firstDate, state.minDate, state.maxDate);
            startDate = state.firstDate;
        }
        // rebuilding months
        if (startDate) {
            /** @type {?} */
            var forceRebuild = 'dayTemplateData' in patch || 'firstDayOfWeek' in patch || 'markDisabled' in patch ||
                'minDate' in patch || 'maxDate' in patch || 'disabled' in patch || 'outsideDays' in patch;
            /** @type {?} */
            var months = buildMonths(this._calendar, startDate, state, this._i18n, forceRebuild);
            // updating months and boundary dates
            state.months = months;
            state.firstDate = months.length > 0 ? months[0].firstDate : undefined;
            state.lastDate = months.length > 0 ? months[months.length - 1].lastDate : undefined;
            // reset selected date if 'markDisabled' returns true
            if ('selectedDate' in patch && !isDateSelectable(state.selectedDate, state)) {
                state.selectedDate = null;
            }
            // adjusting focus after months were built
            if ('firstDate' in patch) {
                if (state.focusDate === undefined || state.focusDate.before(state.firstDate) ||
                    state.focusDate.after(state.lastDate)) {
                    state.focusDate = startDate;
                }
            }
            // adjusting months/years for the select box navigation
            /** @type {?} */
            var yearChanged = !this._state.firstDate || this._state.firstDate.year !== state.firstDate.year;
            /** @type {?} */
            var monthChanged = !this._state.firstDate || this._state.firstDate.month !== state.firstDate.month;
            if (state.navigation === 'select') {
                // years ->  boundaries (min/max were changed)
                if ('minDate' in patch || 'maxDate' in patch || state.selectBoxes.years.length === 0 || yearChanged) {
                    state.selectBoxes.years = generateSelectBoxYears(state.firstDate, state.minDate, state.maxDate);
                }
                // months -> when current year or boundaries change
                if ('minDate' in patch || 'maxDate' in patch || state.selectBoxes.months.length === 0 || yearChanged) {
                    state.selectBoxes.months =
                        generateSelectBoxMonths(this._calendar, state.firstDate, state.minDate, state.maxDate);
                }
            }
            else {
                state.selectBoxes = { years: [], months: [] };
            }
            // updating navigation arrows -> boundaries change (min/max) or month/year changes
            if ((state.navigation === 'arrows' || state.navigation === 'select') &&
                (monthChanged || yearChanged || 'minDate' in patch || 'maxDate' in patch || 'disabled' in patch)) {
                state.prevDisabled = state.disabled || prevMonthDisabled(this._calendar, state.firstDate, state.minDate);
                state.nextDisabled = state.disabled || nextMonthDisabled(this._calendar, state.lastDate, state.maxDate);
            }
        }
        return state;
    };
    /** @nocollapse */
    NgbDatepickerService.ctorParameters = function () { return [
        { type: NgbCalendar },
        { type: NgbDatepickerI18n }
    ]; };
NgbDatepickerService.ngInjectableDef = Éµngcc0.ÉµÉµdefineInjectable({ token: NgbDatepickerService, factory: function NgbDatepickerService_Factory(t) { return new (t || NgbDatepickerService)(Éµngcc0.ÉµÉµinject(NgbCalendar), Éµngcc0.ÉµÉµinject(NgbDatepickerI18n)); }, providedIn: null });
/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(NgbDatepickerService, [{
        type: Injectable
    }], function () { return [{ type: NgbCalendar }, { type: NgbDatepickerI18n }]; }, { _calendar: [], _i18n: [], _VALIDATORS: [], _model$: [], _dateSelect$: [], _state: [], model$: [], dateSelect$: [], set: [], focus: [], focusSelect: [], open: [], select: [], toValidDate: [], getMonth: [], _nextState: [], _patchContexts: [], _updateState: [] });
    return NgbDatepickerService;
}());
export { NgbDatepickerService };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgbDatepickerService.prototype._VALIDATORS;
    /**
     * @type {?}
     * @private
     */
    NgbDatepickerService.prototype._model$;
    /**
     * @type {?}
     * @private
     */
    NgbDatepickerService.prototype._dateSelect$;
    /**
     * @type {?}
     * @private
     */
    NgbDatepickerService.prototype._state;
    /**
     * @type {?}
     * @private
     */
    NgbDatepickerService.prototype._calendar;
    /**
     * @type {?}
     * @private
     */
    NgbDatepickerService.prototype._i18n;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQG5nLWJvb3RzdHJhcC9uZy1ib290c3RyYXAvZXNtNS9kYXRlcGlja2VyL2RhdGVwaWNrZXItc2VydmljZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUE2Yk0sQUFHQTs7Ozs7Ozs7OzZWQUtHIiwiZmlsZSI6ImRhdGVwaWNrZXItc2VydmljZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGNvbnN0YW50UHJvcGVydHksZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgTmdiQ2FsZW5kYXIgfSBmcm9tICcuL25nYi1jYWxlbmRhcic7XHJcbmltcG9ydCB7IE5nYkRhdGUgfSBmcm9tICcuL25nYi1kYXRlJztcclxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBpc0ludGVnZXIsIHRvSW50ZWdlciB9IGZyb20gJy4uL3V0aWwvdXRpbCc7XHJcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgYnVpbGRNb250aHMsIGNoZWNrRGF0ZUluUmFuZ2UsIGNoZWNrTWluQmVmb3JlTWF4LCBpc0NoYW5nZWREYXRlLCBpc0NoYW5nZWRNb250aCwgaXNEYXRlU2VsZWN0YWJsZSwgZ2VuZXJhdGVTZWxlY3RCb3hZZWFycywgZ2VuZXJhdGVTZWxlY3RCb3hNb250aHMsIHByZXZNb250aERpc2FibGVkLCBuZXh0TW9udGhEaXNhYmxlZCB9IGZyb20gJy4vZGF0ZXBpY2tlci10b29scyc7XHJcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgTmdiRGF0ZXBpY2tlckkxOG4gfSBmcm9tICcuL2RhdGVwaWNrZXItaTE4bic7XHJcbi8qKlxyXG4gKiBAcmVjb3JkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gRGF0ZXBpY2tlclNlcnZpY2VJbnB1dHMoKSB7IH1cclxudmFyIE5nYkRhdGVwaWNrZXJTZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmdiRGF0ZXBpY2tlclNlcnZpY2UoX2NhbGVuZGFyLCBfaTE4bikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIgPSBfY2FsZW5kYXI7XHJcbiAgICAgICAgdGhpcy5faTE4biA9IF9pMThuO1xyXG4gICAgICAgIHRoaXMuX1ZBTElEQVRPUlMgPSB7XHJcbiAgICAgICAgICAgIGRheVRlbXBsYXRlRGF0YTogKC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGRheVRlbXBsYXRlRGF0YVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gKGRheVRlbXBsYXRlRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9zdGF0ZS5kYXlUZW1wbGF0ZURhdGEgIT09IGRheVRlbXBsYXRlRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRheVRlbXBsYXRlRGF0YTogZGF5VGVtcGxhdGVEYXRhIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBkaXNwbGF5TW9udGhzOiAoLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gZGlzcGxheU1vbnRoc1xyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gKGRpc3BsYXlNb250aHMpIHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlNb250aHMgPSB0b0ludGVnZXIoZGlzcGxheU1vbnRocyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJbnRlZ2VyKGRpc3BsYXlNb250aHMpICYmIGRpc3BsYXlNb250aHMgPiAwICYmIF90aGlzLl9zdGF0ZS5kaXNwbGF5TW9udGhzICE9PSBkaXNwbGF5TW9udGhzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGlzcGxheU1vbnRoczogZGlzcGxheU1vbnRocyB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgZGlzYWJsZWQ6ICgvKipcclxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBkaXNhYmxlZFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3N0YXRlLmRpc2FibGVkICE9PSBkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRpc2FibGVkOiBkaXNhYmxlZCB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgZmlyc3REYXlPZldlZWs6ICgvKipcclxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBmaXJzdERheU9mV2Vla1xyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gKGZpcnN0RGF5T2ZXZWVrKSB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdERheU9mV2VlayA9IHRvSW50ZWdlcihmaXJzdERheU9mV2Vlayk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJbnRlZ2VyKGZpcnN0RGF5T2ZXZWVrKSAmJiBmaXJzdERheU9mV2VlayA+PSAwICYmIF90aGlzLl9zdGF0ZS5maXJzdERheU9mV2VlayAhPT0gZmlyc3REYXlPZldlZWspIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBmaXJzdERheU9mV2VlazogZmlyc3REYXlPZldlZWsgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIGZvY3VzVmlzaWJsZTogKC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGZvY3VzVmlzaWJsZVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gKGZvY3VzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9zdGF0ZS5mb2N1c1Zpc2libGUgIT09IGZvY3VzVmlzaWJsZSAmJiAhX3RoaXMuX3N0YXRlLmRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZm9jdXNWaXNpYmxlOiBmb2N1c1Zpc2libGUgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIG1hcmtEaXNhYmxlZDogKC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IG1hcmtEaXNhYmxlZFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gKG1hcmtEaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9zdGF0ZS5tYXJrRGlzYWJsZWQgIT09IG1hcmtEaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG1hcmtEaXNhYmxlZDogbWFya0Rpc2FibGVkIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBtYXhEYXRlOiAoLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gZGF0ZVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgICAgIHZhciBtYXhEYXRlID0gX3RoaXMudG9WYWxpZERhdGUoZGF0ZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGFuZ2VkRGF0ZShfdGhpcy5fc3RhdGUubWF4RGF0ZSwgbWF4RGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBtYXhEYXRlOiBtYXhEYXRlIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBtaW5EYXRlOiAoLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gZGF0ZVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgICAgIHZhciBtaW5EYXRlID0gX3RoaXMudG9WYWxpZERhdGUoZGF0ZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGFuZ2VkRGF0ZShfdGhpcy5fc3RhdGUubWluRGF0ZSwgbWluRGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBtaW5EYXRlOiBtaW5EYXRlIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBuYXZpZ2F0aW9uOiAoLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gbmF2aWdhdGlvblxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gKG5hdmlnYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc3RhdGUubmF2aWdhdGlvbiAhPT0gbmF2aWdhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG5hdmlnYXRpb246IG5hdmlnYXRpb24gfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIG91dHNpZGVEYXlzOiAoLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gb3V0c2lkZURheXNcclxuICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChvdXRzaWRlRGF5cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9zdGF0ZS5vdXRzaWRlRGF5cyAhPT0gb3V0c2lkZURheXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBvdXRzaWRlRGF5czogb3V0c2lkZURheXMgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX21vZGVsJCA9IG5ldyBTdWJqZWN0KCk7XHJcbiAgICAgICAgdGhpcy5fZGF0ZVNlbGVjdCQgPSBuZXcgU3ViamVjdCgpO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlID0ge1xyXG4gICAgICAgICAgICBkaXNhYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGRpc3BsYXlNb250aHM6IDEsXHJcbiAgICAgICAgICAgIGZpcnN0RGF5T2ZXZWVrOiAxLFxyXG4gICAgICAgICAgICBmb2N1c1Zpc2libGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBtb250aHM6IFtdLFxyXG4gICAgICAgICAgICBuYXZpZ2F0aW9uOiAnc2VsZWN0JyxcclxuICAgICAgICAgICAgb3V0c2lkZURheXM6ICd2aXNpYmxlJyxcclxuICAgICAgICAgICAgcHJldkRpc2FibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgbmV4dERpc2FibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgc2VsZWN0Qm94ZXM6IHsgeWVhcnM6IFtdLCBtb250aHM6IFtdIH0sXHJcbiAgICAgICAgICAgIHNlbGVjdGVkRGF0ZTogbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdiRGF0ZXBpY2tlclNlcnZpY2UucHJvdG90eXBlLCBcIm1vZGVsJFwiLCB7XHJcbiAgICAgICAgZ2V0OiAvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21vZGVsJC5waXBlKGZpbHRlcigoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBtb2RlbFxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKG1vZGVsKSB7IHJldHVybiBtb2RlbC5tb250aHMubGVuZ3RoID4gMDsgfSkpKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdiRGF0ZXBpY2tlclNlcnZpY2UucHJvdG90eXBlLCBcImRhdGVTZWxlY3QkXCIsIHtcclxuICAgICAgICBnZXQ6IC8qKlxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0ZVNlbGVjdCQucGlwZShmaWx0ZXIoKC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gZGF0ZVxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUgIT09IG51bGw7IH0pKSk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXJTZXJ2aWNlLnByb3RvdHlwZS5zZXQgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICB2YXIgcGF0Y2ggPSBPYmplY3Qua2V5cyhvcHRpb25zKVxyXG4gICAgICAgICAgICAubWFwKCgvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IGtleVxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gX3RoaXMuX1ZBTElEQVRPUlNba2V5XShvcHRpb25zW2tleV0pOyB9KSlcclxuICAgICAgICAgICAgLnJlZHVjZSgoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBvYmpcclxuICAgICAgICAgKiBAcGFyYW0gez99IHBhcnRcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIChvYmosIHBhcnQpIHsgcmV0dXJuICh0c2xpYl8xLl9fYXNzaWduKHt9LCBvYmosIHBhcnQpKTsgfSksIHt9KTtcclxuICAgICAgICBpZiAoT2JqZWN0LmtleXMocGF0Y2gpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fbmV4dFN0YXRlKHBhdGNoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGRhdGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXJTZXJ2aWNlLnByb3RvdHlwZS5mb2N1cyA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fc3RhdGUuZGlzYWJsZWQgJiYgdGhpcy5fY2FsZW5kYXIuaXNWYWxpZChkYXRlKSAmJiBpc0NoYW5nZWREYXRlKHRoaXMuX3N0YXRlLmZvY3VzRGF0ZSwgZGF0ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fbmV4dFN0YXRlKHsgZm9jdXNEYXRlOiBkYXRlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXJTZXJ2aWNlLnByb3RvdHlwZS5mb2N1c1NlbGVjdCA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChpc0RhdGVTZWxlY3RhYmxlKHRoaXMuX3N0YXRlLmZvY3VzRGF0ZSwgdGhpcy5fc3RhdGUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KHRoaXMuX3N0YXRlLmZvY3VzRGF0ZSwgeyBlbWl0RXZlbnQ6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyU2VydmljZS5wcm90b3R5cGUub3BlbiA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICB2YXIgZmlyc3REYXRlID0gdGhpcy50b1ZhbGlkRGF0ZShkYXRlLCB0aGlzLl9jYWxlbmRhci5nZXRUb2RheSgpKTtcclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXRlLmRpc2FibGVkICYmICghdGhpcy5fc3RhdGUuZmlyc3REYXRlIHx8IGlzQ2hhbmdlZE1vbnRoKHRoaXMuX3N0YXRlLmZpcnN0RGF0ZSwgZGF0ZSkpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX25leHRTdGF0ZSh7IGZpcnN0RGF0ZTogZmlyc3REYXRlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZGF0ZVxyXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdiRGF0ZXBpY2tlclNlcnZpY2UucHJvdG90eXBlLnNlbGVjdCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXHJcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIHZhciBzZWxlY3RlZERhdGUgPSB0aGlzLnRvVmFsaWREYXRlKGRhdGUsIG51bGwpO1xyXG4gICAgICAgIGlmICghdGhpcy5fc3RhdGUuZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgaWYgKGlzQ2hhbmdlZERhdGUodGhpcy5fc3RhdGUuc2VsZWN0ZWREYXRlLCBzZWxlY3RlZERhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXh0U3RhdGUoeyBzZWxlY3RlZERhdGU6IHNlbGVjdGVkRGF0ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lbWl0RXZlbnQgJiYgaXNEYXRlU2VsZWN0YWJsZShzZWxlY3RlZERhdGUsIHRoaXMuX3N0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0ZVNlbGVjdCQubmV4dChzZWxlY3RlZERhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXHJcbiAgICAgKiBAcGFyYW0gez89fSBkZWZhdWx0VmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXJTZXJ2aWNlLnByb3RvdHlwZS50b1ZhbGlkRGF0ZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXHJcbiAgICAgKiBAcGFyYW0gez89fSBkZWZhdWx0VmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChkYXRlLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgdmFyIG5nYkRhdGUgPSBOZ2JEYXRlLmZyb20oZGF0ZSk7XHJcbiAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHRoaXMuX2NhbGVuZGFyLmdldFRvZGF5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxlbmRhci5pc1ZhbGlkKG5nYkRhdGUpID8gbmdiRGF0ZSA6IGRlZmF1bHRWYWx1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gc3RydWN0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyU2VydmljZS5wcm90b3R5cGUuZ2V0TW9udGggPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gc3RydWN0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoc3RydWN0KSB7XHJcbiAgICAgICAgdmFyIGVfMSwgX2E7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSB0c2xpYl8xLl9fdmFsdWVzKHRoaXMuX3N0YXRlLm1vbnRocyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtb250aCA9IF9jLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0cnVjdC5tb250aCA9PT0gbW9udGgubnVtYmVyICYmIHN0cnVjdC55ZWFyID09PSBtb250aC55ZWFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb250aCBcIiArIHN0cnVjdC5tb250aCArIFwiIG9mIHllYXIgXCIgKyBzdHJ1Y3QueWVhciArIFwiIG5vdCBmb3VuZFwiKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IHBhdGNoXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyU2VydmljZS5wcm90b3R5cGUuX25leHRTdGF0ZSA9IC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7P30gcGF0Y2hcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChwYXRjaCkge1xyXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICB2YXIgbmV3U3RhdGUgPSB0aGlzLl91cGRhdGVTdGF0ZShwYXRjaCk7XHJcbiAgICAgICAgdGhpcy5fcGF0Y2hDb250ZXh0cyhuZXdTdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXdTdGF0ZTtcclxuICAgICAgICB0aGlzLl9tb2RlbCQubmV4dCh0aGlzLl9zdGF0ZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdiRGF0ZXBpY2tlclNlcnZpY2UucHJvdG90eXBlLl9wYXRjaENvbnRleHRzID0gLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIG1vbnRocyA9IHN0YXRlLm1vbnRocywgZGlzcGxheU1vbnRocyA9IHN0YXRlLmRpc3BsYXlNb250aHMsIHNlbGVjdGVkRGF0ZSA9IHN0YXRlLnNlbGVjdGVkRGF0ZSwgZm9jdXNEYXRlID0gc3RhdGUuZm9jdXNEYXRlLCBmb2N1c1Zpc2libGUgPSBzdGF0ZS5mb2N1c1Zpc2libGUsIGRpc2FibGVkID0gc3RhdGUuZGlzYWJsZWQsIG91dHNpZGVEYXlzID0gc3RhdGUub3V0c2lkZURheXM7XHJcbiAgICAgICAgc3RhdGUubW9udGhzLmZvckVhY2goKC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gbW9udGhcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIChtb250aCkge1xyXG4gICAgICAgICAgICBtb250aC53ZWVrcy5mb3JFYWNoKCgvKipcclxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSB3ZWVrXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiAod2Vlaykge1xyXG4gICAgICAgICAgICAgICAgd2Vlay5kYXlzLmZvckVhY2goKC8qKlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHs/fSBkYXlcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChkYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwYXRjaCBmb2N1cyBmbGFnXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXkuY29udGV4dC5mb2N1c2VkID0gZm9jdXNEYXRlLmVxdWFscyhkYXkuZGF0ZSkgJiYgZm9jdXNWaXNpYmxlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGluZyB0YWJpbmRleFxyXG4gICAgICAgICAgICAgICAgICAgIGRheS50YWJpbmRleCA9ICFkaXNhYmxlZCAmJiBkYXkuZGF0ZS5lcXVhbHMoZm9jdXNEYXRlKSAmJiBmb2N1c0RhdGUubW9udGggPT09IG1vbnRoLm51bWJlciA/IDAgOiAtMTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSBjb250ZXh0IGRpc2FibGVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc2FibGVkID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheS5jb250ZXh0LmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGF0Y2ggc2VsZWN0aW9uIGZsYWdcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWREYXRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF5LmNvbnRleHQuc2VsZWN0ZWQgPSBzZWxlY3RlZERhdGUgIT09IG51bGwgJiYgc2VsZWN0ZWREYXRlLmVxdWFscyhkYXkuZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZpc2liaWxpdHlcclxuICAgICAgICAgICAgICAgICAgICBpZiAobW9udGgubnVtYmVyICE9PSBkYXkuZGF0ZS5tb250aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXkuaGlkZGVuID0gb3V0c2lkZURheXMgPT09ICdoaWRkZW4nIHx8IG91dHNpZGVEYXlzID09PSAnY29sbGFwc2VkJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRpc3BsYXlNb250aHMgPiAxICYmIGRheS5kYXRlLmFmdGVyKG1vbnRoc1swXS5maXJzdERhdGUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5LmRhdGUuYmVmb3JlKG1vbnRoc1tkaXNwbGF5TW9udGhzIC0gMV0ubGFzdERhdGUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSBwYXRjaFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdiRGF0ZXBpY2tlclNlcnZpY2UucHJvdG90eXBlLl91cGRhdGVTdGF0ZSA9IC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7P30gcGF0Y2hcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChwYXRjaCkge1xyXG4gICAgICAgIC8vIHBhdGNoaW5nIGZpZWxkc1xyXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICB2YXIgc3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9zdGF0ZSwgcGF0Y2gpO1xyXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICB2YXIgc3RhcnREYXRlID0gc3RhdGUuZmlyc3REYXRlO1xyXG4gICAgICAgIC8vIG1pbi9tYXggZGF0ZXMgY2hhbmdlZFxyXG4gICAgICAgIGlmICgnbWluRGF0ZScgaW4gcGF0Y2ggfHwgJ21heERhdGUnIGluIHBhdGNoKSB7XHJcbiAgICAgICAgICAgIGNoZWNrTWluQmVmb3JlTWF4KHN0YXRlLm1pbkRhdGUsIHN0YXRlLm1heERhdGUpO1xyXG4gICAgICAgICAgICBzdGF0ZS5mb2N1c0RhdGUgPSBjaGVja0RhdGVJblJhbmdlKHN0YXRlLmZvY3VzRGF0ZSwgc3RhdGUubWluRGF0ZSwgc3RhdGUubWF4RGF0ZSk7XHJcbiAgICAgICAgICAgIHN0YXRlLmZpcnN0RGF0ZSA9IGNoZWNrRGF0ZUluUmFuZ2Uoc3RhdGUuZmlyc3REYXRlLCBzdGF0ZS5taW5EYXRlLCBzdGF0ZS5tYXhEYXRlKTtcclxuICAgICAgICAgICAgc3RhcnREYXRlID0gc3RhdGUuZm9jdXNEYXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkaXNhYmxlZFxyXG4gICAgICAgIGlmICgnZGlzYWJsZWQnIGluIHBhdGNoKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmZvY3VzVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbml0aWFsIHJlYnVpbGQgdmlhICdzZWxlY3QoKSdcclxuICAgICAgICBpZiAoJ3NlbGVjdGVkRGF0ZScgaW4gcGF0Y2ggJiYgdGhpcy5fc3RhdGUubW9udGhzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBzdGFydERhdGUgPSBzdGF0ZS5zZWxlY3RlZERhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRlcm1pbmF0ZSBlYXJseSBpZiBvbmx5IGZvY3VzIHZpc2liaWxpdHkgd2FzIGNoYW5nZWRcclxuICAgICAgICBpZiAoJ2ZvY3VzVmlzaWJsZScgaW4gcGF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmb2N1cyBkYXRlIGNoYW5nZWRcclxuICAgICAgICBpZiAoJ2ZvY3VzRGF0ZScgaW4gcGF0Y2gpIHtcclxuICAgICAgICAgICAgc3RhdGUuZm9jdXNEYXRlID0gY2hlY2tEYXRlSW5SYW5nZShzdGF0ZS5mb2N1c0RhdGUsIHN0YXRlLm1pbkRhdGUsIHN0YXRlLm1heERhdGUpO1xyXG4gICAgICAgICAgICBzdGFydERhdGUgPSBzdGF0ZS5mb2N1c0RhdGU7XHJcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gcmVidWlsZCBpZiBvbmx5IGZvY3VzIGNoYW5nZWQgYW5kIGl0IGlzIHN0aWxsIHZpc2libGVcclxuICAgICAgICAgICAgaWYgKHN0YXRlLm1vbnRocy5sZW5ndGggIT09IDAgJiYgIXN0YXRlLmZvY3VzRGF0ZS5iZWZvcmUoc3RhdGUuZmlyc3REYXRlKSAmJlxyXG4gICAgICAgICAgICAgICAgIXN0YXRlLmZvY3VzRGF0ZS5hZnRlcihzdGF0ZS5sYXN0RGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmaXJzdCBkYXRlIGNoYW5nZWRcclxuICAgICAgICBpZiAoJ2ZpcnN0RGF0ZScgaW4gcGF0Y2gpIHtcclxuICAgICAgICAgICAgc3RhdGUuZmlyc3REYXRlID0gY2hlY2tEYXRlSW5SYW5nZShzdGF0ZS5maXJzdERhdGUsIHN0YXRlLm1pbkRhdGUsIHN0YXRlLm1heERhdGUpO1xyXG4gICAgICAgICAgICBzdGFydERhdGUgPSBzdGF0ZS5maXJzdERhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlYnVpbGRpbmcgbW9udGhzXHJcbiAgICAgICAgaWYgKHN0YXJ0RGF0ZSkge1xyXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgIHZhciBmb3JjZVJlYnVpbGQgPSAnZGF5VGVtcGxhdGVEYXRhJyBpbiBwYXRjaCB8fCAnZmlyc3REYXlPZldlZWsnIGluIHBhdGNoIHx8ICdtYXJrRGlzYWJsZWQnIGluIHBhdGNoIHx8XHJcbiAgICAgICAgICAgICAgICAnbWluRGF0ZScgaW4gcGF0Y2ggfHwgJ21heERhdGUnIGluIHBhdGNoIHx8ICdkaXNhYmxlZCcgaW4gcGF0Y2ggfHwgJ291dHNpZGVEYXlzJyBpbiBwYXRjaDtcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICB2YXIgbW9udGhzID0gYnVpbGRNb250aHModGhpcy5fY2FsZW5kYXIsIHN0YXJ0RGF0ZSwgc3RhdGUsIHRoaXMuX2kxOG4sIGZvcmNlUmVidWlsZCk7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0aW5nIG1vbnRocyBhbmQgYm91bmRhcnkgZGF0ZXNcclxuICAgICAgICAgICAgc3RhdGUubW9udGhzID0gbW9udGhzO1xyXG4gICAgICAgICAgICBzdGF0ZS5maXJzdERhdGUgPSBtb250aHMubGVuZ3RoID4gMCA/IG1vbnRoc1swXS5maXJzdERhdGUgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHN0YXRlLmxhc3REYXRlID0gbW9udGhzLmxlbmd0aCA+IDAgPyBtb250aHNbbW9udGhzLmxlbmd0aCAtIDFdLmxhc3REYXRlIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAvLyByZXNldCBzZWxlY3RlZCBkYXRlIGlmICdtYXJrRGlzYWJsZWQnIHJldHVybnMgdHJ1ZVxyXG4gICAgICAgICAgICBpZiAoJ3NlbGVjdGVkRGF0ZScgaW4gcGF0Y2ggJiYgIWlzRGF0ZVNlbGVjdGFibGUoc3RhdGUuc2VsZWN0ZWREYXRlLCBzdGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlLnNlbGVjdGVkRGF0ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYWRqdXN0aW5nIGZvY3VzIGFmdGVyIG1vbnRocyB3ZXJlIGJ1aWx0XHJcbiAgICAgICAgICAgIGlmICgnZmlyc3REYXRlJyBpbiBwYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZvY3VzRGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHN0YXRlLmZvY3VzRGF0ZS5iZWZvcmUoc3RhdGUuZmlyc3REYXRlKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmZvY3VzRGF0ZS5hZnRlcihzdGF0ZS5sYXN0RGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5mb2N1c0RhdGUgPSBzdGFydERhdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYWRqdXN0aW5nIG1vbnRocy95ZWFycyBmb3IgdGhlIHNlbGVjdCBib3ggbmF2aWdhdGlvblxyXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgIHZhciB5ZWFyQ2hhbmdlZCA9ICF0aGlzLl9zdGF0ZS5maXJzdERhdGUgfHwgdGhpcy5fc3RhdGUuZmlyc3REYXRlLnllYXIgIT09IHN0YXRlLmZpcnN0RGF0ZS55ZWFyO1xyXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgIHZhciBtb250aENoYW5nZWQgPSAhdGhpcy5fc3RhdGUuZmlyc3REYXRlIHx8IHRoaXMuX3N0YXRlLmZpcnN0RGF0ZS5tb250aCAhPT0gc3RhdGUuZmlyc3REYXRlLm1vbnRoO1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUubmF2aWdhdGlvbiA9PT0gJ3NlbGVjdCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIHllYXJzIC0+ICBib3VuZGFyaWVzIChtaW4vbWF4IHdlcmUgY2hhbmdlZClcclxuICAgICAgICAgICAgICAgIGlmICgnbWluRGF0ZScgaW4gcGF0Y2ggfHwgJ21heERhdGUnIGluIHBhdGNoIHx8IHN0YXRlLnNlbGVjdEJveGVzLnllYXJzLmxlbmd0aCA9PT0gMCB8fCB5ZWFyQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnNlbGVjdEJveGVzLnllYXJzID0gZ2VuZXJhdGVTZWxlY3RCb3hZZWFycyhzdGF0ZS5maXJzdERhdGUsIHN0YXRlLm1pbkRhdGUsIHN0YXRlLm1heERhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbW9udGhzIC0+IHdoZW4gY3VycmVudCB5ZWFyIG9yIGJvdW5kYXJpZXMgY2hhbmdlXHJcbiAgICAgICAgICAgICAgICBpZiAoJ21pbkRhdGUnIGluIHBhdGNoIHx8ICdtYXhEYXRlJyBpbiBwYXRjaCB8fCBzdGF0ZS5zZWxlY3RCb3hlcy5tb250aHMubGVuZ3RoID09PSAwIHx8IHllYXJDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2VsZWN0Qm94ZXMubW9udGhzID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVTZWxlY3RCb3hNb250aHModGhpcy5fY2FsZW5kYXIsIHN0YXRlLmZpcnN0RGF0ZSwgc3RhdGUubWluRGF0ZSwgc3RhdGUubWF4RGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5zZWxlY3RCb3hlcyA9IHsgeWVhcnM6IFtdLCBtb250aHM6IFtdIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdXBkYXRpbmcgbmF2aWdhdGlvbiBhcnJvd3MgLT4gYm91bmRhcmllcyBjaGFuZ2UgKG1pbi9tYXgpIG9yIG1vbnRoL3llYXIgY2hhbmdlc1xyXG4gICAgICAgICAgICBpZiAoKHN0YXRlLm5hdmlnYXRpb24gPT09ICdhcnJvd3MnIHx8IHN0YXRlLm5hdmlnYXRpb24gPT09ICdzZWxlY3QnKSAmJlxyXG4gICAgICAgICAgICAgICAgKG1vbnRoQ2hhbmdlZCB8fCB5ZWFyQ2hhbmdlZCB8fCAnbWluRGF0ZScgaW4gcGF0Y2ggfHwgJ21heERhdGUnIGluIHBhdGNoIHx8ICdkaXNhYmxlZCcgaW4gcGF0Y2gpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5wcmV2RGlzYWJsZWQgPSBzdGF0ZS5kaXNhYmxlZCB8fCBwcmV2TW9udGhEaXNhYmxlZCh0aGlzLl9jYWxlbmRhciwgc3RhdGUuZmlyc3REYXRlLCBzdGF0ZS5taW5EYXRlKTtcclxuICAgICAgICAgICAgICAgIHN0YXRlLm5leHREaXNhYmxlZCA9IHN0YXRlLmRpc2FibGVkIHx8IG5leHRNb250aERpc2FibGVkKHRoaXMuX2NhbGVuZGFyLCBzdGF0ZS5sYXN0RGF0ZSwgc3RhdGUubWF4RGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgfTtcclxuICAgIE5nYkRhdGVwaWNrZXJTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXHJcbiAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH1cclxuICAgIF07XHJcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cclxuICAgIE5nYkRhdGVwaWNrZXJTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgICAgIHsgdHlwZTogTmdiQ2FsZW5kYXIgfSxcclxuICAgICAgICB7IHR5cGU6IE5nYkRhdGVwaWNrZXJJMThuIH1cclxuICAgIF07IH07XHJcbiAgICByZXR1cm4gTmdiRGF0ZXBpY2tlclNlcnZpY2U7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IE5nYkRhdGVwaWNrZXJTZXJ2aWNlIH07XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXJTZXJ2aWNlLnByb3RvdHlwZS5fVkFMSURBVE9SUztcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyU2VydmljZS5wcm90b3R5cGUuX21vZGVsJDtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyU2VydmljZS5wcm90b3R5cGUuX2RhdGVTZWxlY3QkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXJTZXJ2aWNlLnByb3RvdHlwZS5fc3RhdGU7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgTmdiRGF0ZXBpY2tlclNlcnZpY2UucHJvdG90eXBlLl9jYWxlbmRhcjtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyU2VydmljZS5wcm90b3R5cGUuX2kxOG47XHJcbn1cciJdfQ==