/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { fromEvent, merge, Subject } from 'rxjs';
import { filter, take, takeUntil } from 'rxjs/operators';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, Directive, ElementRef, EventEmitter, forwardRef, Input, NgZone, Output, TemplateRef, ViewChild, ViewEncapsulation } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { NgbCalendar } from './ngb-calendar';
import { NgbDate } from './ngb-date';
import { NgbDatepickerService } from './datepicker-service';
import { NavigationEvent } from './datepicker-view-model';
import { NgbDatepickerConfig } from './datepicker-config';
import { NgbDateAdapter } from './adapters/ngb-date-adapter';
import { NgbDatepickerI18n } from './datepicker-i18n';
import { isChangedDate, isChangedMonth } from './datepicker-tools';
import { hasClassName } from '../util/util';
/** @type {?} */
import * as ɵngcc0 from '@angular/core';

const _c0 = ["defaultDayTemplate"];
const _c1 = ["content"];
const _c2 = ["defaultDayTemplate", ""];
const _c3 = ["defaultContentTemplate", ""];
const _c4 = [1, "ngb-dp-header"];
const _c5 = [3, "date", "months", "disabled", "showSelect", "prevDisabled", "nextDisabled", "selectBoxes", "navigate", "select", 4, "ngIf"];
const _c6 = [1, "ngb-dp-content"];
const _c7 = ["content", ""];
const _c8 = [3, "ngTemplateOutlet"];
const _c9 = ["ngbDatepickerDayView", "", 3, "date", "currentMonth", "selected", "disabled", "focused"];
function NgbDatepicker_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", _c9);
} if (rf & 2) {
    const date_r662 = ctx.date;
    const currentMonth_r663 = ctx.currentMonth;
    const selected_r664 = ctx.selected;
    const disabled_r665 = ctx.disabled;
    const focused_r666 = ctx.focused;
    ɵngcc0.ɵɵproperty("date", date_r662)("currentMonth", currentMonth_r663)("selected", selected_r664)("disabled", disabled_r665)("focused", focused_r666);
} }
const _c10 = ["class", "ngb-dp-month", 4, "ngFor", "ngForOf"];
const _c11 = [1, "ngb-dp-month"];
const _c12 = ["class", "ngb-dp-month-name", 4, "ngIf"];
const _c13 = [3, "month"];
const _c14 = [1, "ngb-dp-month-name"];
function NgbDatepicker_ng_template_2_div_0_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", _c14);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const month_r668 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r670 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵtextInterpolate2(" ", ctx_r670.i18n.getMonthFullName(month_r668.number, month_r668.year), " ", ctx_r670.i18n.getYearNumerals(month_r668.year), " ");
} }
function NgbDatepicker_ng_template_2_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", _c11);
    ɵngcc0.ɵɵtemplate(1, NgbDatepicker_ng_template_2_div_0_div_1_Template, 2, 2, "div", _c12);
    ɵngcc0.ɵɵelement(2, "ngb-datepicker-month", _c13);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const month_r668 = ctx.$implicit;
    const ctx_r667 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r667.navigation === "none" || ctx_r667.displayMonths > 1 && ctx_r667.navigation === "select");
    ɵngcc0.ɵɵselect(2);
    ɵngcc0.ɵɵproperty("month", month_r668.firstDate);
} }
function NgbDatepicker_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NgbDatepicker_ng_template_2_div_0_Template, 3, 2, "div", _c10);
} if (rf & 2) {
    const ctx_r657 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r657.model.months);
} }
const _c15 = [3, "date", "months", "disabled", "showSelect", "prevDisabled", "nextDisabled", "selectBoxes", "navigate", "select"];
function NgbDatepicker_ngb_datepicker_navigation_5_Template(rf, ctx) { if (rf & 1) {
    const _r673 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngb-datepicker-navigation", _c15);
    ɵngcc0.ɵɵlistener("navigate", function NgbDatepicker_ngb_datepicker_navigation_5_Template_ngb_datepicker_navigation_navigate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r673); const ctx_r672 = ɵngcc0.ɵɵnextContext(); return ctx_r672.onNavigateEvent($event); });
    ɵngcc0.ɵɵlistener("select", function NgbDatepicker_ngb_datepicker_navigation_5_Template_ngb_datepicker_navigation_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r673); const ctx_r674 = ɵngcc0.ɵɵnextContext(); return ctx_r674.onNavigateDateSelect($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r658 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("date", ctx_r658.model.firstDate)("months", ctx_r658.model.months)("disabled", ctx_r658.model.disabled)("showSelect", ctx_r658.model.navigation === "select")("prevDisabled", ctx_r658.model.prevDisabled)("nextDisabled", ctx_r658.model.nextDisabled)("selectBoxes", ctx_r658.model.selectBoxes);
} }
function NgbDatepicker_ng_template_8_Template(rf, ctx) { }
function NgbDatepicker_ng_template_9_Template(rf, ctx) { }
export var NGB_DATEPICKER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    function () { return NgbDatepicker; })),
    multi: true
};
/**
 * An event emitted right before the navigation happens and the month displayed by the datepicker changes.
 * @record
 */
export function NgbDatepickerNavigateEvent() { }
if (false) {
    /**
     * The currently displayed month.
     * @type {?}
     */
    NgbDatepickerNavigateEvent.prototype.current;
    /**
     * The month we're navigating to.
     * @type {?}
     */
    NgbDatepickerNavigateEvent.prototype.next;
    /**
     * Calling this function will prevent navigation from happening.
     *
     * \@since 4.1.0
     * @type {?}
     */
    NgbDatepickerNavigateEvent.prototype.preventDefault;
}
/**
 * An interface that represents the readonly public state of the datepicker.
 *
 * Accessible via the `datepicker.state` getter
 *
 * \@since 5.2.0
 * @record
 */
export function NgbDatepickerState() { }
if (false) {
    /**
     * The earliest date that can be displayed or selected
     * @type {?}
     */
    NgbDatepickerState.prototype.minDate;
    /**
     * The latest date that can be displayed or selected
     * @type {?}
     */
    NgbDatepickerState.prototype.maxDate;
    /**
     * The first visible date of currently displayed months
     * @type {?}
     */
    NgbDatepickerState.prototype.firstDate;
    /**
     * The last visible date of currently displayed months
     * @type {?}
     */
    NgbDatepickerState.prototype.lastDate;
    /**
     * The date currently focused by the datepicker
     * @type {?}
     */
    NgbDatepickerState.prototype.focusedDate;
    /**
     * First dates of months currently displayed by the datepicker
     *
     * \@since 5.3.0
     * @type {?}
     */
    NgbDatepickerState.prototype.months;
}
/**
 * A directive that marks the content template that customizes the way datepicker months are displayed
 *
 * \@since 5.3.0
 */
var NgbDatepickerContent = /** @class */ (function () {
    function NgbDatepickerContent(templateRef) {
        this.templateRef = templateRef;
    }
    /** @nocollapse */
    NgbDatepickerContent.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
NgbDatepickerContent.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbDatepickerContent, selectors: [["ng-template", "ngbDatepickerContent", ""]], factory: function NgbDatepickerContent_Factory(t) { return new (t || NgbDatepickerContent)(ɵngcc0.ɵɵdirectiveInject(TemplateRef)); } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbDatepickerContent, [{
        type: Directive,
        args: [{ selector: 'ng-template[ngbDatepickerContent]' }]
    }], function () { return [{ type: TemplateRef }]; }, { templateRef: [] });
    return NgbDatepickerContent;
}());
export { NgbDatepickerContent };
if (false) {
    /** @type {?} */
    NgbDatepickerContent.prototype.templateRef;
}
/**
 * A highly configurable component that helps you with selecting calendar dates.
 *
 * `NgbDatepicker` is meant to be displayed inline on a page or put inside a popup.
 */
var NgbDatepicker = /** @class */ (function () {
    function NgbDatepicker(_service, _calendar, i18n, config, cd, _elementRef, _ngbDateAdapter, _ngZone) {
        var _this = this;
        this._service = _service;
        this._calendar = _calendar;
        this.i18n = i18n;
        this._elementRef = _elementRef;
        this._ngbDateAdapter = _ngbDateAdapter;
        this._ngZone = _ngZone;
        this._destroyed$ = new Subject();
        this._publicState = (/** @type {?} */ ({}));
        /**
         * An event emitted right before the navigation happens and displayed month changes.
         *
         * See [`NgbDatepickerNavigateEvent`](#/components/datepicker/api#NgbDatepickerNavigateEvent) for the payload info.
         */
        this.navigate = new EventEmitter();
        /**
         * An event emitted when user selects a date using keyboard or mouse.
         *
         * The payload of the event is currently selected `NgbDate`.
         *
         * \@since 5.2.0
         */
        this.dateSelect = new EventEmitter();
        /**
         * An event emitted when user selects a date using keyboard or mouse.
         *
         * The payload of the event is currently selected `NgbDate`.
         *
         * Please use 'dateSelect' output instead, this will be deprecated in version 6.0 due to collision with native
         * 'select' event.
         */
        this.select = this.dateSelect;
        this.onChange = (/**
         * @param {?} _
         * @return {?}
         */
        function (_) { });
        this.onTouched = (/**
         * @return {?}
         */
        function () { });
        ['dayTemplate', 'dayTemplateData', 'displayMonths', 'firstDayOfWeek', 'footerTemplate', 'markDisabled', 'minDate',
            'maxDate', 'navigation', 'outsideDays', 'showWeekdays', 'showWeekNumbers', 'startDate']
            .forEach((/**
         * @param {?} input
         * @return {?}
         */
        function (input) { return _this[input] = config[input]; }));
        _service.dateSelect$.pipe(takeUntil(this._destroyed$)).subscribe((/**
         * @param {?} date
         * @return {?}
         */
        function (date) { _this.dateSelect.emit(date); }));
        _service.model$.pipe(takeUntil(this._destroyed$)).subscribe((/**
         * @param {?} model
         * @return {?}
         */
        function (model) {
            /** @type {?} */
            var newDate = model.firstDate;
            /** @type {?} */
            var oldDate = _this.model ? _this.model.firstDate : null;
            // update public state
            _this._publicState = {
                maxDate: model.maxDate,
                minDate: model.minDate,
                firstDate: model.firstDate,
                lastDate: model.lastDate,
                focusedDate: model.focusDate,
                months: model.months.map((/**
                 * @param {?} viewModel
                 * @return {?}
                 */
                function (viewModel) { return viewModel.firstDate; }))
            };
            /** @type {?} */
            var navigationPrevented = false;
            // emitting navigation event if the first month changes
            if (!newDate.equals(oldDate)) {
                _this.navigate.emit({
                    current: oldDate ? { year: oldDate.year, month: oldDate.month } : null,
                    next: { year: newDate.year, month: newDate.month },
                    preventDefault: (/**
                     * @return {?}
                     */
                    function () { return navigationPrevented = true; })
                });
                // can't prevent the very first navigation
                if (navigationPrevented && oldDate !== null) {
                    _this._service.open(oldDate);
                    return;
                }
            }
            /** @type {?} */
            var newSelectedDate = model.selectedDate;
            /** @type {?} */
            var newFocusedDate = model.focusDate;
            /** @type {?} */
            var oldFocusedDate = _this.model ? _this.model.focusDate : null;
            _this.model = model;
            // handling selection change
            if (isChangedDate(newSelectedDate, _this._controlValue)) {
                _this._controlValue = newSelectedDate;
                _this.onTouched();
                _this.onChange(_this._ngbDateAdapter.toModel(newSelectedDate));
            }
            // handling focus change
            if (isChangedDate(newFocusedDate, oldFocusedDate) && oldFocusedDate && model.focusVisible) {
                _this.focus();
            }
            cd.markForCheck();
        }));
    }
    Object.defineProperty(NgbDatepicker.prototype, "state", {
        /**
         *  Returns the readonly public state of the datepicker
         *
         * @since 5.2.0
         */
        get: /**
         *  Returns the readonly public state of the datepicker
         *
         * \@since 5.2.0
         * @return {?}
         */
        function () { return this._publicState; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgbDatepicker.prototype, "calendar", {
        /**
         *  Returns the calendar service used in the specific datepicker instance.
         *
         *  @since 5.3.0
         */
        get: /**
         *  Returns the calendar service used in the specific datepicker instance.
         *
         * \@since 5.3.0
         * @return {?}
         */
        function () { return this._calendar; },
        enumerable: true,
        configurable: true
    });
    /**
     *  Focuses on given date.
     */
    /**
     *  Focuses on given date.
     * @param {?} date
     * @return {?}
     */
    NgbDatepicker.prototype.focusDate = /**
     *  Focuses on given date.
     * @param {?} date
     * @return {?}
     */
    function (date) { this._service.focus(NgbDate.from(date)); };
    /**
     *  Selects focused date.
     */
    /**
     *  Selects focused date.
     * @return {?}
     */
    NgbDatepicker.prototype.focusSelect = /**
     *  Selects focused date.
     * @return {?}
     */
    function () { this._service.focusSelect(); };
    /**
     * @return {?}
     */
    NgbDatepicker.prototype.focus = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._ngZone.onStable.asObservable().pipe(take(1)).subscribe((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var elementToFocus = _this._elementRef.nativeElement.querySelector('div.ngb-dp-day[tabindex="0"]');
            if (elementToFocus) {
                elementToFocus.focus();
            }
        }));
    };
    /**
     * Navigates to the provided date.
     *
     * With the default calendar we use ISO 8601: 'month' is 1=Jan ... 12=Dec.
     * If nothing or invalid date provided calendar will open current month.
     *
     * Use the `[startDate]` input as an alternative.
     */
    /**
     * Navigates to the provided date.
     *
     * With the default calendar we use ISO 8601: 'month' is 1=Jan ... 12=Dec.
     * If nothing or invalid date provided calendar will open current month.
     *
     * Use the `[startDate]` input as an alternative.
     * @param {?=} date
     * @return {?}
     */
    NgbDatepicker.prototype.navigateTo = /**
     * Navigates to the provided date.
     *
     * With the default calendar we use ISO 8601: 'month' is 1=Jan ... 12=Dec.
     * If nothing or invalid date provided calendar will open current month.
     *
     * Use the `[startDate]` input as an alternative.
     * @param {?=} date
     * @return {?}
     */
    function (date) {
        this._service.open(NgbDate.from(date ? date.day ? (/** @type {?} */ (date)) : tslib_1.__assign({}, date, { day: 1 }) : null));
    };
    /**
     * @return {?}
     */
    NgbDatepicker.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._ngZone.runOutsideAngular((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var focusIns$ = fromEvent(_this._contentEl.nativeElement, 'focusin');
            /** @type {?} */
            var focusOuts$ = fromEvent(_this._contentEl.nativeElement, 'focusout');
            var nativeElement = _this._elementRef.nativeElement;
            // we're changing 'focusVisible' only when entering or leaving months view
            // and ignoring all focus events where both 'target' and 'related' target are day cells
            merge(focusIns$, focusOuts$)
                .pipe(filter((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var target = _a.target, relatedTarget = _a.relatedTarget;
                return !(hasClassName(target, 'ngb-dp-day') && hasClassName(relatedTarget, 'ngb-dp-day') &&
                    nativeElement.contains((/** @type {?} */ (target))) && nativeElement.contains((/** @type {?} */ (relatedTarget))));
            })), takeUntil(_this._destroyed$))
                .subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var type = _a.type;
                return _this._ngZone.run((/**
                 * @return {?}
                 */
                function () { return _this._service.set({ focusVisible: type === 'focusin' }); }));
            }));
        }));
    };
    /**
     * @return {?}
     */
    NgbDatepicker.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () { this._destroyed$.next(); };
    /**
     * @return {?}
     */
    NgbDatepicker.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.model === undefined) {
            /** @type {?} */
            var inputs_1 = {};
            ['dayTemplateData', 'displayMonths', 'markDisabled', 'firstDayOfWeek', 'navigation', 'minDate', 'maxDate',
                'outsideDays']
                .forEach((/**
             * @param {?} name
             * @return {?}
             */
            function (name) { return inputs_1[name] = _this[name]; }));
            this._service.set(inputs_1);
            this.navigateTo(this.startDate);
        }
        if (!this.dayTemplate) {
            this.dayTemplate = this._defaultDayTemplate;
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    NgbDatepicker.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        var _this = this;
        /** @type {?} */
        var inputs = {};
        ['dayTemplateData', 'displayMonths', 'markDisabled', 'firstDayOfWeek', 'navigation', 'minDate', 'maxDate',
            'outsideDays']
            .filter((/**
         * @param {?} name
         * @return {?}
         */
        function (name) { return name in changes; }))
            .forEach((/**
         * @param {?} name
         * @return {?}
         */
        function (name) { return inputs[name] = _this[name]; }));
        this._service.set(inputs);
        if ('startDate' in changes) {
            var _a = changes.startDate, currentValue = _a.currentValue, previousValue = _a.previousValue;
            if (isChangedMonth(previousValue, currentValue)) {
                this.navigateTo(this.startDate);
            }
        }
    };
    /**
     * @param {?} date
     * @return {?}
     */
    NgbDatepicker.prototype.onDateSelect = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        this._service.focus(date);
        this._service.select(date, { emitEvent: true });
    };
    /**
     * @param {?} date
     * @return {?}
     */
    NgbDatepicker.prototype.onNavigateDateSelect = /**
     * @param {?} date
     * @return {?}
     */
    function (date) { this._service.open(date); };
    /**
     * @param {?} event
     * @return {?}
     */
    NgbDatepicker.prototype.onNavigateEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        switch (event) {
            case NavigationEvent.PREV:
                this._service.open(this._calendar.getPrev(this.model.firstDate, 'm', 1));
                break;
            case NavigationEvent.NEXT:
                this._service.open(this._calendar.getNext(this.model.firstDate, 'm', 1));
                break;
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NgbDatepicker.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this.onChange = fn; };
    /**
     * @param {?} fn
     * @return {?}
     */
    NgbDatepicker.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this.onTouched = fn; };
    /**
     * @param {?} disabled
     * @return {?}
     */
    NgbDatepicker.prototype.setDisabledState = /**
     * @param {?} disabled
     * @return {?}
     */
    function (disabled) { this._service.set({ disabled: disabled }); };
    /**
     * @param {?} value
     * @return {?}
     */
    NgbDatepicker.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._controlValue = NgbDate.from(this._ngbDateAdapter.fromModel(value));
        this._service.select(this._controlValue);
    };
    /** @nocollapse */
    NgbDatepicker.ctorParameters = function () { return [
        { type: NgbDatepickerService },
        { type: NgbCalendar },
        { type: NgbDatepickerI18n },
        { type: NgbDatepickerConfig },
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgbDateAdapter },
        { type: NgZone }
    ]; };
    NgbDatepicker.propDecorators = {
        _defaultDayTemplate: [{ type: ViewChild, args: ['defaultDayTemplate', { static: true },] }],
        _contentEl: [{ type: ViewChild, args: ['content', { static: true },] }],
        contentTemplate: [{ type: ContentChild, args: [NgbDatepickerContent, { static: true },] }],
        dayTemplate: [{ type: Input }],
        dayTemplateData: [{ type: Input }],
        displayMonths: [{ type: Input }],
        firstDayOfWeek: [{ type: Input }],
        footerTemplate: [{ type: Input }],
        markDisabled: [{ type: Input }],
        maxDate: [{ type: Input }],
        minDate: [{ type: Input }],
        navigation: [{ type: Input }],
        outsideDays: [{ type: Input }],
        showWeekdays: [{ type: Input }],
        showWeekNumbers: [{ type: Input }],
        startDate: [{ type: Input }],
        navigate: [{ type: Output }],
        dateSelect: [{ type: Output }],
        select: [{ type: Output }]
    };
NgbDatepicker.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: NgbDatepicker, selectors: [["ngb-datepicker"]], factory: function NgbDatepicker_Factory(t) { return new (t || NgbDatepicker)(ɵngcc0.ɵɵdirectiveInject(NgbDatepickerService), ɵngcc0.ɵɵdirectiveInject(NgbCalendar), ɵngcc0.ɵɵdirectiveInject(NgbDatepickerI18n), ɵngcc0.ɵɵdirectiveInject(NgbDatepickerConfig), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(NgbDateAdapter), ɵngcc0.ɵɵdirectiveInject(NgZone)); }, contentQueries: function NgbDatepicker_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, NgbDatepickerContent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.contentTemplate = _t.first);
    } }, viewQuery: function NgbDatepicker_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
        ɵngcc0.ɵɵstaticViewQuery(_c1, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx._defaultDayTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx._contentEl = _t.first);
    } }, inputs: { dayTemplate: "dayTemplate", dayTemplateData: "dayTemplateData", displayMonths: "displayMonths", firstDayOfWeek: "firstDayOfWeek", footerTemplate: "footerTemplate", markDisabled: "markDisabled", maxDate: "maxDate", minDate: "minDate", navigation: "navigation", outsideDays: "outsideDays", showWeekdays: "showWeekdays", showWeekNumbers: "showWeekNumbers", startDate: "startDate" }, outputs: { navigate: "navigate", dateSelect: "dateSelect", select: "select" }, exportAs: ["ngbDatepicker"], features: [ɵngcc0.ɵɵProvidersFeature([NGB_DATEPICKER_VALUE_ACCESSOR, NgbDatepickerService]), ɵngcc0.ɵɵNgOnChangesFeature()], consts: 10, vars: 4, template: function NgbDatepicker_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NgbDatepicker_ng_template_0_Template, 1, 5, "ng-template", null, _c2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, NgbDatepicker_ng_template_2_Template, 1, 1, "ng-template", null, _c3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementStart(4, "div", _c4);
        ɵngcc0.ɵɵtemplate(5, NgbDatepicker_ngb_datepicker_navigation_5_Template, 1, 7, "ngb-datepicker-navigation", _c5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "div", _c6, _c7);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵtemplate(8, NgbDatepicker_ng_template_8_Template, 0, 0, "ng-template", _c8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(9, NgbDatepicker_ng_template_9_Template, 0, 0, "ng-template", _c8);
    } if (rf & 2) {
        const _r656 = ɵngcc0.ɵɵreference(3);
        ɵngcc0.ɵɵselect(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.navigation !== "none");
        ɵngcc0.ɵɵselect(6);
        ɵngcc0.ɵɵclassProp("ngb-dp-months", !ctx.contentTemplate);
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵselect(8);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", (ctx.contentTemplate == null ? null : ctx.contentTemplate.templateRef) || _r656);
        ɵngcc0.ɵɵselect(9);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.footerTemplate);
    } }, styles: ["ngb-datepicker{border:1px solid #dfdfdf;border-radius:.25rem;display:inline-block}ngb-datepicker-month{pointer-events:auto}ngb-datepicker.dropdown-menu{padding:0}.ngb-dp-body{z-index:1050}.ngb-dp-header{border-bottom:0;border-radius:.25rem .25rem 0 0;padding-top:.25rem;background-color:#f8f9fa;background-color:var(--light)}.ngb-dp-months{display:-ms-flexbox;display:flex}.ngb-dp-month{pointer-events:none}.ngb-dp-month-name{font-size:larger;height:2rem;line-height:2rem;text-align:center;background-color:#f8f9fa;background-color:var(--light)}.ngb-dp-month+.ngb-dp-month .ngb-dp-month-name,.ngb-dp-month+.ngb-dp-month .ngb-dp-week{padding-left:1rem}.ngb-dp-month:last-child .ngb-dp-week{padding-right:.25rem}.ngb-dp-month:first-child .ngb-dp-week{padding-left:.25rem}.ngb-dp-month .ngb-dp-week:last-child{padding-bottom:.25rem}"], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbDatepicker, [{
        type: Component,
        args: [{
                exportAs: 'ngbDatepicker',
                selector: 'ngb-datepicker',
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                template: "\n    <ng-template #defaultDayTemplate let-date=\"date\" let-currentMonth=\"currentMonth\" let-selected=\"selected\" let-disabled=\"disabled\" let-focused=\"focused\">\n      <div ngbDatepickerDayView\n        [date]=\"date\"\n        [currentMonth]=\"currentMonth\"\n        [selected]=\"selected\"\n        [disabled]=\"disabled\"\n        [focused]=\"focused\">\n      </div>\n    </ng-template>\n\n    <ng-template #defaultContentTemplate>\n      <div *ngFor=\"let month of model.months; let i = index;\" class=\"ngb-dp-month\">\n        <div *ngIf=\"navigation === 'none' || (displayMonths > 1 && navigation === 'select')\" class=\"ngb-dp-month-name\">\n          {{ i18n.getMonthFullName(month.number, month.year) }} {{ i18n.getYearNumerals(month.year) }}\n        </div>\n        <ngb-datepicker-month [month]=\"month.firstDate\"></ngb-datepicker-month>\n      </div>\n    </ng-template>\n\n    <div class=\"ngb-dp-header\">\n      <ngb-datepicker-navigation *ngIf=\"navigation !== 'none'\"\n        [date]=\"model.firstDate\"\n        [months]=\"model.months\"\n        [disabled]=\"model.disabled\"\n        [showSelect]=\"model.navigation === 'select'\"\n        [prevDisabled]=\"model.prevDisabled\"\n        [nextDisabled]=\"model.nextDisabled\"\n        [selectBoxes]=\"model.selectBoxes\"\n        (navigate)=\"onNavigateEvent($event)\"\n        (select)=\"onNavigateDateSelect($event)\">\n      </ngb-datepicker-navigation>\n    </div>\n\n    <div class=\"ngb-dp-content\" [class.ngb-dp-months]=\"!contentTemplate\" #content>\n      <ng-template [ngTemplateOutlet]=\"contentTemplate?.templateRef || defaultContentTemplate\"></ng-template>\n    </div>\n\n    <ng-template [ngTemplateOutlet]=\"footerTemplate\"></ng-template>\n  ",
                providers: [NGB_DATEPICKER_VALUE_ACCESSOR, NgbDatepickerService],
                styles: ["ngb-datepicker{border:1px solid #dfdfdf;border-radius:.25rem;display:inline-block}ngb-datepicker-month{pointer-events:auto}ngb-datepicker.dropdown-menu{padding:0}.ngb-dp-body{z-index:1050}.ngb-dp-header{border-bottom:0;border-radius:.25rem .25rem 0 0;padding-top:.25rem;background-color:#f8f9fa;background-color:var(--light)}.ngb-dp-months{display:-ms-flexbox;display:flex}.ngb-dp-month{pointer-events:none}.ngb-dp-month-name{font-size:larger;height:2rem;line-height:2rem;text-align:center;background-color:#f8f9fa;background-color:var(--light)}.ngb-dp-month+.ngb-dp-month .ngb-dp-month-name,.ngb-dp-month+.ngb-dp-month .ngb-dp-week{padding-left:1rem}.ngb-dp-month:last-child .ngb-dp-week{padding-right:.25rem}.ngb-dp-month:first-child .ngb-dp-week{padding-left:.25rem}.ngb-dp-month .ngb-dp-week:last-child{padding-bottom:.25rem}"]
            }]
    }], function () { return [{ type: NgbDatepickerService }, { type: NgbCalendar }, { type: NgbDatepickerI18n }, { type: NgbDatepickerConfig }, { type: ChangeDetectorRef }, { type: ElementRef }, { type: NgbDateAdapter }, { type: NgZone }]; }, { _service: [], _calendar: [], i18n: [], _elementRef: [], _ngbDateAdapter: [], _ngZone: [], _destroyed$: [], _publicState: [], navigate: [{
            type: Output
        }], dateSelect: [{
            type: Output
        }], select: [{
            type: Output
        }], onChange: [], onTouched: [], state: [], calendar: [], focusDate: [], focusSelect: [], focus: [], navigateTo: [], ngAfterViewInit: [], ngOnDestroy: [], ngOnInit: [], dayTemplate: [{
            type: Input
        }], ngOnChanges: [], onDateSelect: [], onNavigateDateSelect: [], onNavigateEvent: [], registerOnChange: [], registerOnTouched: [], setDisabledState: [], writeValue: [], _controlValue: [], _defaultDayTemplate: [{
            type: ViewChild,
            args: ['defaultDayTemplate', { static: true }]
        }], _contentEl: [{
            type: ViewChild,
            args: ['content', { static: true }]
        }], contentTemplate: [{
            type: ContentChild,
            args: [NgbDatepickerContent, { static: true }]
        }], dayTemplateData: [{
            type: Input
        }], displayMonths: [{
            type: Input
        }], firstDayOfWeek: [{
            type: Input
        }], footerTemplate: [{
            type: Input
        }], markDisabled: [{
            type: Input
        }], maxDate: [{
            type: Input
        }], minDate: [{
            type: Input
        }], navigation: [{
            type: Input
        }], outsideDays: [{
            type: Input
        }], showWeekdays: [{
            type: Input
        }], showWeekNumbers: [{
            type: Input
        }], startDate: [{
            type: Input
        }] });
    return NgbDatepicker;
}());
export { NgbDatepicker };
if (false) {
    /** @type {?} */
    NgbDatepicker.prototype.model;
    /**
     * @type {?}
     * @private
     */
    NgbDatepicker.prototype._defaultDayTemplate;
    /**
     * @type {?}
     * @private
     */
    NgbDatepicker.prototype._contentEl;
    /** @type {?} */
    NgbDatepicker.prototype.contentTemplate;
    /**
     * @type {?}
     * @private
     */
    NgbDatepicker.prototype._controlValue;
    /**
     * @type {?}
     * @private
     */
    NgbDatepicker.prototype._destroyed$;
    /**
     * @type {?}
     * @private
     */
    NgbDatepicker.prototype._publicState;
    /**
     * The reference to a custom template for the day.
     *
     * Allows to completely override the way a day 'cell' in the calendar is displayed.
     *
     * See [`DayTemplateContext`](#/components/datepicker/api#DayTemplateContext) for the data you get inside.
     * @type {?}
     */
    NgbDatepicker.prototype.dayTemplate;
    /**
     * The callback to pass any arbitrary data to the template cell via the
     * [`DayTemplateContext`](#/components/datepicker/api#DayTemplateContext)'s `data` parameter.
     *
     * `current` is the month that is currently displayed by the datepicker.
     *
     * \@since 3.3.0
     * @type {?}
     */
    NgbDatepicker.prototype.dayTemplateData;
    /**
     * The number of months to display.
     * @type {?}
     */
    NgbDatepicker.prototype.displayMonths;
    /**
     * The first day of the week.
     *
     * With default calendar we use ISO 8601: 'weekday' is 1=Mon ... 7=Sun.
     * @type {?}
     */
    NgbDatepicker.prototype.firstDayOfWeek;
    /**
     * The reference to the custom template for the datepicker footer.
     *
     * \@since 3.3.0
     * @type {?}
     */
    NgbDatepicker.prototype.footerTemplate;
    /**
     * The callback to mark some dates as disabled.
     *
     * It is called for each new date when navigating to a different month.
     *
     * `current` is the month that is currently displayed by the datepicker.
     * @type {?}
     */
    NgbDatepicker.prototype.markDisabled;
    /**
     * The latest date that can be displayed or selected.
     *
     * If not provided, 'year' select box will display 10 years after the current month.
     * @type {?}
     */
    NgbDatepicker.prototype.maxDate;
    /**
     * The earliest date that can be displayed or selected.
     *
     * If not provided, 'year' select box will display 10 years before the current month.
     * @type {?}
     */
    NgbDatepicker.prototype.minDate;
    /**
     * Navigation type.
     *
     * * `"select"` - select boxes for month and navigation arrows
     * * `"arrows"` - only navigation arrows
     * * `"none"` - no navigation visible at all
     * @type {?}
     */
    NgbDatepicker.prototype.navigation;
    /**
     * The way of displaying days that don't belong to the current month.
     *
     * * `"visible"` - days are visible
     * * `"hidden"` - days are hidden, white space preserved
     * * `"collapsed"` - days are collapsed, so the datepicker height might change between months
     *
     * For the 2+ months view, days in between months are never shown.
     * @type {?}
     */
    NgbDatepicker.prototype.outsideDays;
    /**
     * If `true`, weekdays will be displayed.
     * @type {?}
     */
    NgbDatepicker.prototype.showWeekdays;
    /**
     * If `true`, week numbers will be displayed.
     * @type {?}
     */
    NgbDatepicker.prototype.showWeekNumbers;
    /**
     * The date to open calendar with.
     *
     * With the default calendar we use ISO 8601: 'month' is 1=Jan ... 12=Dec.
     * If nothing or invalid date is provided, calendar will open with current month.
     *
     * You could use `navigateTo(date)` method as an alternative.
     * @type {?}
     */
    NgbDatepicker.prototype.startDate;
    /**
     * An event emitted right before the navigation happens and displayed month changes.
     *
     * See [`NgbDatepickerNavigateEvent`](#/components/datepicker/api#NgbDatepickerNavigateEvent) for the payload info.
     * @type {?}
     */
    NgbDatepicker.prototype.navigate;
    /**
     * An event emitted when user selects a date using keyboard or mouse.
     *
     * The payload of the event is currently selected `NgbDate`.
     *
     * \@since 5.2.0
     * @type {?}
     */
    NgbDatepicker.prototype.dateSelect;
    /**
     * An event emitted when user selects a date using keyboard or mouse.
     *
     * The payload of the event is currently selected `NgbDate`.
     *
     * Please use 'dateSelect' output instead, this will be deprecated in version 6.0 due to collision with native
     * 'select' event.
     * @type {?}
     */
    NgbDatepicker.prototype.select;
    /** @type {?} */
    NgbDatepicker.prototype.onChange;
    /** @type {?} */
    NgbDatepicker.prototype.onTouched;
    /**
     * @type {?}
     * @private
     */
    NgbDatepicker.prototype._service;
    /**
     * @type {?}
     * @private
     */
    NgbDatepicker.prototype._calendar;
    /** @type {?} */
    NgbDatepicker.prototype.i18n;
    /**
     * @type {?}
     * @private
     */
    NgbDatepicker.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    NgbDatepicker.prototype._ngbDateAdapter;
    /**
     * @type {?}
     * @private
     */
    NgbDatepicker.prototype._ngZone;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQG5nLWJvb3RzdHJhcC9uZy1ib290c3RyYXAvZXNtNS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBbUZLLEFBR0M7Ozs7Ozs7Ozs4RUFJRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFtYUgsQUFXQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2NBZ0NBIiwiZmlsZSI6ImRhdGVwaWNrZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IGZyb21FdmVudCwgbWVyZ2UsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgZmlsdGVyLCB0YWtlLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBmb3J3YXJkUmVmLCBJbnB1dCwgTmdab25lLCBPdXRwdXQsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyBOZ2JDYWxlbmRhciB9IGZyb20gJy4vbmdiLWNhbGVuZGFyJztcclxuaW1wb3J0IHsgTmdiRGF0ZSB9IGZyb20gJy4vbmdiLWRhdGUnO1xyXG5pbXBvcnQgeyBOZ2JEYXRlcGlja2VyU2VydmljZSB9IGZyb20gJy4vZGF0ZXBpY2tlci1zZXJ2aWNlJztcclxuaW1wb3J0IHsgTmF2aWdhdGlvbkV2ZW50IH0gZnJvbSAnLi9kYXRlcGlja2VyLXZpZXctbW9kZWwnO1xyXG5pbXBvcnQgeyBOZ2JEYXRlcGlja2VyQ29uZmlnIH0gZnJvbSAnLi9kYXRlcGlja2VyLWNvbmZpZyc7XHJcbmltcG9ydCB7IE5nYkRhdGVBZGFwdGVyIH0gZnJvbSAnLi9hZGFwdGVycy9uZ2ItZGF0ZS1hZGFwdGVyJztcclxuaW1wb3J0IHsgTmdiRGF0ZXBpY2tlckkxOG4gfSBmcm9tICcuL2RhdGVwaWNrZXItaTE4bic7XHJcbmltcG9ydCB7IGlzQ2hhbmdlZERhdGUsIGlzQ2hhbmdlZE1vbnRoIH0gZnJvbSAnLi9kYXRlcGlja2VyLXRvb2xzJztcclxuaW1wb3J0IHsgaGFzQ2xhc3NOYW1lIH0gZnJvbSAnLi4vdXRpbC91dGlsJztcclxuLyoqIEB0eXBlIHs/fSAqL1xyXG5leHBvcnQgdmFyIE5HQl9EQVRFUElDS0VSX1ZBTFVFX0FDQ0VTU09SID0ge1xyXG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXHJcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBOZ2JEYXRlcGlja2VyOyB9KSksXHJcbiAgICBtdWx0aTogdHJ1ZVxyXG59O1xyXG4vKipcclxuICogQW4gZXZlbnQgZW1pdHRlZCByaWdodCBiZWZvcmUgdGhlIG5hdmlnYXRpb24gaGFwcGVucyBhbmQgdGhlIG1vbnRoIGRpc3BsYXllZCBieSB0aGUgZGF0ZXBpY2tlciBjaGFuZ2VzLlxyXG4gKiBAcmVjb3JkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gTmdiRGF0ZXBpY2tlck5hdmlnYXRlRXZlbnQoKSB7IH1cclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50bHkgZGlzcGxheWVkIG1vbnRoLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXJOYXZpZ2F0ZUV2ZW50LnByb3RvdHlwZS5jdXJyZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbW9udGggd2UncmUgbmF2aWdhdGluZyB0by5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyTmF2aWdhdGVFdmVudC5wcm90b3R5cGUubmV4dDtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIHdpbGwgcHJldmVudCBuYXZpZ2F0aW9uIGZyb20gaGFwcGVuaW5nLlxyXG4gICAgICpcclxuICAgICAqIFxcQHNpbmNlIDQuMS4wXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiRGF0ZXBpY2tlck5hdmlnYXRlRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBBbiBpbnRlcmZhY2UgdGhhdCByZXByZXNlbnRzIHRoZSByZWFkb25seSBwdWJsaWMgc3RhdGUgb2YgdGhlIGRhdGVwaWNrZXIuXHJcbiAqXHJcbiAqIEFjY2Vzc2libGUgdmlhIHRoZSBgZGF0ZXBpY2tlci5zdGF0ZWAgZ2V0dGVyXHJcbiAqXHJcbiAqIFxcQHNpbmNlIDUuMi4wXHJcbiAqIEByZWNvcmRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBOZ2JEYXRlcGlja2VyU3RhdGUoKSB7IH1cclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBlYXJsaWVzdCBkYXRlIHRoYXQgY2FuIGJlIGRpc3BsYXllZCBvciBzZWxlY3RlZFxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXJTdGF0ZS5wcm90b3R5cGUubWluRGF0ZTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxhdGVzdCBkYXRlIHRoYXQgY2FuIGJlIGRpc3BsYXllZCBvciBzZWxlY3RlZFxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXJTdGF0ZS5wcm90b3R5cGUubWF4RGF0ZTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZpcnN0IHZpc2libGUgZGF0ZSBvZiBjdXJyZW50bHkgZGlzcGxheWVkIG1vbnRoc1xyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXJTdGF0ZS5wcm90b3R5cGUuZmlyc3REYXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGFzdCB2aXNpYmxlIGRhdGUgb2YgY3VycmVudGx5IGRpc3BsYXllZCBtb250aHNcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyU3RhdGUucHJvdG90eXBlLmxhc3REYXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGF0ZSBjdXJyZW50bHkgZm9jdXNlZCBieSB0aGUgZGF0ZXBpY2tlclxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXJTdGF0ZS5wcm90b3R5cGUuZm9jdXNlZERhdGU7XHJcbiAgICAvKipcclxuICAgICAqIEZpcnN0IGRhdGVzIG9mIG1vbnRocyBjdXJyZW50bHkgZGlzcGxheWVkIGJ5IHRoZSBkYXRlcGlja2VyXHJcbiAgICAgKlxyXG4gICAgICogXFxAc2luY2UgNS4zLjBcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyU3RhdGUucHJvdG90eXBlLm1vbnRocztcclxufVxyXG4vKipcclxuICogQSBkaXJlY3RpdmUgdGhhdCBtYXJrcyB0aGUgY29udGVudCB0ZW1wbGF0ZSB0aGF0IGN1c3RvbWl6ZXMgdGhlIHdheSBkYXRlcGlja2VyIG1vbnRocyBhcmUgZGlzcGxheWVkXHJcbiAqXHJcbiAqIFxcQHNpbmNlIDUuMy4wXHJcbiAqL1xyXG52YXIgTmdiRGF0ZXBpY2tlckNvbnRlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZ2JEYXRlcGlja2VyQ29udGVudCh0ZW1wbGF0ZVJlZikge1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcclxuICAgIH1cclxuICAgIE5nYkRhdGVwaWNrZXJDb250ZW50LmRlY29yYXRvcnMgPSBbXHJcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbmctdGVtcGxhdGVbbmdiRGF0ZXBpY2tlckNvbnRlbnRdJyB9LF0gfVxyXG4gICAgXTtcclxuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xyXG4gICAgTmdiRGF0ZXBpY2tlckNvbnRlbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXHJcbiAgICAgICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiB9XHJcbiAgICBdOyB9O1xyXG4gICAgcmV0dXJuIE5nYkRhdGVwaWNrZXJDb250ZW50O1xyXG59KCkpO1xyXG5leHBvcnQgeyBOZ2JEYXRlcGlja2VyQ29udGVudCB9O1xyXG5pZiAoZmFsc2UpIHtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE5nYkRhdGVwaWNrZXJDb250ZW50LnByb3RvdHlwZS50ZW1wbGF0ZVJlZjtcclxufVxyXG4vKipcclxuICogQSBoaWdobHkgY29uZmlndXJhYmxlIGNvbXBvbmVudCB0aGF0IGhlbHBzIHlvdSB3aXRoIHNlbGVjdGluZyBjYWxlbmRhciBkYXRlcy5cclxuICpcclxuICogYE5nYkRhdGVwaWNrZXJgIGlzIG1lYW50IHRvIGJlIGRpc3BsYXllZCBpbmxpbmUgb24gYSBwYWdlIG9yIHB1dCBpbnNpZGUgYSBwb3B1cC5cclxuICovXHJcbnZhciBOZ2JEYXRlcGlja2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmdiRGF0ZXBpY2tlcihfc2VydmljZSwgX2NhbGVuZGFyLCBpMThuLCBjb25maWcsIGNkLCBfZWxlbWVudFJlZiwgX25nYkRhdGVBZGFwdGVyLCBfbmdab25lKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9zZXJ2aWNlID0gX3NlcnZpY2U7XHJcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIgPSBfY2FsZW5kYXI7XHJcbiAgICAgICAgdGhpcy5pMThuID0gaTE4bjtcclxuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XHJcbiAgICAgICAgdGhpcy5fbmdiRGF0ZUFkYXB0ZXIgPSBfbmdiRGF0ZUFkYXB0ZXI7XHJcbiAgICAgICAgdGhpcy5fbmdab25lID0gX25nWm9uZTtcclxuICAgICAgICB0aGlzLl9kZXN0cm95ZWQkID0gbmV3IFN1YmplY3QoKTtcclxuICAgICAgICB0aGlzLl9wdWJsaWNTdGF0ZSA9ICgvKiogQHR5cGUgez99ICovICh7fSkpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGV2ZW50IGVtaXR0ZWQgcmlnaHQgYmVmb3JlIHRoZSBuYXZpZ2F0aW9uIGhhcHBlbnMgYW5kIGRpc3BsYXllZCBtb250aCBjaGFuZ2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogU2VlIFtgTmdiRGF0ZXBpY2tlck5hdmlnYXRlRXZlbnRgXSgjL2NvbXBvbmVudHMvZGF0ZXBpY2tlci9hcGkjTmdiRGF0ZXBpY2tlck5hdmlnYXRlRXZlbnQpIGZvciB0aGUgcGF5bG9hZCBpbmZvLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubmF2aWdhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gZXZlbnQgZW1pdHRlZCB3aGVuIHVzZXIgc2VsZWN0cyBhIGRhdGUgdXNpbmcga2V5Ym9hcmQgb3IgbW91c2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGUgcGF5bG9hZCBvZiB0aGUgZXZlbnQgaXMgY3VycmVudGx5IHNlbGVjdGVkIGBOZ2JEYXRlYC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFxcQHNpbmNlIDUuMi4wXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kYXRlU2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGV2ZW50IGVtaXR0ZWQgd2hlbiB1c2VyIHNlbGVjdHMgYSBkYXRlIHVzaW5nIGtleWJvYXJkIG9yIG1vdXNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhlIHBheWxvYWQgb2YgdGhlIGV2ZW50IGlzIGN1cnJlbnRseSBzZWxlY3RlZCBgTmdiRGF0ZWAuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBQbGVhc2UgdXNlICdkYXRlU2VsZWN0JyBvdXRwdXQgaW5zdGVhZCwgdGhpcyB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdmVyc2lvbiA2LjAgZHVlIHRvIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZVxyXG4gICAgICAgICAqICdzZWxlY3QnIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gdGhpcy5kYXRlU2VsZWN0O1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSAoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBfXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiAoXykgeyB9KTtcclxuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9ICgvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgfSk7XHJcbiAgICAgICAgWydkYXlUZW1wbGF0ZScsICdkYXlUZW1wbGF0ZURhdGEnLCAnZGlzcGxheU1vbnRocycsICdmaXJzdERheU9mV2VlaycsICdmb290ZXJUZW1wbGF0ZScsICdtYXJrRGlzYWJsZWQnLCAnbWluRGF0ZScsXHJcbiAgICAgICAgICAgICdtYXhEYXRlJywgJ25hdmlnYXRpb24nLCAnb3V0c2lkZURheXMnLCAnc2hvd1dlZWtkYXlzJywgJ3Nob3dXZWVrTnVtYmVycycsICdzdGFydERhdGUnXVxyXG4gICAgICAgICAgICAuZm9yRWFjaCgoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBpbnB1dFxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBfdGhpc1tpbnB1dF0gPSBjb25maWdbaW5wdXRdOyB9KSk7XHJcbiAgICAgICAgX3NlcnZpY2UuZGF0ZVNlbGVjdCQucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkJCkpLnN1YnNjcmliZSgoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBkYXRlXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiAoZGF0ZSkgeyBfdGhpcy5kYXRlU2VsZWN0LmVtaXQoZGF0ZSk7IH0pKTtcclxuICAgICAgICBfc2VydmljZS5tb2RlbCQucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkJCkpLnN1YnNjcmliZSgoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBtb2RlbFxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKG1vZGVsKSB7XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgdmFyIG5ld0RhdGUgPSBtb2RlbC5maXJzdERhdGU7XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgdmFyIG9sZERhdGUgPSBfdGhpcy5tb2RlbCA/IF90aGlzLm1vZGVsLmZpcnN0RGF0ZSA6IG51bGw7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwdWJsaWMgc3RhdGVcclxuICAgICAgICAgICAgX3RoaXMuX3B1YmxpY1N0YXRlID0ge1xyXG4gICAgICAgICAgICAgICAgbWF4RGF0ZTogbW9kZWwubWF4RGF0ZSxcclxuICAgICAgICAgICAgICAgIG1pbkRhdGU6IG1vZGVsLm1pbkRhdGUsXHJcbiAgICAgICAgICAgICAgICBmaXJzdERhdGU6IG1vZGVsLmZpcnN0RGF0ZSxcclxuICAgICAgICAgICAgICAgIGxhc3REYXRlOiBtb2RlbC5sYXN0RGF0ZSxcclxuICAgICAgICAgICAgICAgIGZvY3VzZWREYXRlOiBtb2RlbC5mb2N1c0RhdGUsXHJcbiAgICAgICAgICAgICAgICBtb250aHM6IG1vZGVsLm1vbnRocy5tYXAoKC8qKlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHs/fSB2aWV3TW9kZWxcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2aWV3TW9kZWwpIHsgcmV0dXJuIHZpZXdNb2RlbC5maXJzdERhdGU7IH0pKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgIHZhciBuYXZpZ2F0aW9uUHJldmVudGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIGVtaXR0aW5nIG5hdmlnYXRpb24gZXZlbnQgaWYgdGhlIGZpcnN0IG1vbnRoIGNoYW5nZXNcclxuICAgICAgICAgICAgaWYgKCFuZXdEYXRlLmVxdWFscyhvbGREYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubmF2aWdhdGUuZW1pdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudDogb2xkRGF0ZSA/IHsgeWVhcjogb2xkRGF0ZS55ZWFyLCBtb250aDogb2xkRGF0ZS5tb250aCB9IDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBuZXh0OiB7IHllYXI6IG5ld0RhdGUueWVhciwgbW9udGg6IG5ld0RhdGUubW9udGggfSxcclxuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogKC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmF2aWdhdGlvblByZXZlbnRlZCA9IHRydWU7IH0pXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIGNhbid0IHByZXZlbnQgdGhlIHZlcnkgZmlyc3QgbmF2aWdhdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKG5hdmlnYXRpb25QcmV2ZW50ZWQgJiYgb2xkRGF0ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXJ2aWNlLm9wZW4ob2xkRGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgdmFyIG5ld1NlbGVjdGVkRGF0ZSA9IG1vZGVsLnNlbGVjdGVkRGF0ZTtcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICB2YXIgbmV3Rm9jdXNlZERhdGUgPSBtb2RlbC5mb2N1c0RhdGU7XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgdmFyIG9sZEZvY3VzZWREYXRlID0gX3RoaXMubW9kZWwgPyBfdGhpcy5tb2RlbC5mb2N1c0RhdGUgOiBudWxsO1xyXG4gICAgICAgICAgICBfdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgICAgICAvLyBoYW5kbGluZyBzZWxlY3Rpb24gY2hhbmdlXHJcbiAgICAgICAgICAgIGlmIChpc0NoYW5nZWREYXRlKG5ld1NlbGVjdGVkRGF0ZSwgX3RoaXMuX2NvbnRyb2xWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9jb250cm9sVmFsdWUgPSBuZXdTZWxlY3RlZERhdGU7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5vblRvdWNoZWQoKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLm9uQ2hhbmdlKF90aGlzLl9uZ2JEYXRlQWRhcHRlci50b01vZGVsKG5ld1NlbGVjdGVkRGF0ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGhhbmRsaW5nIGZvY3VzIGNoYW5nZVxyXG4gICAgICAgICAgICBpZiAoaXNDaGFuZ2VkRGF0ZShuZXdGb2N1c2VkRGF0ZSwgb2xkRm9jdXNlZERhdGUpICYmIG9sZEZvY3VzZWREYXRlICYmIG1vZGVsLmZvY3VzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZm9jdXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjZC5tYXJrRm9yQ2hlY2soKTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdiRGF0ZXBpY2tlci5wcm90b3R5cGUsIFwic3RhdGVcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqICBSZXR1cm5zIHRoZSByZWFkb25seSBwdWJsaWMgc3RhdGUgb2YgdGhlIGRhdGVwaWNrZXJcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzaW5jZSA1LjIuMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogLyoqXHJcbiAgICAgICAgICogIFJldHVybnMgdGhlIHJlYWRvbmx5IHB1YmxpYyBzdGF0ZSBvZiB0aGUgZGF0ZXBpY2tlclxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogXFxAc2luY2UgNS4yLjBcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3B1YmxpY1N0YXRlOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ2JEYXRlcGlja2VyLnByb3RvdHlwZSwgXCJjYWxlbmRhclwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogIFJldHVybnMgdGhlIGNhbGVuZGFyIHNlcnZpY2UgdXNlZCBpbiB0aGUgc3BlY2lmaWMgZGF0ZXBpY2tlciBpbnN0YW5jZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICBAc2luY2UgNS4zLjBcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IC8qKlxyXG4gICAgICAgICAqICBSZXR1cm5zIHRoZSBjYWxlbmRhciBzZXJ2aWNlIHVzZWQgaW4gdGhlIHNwZWNpZmljIGRhdGVwaWNrZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBcXEBzaW5jZSA1LjMuMFxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2FsZW5kYXI7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgRm9jdXNlcyBvbiBnaXZlbiBkYXRlLlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqICBGb2N1c2VzIG9uIGdpdmVuIGRhdGUuXHJcbiAgICAgKiBAcGFyYW0gez99IGRhdGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXIucHJvdG90eXBlLmZvY3VzRGF0ZSA9IC8qKlxyXG4gICAgICogIEZvY3VzZXMgb24gZ2l2ZW4gZGF0ZS5cclxuICAgICAqIEBwYXJhbSB7P30gZGF0ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGRhdGUpIHsgdGhpcy5fc2VydmljZS5mb2N1cyhOZ2JEYXRlLmZyb20oZGF0ZSkpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgU2VsZWN0cyBmb2N1c2VkIGRhdGUuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogIFNlbGVjdHMgZm9jdXNlZCBkYXRlLlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdiRGF0ZXBpY2tlci5wcm90b3R5cGUuZm9jdXNTZWxlY3QgPSAvKipcclxuICAgICAqICBTZWxlY3RzIGZvY3VzZWQgZGF0ZS5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5fc2VydmljZS5mb2N1c1NlbGVjdCgpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyLnByb3RvdHlwZS5mb2N1cyA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fbmdab25lLm9uU3RhYmxlLmFzT2JzZXJ2YWJsZSgpLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKCgvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudFRvRm9jdXMgPSBfdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Rpdi5uZ2ItZHAtZGF5W3RhYmluZGV4PVwiMFwiXScpO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudFRvRm9jdXMpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRUb0ZvY3VzLmZvY3VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYXZpZ2F0ZXMgdG8gdGhlIHByb3ZpZGVkIGRhdGUuXHJcbiAgICAgKlxyXG4gICAgICogV2l0aCB0aGUgZGVmYXVsdCBjYWxlbmRhciB3ZSB1c2UgSVNPIDg2MDE6ICdtb250aCcgaXMgMT1KYW4gLi4uIDEyPURlYy5cclxuICAgICAqIElmIG5vdGhpbmcgb3IgaW52YWxpZCBkYXRlIHByb3ZpZGVkIGNhbGVuZGFyIHdpbGwgb3BlbiBjdXJyZW50IG1vbnRoLlxyXG4gICAgICpcclxuICAgICAqIFVzZSB0aGUgYFtzdGFydERhdGVdYCBpbnB1dCBhcyBhbiBhbHRlcm5hdGl2ZS5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYXZpZ2F0ZXMgdG8gdGhlIHByb3ZpZGVkIGRhdGUuXHJcbiAgICAgKlxyXG4gICAgICogV2l0aCB0aGUgZGVmYXVsdCBjYWxlbmRhciB3ZSB1c2UgSVNPIDg2MDE6ICdtb250aCcgaXMgMT1KYW4gLi4uIDEyPURlYy5cclxuICAgICAqIElmIG5vdGhpbmcgb3IgaW52YWxpZCBkYXRlIHByb3ZpZGVkIGNhbGVuZGFyIHdpbGwgb3BlbiBjdXJyZW50IG1vbnRoLlxyXG4gICAgICpcclxuICAgICAqIFVzZSB0aGUgYFtzdGFydERhdGVdYCBpbnB1dCBhcyBhbiBhbHRlcm5hdGl2ZS5cclxuICAgICAqIEBwYXJhbSB7Pz19IGRhdGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXIucHJvdG90eXBlLm5hdmlnYXRlVG8gPSAvKipcclxuICAgICAqIE5hdmlnYXRlcyB0byB0aGUgcHJvdmlkZWQgZGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBXaXRoIHRoZSBkZWZhdWx0IGNhbGVuZGFyIHdlIHVzZSBJU08gODYwMTogJ21vbnRoJyBpcyAxPUphbiAuLi4gMTI9RGVjLlxyXG4gICAgICogSWYgbm90aGluZyBvciBpbnZhbGlkIGRhdGUgcHJvdmlkZWQgY2FsZW5kYXIgd2lsbCBvcGVuIGN1cnJlbnQgbW9udGguXHJcbiAgICAgKlxyXG4gICAgICogVXNlIHRoZSBgW3N0YXJ0RGF0ZV1gIGlucHV0IGFzIGFuIGFsdGVybmF0aXZlLlxyXG4gICAgICogQHBhcmFtIHs/PX0gZGF0ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICB0aGlzLl9zZXJ2aWNlLm9wZW4oTmdiRGF0ZS5mcm9tKGRhdGUgPyBkYXRlLmRheSA/ICgvKiogQHR5cGUgez99ICovIChkYXRlKSkgOiB0c2xpYl8xLl9fYXNzaWduKHt9LCBkYXRlLCB7IGRheTogMSB9KSA6IG51bGwpKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICB2YXIgZm9jdXNJbnMkID0gZnJvbUV2ZW50KF90aGlzLl9jb250ZW50RWwubmF0aXZlRWxlbWVudCwgJ2ZvY3VzaW4nKTtcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICB2YXIgZm9jdXNPdXRzJCA9IGZyb21FdmVudChfdGhpcy5fY29udGVudEVsLm5hdGl2ZUVsZW1lbnQsICdmb2N1c291dCcpO1xyXG4gICAgICAgICAgICB2YXIgbmF0aXZlRWxlbWVudCA9IF90aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICAgICAgICAgIC8vIHdlJ3JlIGNoYW5naW5nICdmb2N1c1Zpc2libGUnIG9ubHkgd2hlbiBlbnRlcmluZyBvciBsZWF2aW5nIG1vbnRocyB2aWV3XHJcbiAgICAgICAgICAgIC8vIGFuZCBpZ25vcmluZyBhbGwgZm9jdXMgZXZlbnRzIHdoZXJlIGJvdGggJ3RhcmdldCcgYW5kICdyZWxhdGVkJyB0YXJnZXQgYXJlIGRheSBjZWxsc1xyXG4gICAgICAgICAgICBtZXJnZShmb2N1c0lucyQsIGZvY3VzT3V0cyQpXHJcbiAgICAgICAgICAgICAgICAucGlwZShmaWx0ZXIoKC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IF9fMFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gX2EudGFyZ2V0LCByZWxhdGVkVGFyZ2V0ID0gX2EucmVsYXRlZFRhcmdldDtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhKGhhc0NsYXNzTmFtZSh0YXJnZXQsICduZ2ItZHAtZGF5JykgJiYgaGFzQ2xhc3NOYW1lKHJlbGF0ZWRUYXJnZXQsICduZ2ItZHAtZGF5JykgJiZcclxuICAgICAgICAgICAgICAgICAgICBuYXRpdmVFbGVtZW50LmNvbnRhaW5zKCgvKiogQHR5cGUgez99ICovICh0YXJnZXQpKSkgJiYgbmF0aXZlRWxlbWVudC5jb250YWlucygoLyoqIEB0eXBlIHs/fSAqLyAocmVsYXRlZFRhcmdldCkpKSk7XHJcbiAgICAgICAgICAgIH0pKSwgdGFrZVVudGlsKF90aGlzLl9kZXN0cm95ZWQkKSlcclxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IF9fMFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX25nWm9uZS5ydW4oKC8qKlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3NlcnZpY2Uuc2V0KHsgZm9jdXNWaXNpYmxlOiB0eXBlID09PSAnZm9jdXNpbicgfSk7IH0pKTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7IHRoaXMuX2Rlc3Ryb3llZCQubmV4dCgpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyLnByb3RvdHlwZS5uZ09uSW5pdCA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMubW9kZWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgIHZhciBpbnB1dHNfMSA9IHt9O1xyXG4gICAgICAgICAgICBbJ2RheVRlbXBsYXRlRGF0YScsICdkaXNwbGF5TW9udGhzJywgJ21hcmtEaXNhYmxlZCcsICdmaXJzdERheU9mV2VlaycsICduYXZpZ2F0aW9uJywgJ21pbkRhdGUnLCAnbWF4RGF0ZScsXHJcbiAgICAgICAgICAgICAgICAnb3V0c2lkZURheXMnXVxyXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IG5hbWVcclxuICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBpbnB1dHNfMVtuYW1lXSA9IF90aGlzW25hbWVdOyB9KSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlcnZpY2Uuc2V0KGlucHV0c18xKTtcclxuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZVRvKHRoaXMuc3RhcnREYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmRheVRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5VGVtcGxhdGUgPSB0aGlzLl9kZWZhdWx0RGF5VGVtcGxhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIHZhciBpbnB1dHMgPSB7fTtcclxuICAgICAgICBbJ2RheVRlbXBsYXRlRGF0YScsICdkaXNwbGF5TW9udGhzJywgJ21hcmtEaXNhYmxlZCcsICdmaXJzdERheU9mV2VlaycsICduYXZpZ2F0aW9uJywgJ21pbkRhdGUnLCAnbWF4RGF0ZScsXHJcbiAgICAgICAgICAgICdvdXRzaWRlRGF5cyddXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5hbWUgaW4gY2hhbmdlczsgfSkpXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKCgvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IG5hbWVcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBpbnB1dHNbbmFtZV0gPSBfdGhpc1tuYW1lXTsgfSkpO1xyXG4gICAgICAgIHRoaXMuX3NlcnZpY2Uuc2V0KGlucHV0cyk7XHJcbiAgICAgICAgaWYgKCdzdGFydERhdGUnIGluIGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgdmFyIF9hID0gY2hhbmdlcy5zdGFydERhdGUsIGN1cnJlbnRWYWx1ZSA9IF9hLmN1cnJlbnRWYWx1ZSwgcHJldmlvdXNWYWx1ZSA9IF9hLnByZXZpb3VzVmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChpc0NoYW5nZWRNb250aChwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRlVG8odGhpcy5zdGFydERhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyLnByb3RvdHlwZS5vbkRhdGVTZWxlY3QgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZGF0ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICB0aGlzLl9zZXJ2aWNlLmZvY3VzKGRhdGUpO1xyXG4gICAgICAgIHRoaXMuX3NlcnZpY2Uuc2VsZWN0KGRhdGUsIHsgZW1pdEV2ZW50OiB0cnVlIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyLnByb3RvdHlwZS5vbk5hdmlnYXRlRGF0ZVNlbGVjdCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZGF0ZSkgeyB0aGlzLl9zZXJ2aWNlLm9wZW4oZGF0ZSk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXIucHJvdG90eXBlLm9uTmF2aWdhdGVFdmVudCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgc3dpdGNoIChldmVudCkge1xyXG4gICAgICAgICAgICBjYXNlIE5hdmlnYXRpb25FdmVudC5QUkVWOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VydmljZS5vcGVuKHRoaXMuX2NhbGVuZGFyLmdldFByZXYodGhpcy5tb2RlbC5maXJzdERhdGUsICdtJywgMSkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTmF2aWdhdGlvbkV2ZW50Lk5FWFQ6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXJ2aWNlLm9wZW4odGhpcy5fY2FsZW5kYXIuZ2V0TmV4dCh0aGlzLm1vZGVsLmZpcnN0RGF0ZSwgJ20nLCAxKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGZuXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGZuXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vbkNoYW5nZSA9IGZuOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGZuXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBmblxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZGlzYWJsZWRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXIucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZGlzYWJsZWRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChkaXNhYmxlZCkgeyB0aGlzLl9zZXJ2aWNlLnNldCh7IGRpc2FibGVkOiBkaXNhYmxlZCB9KTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdiRGF0ZXBpY2tlci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fY29udHJvbFZhbHVlID0gTmdiRGF0ZS5mcm9tKHRoaXMuX25nYkRhdGVBZGFwdGVyLmZyb21Nb2RlbCh2YWx1ZSkpO1xyXG4gICAgICAgIHRoaXMuX3NlcnZpY2Uuc2VsZWN0KHRoaXMuX2NvbnRyb2xWYWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgTmdiRGF0ZXBpY2tlci5kZWNvcmF0b3JzID0gW1xyXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbmdiRGF0ZXBpY2tlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduZ2ItZGF0ZXBpY2tlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5nLXRlbXBsYXRlICNkZWZhdWx0RGF5VGVtcGxhdGUgbGV0LWRhdGU9XFxcImRhdGVcXFwiIGxldC1jdXJyZW50TW9udGg9XFxcImN1cnJlbnRNb250aFxcXCIgbGV0LXNlbGVjdGVkPVxcXCJzZWxlY3RlZFxcXCIgbGV0LWRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCIgbGV0LWZvY3VzZWQ9XFxcImZvY3VzZWRcXFwiPlxcbiAgICAgIDxkaXYgbmdiRGF0ZXBpY2tlckRheVZpZXdcXG4gICAgICAgIFtkYXRlXT1cXFwiZGF0ZVxcXCJcXG4gICAgICAgIFtjdXJyZW50TW9udGhdPVxcXCJjdXJyZW50TW9udGhcXFwiXFxuICAgICAgICBbc2VsZWN0ZWRdPVxcXCJzZWxlY3RlZFxcXCJcXG4gICAgICAgIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIlxcbiAgICAgICAgW2ZvY3VzZWRdPVxcXCJmb2N1c2VkXFxcIj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9uZy10ZW1wbGF0ZT5cXG5cXG4gICAgPG5nLXRlbXBsYXRlICNkZWZhdWx0Q29udGVudFRlbXBsYXRlPlxcbiAgICAgIDxkaXYgKm5nRm9yPVxcXCJsZXQgbW9udGggb2YgbW9kZWwubW9udGhzOyBsZXQgaSA9IGluZGV4O1xcXCIgY2xhc3M9XFxcIm5nYi1kcC1tb250aFxcXCI+XFxuICAgICAgICA8ZGl2ICpuZ0lmPVxcXCJuYXZpZ2F0aW9uID09PSAnbm9uZScgfHwgKGRpc3BsYXlNb250aHMgPiAxICYmIG5hdmlnYXRpb24gPT09ICdzZWxlY3QnKVxcXCIgY2xhc3M9XFxcIm5nYi1kcC1tb250aC1uYW1lXFxcIj5cXG4gICAgICAgICAge3sgaTE4bi5nZXRNb250aEZ1bGxOYW1lKG1vbnRoLm51bWJlciwgbW9udGgueWVhcikgfX0ge3sgaTE4bi5nZXRZZWFyTnVtZXJhbHMobW9udGgueWVhcikgfX1cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPG5nYi1kYXRlcGlja2VyLW1vbnRoIFttb250aF09XFxcIm1vbnRoLmZpcnN0RGF0ZVxcXCI+PC9uZ2ItZGF0ZXBpY2tlci1tb250aD5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9uZy10ZW1wbGF0ZT5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwibmdiLWRwLWhlYWRlclxcXCI+XFxuICAgICAgPG5nYi1kYXRlcGlja2VyLW5hdmlnYXRpb24gKm5nSWY9XFxcIm5hdmlnYXRpb24gIT09ICdub25lJ1xcXCJcXG4gICAgICAgIFtkYXRlXT1cXFwibW9kZWwuZmlyc3REYXRlXFxcIlxcbiAgICAgICAgW21vbnRoc109XFxcIm1vZGVsLm1vbnRoc1xcXCJcXG4gICAgICAgIFtkaXNhYmxlZF09XFxcIm1vZGVsLmRpc2FibGVkXFxcIlxcbiAgICAgICAgW3Nob3dTZWxlY3RdPVxcXCJtb2RlbC5uYXZpZ2F0aW9uID09PSAnc2VsZWN0J1xcXCJcXG4gICAgICAgIFtwcmV2RGlzYWJsZWRdPVxcXCJtb2RlbC5wcmV2RGlzYWJsZWRcXFwiXFxuICAgICAgICBbbmV4dERpc2FibGVkXT1cXFwibW9kZWwubmV4dERpc2FibGVkXFxcIlxcbiAgICAgICAgW3NlbGVjdEJveGVzXT1cXFwibW9kZWwuc2VsZWN0Qm94ZXNcXFwiXFxuICAgICAgICAobmF2aWdhdGUpPVxcXCJvbk5hdmlnYXRlRXZlbnQoJGV2ZW50KVxcXCJcXG4gICAgICAgIChzZWxlY3QpPVxcXCJvbk5hdmlnYXRlRGF0ZVNlbGVjdCgkZXZlbnQpXFxcIj5cXG4gICAgICA8L25nYi1kYXRlcGlja2VyLW5hdmlnYXRpb24+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJuZ2ItZHAtY29udGVudFxcXCIgW2NsYXNzLm5nYi1kcC1tb250aHNdPVxcXCIhY29udGVudFRlbXBsYXRlXFxcIiAjY29udGVudD5cXG4gICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVxcXCJjb250ZW50VGVtcGxhdGU/LnRlbXBsYXRlUmVmIHx8IGRlZmF1bHRDb250ZW50VGVtcGxhdGVcXFwiPjwvbmctdGVtcGxhdGU+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVxcXCJmb290ZXJUZW1wbGF0ZVxcXCI+PC9uZy10ZW1wbGF0ZT5cXG4gIFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW05HQl9EQVRFUElDS0VSX1ZBTFVFX0FDQ0VTU09SLCBOZ2JEYXRlcGlja2VyU2VydmljZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBbXCJuZ2ItZGF0ZXBpY2tlcntib3JkZXI6MXB4IHNvbGlkICNkZmRmZGY7Ym9yZGVyLXJhZGl1czouMjVyZW07ZGlzcGxheTppbmxpbmUtYmxvY2t9bmdiLWRhdGVwaWNrZXItbW9udGh7cG9pbnRlci1ldmVudHM6YXV0b31uZ2ItZGF0ZXBpY2tlci5kcm9wZG93bi1tZW51e3BhZGRpbmc6MH0ubmdiLWRwLWJvZHl7ei1pbmRleDoxMDUwfS5uZ2ItZHAtaGVhZGVye2JvcmRlci1ib3R0b206MDtib3JkZXItcmFkaXVzOi4yNXJlbSAuMjVyZW0gMCAwO3BhZGRpbmctdG9wOi4yNXJlbTtiYWNrZ3JvdW5kLWNvbG9yOiNmOGY5ZmE7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1saWdodCl9Lm5nYi1kcC1tb250aHN7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXh9Lm5nYi1kcC1tb250aHtwb2ludGVyLWV2ZW50czpub25lfS5uZ2ItZHAtbW9udGgtbmFtZXtmb250LXNpemU6bGFyZ2VyO2hlaWdodDoycmVtO2xpbmUtaGVpZ2h0OjJyZW07dGV4dC1hbGlnbjpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjojZjhmOWZhO2JhY2tncm91bmQtY29sb3I6dmFyKC0tbGlnaHQpfS5uZ2ItZHAtbW9udGgrLm5nYi1kcC1tb250aCAubmdiLWRwLW1vbnRoLW5hbWUsLm5nYi1kcC1tb250aCsubmdiLWRwLW1vbnRoIC5uZ2ItZHAtd2Vla3twYWRkaW5nLWxlZnQ6MXJlbX0ubmdiLWRwLW1vbnRoOmxhc3QtY2hpbGQgLm5nYi1kcC13ZWVre3BhZGRpbmctcmlnaHQ6LjI1cmVtfS5uZ2ItZHAtbW9udGg6Zmlyc3QtY2hpbGQgLm5nYi1kcC13ZWVre3BhZGRpbmctbGVmdDouMjVyZW19Lm5nYi1kcC1tb250aCAubmdiLWRwLXdlZWs6bGFzdC1jaGlsZHtwYWRkaW5nLWJvdHRvbTouMjVyZW19XCJdXHJcbiAgICAgICAgICAgICAgICB9XSB9XHJcbiAgICBdO1xyXG4gICAgLyoqIEBub2NvbGxhcHNlICovXHJcbiAgICBOZ2JEYXRlcGlja2VyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgICAgIHsgdHlwZTogTmdiRGF0ZXBpY2tlclNlcnZpY2UgfSxcclxuICAgICAgICB7IHR5cGU6IE5nYkNhbGVuZGFyIH0sXHJcbiAgICAgICAgeyB0eXBlOiBOZ2JEYXRlcGlja2VySTE4biB9LFxyXG4gICAgICAgIHsgdHlwZTogTmdiRGF0ZXBpY2tlckNvbmZpZyB9LFxyXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcclxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcclxuICAgICAgICB7IHR5cGU6IE5nYkRhdGVBZGFwdGVyIH0sXHJcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxyXG4gICAgXTsgfTtcclxuICAgIE5nYkRhdGVwaWNrZXIucHJvcERlY29yYXRvcnMgPSB7XHJcbiAgICAgICAgX2RlZmF1bHREYXlUZW1wbGF0ZTogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ2RlZmF1bHREYXlUZW1wbGF0ZScsIHsgc3RhdGljOiB0cnVlIH0sXSB9XSxcclxuICAgICAgICBfY29udGVudEVsOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnY29udGVudCcsIHsgc3RhdGljOiB0cnVlIH0sXSB9XSxcclxuICAgICAgICBjb250ZW50VGVtcGxhdGU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW05nYkRhdGVwaWNrZXJDb250ZW50LCB7IHN0YXRpYzogdHJ1ZSB9LF0gfV0sXHJcbiAgICAgICAgZGF5VGVtcGxhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIGRheVRlbXBsYXRlRGF0YTogW3sgdHlwZTogSW5wdXQgfV0sXHJcbiAgICAgICAgZGlzcGxheU1vbnRoczogW3sgdHlwZTogSW5wdXQgfV0sXHJcbiAgICAgICAgZmlyc3REYXlPZldlZWs6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIGZvb3RlclRlbXBsYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcclxuICAgICAgICBtYXJrRGlzYWJsZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIG1heERhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIG1pbkRhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIG5hdmlnYXRpb246IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIG91dHNpZGVEYXlzOiBbeyB0eXBlOiBJbnB1dCB9XSxcclxuICAgICAgICBzaG93V2Vla2RheXM6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIHNob3dXZWVrTnVtYmVyczogW3sgdHlwZTogSW5wdXQgfV0sXHJcbiAgICAgICAgc3RhcnREYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcclxuICAgICAgICBuYXZpZ2F0ZTogW3sgdHlwZTogT3V0cHV0IH1dLFxyXG4gICAgICAgIGRhdGVTZWxlY3Q6IFt7IHR5cGU6IE91dHB1dCB9XSxcclxuICAgICAgICBzZWxlY3Q6IFt7IHR5cGU6IE91dHB1dCB9XVxyXG4gICAgfTtcclxuICAgIHJldHVybiBOZ2JEYXRlcGlja2VyO1xyXG59KCkpO1xyXG5leHBvcnQgeyBOZ2JEYXRlcGlja2VyIH07XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgTmdiRGF0ZXBpY2tlci5wcm90b3R5cGUubW9kZWw7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgTmdiRGF0ZXBpY2tlci5wcm90b3R5cGUuX2RlZmF1bHREYXlUZW1wbGF0ZTtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyLnByb3RvdHlwZS5fY29udGVudEVsO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgTmdiRGF0ZXBpY2tlci5wcm90b3R5cGUuY29udGVudFRlbXBsYXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXIucHJvdG90eXBlLl9jb250cm9sVmFsdWU7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgTmdiRGF0ZXBpY2tlci5wcm90b3R5cGUuX2Rlc3Ryb3llZCQ7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgTmdiRGF0ZXBpY2tlci5wcm90b3R5cGUuX3B1YmxpY1N0YXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVmZXJlbmNlIHRvIGEgY3VzdG9tIHRlbXBsYXRlIGZvciB0aGUgZGF5LlxyXG4gICAgICpcclxuICAgICAqIEFsbG93cyB0byBjb21wbGV0ZWx5IG92ZXJyaWRlIHRoZSB3YXkgYSBkYXkgJ2NlbGwnIGluIHRoZSBjYWxlbmRhciBpcyBkaXNwbGF5ZWQuXHJcbiAgICAgKlxyXG4gICAgICogU2VlIFtgRGF5VGVtcGxhdGVDb250ZXh0YF0oIy9jb21wb25lbnRzL2RhdGVwaWNrZXIvYXBpI0RheVRlbXBsYXRlQ29udGV4dCkgZm9yIHRoZSBkYXRhIHlvdSBnZXQgaW5zaWRlLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXIucHJvdG90eXBlLmRheVRlbXBsYXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2FsbGJhY2sgdG8gcGFzcyBhbnkgYXJiaXRyYXJ5IGRhdGEgdG8gdGhlIHRlbXBsYXRlIGNlbGwgdmlhIHRoZVxyXG4gICAgICogW2BEYXlUZW1wbGF0ZUNvbnRleHRgXSgjL2NvbXBvbmVudHMvZGF0ZXBpY2tlci9hcGkjRGF5VGVtcGxhdGVDb250ZXh0KSdzIGBkYXRhYCBwYXJhbWV0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogYGN1cnJlbnRgIGlzIHRoZSBtb250aCB0aGF0IGlzIGN1cnJlbnRseSBkaXNwbGF5ZWQgYnkgdGhlIGRhdGVwaWNrZXIuXHJcbiAgICAgKlxyXG4gICAgICogXFxAc2luY2UgMy4zLjBcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyLnByb3RvdHlwZS5kYXlUZW1wbGF0ZURhdGE7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgbW9udGhzIHRvIGRpc3BsYXkuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiRGF0ZXBpY2tlci5wcm90b3R5cGUuZGlzcGxheU1vbnRocztcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAqXHJcbiAgICAgKiBXaXRoIGRlZmF1bHQgY2FsZW5kYXIgd2UgdXNlIElTTyA4NjAxOiAnd2Vla2RheScgaXMgMT1Nb24gLi4uIDc9U3VuLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXIucHJvdG90eXBlLmZpcnN0RGF5T2ZXZWVrO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVmZXJlbmNlIHRvIHRoZSBjdXN0b20gdGVtcGxhdGUgZm9yIHRoZSBkYXRlcGlja2VyIGZvb3Rlci5cclxuICAgICAqXHJcbiAgICAgKiBcXEBzaW5jZSAzLjMuMFxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXIucHJvdG90eXBlLmZvb3RlclRlbXBsYXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2FsbGJhY2sgdG8gbWFyayBzb21lIGRhdGVzIGFzIGRpc2FibGVkLlxyXG4gICAgICpcclxuICAgICAqIEl0IGlzIGNhbGxlZCBmb3IgZWFjaCBuZXcgZGF0ZSB3aGVuIG5hdmlnYXRpbmcgdG8gYSBkaWZmZXJlbnQgbW9udGguXHJcbiAgICAgKlxyXG4gICAgICogYGN1cnJlbnRgIGlzIHRoZSBtb250aCB0aGF0IGlzIGN1cnJlbnRseSBkaXNwbGF5ZWQgYnkgdGhlIGRhdGVwaWNrZXIuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiRGF0ZXBpY2tlci5wcm90b3R5cGUubWFya0Rpc2FibGVkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGF0ZXN0IGRhdGUgdGhhdCBjYW4gYmUgZGlzcGxheWVkIG9yIHNlbGVjdGVkLlxyXG4gICAgICpcclxuICAgICAqIElmIG5vdCBwcm92aWRlZCwgJ3llYXInIHNlbGVjdCBib3ggd2lsbCBkaXNwbGF5IDEwIHllYXJzIGFmdGVyIHRoZSBjdXJyZW50IG1vbnRoLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXIucHJvdG90eXBlLm1heERhdGU7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBlYXJsaWVzdCBkYXRlIHRoYXQgY2FuIGJlIGRpc3BsYXllZCBvciBzZWxlY3RlZC5cclxuICAgICAqXHJcbiAgICAgKiBJZiBub3QgcHJvdmlkZWQsICd5ZWFyJyBzZWxlY3QgYm94IHdpbGwgZGlzcGxheSAxMCB5ZWFycyBiZWZvcmUgdGhlIGN1cnJlbnQgbW9udGguXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiRGF0ZXBpY2tlci5wcm90b3R5cGUubWluRGF0ZTtcclxuICAgIC8qKlxyXG4gICAgICogTmF2aWdhdGlvbiB0eXBlLlxyXG4gICAgICpcclxuICAgICAqICogYFwic2VsZWN0XCJgIC0gc2VsZWN0IGJveGVzIGZvciBtb250aCBhbmQgbmF2aWdhdGlvbiBhcnJvd3NcclxuICAgICAqICogYFwiYXJyb3dzXCJgIC0gb25seSBuYXZpZ2F0aW9uIGFycm93c1xyXG4gICAgICogKiBgXCJub25lXCJgIC0gbm8gbmF2aWdhdGlvbiB2aXNpYmxlIGF0IGFsbFxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXIucHJvdG90eXBlLm5hdmlnYXRpb247XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB3YXkgb2YgZGlzcGxheWluZyBkYXlzIHRoYXQgZG9uJ3QgYmVsb25nIHRvIHRoZSBjdXJyZW50IG1vbnRoLlxyXG4gICAgICpcclxuICAgICAqICogYFwidmlzaWJsZVwiYCAtIGRheXMgYXJlIHZpc2libGVcclxuICAgICAqICogYFwiaGlkZGVuXCJgIC0gZGF5cyBhcmUgaGlkZGVuLCB3aGl0ZSBzcGFjZSBwcmVzZXJ2ZWRcclxuICAgICAqICogYFwiY29sbGFwc2VkXCJgIC0gZGF5cyBhcmUgY29sbGFwc2VkLCBzbyB0aGUgZGF0ZXBpY2tlciBoZWlnaHQgbWlnaHQgY2hhbmdlIGJldHdlZW4gbW9udGhzXHJcbiAgICAgKlxyXG4gICAgICogRm9yIHRoZSAyKyBtb250aHMgdmlldywgZGF5cyBpbiBiZXR3ZWVuIG1vbnRocyBhcmUgbmV2ZXIgc2hvd24uXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiRGF0ZXBpY2tlci5wcm90b3R5cGUub3V0c2lkZURheXM7XHJcbiAgICAvKipcclxuICAgICAqIElmIGB0cnVlYCwgd2Vla2RheXMgd2lsbCBiZSBkaXNwbGF5ZWQuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiRGF0ZXBpY2tlci5wcm90b3R5cGUuc2hvd1dlZWtkYXlzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBgdHJ1ZWAsIHdlZWsgbnVtYmVycyB3aWxsIGJlIGRpc3BsYXllZC5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyLnByb3RvdHlwZS5zaG93V2Vla051bWJlcnM7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkYXRlIHRvIG9wZW4gY2FsZW5kYXIgd2l0aC5cclxuICAgICAqXHJcbiAgICAgKiBXaXRoIHRoZSBkZWZhdWx0IGNhbGVuZGFyIHdlIHVzZSBJU08gODYwMTogJ21vbnRoJyBpcyAxPUphbiAuLi4gMTI9RGVjLlxyXG4gICAgICogSWYgbm90aGluZyBvciBpbnZhbGlkIGRhdGUgaXMgcHJvdmlkZWQsIGNhbGVuZGFyIHdpbGwgb3BlbiB3aXRoIGN1cnJlbnQgbW9udGguXHJcbiAgICAgKlxyXG4gICAgICogWW91IGNvdWxkIHVzZSBgbmF2aWdhdGVUbyhkYXRlKWAgbWV0aG9kIGFzIGFuIGFsdGVybmF0aXZlLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXIucHJvdG90eXBlLnN0YXJ0RGF0ZTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gZXZlbnQgZW1pdHRlZCByaWdodCBiZWZvcmUgdGhlIG5hdmlnYXRpb24gaGFwcGVucyBhbmQgZGlzcGxheWVkIG1vbnRoIGNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogU2VlIFtgTmdiRGF0ZXBpY2tlck5hdmlnYXRlRXZlbnRgXSgjL2NvbXBvbmVudHMvZGF0ZXBpY2tlci9hcGkjTmdiRGF0ZXBpY2tlck5hdmlnYXRlRXZlbnQpIGZvciB0aGUgcGF5bG9hZCBpbmZvLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXIucHJvdG90eXBlLm5hdmlnYXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBldmVudCBlbWl0dGVkIHdoZW4gdXNlciBzZWxlY3RzIGEgZGF0ZSB1c2luZyBrZXlib2FyZCBvciBtb3VzZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgcGF5bG9hZCBvZiB0aGUgZXZlbnQgaXMgY3VycmVudGx5IHNlbGVjdGVkIGBOZ2JEYXRlYC5cclxuICAgICAqXHJcbiAgICAgKiBcXEBzaW5jZSA1LjIuMFxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXIucHJvdG90eXBlLmRhdGVTZWxlY3Q7XHJcbiAgICAvKipcclxuICAgICAqIEFuIGV2ZW50IGVtaXR0ZWQgd2hlbiB1c2VyIHNlbGVjdHMgYSBkYXRlIHVzaW5nIGtleWJvYXJkIG9yIG1vdXNlLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBwYXlsb2FkIG9mIHRoZSBldmVudCBpcyBjdXJyZW50bHkgc2VsZWN0ZWQgYE5nYkRhdGVgLlxyXG4gICAgICpcclxuICAgICAqIFBsZWFzZSB1c2UgJ2RhdGVTZWxlY3QnIG91dHB1dCBpbnN0ZWFkLCB0aGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB2ZXJzaW9uIDYuMCBkdWUgdG8gY29sbGlzaW9uIHdpdGggbmF0aXZlXHJcbiAgICAgKiAnc2VsZWN0JyBldmVudC5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyLnByb3RvdHlwZS5zZWxlY3Q7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JEYXRlcGlja2VyLnByb3RvdHlwZS5vbkNoYW5nZTtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE5nYkRhdGVwaWNrZXIucHJvdG90eXBlLm9uVG91Y2hlZDtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyLnByb3RvdHlwZS5fc2VydmljZTtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyLnByb3RvdHlwZS5fY2FsZW5kYXI7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ2JEYXRlcGlja2VyLnByb3RvdHlwZS5pMThuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXIucHJvdG90eXBlLl9lbGVtZW50UmVmO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIE5nYkRhdGVwaWNrZXIucHJvdG90eXBlLl9uZ2JEYXRlQWRhcHRlcjtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBOZ2JEYXRlcGlja2VyLnByb3RvdHlwZS5fbmdab25lO1xyXG59XHIiXX0=