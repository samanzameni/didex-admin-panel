/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, Component, Input, ViewEncapsulation } from '@angular/core';
import { getValueInRange, isNumber } from '../util/util';
import { NgbProgressbarConfig } from './progressbar-config';
/**
 * A directive that provides feedback on the progress of a workflow or an action.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = [1, "progress"];
const _c1 = ["role", "progressbar", "aria-valuemin", "0"];
const _c2 = [4, "ngIf"];
var I18N_3;
if (ngI18nClosureMode) {
    const MSG_EXTERNAL_ngb_progressbar_value$$ESM5_PROGRESSBAR_PROGRESSBAR_JS__4 = goog.getMsg("{$interpolation}%", { "interpolation": "\uFFFD0\uFFFD" });
    I18N_3 = MSG_EXTERNAL_ngb_progressbar_value$$ESM5_PROGRESSBAR_PROGRESSBAR_JS__4;
}
else {
    I18N_3 = ɵngcc0.ɵɵi18nLocalize("{$interpolation}%", { "interpolation": "\uFFFD0\uFFFD" });
}
function NgbProgressbar_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵi18n(1, I18N_3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r758 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵi18nExp(ctx_r758.getPercentValue());
    ɵngcc0.ɵɵi18nApply(1);
} }
const _c5 = ["*"];
var NgbProgressbar = /** @class */ (function () {
    function NgbProgressbar(config) {
        /**
         * The current value for the progress bar.
         *
         * Should be in the `[0, max]` range.
         */
        this.value = 0;
        this.max = config.max;
        this.animated = config.animated;
        this.striped = config.striped;
        this.textType = config.textType;
        this.type = config.type;
        this.showValue = config.showValue;
        this.height = config.height;
    }
    Object.defineProperty(NgbProgressbar.prototype, "max", {
        get: /**
         * @return {?}
         */
        function () { return this._max; },
        /**
         * The maximal value to be displayed in the progress bar.
         *
         * Should be a positive number. Will default to 100 otherwise.
         */
        set: /**
         * The maximal value to be displayed in the progress bar.
         *
         * Should be a positive number. Will default to 100 otherwise.
         * @param {?} max
         * @return {?}
         */
        function (max) {
            this._max = !isNumber(max) || max <= 0 ? 100 : max;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NgbProgressbar.prototype.getValue = /**
     * @return {?}
     */
    function () { return getValueInRange(this.value, this.max); };
    /**
     * @return {?}
     */
    NgbProgressbar.prototype.getPercentValue = /**
     * @return {?}
     */
    function () { return 100 * this.getValue() / this.max; };
    /** @nocollapse */
    NgbProgressbar.ctorParameters = function () { return [
        { type: NgbProgressbarConfig }
    ]; };
    NgbProgressbar.propDecorators = {
        max: [{ type: Input }],
        animated: [{ type: Input }],
        striped: [{ type: Input }],
        showValue: [{ type: Input }],
        textType: [{ type: Input }],
        type: [{ type: Input }],
        value: [{ type: Input }],
        height: [{ type: Input }]
    };
NgbProgressbar.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: NgbProgressbar, selectors: [["ngb-progressbar"]], factory: function NgbProgressbar_Factory(t) { return new (t || NgbProgressbar)(ɵngcc0.ɵɵdirectiveInject(NgbProgressbarConfig)); }, inputs: { value: "value", max: "max", animated: "animated", striped: "striped", textType: "textType", type: "type", showValue: "showValue", height: "height" }, ngContentSelectors: _c5, consts: 4, vars: 10, template: function NgbProgressbar_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", _c0);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵelementStart(1, "div", _c1);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵtemplate(2, NgbProgressbar_span_2_Template, 2, 1, "span", _c2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("height", ctx.height);
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵselect(1);
        ɵngcc0.ɵɵclassMapInterpolate4("progress-bar", ctx.type ? " bg-" + ctx.type : "", "", ctx.textType ? " text-" + ctx.textType : "", "\n      ", ctx.animated ? " progress-bar-animated" : "", "", ctx.striped ? " progress-bar-striped" : "", "");
        ɵngcc0.ɵɵstyleProp("width", ctx.getPercentValue(), "%");
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵattribute("aria-valuenow", ctx.getValue())("aria-valuemax", ctx.max);
        ɵngcc0.ɵɵselect(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showValue);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbProgressbar, [{
        type: Component,
        args: [{
                selector: 'ngb-progressbar',
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                template: "\n    <div class=\"progress\" [style.height]=\"height\">\n      <div class=\"progress-bar{{type ? ' bg-' + type : ''}}{{textType ? ' text-' + textType : ''}}\n      {{animated ? ' progress-bar-animated' : ''}}{{striped ? ' progress-bar-striped' : ''}}\" role=\"progressbar\" [style.width.%]=\"getPercentValue()\"\n      [attr.aria-valuenow]=\"getValue()\" aria-valuemin=\"0\" [attr.aria-valuemax]=\"max\">\n        <span *ngIf=\"showValue\" i18n=\"@@ngb.progressbar.value\">{{getPercentValue()}}%</span><ng-content></ng-content>\n      </div>\n    </div>\n  "
            }]
    }], function () { return [{ type: NgbProgressbarConfig }]; }, { value: [{
            type: Input
        }], max: [{
            type: Input
        }], animated: [{
            type: Input
        }], striped: [{
            type: Input
        }], textType: [{
            type: Input
        }], type: [{
            type: Input
        }], showValue: [{
            type: Input
        }], height: [{
            type: Input
        }], getValue: [], getPercentValue: [] });
    return NgbProgressbar;
}());
export { NgbProgressbar };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgbProgressbar.prototype._max;
    /**
     * If `true`, the stripes on the progress bar are animated.
     *
     * Takes effect only for browsers supporting CSS3 animations, and if `striped` is `true`.
     * @type {?}
     */
    NgbProgressbar.prototype.animated;
    /**
     * If `true`, the progress bars will be displayed as striped.
     * @type {?}
     */
    NgbProgressbar.prototype.striped;
    /**
     * If `true`, the current percentage will be shown in the `xx%` format.
     * @type {?}
     */
    NgbProgressbar.prototype.showValue;
    /**
     * Optional text variant type of the progress bar.
     *
     * Supports types based on Bootstrap background color variants, like:
     *  `"success"`, `"info"`, `"warning"`, `"danger"`, `"primary"`, `"secondary"`, `"dark"` and so on.
     *
     * \@since 5.2.0
     * @type {?}
     */
    NgbProgressbar.prototype.textType;
    /**
     * The type of the progress bar.
     *
     * Supports types based on Bootstrap background color variants, like:
     *  `"success"`, `"info"`, `"warning"`, `"danger"`, `"primary"`, `"secondary"`, `"dark"` and so on.
     * @type {?}
     */
    NgbProgressbar.prototype.type;
    /**
     * The current value for the progress bar.
     *
     * Should be in the `[0, max]` range.
     * @type {?}
     */
    NgbProgressbar.prototype.value;
    /**
     * The height of the progress bar.
     *
     * Accepts any valid CSS height values, ex. `"2rem"`
     * @type {?}
     */
    NgbProgressbar.prototype.height;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQG5nLWJvb3RzdHJhcC9uZy1ib290c3RyYXAvZXNtNS9wcm9ncmVzc2Jhci9wcm9ncmVzc2Jhci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFVQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2REFvRDZELEFBUXZEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aURBY0EiLCJmaWxlIjoicHJvZ3Jlc3NiYXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbmltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIElucHV0LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBnZXRWYWx1ZUluUmFuZ2UsIGlzTnVtYmVyIH0gZnJvbSAnLi4vdXRpbC91dGlsJztcclxuaW1wb3J0IHsgTmdiUHJvZ3Jlc3NiYXJDb25maWcgfSBmcm9tICcuL3Byb2dyZXNzYmFyLWNvbmZpZyc7XHJcbi8qKlxyXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IHByb3ZpZGVzIGZlZWRiYWNrIG9uIHRoZSBwcm9ncmVzcyBvZiBhIHdvcmtmbG93IG9yIGFuIGFjdGlvbi5cclxuICovXHJcbnZhciBOZ2JQcm9ncmVzc2JhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5nYlByb2dyZXNzYmFyKGNvbmZpZykge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjdXJyZW50IHZhbHVlIGZvciB0aGUgcHJvZ3Jlc3MgYmFyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogU2hvdWxkIGJlIGluIHRoZSBgWzAsIG1heF1gIHJhbmdlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSAwO1xyXG4gICAgICAgIHRoaXMubWF4ID0gY29uZmlnLm1heDtcclxuICAgICAgICB0aGlzLmFuaW1hdGVkID0gY29uZmlnLmFuaW1hdGVkO1xyXG4gICAgICAgIHRoaXMuc3RyaXBlZCA9IGNvbmZpZy5zdHJpcGVkO1xyXG4gICAgICAgIHRoaXMudGV4dFR5cGUgPSBjb25maWcudGV4dFR5cGU7XHJcbiAgICAgICAgdGhpcy50eXBlID0gY29uZmlnLnR5cGU7XHJcbiAgICAgICAgdGhpcy5zaG93VmFsdWUgPSBjb25maWcuc2hvd1ZhbHVlO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gY29uZmlnLmhlaWdodDtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ2JQcm9ncmVzc2Jhci5wcm90b3R5cGUsIFwibWF4XCIsIHtcclxuICAgICAgICBnZXQ6IC8qKlxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWF4OyB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtYXhpbWFsIHZhbHVlIHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgcHJvZ3Jlc3MgYmFyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogU2hvdWxkIGJlIGEgcG9zaXRpdmUgbnVtYmVyLiBXaWxsIGRlZmF1bHQgdG8gMTAwIG90aGVyd2lzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXQ6IC8qKlxyXG4gICAgICAgICAqIFRoZSBtYXhpbWFsIHZhbHVlIHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgcHJvZ3Jlc3MgYmFyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogU2hvdWxkIGJlIGEgcG9zaXRpdmUgbnVtYmVyLiBXaWxsIGRlZmF1bHQgdG8gMTAwIG90aGVyd2lzZS5cclxuICAgICAgICAgKiBAcGFyYW0gez99IG1heFxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKG1heCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXggPSAhaXNOdW1iZXIobWF4KSB8fCBtYXggPD0gMCA/IDEwMCA6IG1heDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdiUHJvZ3Jlc3NiYXIucHJvdG90eXBlLmdldFZhbHVlID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRWYWx1ZUluUmFuZ2UodGhpcy52YWx1ZSwgdGhpcy5tYXgpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JQcm9ncmVzc2Jhci5wcm90b3R5cGUuZ2V0UGVyY2VudFZhbHVlID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiAxMDAgKiB0aGlzLmdldFZhbHVlKCkgLyB0aGlzLm1heDsgfTtcclxuICAgIE5nYlByb2dyZXNzYmFyLmRlY29yYXRvcnMgPSBbXHJcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduZ2ItcHJvZ3Jlc3NiYXInLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxkaXYgY2xhc3M9XFxcInByb2dyZXNzXFxcIiBbc3R5bGUuaGVpZ2h0XT1cXFwiaGVpZ2h0XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJwcm9ncmVzcy1iYXJ7e3R5cGUgPyAnIGJnLScgKyB0eXBlIDogJyd9fXt7dGV4dFR5cGUgPyAnIHRleHQtJyArIHRleHRUeXBlIDogJyd9fVxcbiAgICAgIHt7YW5pbWF0ZWQgPyAnIHByb2dyZXNzLWJhci1hbmltYXRlZCcgOiAnJ319e3tzdHJpcGVkID8gJyBwcm9ncmVzcy1iYXItc3RyaXBlZCcgOiAnJ319XFxcIiByb2xlPVxcXCJwcm9ncmVzc2JhclxcXCIgW3N0eWxlLndpZHRoLiVdPVxcXCJnZXRQZXJjZW50VmFsdWUoKVxcXCJcXG4gICAgICBbYXR0ci5hcmlhLXZhbHVlbm93XT1cXFwiZ2V0VmFsdWUoKVxcXCIgYXJpYS12YWx1ZW1pbj1cXFwiMFxcXCIgW2F0dHIuYXJpYS12YWx1ZW1heF09XFxcIm1heFxcXCI+XFxuICAgICAgICA8c3BhbiAqbmdJZj1cXFwic2hvd1ZhbHVlXFxcIiBpMThuPVxcXCJAQG5nYi5wcm9ncmVzc2Jhci52YWx1ZVxcXCI+e3tnZXRQZXJjZW50VmFsdWUoKX19JTwvc3Bhbj48bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgXCJcclxuICAgICAgICAgICAgICAgIH1dIH1cclxuICAgIF07XHJcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cclxuICAgIE5nYlByb2dyZXNzYmFyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgICAgIHsgdHlwZTogTmdiUHJvZ3Jlc3NiYXJDb25maWcgfVxyXG4gICAgXTsgfTtcclxuICAgIE5nYlByb2dyZXNzYmFyLnByb3BEZWNvcmF0b3JzID0ge1xyXG4gICAgICAgIG1heDogW3sgdHlwZTogSW5wdXQgfV0sXHJcbiAgICAgICAgYW5pbWF0ZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIHN0cmlwZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIHNob3dWYWx1ZTogW3sgdHlwZTogSW5wdXQgfV0sXHJcbiAgICAgICAgdGV4dFR5cGU6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIHR5cGU6IFt7IHR5cGU6IElucHV0IH1dLFxyXG4gICAgICAgIHZhbHVlOiBbeyB0eXBlOiBJbnB1dCB9XSxcclxuICAgICAgICBoZWlnaHQ6IFt7IHR5cGU6IElucHV0IH1dXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5nYlByb2dyZXNzYmFyO1xyXG59KCkpO1xyXG5leHBvcnQgeyBOZ2JQcm9ncmVzc2JhciB9O1xyXG5pZiAoZmFsc2UpIHtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBOZ2JQcm9ncmVzc2Jhci5wcm90b3R5cGUuX21heDtcclxuICAgIC8qKlxyXG4gICAgICogSWYgYHRydWVgLCB0aGUgc3RyaXBlcyBvbiB0aGUgcHJvZ3Jlc3MgYmFyIGFyZSBhbmltYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBUYWtlcyBlZmZlY3Qgb25seSBmb3IgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MzIGFuaW1hdGlvbnMsIGFuZCBpZiBgc3RyaXBlZGAgaXMgYHRydWVgLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYlByb2dyZXNzYmFyLnByb3RvdHlwZS5hbmltYXRlZDtcclxuICAgIC8qKlxyXG4gICAgICogSWYgYHRydWVgLCB0aGUgcHJvZ3Jlc3MgYmFycyB3aWxsIGJlIGRpc3BsYXllZCBhcyBzdHJpcGVkLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYlByb2dyZXNzYmFyLnByb3RvdHlwZS5zdHJpcGVkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBjdXJyZW50IHBlcmNlbnRhZ2Ugd2lsbCBiZSBzaG93biBpbiB0aGUgYHh4JWAgZm9ybWF0LlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYlByb2dyZXNzYmFyLnByb3RvdHlwZS5zaG93VmFsdWU7XHJcbiAgICAvKipcclxuICAgICAqIE9wdGlvbmFsIHRleHQgdmFyaWFudCB0eXBlIG9mIHRoZSBwcm9ncmVzcyBiYXIuXHJcbiAgICAgKlxyXG4gICAgICogU3VwcG9ydHMgdHlwZXMgYmFzZWQgb24gQm9vdHN0cmFwIGJhY2tncm91bmQgY29sb3IgdmFyaWFudHMsIGxpa2U6XHJcbiAgICAgKiAgYFwic3VjY2Vzc1wiYCwgYFwiaW5mb1wiYCwgYFwid2FybmluZ1wiYCwgYFwiZGFuZ2VyXCJgLCBgXCJwcmltYXJ5XCJgLCBgXCJzZWNvbmRhcnlcImAsIGBcImRhcmtcImAgYW5kIHNvIG9uLlxyXG4gICAgICpcclxuICAgICAqIFxcQHNpbmNlIDUuMi4wXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdiUHJvZ3Jlc3NiYXIucHJvdG90eXBlLnRleHRUeXBlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgcHJvZ3Jlc3MgYmFyLlxyXG4gICAgICpcclxuICAgICAqIFN1cHBvcnRzIHR5cGVzIGJhc2VkIG9uIEJvb3RzdHJhcCBiYWNrZ3JvdW5kIGNvbG9yIHZhcmlhbnRzLCBsaWtlOlxyXG4gICAgICogIGBcInN1Y2Nlc3NcImAsIGBcImluZm9cImAsIGBcIndhcm5pbmdcImAsIGBcImRhbmdlclwiYCwgYFwicHJpbWFyeVwiYCwgYFwic2Vjb25kYXJ5XCJgLCBgXCJkYXJrXCJgIGFuZCBzbyBvbi5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ2JQcm9ncmVzc2Jhci5wcm90b3R5cGUudHlwZTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgdmFsdWUgZm9yIHRoZSBwcm9ncmVzcyBiYXIuXHJcbiAgICAgKlxyXG4gICAgICogU2hvdWxkIGJlIGluIHRoZSBgWzAsIG1heF1gIHJhbmdlLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYlByb2dyZXNzYmFyLnByb3RvdHlwZS52YWx1ZTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgcHJvZ3Jlc3MgYmFyLlxyXG4gICAgICpcclxuICAgICAqIEFjY2VwdHMgYW55IHZhbGlkIENTUyBoZWlnaHQgdmFsdWVzLCBleC4gYFwiMnJlbVwiYFxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nYlByb2dyZXNzYmFyLnByb3RvdHlwZS5oZWlnaHQ7XHJcbn1cciJdfQ==