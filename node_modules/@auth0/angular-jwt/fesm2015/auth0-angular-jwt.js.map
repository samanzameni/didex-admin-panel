{"version":3,"sources":["d:/Angular Project/Didex/didex-admin-panel/node_modules/@auth0/angular-jwt/fesm2015/auth0-angular-jwt.js"],"names":[],"mappings":"AAAA;;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uLA+FC;;;;+BAI8B,AACd;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0TAuEhB;;;;;6BAK4B,AACZ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+JA8BhB;;;;sCAIqC,AACvB","file":"auth0-angular-jwt.js","sourcesContent":["import { __decorate, __param, __metadata } from 'tslib';\r\nimport { InjectionToken, Inject, Injectable, Optional, SkipSelf, NgModule } from '@angular/core';\r\nimport { mergeMap } from 'rxjs/operators';\r\nimport { parse } from 'url';\r\nimport { from } from 'rxjs';\r\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\r\n\r\nconst JWT_OPTIONS = new InjectionToken('JWT_OPTIONS');\r\n\r\n// tslint:disable:no-bitwise\r\nlet JwtHelperService = class JwtHelperService {\r\n    constructor(config = null) {\r\n        this.tokenGetter = config && config.tokenGetter || function () { };\r\n    }\r\n    urlBase64Decode(str) {\r\n        let output = str.replace(/-/g, '+').replace(/_/g, '/');\r\n        switch (output.length % 4) {\r\n            case 0: {\r\n                break;\r\n            }\r\n            case 2: {\r\n                output += '==';\r\n                break;\r\n            }\r\n            case 3: {\r\n                output += '=';\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error('Illegal base64url string!');\r\n            }\r\n        }\r\n        return this.b64DecodeUnicode(output);\r\n    }\r\n    // credits for decoder goes to https://github.com/atk\r\n    b64decode(str) {\r\n        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r\n        let output = '';\r\n        str = String(str).replace(/=+$/, '');\r\n        if (str.length % 4 === 1) {\r\n            throw new Error('\\'atob\\' failed: The string to be decoded is not correctly encoded.');\r\n        }\r\n        for (\r\n        // initialize result and counters\r\n        let bc = 0, bs, buffer, idx = 0; \r\n        // get next character\r\n        (buffer = str.charAt(idx++)); \r\n        // character found in table? initialize bit storage and add its ascii value;\r\n        ~buffer &&\r\n            ((bs = bc % 4 ? bs * 64 + buffer : buffer),\r\n                // and if not first of each 4 characters,\r\n                // convert the first 8 bits to one ascii character\r\n                bc++ % 4)\r\n            ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\r\n            : 0) {\r\n            // try to find character in table (0-63, not found => -1)\r\n            buffer = chars.indexOf(buffer);\r\n        }\r\n        return output;\r\n    }\r\n    b64DecodeUnicode(str) {\r\n        return decodeURIComponent(Array.prototype.map\r\n            .call(this.b64decode(str), (c) => {\r\n            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\r\n        })\r\n            .join(''));\r\n    }\r\n    decodeToken(token = this.tokenGetter()) {\r\n        if (!token || token === '') {\r\n            return null;\r\n        }\r\n        const parts = token.split('.');\r\n        if (parts.length !== 3) {\r\n            throw new Error('The inspected token doesn\\'t appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.');\r\n        }\r\n        const decoded = this.urlBase64Decode(parts[1]);\r\n        if (!decoded) {\r\n            throw new Error('Cannot decode the token.');\r\n        }\r\n        return JSON.parse(decoded);\r\n    }\r\n    getTokenExpirationDate(token = this.tokenGetter()) {\r\n        let decoded;\r\n        decoded = this.decodeToken(token);\r\n        if (!decoded || !decoded.hasOwnProperty('exp')) {\r\n            return null;\r\n        }\r\n        const date = new Date(0);\r\n        date.setUTCSeconds(decoded.exp);\r\n        return date;\r\n    }\r\n    isTokenExpired(token = this.tokenGetter(), offsetSeconds) {\r\n        if (!token || token === '') {\r\n            return true;\r\n        }\r\n        const date = this.getTokenExpirationDate(token);\r\n        offsetSeconds = offsetSeconds || 0;\r\n        if (date === null) {\r\n            return false;\r\n        }\r\n        return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\r\n    }\r\n};\r\nJwtHelperService.ctorParameters = () => [\r\n    { type: undefined, decorators: [{ type: Inject, args: [JWT_OPTIONS,] }] }\r\n];\r\nJwtHelperService = __decorate([\r\n    Injectable(),\r\n    __param(0, Inject(JWT_OPTIONS)),\r\n    __metadata(\"design:paramtypes\", [Object])\r\n], JwtHelperService);\r\n\r\nlet JwtInterceptor = class JwtInterceptor {\r\n    constructor(config, jwtHelper) {\r\n        this.jwtHelper = jwtHelper;\r\n        this.tokenGetter = config.tokenGetter;\r\n        this.headerName = config.headerName || 'Authorization';\r\n        this.authScheme =\r\n            config.authScheme || config.authScheme === ''\r\n                ? config.authScheme\r\n                : 'Bearer ';\r\n        this.whitelistedDomains = config.whitelistedDomains || [];\r\n        this.blacklistedRoutes = config.blacklistedRoutes || [];\r\n        this.throwNoTokenError = config.throwNoTokenError || false;\r\n        this.skipWhenExpired = config.skipWhenExpired;\r\n    }\r\n    isWhitelistedDomain(request) {\r\n        const requestUrl = parse(request.url, false, true);\r\n        return (requestUrl.host === null ||\r\n            this.whitelistedDomains.findIndex(domain => typeof domain === 'string'\r\n                ? domain === requestUrl.host\r\n                : domain instanceof RegExp\r\n                    ? domain.test(requestUrl.host)\r\n                    : false) > -1);\r\n    }\r\n    isBlacklistedRoute(request) {\r\n        const url = request.url;\r\n        return (this.blacklistedRoutes.findIndex(route => typeof route === 'string'\r\n            ? route === url\r\n            : route instanceof RegExp\r\n                ? route.test(url)\r\n                : false) > -1);\r\n    }\r\n    handleInterception(token, request, next) {\r\n        let tokenIsExpired = false;\r\n        if (!token && this.throwNoTokenError) {\r\n            throw new Error('Could not get token from tokenGetter function.');\r\n        }\r\n        if (this.skipWhenExpired) {\r\n            tokenIsExpired = token ? this.jwtHelper.isTokenExpired(token) : true;\r\n        }\r\n        if (token && tokenIsExpired && this.skipWhenExpired) {\r\n            request = request.clone();\r\n        }\r\n        else if (token) {\r\n            request = request.clone({\r\n                setHeaders: {\r\n                    [this.headerName]: `${this.authScheme}${token}`\r\n                }\r\n            });\r\n        }\r\n        return next.handle(request);\r\n    }\r\n    intercept(request, next) {\r\n        if (!this.isWhitelistedDomain(request) ||\r\n            this.isBlacklistedRoute(request)) {\r\n            return next.handle(request);\r\n        }\r\n        const token = this.tokenGetter();\r\n        if (token instanceof Promise) {\r\n            return from(token).pipe(mergeMap((asyncToken) => {\r\n                return this.handleInterception(asyncToken, request, next);\r\n            }));\r\n        }\r\n        else {\r\n            return this.handleInterception(token, request, next);\r\n        }\r\n    }\r\n};\r\nJwtInterceptor.ctorParameters = () => [\r\n    { type: undefined, decorators: [{ type: Inject, args: [JWT_OPTIONS,] }] },\r\n    { type: JwtHelperService }\r\n];\r\nJwtInterceptor = __decorate([\r\n    Injectable(),\r\n    __param(0, Inject(JWT_OPTIONS)),\r\n    __metadata(\"design:paramtypes\", [Object, JwtHelperService])\r\n], JwtInterceptor);\r\n\r\nvar JwtModule_1;\r\nlet JwtModule = JwtModule_1 = class JwtModule {\r\n    constructor(parentModule) {\r\n        if (parentModule) {\r\n            throw new Error('JwtModule is already loaded. It should only be imported in your application\\'s main module.');\r\n        }\r\n    }\r\n    static forRoot(options) {\r\n        return {\r\n            ngModule: JwtModule_1,\r\n            providers: [\r\n                {\r\n                    provide: HTTP_INTERCEPTORS,\r\n                    useClass: JwtInterceptor,\r\n                    multi: true\r\n                },\r\n                options.jwtOptionsProvider ||\r\n                    {\r\n                        provide: JWT_OPTIONS,\r\n                        useValue: options.config\r\n                    },\r\n                JwtHelperService\r\n            ]\r\n        };\r\n    }\r\n};\r\nJwtModule.ctorParameters = () => [\r\n    { type: JwtModule, decorators: [{ type: Optional }, { type: SkipSelf }] }\r\n];\r\nJwtModule = JwtModule_1 = __decorate([\r\n    NgModule(),\r\n    __param(0, Optional()), __param(0, SkipSelf()),\r\n    __metadata(\"design:paramtypes\", [JwtModule])\r\n], JwtModule);\r\n\r\n/*\r\n * Public API Surface of angular-jwt\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { JWT_OPTIONS, JwtHelperService, JwtInterceptor, JwtModule };\r\n\r\n"]}