import { __decorate, __metadata, __param } from "tslib";
import { Injectable, Inject } from '@angular/core';
import { JwtHelperService } from './jwthelper.service';
import { JWT_OPTIONS } from './jwtoptions.token';
import { mergeMap } from 'rxjs/operators';
import { parse } from 'url';
import { from } from 'rxjs';
import * as ɵngcc0 from '@angular/core';
let JwtInterceptor = class JwtInterceptor {
    constructor(config, jwtHelper) {
        this.jwtHelper = jwtHelper;
        this.tokenGetter = config.tokenGetter;
        this.headerName = config.headerName || 'Authorization';
        this.authScheme =
            config.authScheme || config.authScheme === ''
                ? config.authScheme
                : 'Bearer ';
        this.whitelistedDomains = config.whitelistedDomains || [];
        this.blacklistedRoutes = config.blacklistedRoutes || [];
        this.throwNoTokenError = config.throwNoTokenError || false;
        this.skipWhenExpired = config.skipWhenExpired;
    }
    isWhitelistedDomain(request) {
        const requestUrl = parse(request.url, false, true);
        return (requestUrl.host === null ||
            this.whitelistedDomains.findIndex(domain => typeof domain === 'string'
                ? domain === requestUrl.host
                : domain instanceof RegExp
                    ? domain.test(requestUrl.host)
                    : false) > -1);
    }
    isBlacklistedRoute(request) {
        const url = request.url;
        return (this.blacklistedRoutes.findIndex(route => typeof route === 'string'
            ? route === url
            : route instanceof RegExp
                ? route.test(url)
                : false) > -1);
    }
    handleInterception(token, request, next) {
        let tokenIsExpired = false;
        if (!token && this.throwNoTokenError) {
            throw new Error('Could not get token from tokenGetter function.');
        }
        if (this.skipWhenExpired) {
            tokenIsExpired = token ? this.jwtHelper.isTokenExpired(token) : true;
        }
        if (token && tokenIsExpired && this.skipWhenExpired) {
            request = request.clone();
        }
        else if (token) {
            request = request.clone({
                setHeaders: {
                    [this.headerName]: `${this.authScheme}${token}`
                }
            });
        }
        return next.handle(request);
    }
    intercept(request, next) {
        if (!this.isWhitelistedDomain(request) ||
            this.isBlacklistedRoute(request)) {
            return next.handle(request);
        }
        const token = this.tokenGetter();
        if (token instanceof Promise) {
            return from(token).pipe(mergeMap((asyncToken) => {
                return this.handleInterception(asyncToken, request, next);
            }));
        }
        else {
            return this.handleInterception(token, request, next);
        }
    }
}
JwtInterceptor.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: JwtInterceptor, factory: function JwtInterceptor_Factory(t) { return new (t || JwtInterceptor)(ɵngcc0.ɵɵinject(JWT_OPTIONS), ɵngcc0.ɵɵinject(JwtHelperService)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(JwtInterceptor, [{
        type: Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [JWT_OPTIONS]
            }] }, { type: JwtHelperService }]; }, { constructor: [], jwtHelper: [], tokenGetter: [], headerName: [], authScheme: [], whitelistedDomains: [], blacklistedRoutes: [], throwNoTokenError: [], skipWhenExpired: [], isWhitelistedDomain: [], isBlacklistedRoute: [], handleInterception: [], intercept: [] });;
JwtInterceptor.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [JWT_OPTIONS,] }] },
    { type: JwtHelperService }
];
JwtInterceptor = __decorate([
    __param(0, Inject(JWT_OPTIONS)),
    __metadata("design:paramtypes", [Object, JwtHelperService])
], JwtInterceptor);
export { JwtInterceptor };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQGF1dGgwL2FuZ3VsYXItand0L2VzbTIwMTUvbGliL2p3dC5pbnRlcmNlcHRvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswVEFrRUM7Ozs7OzZCQUs0QixBQUNaIiwiZmlsZSI6Imp3dC5pbnRlcmNlcHRvci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZGVjb3JhdGUsIF9fbWV0YWRhdGEsIF9fcGFyYW0gfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEp3dEhlbHBlclNlcnZpY2UgfSBmcm9tICcuL2p3dGhlbHBlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSldUX09QVElPTlMgfSBmcm9tICcuL2p3dG9wdGlvbnMudG9rZW4nO1xyXG5pbXBvcnQgeyBtZXJnZU1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgcGFyc2UgfSBmcm9tICd1cmwnO1xyXG5pbXBvcnQgeyBmcm9tIH0gZnJvbSAncnhqcyc7XHJcbmxldCBKd3RJbnRlcmNlcHRvciA9IGNsYXNzIEp3dEludGVyY2VwdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgand0SGVscGVyKSB7XHJcbiAgICAgICAgdGhpcy5qd3RIZWxwZXIgPSBqd3RIZWxwZXI7XHJcbiAgICAgICAgdGhpcy50b2tlbkdldHRlciA9IGNvbmZpZy50b2tlbkdldHRlcjtcclxuICAgICAgICB0aGlzLmhlYWRlck5hbWUgPSBjb25maWcuaGVhZGVyTmFtZSB8fCAnQXV0aG9yaXphdGlvbic7XHJcbiAgICAgICAgdGhpcy5hdXRoU2NoZW1lID1cclxuICAgICAgICAgICAgY29uZmlnLmF1dGhTY2hlbWUgfHwgY29uZmlnLmF1dGhTY2hlbWUgPT09ICcnXHJcbiAgICAgICAgICAgICAgICA/IGNvbmZpZy5hdXRoU2NoZW1lXHJcbiAgICAgICAgICAgICAgICA6ICdCZWFyZXIgJztcclxuICAgICAgICB0aGlzLndoaXRlbGlzdGVkRG9tYWlucyA9IGNvbmZpZy53aGl0ZWxpc3RlZERvbWFpbnMgfHwgW107XHJcbiAgICAgICAgdGhpcy5ibGFja2xpc3RlZFJvdXRlcyA9IGNvbmZpZy5ibGFja2xpc3RlZFJvdXRlcyB8fCBbXTtcclxuICAgICAgICB0aGlzLnRocm93Tm9Ub2tlbkVycm9yID0gY29uZmlnLnRocm93Tm9Ub2tlbkVycm9yIHx8IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2tpcFdoZW5FeHBpcmVkID0gY29uZmlnLnNraXBXaGVuRXhwaXJlZDtcclxuICAgIH1cclxuICAgIGlzV2hpdGVsaXN0ZWREb21haW4ocmVxdWVzdCkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3RVcmwgPSBwYXJzZShyZXF1ZXN0LnVybCwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgIHJldHVybiAocmVxdWVzdFVybC5ob3N0ID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgIHRoaXMud2hpdGVsaXN0ZWREb21haW5zLmZpbmRJbmRleChkb21haW4gPT4gdHlwZW9mIGRvbWFpbiA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgICAgID8gZG9tYWluID09PSByZXF1ZXN0VXJsLmhvc3RcclxuICAgICAgICAgICAgICAgIDogZG9tYWluIGluc3RhbmNlb2YgUmVnRXhwXHJcbiAgICAgICAgICAgICAgICAgICAgPyBkb21haW4udGVzdChyZXF1ZXN0VXJsLmhvc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBmYWxzZSkgPiAtMSk7XHJcbiAgICB9XHJcbiAgICBpc0JsYWNrbGlzdGVkUm91dGUocmVxdWVzdCkge1xyXG4gICAgICAgIGNvbnN0IHVybCA9IHJlcXVlc3QudXJsO1xyXG4gICAgICAgIHJldHVybiAodGhpcy5ibGFja2xpc3RlZFJvdXRlcy5maW5kSW5kZXgocm91dGUgPT4gdHlwZW9mIHJvdXRlID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICA/IHJvdXRlID09PSB1cmxcclxuICAgICAgICAgICAgOiByb3V0ZSBpbnN0YW5jZW9mIFJlZ0V4cFxyXG4gICAgICAgICAgICAgICAgPyByb3V0ZS50ZXN0KHVybClcclxuICAgICAgICAgICAgICAgIDogZmFsc2UpID4gLTEpO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlSW50ZXJjZXB0aW9uKHRva2VuLCByZXF1ZXN0LCBuZXh0KSB7XHJcbiAgICAgICAgbGV0IHRva2VuSXNFeHBpcmVkID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCF0b2tlbiAmJiB0aGlzLnRocm93Tm9Ub2tlbkVycm9yKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCB0b2tlbiBmcm9tIHRva2VuR2V0dGVyIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5za2lwV2hlbkV4cGlyZWQpIHtcclxuICAgICAgICAgICAgdG9rZW5Jc0V4cGlyZWQgPSB0b2tlbiA/IHRoaXMuand0SGVscGVyLmlzVG9rZW5FeHBpcmVkKHRva2VuKSA6IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b2tlbiAmJiB0b2tlbklzRXhwaXJlZCAmJiB0aGlzLnNraXBXaGVuRXhwaXJlZCkge1xyXG4gICAgICAgICAgICByZXF1ZXN0ID0gcmVxdWVzdC5jbG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0b2tlbikge1xyXG4gICAgICAgICAgICByZXF1ZXN0ID0gcmVxdWVzdC5jbG9uZSh7XHJcbiAgICAgICAgICAgICAgICBzZXRIZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgW3RoaXMuaGVhZGVyTmFtZV06IGAke3RoaXMuYXV0aFNjaGVtZX0ke3Rva2VufWBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIGludGVyY2VwdChyZXF1ZXN0LCBuZXh0KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzV2hpdGVsaXN0ZWREb21haW4ocmVxdWVzdCkgfHxcclxuICAgICAgICAgICAgdGhpcy5pc0JsYWNrbGlzdGVkUm91dGUocmVxdWVzdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5leHQuaGFuZGxlKHJlcXVlc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMudG9rZW5HZXR0ZXIoKTtcclxuICAgICAgICBpZiAodG9rZW4gaW5zdGFuY2VvZiBQcm9taXNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tKHRva2VuKS5waXBlKG1lcmdlTWFwKChhc3luY1Rva2VuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVJbnRlcmNlcHRpb24oYXN5bmNUb2tlbiwgcmVxdWVzdCwgbmV4dCk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUludGVyY2VwdGlvbih0b2tlbiwgcmVxdWVzdCwgbmV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5Kd3RJbnRlcmNlcHRvci5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcclxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtKV1RfT1BUSU9OUyxdIH1dIH0sXHJcbiAgICB7IHR5cGU6IEp3dEhlbHBlclNlcnZpY2UgfVxyXG5dO1xyXG5Kd3RJbnRlcmNlcHRvciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgSW5qZWN0YWJsZSgpLFxyXG4gICAgX19wYXJhbSgwLCBJbmplY3QoSldUX09QVElPTlMpKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0LCBKd3RIZWxwZXJTZXJ2aWNlXSlcclxuXSwgSnd0SW50ZXJjZXB0b3IpO1xyXG5leHBvcnQgeyBKd3RJbnRlcmNlcHRvciB9O1xyIl19