import { __decorate, __metadata, __param } from "tslib";
import { Injectable, Inject } from '@angular/core';
import { JwtHelperService } from './jwthelper.service';
import { JWT_OPTIONS } from './jwtoptions.token';
import { mergeMap } from 'rxjs/operators';
import { parse } from 'url';
import { from } from 'rxjs';
import * as ɵngcc0 from '@angular/core';
var JwtInterceptor = /** @class */ (function () {
    function JwtInterceptor(config, jwtHelper) {
        this.jwtHelper = jwtHelper;
        this.tokenGetter = config.tokenGetter;
        this.headerName = config.headerName || 'Authorization';
        this.authScheme =
            config.authScheme || config.authScheme === ''
                ? config.authScheme
                : 'Bearer ';
        this.whitelistedDomains = config.whitelistedDomains || [];
        this.blacklistedRoutes = config.blacklistedRoutes || [];
        this.throwNoTokenError = config.throwNoTokenError || false;
        this.skipWhenExpired = config.skipWhenExpired;
    }
    JwtInterceptor.prototype.isWhitelistedDomain = function (request) {
        var requestUrl = parse(request.url, false, true);
        return (requestUrl.host === null ||
            this.whitelistedDomains.findIndex(function (domain) {
                return typeof domain === 'string'
                    ? domain === requestUrl.host
                    : domain instanceof RegExp
                        ? domain.test(requestUrl.host)
                        : false;
            }) > -1);
    };
    JwtInterceptor.prototype.isBlacklistedRoute = function (request) {
        var url = request.url;
        return (this.blacklistedRoutes.findIndex(function (route) {
            return typeof route === 'string'
                ? route === url
                : route instanceof RegExp
                    ? route.test(url)
                    : false;
        }) > -1);
    };
    JwtInterceptor.prototype.handleInterception = function (token, request, next) {
        var _a;
        var tokenIsExpired = false;
        if (!token && this.throwNoTokenError) {
            throw new Error('Could not get token from tokenGetter function.');
        }
        if (this.skipWhenExpired) {
            tokenIsExpired = token ? this.jwtHelper.isTokenExpired(token) : true;
        }
        if (token && tokenIsExpired && this.skipWhenExpired) {
            request = request.clone();
        }
        else if (token) {
            request = request.clone({
                setHeaders: (_a = {},
                    _a[this.headerName] = "" + this.authScheme + token,
                    _a)
            });
        }
        return next.handle(request);
    };
    JwtInterceptor.prototype.intercept = function (request, next) {
        var _this = this;
        if (!this.isWhitelistedDomain(request) ||
            this.isBlacklistedRoute(request)) {
            return next.handle(request);
        }
        var token = this.tokenGetter();
        if (token instanceof Promise) {
            return from(token).pipe(mergeMap(function (asyncToken) {
                return _this.handleInterception(asyncToken, request, next);
            }));
        }
        else {
            return this.handleInterception(token, request, next);
        }
    };
    JwtInterceptor.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [JWT_OPTIONS,] }] },
        { type: JwtHelperService }
    ]; };
    JwtInterceptor = __decorate([
        __param(0, Inject(JWT_OPTIONS)),
        __metadata("design:paramtypes", [Object, JwtHelperService])
    ], JwtInterceptor);
JwtInterceptor.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: JwtInterceptor, factory: function JwtInterceptor_Factory(t) { return new (t || JwtInterceptor)(ɵngcc0.ɵɵinject(JWT_OPTIONS), ɵngcc0.ɵɵinject(JwtHelperService)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(JwtInterceptor, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [JWT_OPTIONS]
            }] }, { type: JwtHelperService }]; }, { jwtHelper: [], tokenGetter: [], headerName: [], authScheme: [], whitelistedDomains: [], blacklistedRoutes: [], throwNoTokenError: [], skipWhenExpired: [], isWhitelistedDomain: [], isBlacklistedRoute: [], handleInterception: [], intercept: [] });
    return JwtInterceptor;
}());
export { JwtInterceptor };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQGF1dGgwL2FuZ3VsYXItand0L2VzbTUvbGliL2p3dC5pbnRlcmNlcHRvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpQ0E0RWlDLEFBQ1o7Ozs7Ozs7Ozs7eVNBR0UiLCJmaWxlIjoiand0LmludGVyY2VwdG9yLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19kZWNvcmF0ZSwgX19tZXRhZGF0YSwgX19wYXJhbSB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgSnd0SGVscGVyU2VydmljZSB9IGZyb20gJy4vand0aGVscGVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBKV1RfT1BUSU9OUyB9IGZyb20gJy4vand0b3B0aW9ucy50b2tlbic7XHJcbmltcG9ydCB7IG1lcmdlTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gJ3VybCc7XHJcbmltcG9ydCB7IGZyb20gfSBmcm9tICdyeGpzJztcclxudmFyIEp3dEludGVyY2VwdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSnd0SW50ZXJjZXB0b3IoY29uZmlnLCBqd3RIZWxwZXIpIHtcclxuICAgICAgICB0aGlzLmp3dEhlbHBlciA9IGp3dEhlbHBlcjtcclxuICAgICAgICB0aGlzLnRva2VuR2V0dGVyID0gY29uZmlnLnRva2VuR2V0dGVyO1xyXG4gICAgICAgIHRoaXMuaGVhZGVyTmFtZSA9IGNvbmZpZy5oZWFkZXJOYW1lIHx8ICdBdXRob3JpemF0aW9uJztcclxuICAgICAgICB0aGlzLmF1dGhTY2hlbWUgPVxyXG4gICAgICAgICAgICBjb25maWcuYXV0aFNjaGVtZSB8fCBjb25maWcuYXV0aFNjaGVtZSA9PT0gJydcclxuICAgICAgICAgICAgICAgID8gY29uZmlnLmF1dGhTY2hlbWVcclxuICAgICAgICAgICAgICAgIDogJ0JlYXJlciAnO1xyXG4gICAgICAgIHRoaXMud2hpdGVsaXN0ZWREb21haW5zID0gY29uZmlnLndoaXRlbGlzdGVkRG9tYWlucyB8fCBbXTtcclxuICAgICAgICB0aGlzLmJsYWNrbGlzdGVkUm91dGVzID0gY29uZmlnLmJsYWNrbGlzdGVkUm91dGVzIHx8IFtdO1xyXG4gICAgICAgIHRoaXMudGhyb3dOb1Rva2VuRXJyb3IgPSBjb25maWcudGhyb3dOb1Rva2VuRXJyb3IgfHwgZmFsc2U7XHJcbiAgICAgICAgdGhpcy5za2lwV2hlbkV4cGlyZWQgPSBjb25maWcuc2tpcFdoZW5FeHBpcmVkO1xyXG4gICAgfVxyXG4gICAgSnd0SW50ZXJjZXB0b3IucHJvdG90eXBlLmlzV2hpdGVsaXN0ZWREb21haW4gPSBmdW5jdGlvbiAocmVxdWVzdCkge1xyXG4gICAgICAgIHZhciByZXF1ZXN0VXJsID0gcGFyc2UocmVxdWVzdC51cmwsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gKHJlcXVlc3RVcmwuaG9zdCA9PT0gbnVsbCB8fFxyXG4gICAgICAgICAgICB0aGlzLndoaXRlbGlzdGVkRG9tYWlucy5maW5kSW5kZXgoZnVuY3Rpb24gKGRvbWFpbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBkb21haW4gPT09ICdzdHJpbmcnXHJcbiAgICAgICAgICAgICAgICAgICAgPyBkb21haW4gPT09IHJlcXVlc3RVcmwuaG9zdFxyXG4gICAgICAgICAgICAgICAgICAgIDogZG9tYWluIGluc3RhbmNlb2YgUmVnRXhwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZG9tYWluLnRlc3QocmVxdWVzdFVybC5ob3N0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xyXG4gICAgICAgICAgICB9KSA+IC0xKTtcclxuICAgIH07XHJcbiAgICBKd3RJbnRlcmNlcHRvci5wcm90b3R5cGUuaXNCbGFja2xpc3RlZFJvdXRlID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcclxuICAgICAgICB2YXIgdXJsID0gcmVxdWVzdC51cmw7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmJsYWNrbGlzdGVkUm91dGVzLmZpbmRJbmRleChmdW5jdGlvbiAocm91dGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiByb3V0ZSA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgICAgID8gcm91dGUgPT09IHVybFxyXG4gICAgICAgICAgICAgICAgOiByb3V0ZSBpbnN0YW5jZW9mIFJlZ0V4cFxyXG4gICAgICAgICAgICAgICAgICAgID8gcm91dGUudGVzdCh1cmwpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBmYWxzZTtcclxuICAgICAgICB9KSA+IC0xKTtcclxuICAgIH07XHJcbiAgICBKd3RJbnRlcmNlcHRvci5wcm90b3R5cGUuaGFuZGxlSW50ZXJjZXB0aW9uID0gZnVuY3Rpb24gKHRva2VuLCByZXF1ZXN0LCBuZXh0KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciB0b2tlbklzRXhwaXJlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICghdG9rZW4gJiYgdGhpcy50aHJvd05vVG9rZW5FcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgdG9rZW4gZnJvbSB0b2tlbkdldHRlciBmdW5jdGlvbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2tpcFdoZW5FeHBpcmVkKSB7XHJcbiAgICAgICAgICAgIHRva2VuSXNFeHBpcmVkID0gdG9rZW4gPyB0aGlzLmp3dEhlbHBlci5pc1Rva2VuRXhwaXJlZCh0b2tlbikgOiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9rZW4gJiYgdG9rZW5Jc0V4cGlyZWQgJiYgdGhpcy5za2lwV2hlbkV4cGlyZWQpIHtcclxuICAgICAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3QuY2xvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodG9rZW4pIHtcclxuICAgICAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3QuY2xvbmUoe1xyXG4gICAgICAgICAgICAgICAgc2V0SGVhZGVyczogKF9hID0ge30sXHJcbiAgICAgICAgICAgICAgICAgICAgX2FbdGhpcy5oZWFkZXJOYW1lXSA9IFwiXCIgKyB0aGlzLmF1dGhTY2hlbWUgKyB0b2tlbixcclxuICAgICAgICAgICAgICAgICAgICBfYSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXF1ZXN0KTtcclxuICAgIH07XHJcbiAgICBKd3RJbnRlcmNlcHRvci5wcm90b3R5cGUuaW50ZXJjZXB0ID0gZnVuY3Rpb24gKHJlcXVlc3QsIG5leHQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICghdGhpcy5pc1doaXRlbGlzdGVkRG9tYWluKHJlcXVlc3QpIHx8XHJcbiAgICAgICAgICAgIHRoaXMuaXNCbGFja2xpc3RlZFJvdXRlKHJlcXVlc3QpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRva2VuID0gdGhpcy50b2tlbkdldHRlcigpO1xyXG4gICAgICAgIGlmICh0b2tlbiBpbnN0YW5jZW9mIFByb21pc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZyb20odG9rZW4pLnBpcGUobWVyZ2VNYXAoZnVuY3Rpb24gKGFzeW5jVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVJbnRlcmNlcHRpb24oYXN5bmNUb2tlbiwgcmVxdWVzdCwgbmV4dCk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUludGVyY2VwdGlvbih0b2tlbiwgcmVxdWVzdCwgbmV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEp3dEludGVyY2VwdG9yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtKV1RfT1BUSU9OUyxdIH1dIH0sXHJcbiAgICAgICAgeyB0eXBlOiBKd3RIZWxwZXJTZXJ2aWNlIH1cclxuICAgIF07IH07XHJcbiAgICBKd3RJbnRlcmNlcHRvciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEluamVjdGFibGUoKSxcclxuICAgICAgICBfX3BhcmFtKDAsIEluamVjdChKV1RfT1BUSU9OUykpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0LCBKd3RIZWxwZXJTZXJ2aWNlXSlcclxuICAgIF0sIEp3dEludGVyY2VwdG9yKTtcclxuICAgIHJldHVybiBKd3RJbnRlcmNlcHRvcjtcclxufSgpKTtcclxuZXhwb3J0IHsgSnd0SW50ZXJjZXB0b3IgfTtcciJdfQ==