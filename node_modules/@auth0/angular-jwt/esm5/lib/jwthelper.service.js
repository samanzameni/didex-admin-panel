// tslint:disable:no-bitwise
import { __decorate, __metadata, __param } from "tslib";
import { Injectable, Inject } from '@angular/core';
import { JWT_OPTIONS } from './jwtoptions.token';
import * as ɵngcc0 from '@angular/core';
var JwtHelperService = /** @class */ (function () {
    function JwtHelperService(config) {
        if (config === void 0) { config = null; }
        this.tokenGetter = config && config.tokenGetter || function () { };
    }
    JwtHelperService.prototype.urlBase64Decode = function (str) {
        var output = str.replace(/-/g, '+').replace(/_/g, '/');
        switch (output.length % 4) {
            case 0: {
                break;
            }
            case 2: {
                output += '==';
                break;
            }
            case 3: {
                output += '=';
                break;
            }
            default: {
                throw new Error('Illegal base64url string!');
            }
        }
        return this.b64DecodeUnicode(output);
    };
    // credits for decoder goes to https://github.com/atk
    JwtHelperService.prototype.b64decode = function (str) {
        var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        var output = '';
        str = String(str).replace(/=+$/, '');
        if (str.length % 4 === 1) {
            throw new Error('\'atob\' failed: The string to be decoded is not correctly encoded.');
        }
        for (
        // initialize result and counters
        var bc = 0, bs = void 0, buffer = void 0, idx = 0; 
        // get next character
        (buffer = str.charAt(idx++)); 
        // character found in table? initialize bit storage and add its ascii value;
        ~buffer &&
            ((bs = bc % 4 ? bs * 64 + buffer : buffer),
                // and if not first of each 4 characters,
                // convert the first 8 bits to one ascii character
                bc++ % 4)
            ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))
            : 0) {
            // try to find character in table (0-63, not found => -1)
            buffer = chars.indexOf(buffer);
        }
        return output;
    };
    JwtHelperService.prototype.b64DecodeUnicode = function (str) {
        return decodeURIComponent(Array.prototype.map
            .call(this.b64decode(str), function (c) {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        })
            .join(''));
    };
    JwtHelperService.prototype.decodeToken = function (token) {
        if (token === void 0) { token = this.tokenGetter(); }
        if (!token || token === '') {
            return null;
        }
        var parts = token.split('.');
        if (parts.length !== 3) {
            throw new Error('The inspected token doesn\'t appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.');
        }
        var decoded = this.urlBase64Decode(parts[1]);
        if (!decoded) {
            throw new Error('Cannot decode the token.');
        }
        return JSON.parse(decoded);
    };
    JwtHelperService.prototype.getTokenExpirationDate = function (token) {
        if (token === void 0) { token = this.tokenGetter(); }
        var decoded;
        decoded = this.decodeToken(token);
        if (!decoded || !decoded.hasOwnProperty('exp')) {
            return null;
        }
        var date = new Date(0);
        date.setUTCSeconds(decoded.exp);
        return date;
    };
    JwtHelperService.prototype.isTokenExpired = function (token, offsetSeconds) {
        if (token === void 0) { token = this.tokenGetter(); }
        if (!token || token === '') {
            return true;
        }
        var date = this.getTokenExpirationDate(token);
        offsetSeconds = offsetSeconds || 0;
        if (date === null) {
            return false;
        }
        return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);
    };
    JwtHelperService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [JWT_OPTIONS,] }] }
    ]; };
    JwtHelperService = __decorate([
        __param(0, Inject(JWT_OPTIONS)),
        __metadata("design:paramtypes", [Object])
    ], JwtHelperService);
JwtHelperService.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: JwtHelperService, factory: function JwtHelperService_Factory(t) { return new (t || JwtHelperService)(ɵngcc0.ɵɵinject(JWT_OPTIONS)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(JwtHelperService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [JWT_OPTIONS]
            }] }]; }, { tokenGetter: [], urlBase64Decode: [], b64decode: [], b64DecodeUnicode: [], decodeToken: [], getTokenExpirationDate: [], isTokenExpired: [] });
    return JwtHelperService;
}());
export { JwtHelperService };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQGF1dGgwL2FuZ3VsYXItand0L2VzbTUvbGliL2p3dGhlbHBlci5zZXJ2aWNlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7OztBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUNBbUdtQyxBQUNkOzs7Ozs7Ozs7O3NLQUdJIiwiZmlsZSI6Imp3dGhlbHBlci5zZXJ2aWNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGU6bm8tYml0d2lzZVxyXG5pbXBvcnQgeyBfX2RlY29yYXRlLCBfX21ldGFkYXRhLCBfX3BhcmFtIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBKV1RfT1BUSU9OUyB9IGZyb20gJy4vand0b3B0aW9ucy50b2tlbic7XHJcbnZhciBKd3RIZWxwZXJTZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSnd0SGVscGVyU2VydmljZShjb25maWcpIHtcclxuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0gbnVsbDsgfVxyXG4gICAgICAgIHRoaXMudG9rZW5HZXR0ZXIgPSBjb25maWcgJiYgY29uZmlnLnRva2VuR2V0dGVyIHx8IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIH1cclxuICAgIEp3dEhlbHBlclNlcnZpY2UucHJvdG90eXBlLnVybEJhc2U2NERlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICB2YXIgb3V0cHV0ID0gc3RyLnJlcGxhY2UoLy0vZywgJysnKS5yZXBsYWNlKC9fL2csICcvJyk7XHJcbiAgICAgICAgc3dpdGNoIChvdXRwdXQubGVuZ3RoICUgNCkge1xyXG4gICAgICAgICAgICBjYXNlIDA6IHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgMjoge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICc9PSc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIDM6IHtcclxuICAgICAgICAgICAgICAgIG91dHB1dCArPSAnPSc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYmFzZTY0dXJsIHN0cmluZyEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5iNjREZWNvZGVVbmljb2RlKG91dHB1dCk7XHJcbiAgICB9O1xyXG4gICAgLy8gY3JlZGl0cyBmb3IgZGVjb2RlciBnb2VzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9hdGtcclxuICAgIEp3dEhlbHBlclNlcnZpY2UucHJvdG90eXBlLmI2NGRlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICB2YXIgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSAnJztcclxuICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKS5yZXBsYWNlKC89KyQvLCAnJyk7XHJcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggJSA0ID09PSAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXFwnYXRvYlxcJyBmYWlsZWQ6IFRoZSBzdHJpbmcgdG8gYmUgZGVjb2RlZCBpcyBub3QgY29ycmVjdGx5IGVuY29kZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoXHJcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSByZXN1bHQgYW5kIGNvdW50ZXJzXHJcbiAgICAgICAgdmFyIGJjID0gMCwgYnMgPSB2b2lkIDAsIGJ1ZmZlciA9IHZvaWQgMCwgaWR4ID0gMDsgXHJcbiAgICAgICAgLy8gZ2V0IG5leHQgY2hhcmFjdGVyXHJcbiAgICAgICAgKGJ1ZmZlciA9IHN0ci5jaGFyQXQoaWR4KyspKTsgXHJcbiAgICAgICAgLy8gY2hhcmFjdGVyIGZvdW5kIGluIHRhYmxlPyBpbml0aWFsaXplIGJpdCBzdG9yYWdlIGFuZCBhZGQgaXRzIGFzY2lpIHZhbHVlO1xyXG4gICAgICAgIH5idWZmZXIgJiZcclxuICAgICAgICAgICAgKChicyA9IGJjICUgNCA/IGJzICogNjQgKyBidWZmZXIgOiBidWZmZXIpLFxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIGlmIG5vdCBmaXJzdCBvZiBlYWNoIDQgY2hhcmFjdGVycyxcclxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIGZpcnN0IDggYml0cyB0byBvbmUgYXNjaWkgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICBiYysrICUgNClcclxuICAgICAgICAgICAgPyAob3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1ICYgKGJzID4+ICgoLTIgKiBiYykgJiA2KSkpKVxyXG4gICAgICAgICAgICA6IDApIHtcclxuICAgICAgICAgICAgLy8gdHJ5IHRvIGZpbmQgY2hhcmFjdGVyIGluIHRhYmxlICgwLTYzLCBub3QgZm91bmQgPT4gLTEpXHJcbiAgICAgICAgICAgIGJ1ZmZlciA9IGNoYXJzLmluZGV4T2YoYnVmZmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH07XHJcbiAgICBKd3RIZWxwZXJTZXJ2aWNlLnByb3RvdHlwZS5iNjREZWNvZGVVbmljb2RlID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoQXJyYXkucHJvdG90eXBlLm1hcFxyXG4gICAgICAgICAgICAuY2FsbCh0aGlzLmI2NGRlY29kZShzdHIpLCBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICByZXR1cm4gJyUnICsgKCcwMCcgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmpvaW4oJycpKTtcclxuICAgIH07XHJcbiAgICBKd3RIZWxwZXJTZXJ2aWNlLnByb3RvdHlwZS5kZWNvZGVUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgICAgIGlmICh0b2tlbiA9PT0gdm9pZCAwKSB7IHRva2VuID0gdGhpcy50b2tlbkdldHRlcigpOyB9XHJcbiAgICAgICAgaWYgKCF0b2tlbiB8fCB0b2tlbiA9PT0gJycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXJ0cyA9IHRva2VuLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbnNwZWN0ZWQgdG9rZW4gZG9lc25cXCd0IGFwcGVhciB0byBiZSBhIEpXVC4gQ2hlY2sgdG8gbWFrZSBzdXJlIGl0IGhhcyB0aHJlZSBwYXJ0cyBhbmQgc2VlIGh0dHBzOi8vand0LmlvIGZvciBtb3JlLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGVjb2RlZCA9IHRoaXMudXJsQmFzZTY0RGVjb2RlKHBhcnRzWzFdKTtcclxuICAgICAgICBpZiAoIWRlY29kZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGVjb2RlIHRoZSB0b2tlbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlZCk7XHJcbiAgICB9O1xyXG4gICAgSnd0SGVscGVyU2VydmljZS5wcm90b3R5cGUuZ2V0VG9rZW5FeHBpcmF0aW9uRGF0ZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgICAgIGlmICh0b2tlbiA9PT0gdm9pZCAwKSB7IHRva2VuID0gdGhpcy50b2tlbkdldHRlcigpOyB9XHJcbiAgICAgICAgdmFyIGRlY29kZWQ7XHJcbiAgICAgICAgZGVjb2RlZCA9IHRoaXMuZGVjb2RlVG9rZW4odG9rZW4pO1xyXG4gICAgICAgIGlmICghZGVjb2RlZCB8fCAhZGVjb2RlZC5oYXNPd25Qcm9wZXJ0eSgnZXhwJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoMCk7XHJcbiAgICAgICAgZGF0ZS5zZXRVVENTZWNvbmRzKGRlY29kZWQuZXhwKTtcclxuICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgIH07XHJcbiAgICBKd3RIZWxwZXJTZXJ2aWNlLnByb3RvdHlwZS5pc1Rva2VuRXhwaXJlZCA9IGZ1bmN0aW9uICh0b2tlbiwgb2Zmc2V0U2Vjb25kcykge1xyXG4gICAgICAgIGlmICh0b2tlbiA9PT0gdm9pZCAwKSB7IHRva2VuID0gdGhpcy50b2tlbkdldHRlcigpOyB9XHJcbiAgICAgICAgaWYgKCF0b2tlbiB8fCB0b2tlbiA9PT0gJycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkYXRlID0gdGhpcy5nZXRUb2tlbkV4cGlyYXRpb25EYXRlKHRva2VuKTtcclxuICAgICAgICBvZmZzZXRTZWNvbmRzID0gb2Zmc2V0U2Vjb25kcyB8fCAwO1xyXG4gICAgICAgIGlmIChkYXRlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICEoZGF0ZS52YWx1ZU9mKCkgPiBuZXcgRGF0ZSgpLnZhbHVlT2YoKSArIG9mZnNldFNlY29uZHMgKiAxMDAwKTtcclxuICAgIH07XHJcbiAgICBKd3RIZWxwZXJTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtKV1RfT1BUSU9OUyxdIH1dIH1cclxuICAgIF07IH07XHJcbiAgICBKd3RIZWxwZXJTZXJ2aWNlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5qZWN0YWJsZSgpLFxyXG4gICAgICAgIF9fcGFyYW0oMCwgSW5qZWN0KEpXVF9PUFRJT05TKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxyXG4gICAgXSwgSnd0SGVscGVyU2VydmljZSk7XHJcbiAgICByZXR1cm4gSnd0SGVscGVyU2VydmljZTtcclxufSgpKTtcclxuZXhwb3J0IHsgSnd0SGVscGVyU2VydmljZSB9O1xyIl19