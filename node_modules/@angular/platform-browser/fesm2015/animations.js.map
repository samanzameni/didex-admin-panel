{"version":3,"sources":["d:/Angular Project/Didex/didex-admin-panel/node_modules/@angular/platform-browser/fesm2015/animations.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8BC,0FAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6UD,+YAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsWD,0GAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwED,6OAMC;;;;;;;;;;;;;;;;CAMD,yOAMC","file":"animations.js","sourcesContent":["/**\r\n * @license Angular v8.2.14\r\n * (c) 2010-2019 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { ViewEncapsulation, Injectable, RendererFactory2, Inject, NgZone, InjectionToken, NgModule } from '@angular/core';\r\nimport { ɵDomRendererFactory2, BrowserModule } from '@angular/platform-browser';\r\nimport { AnimationBuilder, sequence, AnimationFactory } from '@angular/animations';\r\nimport { ɵAnimationEngine, AnimationDriver, ɵAnimationStyleNormalizer, ɵsupportsWebAnimations, ɵWebAnimationsDriver, ɵCssKeyframesDriver, ɵWebAnimationsStyleNormalizer, ɵNoopAnimationDriver } from '@angular/animations/browser';\r\nimport { DOCUMENT } from '@angular/common';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass BrowserAnimationBuilder extends AnimationBuilder {\r\n    /**\r\n     * @param {?} rootRenderer\r\n     * @param {?} doc\r\n     */\r\n    constructor(rootRenderer, doc) {\r\n        super();\r\n        this._nextAnimationId = 0;\r\n        /** @type {?} */\r\n        const typeData = (/** @type {?} */ ({\r\n            id: '0',\r\n            encapsulation: ViewEncapsulation.None,\r\n            styles: [],\r\n            data: { animation: [] }\r\n        }));\r\n        this._renderer = (/** @type {?} */ (rootRenderer.createRenderer(doc.body, typeData)));\r\n    }\r\n    /**\r\n     * @param {?} animation\r\n     * @return {?}\r\n     */\r\n    build(animation) {\r\n        /** @type {?} */\r\n        const id = this._nextAnimationId.toString();\r\n        this._nextAnimationId++;\r\n        /** @type {?} */\r\n        const entry = Array.isArray(animation) ? sequence(animation) : animation;\r\n        issueAnimationCommand(this._renderer, null, id, 'register', [entry]);\r\n        return new BrowserAnimationFactory(id, this._renderer);\r\n    }\r\n}\r\nBrowserAnimationBuilder.decorators = [\r\n    { type: Injectable }\r\n];\r\n/** @nocollapse */\r\nBrowserAnimationBuilder.ctorParameters = () => [\r\n    { type: RendererFactory2 },\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\r\n];\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    BrowserAnimationBuilder.prototype._nextAnimationId;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    BrowserAnimationBuilder.prototype._renderer;\r\n}\r\nclass BrowserAnimationFactory extends AnimationFactory {\r\n    /**\r\n     * @param {?} _id\r\n     * @param {?} _renderer\r\n     */\r\n    constructor(_id, _renderer) {\r\n        super();\r\n        this._id = _id;\r\n        this._renderer = _renderer;\r\n    }\r\n    /**\r\n     * @param {?} element\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    create(element, options) {\r\n        return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);\r\n    }\r\n}\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    BrowserAnimationFactory.prototype._id;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    BrowserAnimationFactory.prototype._renderer;\r\n}\r\nclass RendererAnimationPlayer {\r\n    /**\r\n     * @param {?} id\r\n     * @param {?} element\r\n     * @param {?} options\r\n     * @param {?} _renderer\r\n     */\r\n    constructor(id, element, options, _renderer) {\r\n        this.id = id;\r\n        this.element = element;\r\n        this._renderer = _renderer;\r\n        this.parentPlayer = null;\r\n        this._started = false;\r\n        this.totalTime = 0;\r\n        this._command('create', options);\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} eventName\r\n     * @param {?} callback\r\n     * @return {?}\r\n     */\r\n    _listen(eventName, callback) {\r\n        return this._renderer.listen(this.element, `@@${this.id}:${eventName}`, callback);\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} command\r\n     * @param {...?} args\r\n     * @return {?}\r\n     */\r\n    _command(command, ...args) {\r\n        return issueAnimationCommand(this._renderer, this.element, this.id, command, args);\r\n    }\r\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    onDone(fn) { this._listen('done', fn); }\r\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    onStart(fn) { this._listen('start', fn); }\r\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    onDestroy(fn) { this._listen('destroy', fn); }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    init() { this._command('init'); }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    hasStarted() { return this._started; }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    play() {\r\n        this._command('play');\r\n        this._started = true;\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    pause() { this._command('pause'); }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    restart() { this._command('restart'); }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    finish() { this._command('finish'); }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    destroy() { this._command('destroy'); }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    reset() { this._command('reset'); }\r\n    /**\r\n     * @param {?} p\r\n     * @return {?}\r\n     */\r\n    setPosition(p) { this._command('setPosition', p); }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    getPosition() { return 0; }\r\n}\r\nif (false) {\r\n    /** @type {?} */\r\n    RendererAnimationPlayer.prototype.parentPlayer;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    RendererAnimationPlayer.prototype._started;\r\n    /** @type {?} */\r\n    RendererAnimationPlayer.prototype.totalTime;\r\n    /** @type {?} */\r\n    RendererAnimationPlayer.prototype.id;\r\n    /** @type {?} */\r\n    RendererAnimationPlayer.prototype.element;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    RendererAnimationPlayer.prototype._renderer;\r\n}\r\n/**\r\n * @param {?} renderer\r\n * @param {?} element\r\n * @param {?} id\r\n * @param {?} command\r\n * @param {?} args\r\n * @return {?}\r\n */\r\nfunction issueAnimationCommand(renderer, element, id, command, args) {\r\n    return renderer.setProperty(element, `@@${id}:${command}`, args);\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @type {?} */\r\nconst ANIMATION_PREFIX = '@';\r\n/** @type {?} */\r\nconst DISABLE_ANIMATIONS_FLAG = '@.disabled';\r\nclass AnimationRendererFactory {\r\n    /**\r\n     * @param {?} delegate\r\n     * @param {?} engine\r\n     * @param {?} _zone\r\n     */\r\n    constructor(delegate, engine, _zone) {\r\n        this.delegate = delegate;\r\n        this.engine = engine;\r\n        this._zone = _zone;\r\n        this._currentId = 0;\r\n        this._microtaskId = 1;\r\n        this._animationCallbacksBuffer = [];\r\n        this._rendererCache = new Map();\r\n        this._cdRecurDepth = 0;\r\n        this.promise = Promise.resolve(0);\r\n        engine.onRemovalComplete = (/**\r\n         * @param {?} element\r\n         * @param {?} delegate\r\n         * @return {?}\r\n         */\r\n        (element, delegate) => {\r\n            // Note: if an component element has a leave animation, and the component\r\n            // a host leave animation, the view engine will call `removeChild` for the parent\r\n            // component renderer as well as for the child component renderer.\r\n            // Therefore, we need to check if we already removed the element.\r\n            if (delegate && delegate.parentNode(element)) {\r\n                delegate.removeChild(element.parentNode, element);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @param {?} hostElement\r\n     * @param {?} type\r\n     * @return {?}\r\n     */\r\n    createRenderer(hostElement, type) {\r\n        /** @type {?} */\r\n        const EMPTY_NAMESPACE_ID = '';\r\n        // cache the delegates to find out which cached delegate can\r\n        // be used by which cached renderer\r\n        /** @type {?} */\r\n        const delegate = this.delegate.createRenderer(hostElement, type);\r\n        if (!hostElement || !type || !type.data || !type.data['animation']) {\r\n            /** @type {?} */\r\n            let renderer = this._rendererCache.get(delegate);\r\n            if (!renderer) {\r\n                renderer = new BaseAnimationRenderer(EMPTY_NAMESPACE_ID, delegate, this.engine);\r\n                // only cache this result when the base renderer is used\r\n                this._rendererCache.set(delegate, renderer);\r\n            }\r\n            return renderer;\r\n        }\r\n        /** @type {?} */\r\n        const componentId = type.id;\r\n        /** @type {?} */\r\n        const namespaceId = type.id + '-' + this._currentId;\r\n        this._currentId++;\r\n        this.engine.register(namespaceId, hostElement);\r\n        /** @type {?} */\r\n        const animationTriggers = (/** @type {?} */ (type.data['animation']));\r\n        animationTriggers.forEach((/**\r\n         * @param {?} trigger\r\n         * @return {?}\r\n         */\r\n        trigger => this.engine.registerTrigger(componentId, namespaceId, hostElement, trigger.name, trigger)));\r\n        return new AnimationRenderer(this, namespaceId, delegate, this.engine);\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    begin() {\r\n        this._cdRecurDepth++;\r\n        if (this.delegate.begin) {\r\n            this.delegate.begin();\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _scheduleCountTask() {\r\n        // always use promise to schedule microtask instead of use Zone\r\n        this.promise.then((/**\r\n         * @return {?}\r\n         */\r\n        () => { this._microtaskId++; }));\r\n    }\r\n    /**\r\n     * \\@internal\r\n     * @param {?} count\r\n     * @param {?} fn\r\n     * @param {?} data\r\n     * @return {?}\r\n     */\r\n    scheduleListenerCallback(count, fn, data) {\r\n        if (count >= 0 && count < this._microtaskId) {\r\n            this._zone.run((/**\r\n             * @return {?}\r\n             */\r\n            () => fn(data)));\r\n            return;\r\n        }\r\n        if (this._animationCallbacksBuffer.length == 0) {\r\n            Promise.resolve(null).then((/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                this._zone.run((/**\r\n                 * @return {?}\r\n                 */\r\n                () => {\r\n                    this._animationCallbacksBuffer.forEach((/**\r\n                     * @param {?} tuple\r\n                     * @return {?}\r\n                     */\r\n                    tuple => {\r\n                        const [fn, data] = tuple;\r\n                        fn(data);\r\n                    }));\r\n                    this._animationCallbacksBuffer = [];\r\n                }));\r\n            }));\r\n        }\r\n        this._animationCallbacksBuffer.push([fn, data]);\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    end() {\r\n        this._cdRecurDepth--;\r\n        // this is to prevent animations from running twice when an inner\r\n        // component does CD when a parent component instead has inserted it\r\n        if (this._cdRecurDepth == 0) {\r\n            this._zone.runOutsideAngular((/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                this._scheduleCountTask();\r\n                this.engine.flush(this._microtaskId);\r\n            }));\r\n        }\r\n        if (this.delegate.end) {\r\n            this.delegate.end();\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    whenRenderingDone() { return this.engine.whenRenderingDone(); }\r\n}\r\nAnimationRendererFactory.decorators = [\r\n    { type: Injectable }\r\n];\r\n/** @nocollapse */\r\nAnimationRendererFactory.ctorParameters = () => [\r\n    { type: RendererFactory2 },\r\n    { type: ɵAnimationEngine },\r\n    { type: NgZone }\r\n];\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    AnimationRendererFactory.prototype._currentId;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    AnimationRendererFactory.prototype._microtaskId;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    AnimationRendererFactory.prototype._animationCallbacksBuffer;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    AnimationRendererFactory.prototype._rendererCache;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    AnimationRendererFactory.prototype._cdRecurDepth;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    AnimationRendererFactory.prototype.promise;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    AnimationRendererFactory.prototype.delegate;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    AnimationRendererFactory.prototype.engine;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    AnimationRendererFactory.prototype._zone;\r\n}\r\nclass BaseAnimationRenderer {\r\n    /**\r\n     * @param {?} namespaceId\r\n     * @param {?} delegate\r\n     * @param {?} engine\r\n     */\r\n    constructor(namespaceId, delegate, engine) {\r\n        this.namespaceId = namespaceId;\r\n        this.delegate = delegate;\r\n        this.engine = engine;\r\n        this.destroyNode = this.delegate.destroyNode ? (/**\r\n         * @param {?} n\r\n         * @return {?}\r\n         */\r\n        (n) => (/** @type {?} */ (delegate.destroyNode))(n)) : null;\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get data() { return this.delegate.data; }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    destroy() {\r\n        this.engine.destroy(this.namespaceId, this.delegate);\r\n        this.delegate.destroy();\r\n    }\r\n    /**\r\n     * @param {?} name\r\n     * @param {?=} namespace\r\n     * @return {?}\r\n     */\r\n    createElement(name, namespace) {\r\n        return this.delegate.createElement(name, namespace);\r\n    }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    createComment(value) { return this.delegate.createComment(value); }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    createText(value) { return this.delegate.createText(value); }\r\n    /**\r\n     * @param {?} parent\r\n     * @param {?} newChild\r\n     * @return {?}\r\n     */\r\n    appendChild(parent, newChild) {\r\n        this.delegate.appendChild(parent, newChild);\r\n        this.engine.onInsert(this.namespaceId, newChild, parent, false);\r\n    }\r\n    /**\r\n     * @param {?} parent\r\n     * @param {?} newChild\r\n     * @param {?} refChild\r\n     * @return {?}\r\n     */\r\n    insertBefore(parent, newChild, refChild) {\r\n        this.delegate.insertBefore(parent, newChild, refChild);\r\n        this.engine.onInsert(this.namespaceId, newChild, parent, true);\r\n    }\r\n    /**\r\n     * @param {?} parent\r\n     * @param {?} oldChild\r\n     * @param {?} isHostElement\r\n     * @return {?}\r\n     */\r\n    removeChild(parent, oldChild, isHostElement) {\r\n        this.engine.onRemove(this.namespaceId, oldChild, this.delegate, isHostElement);\r\n    }\r\n    /**\r\n     * @param {?} selectorOrNode\r\n     * @param {?=} preserveContent\r\n     * @return {?}\r\n     */\r\n    selectRootElement(selectorOrNode, preserveContent) {\r\n        return this.delegate.selectRootElement(selectorOrNode, preserveContent);\r\n    }\r\n    /**\r\n     * @param {?} node\r\n     * @return {?}\r\n     */\r\n    parentNode(node) { return this.delegate.parentNode(node); }\r\n    /**\r\n     * @param {?} node\r\n     * @return {?}\r\n     */\r\n    nextSibling(node) { return this.delegate.nextSibling(node); }\r\n    /**\r\n     * @param {?} el\r\n     * @param {?} name\r\n     * @param {?} value\r\n     * @param {?=} namespace\r\n     * @return {?}\r\n     */\r\n    setAttribute(el, name, value, namespace) {\r\n        this.delegate.setAttribute(el, name, value, namespace);\r\n    }\r\n    /**\r\n     * @param {?} el\r\n     * @param {?} name\r\n     * @param {?=} namespace\r\n     * @return {?}\r\n     */\r\n    removeAttribute(el, name, namespace) {\r\n        this.delegate.removeAttribute(el, name, namespace);\r\n    }\r\n    /**\r\n     * @param {?} el\r\n     * @param {?} name\r\n     * @return {?}\r\n     */\r\n    addClass(el, name) { this.delegate.addClass(el, name); }\r\n    /**\r\n     * @param {?} el\r\n     * @param {?} name\r\n     * @return {?}\r\n     */\r\n    removeClass(el, name) { this.delegate.removeClass(el, name); }\r\n    /**\r\n     * @param {?} el\r\n     * @param {?} style\r\n     * @param {?} value\r\n     * @param {?=} flags\r\n     * @return {?}\r\n     */\r\n    setStyle(el, style, value, flags) {\r\n        this.delegate.setStyle(el, style, value, flags);\r\n    }\r\n    /**\r\n     * @param {?} el\r\n     * @param {?} style\r\n     * @param {?=} flags\r\n     * @return {?}\r\n     */\r\n    removeStyle(el, style, flags) {\r\n        this.delegate.removeStyle(el, style, flags);\r\n    }\r\n    /**\r\n     * @param {?} el\r\n     * @param {?} name\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    setProperty(el, name, value) {\r\n        if (name.charAt(0) == ANIMATION_PREFIX && name == DISABLE_ANIMATIONS_FLAG) {\r\n            this.disableAnimations(el, !!value);\r\n        }\r\n        else {\r\n            this.delegate.setProperty(el, name, value);\r\n        }\r\n    }\r\n    /**\r\n     * @param {?} node\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    setValue(node, value) { this.delegate.setValue(node, value); }\r\n    /**\r\n     * @param {?} target\r\n     * @param {?} eventName\r\n     * @param {?} callback\r\n     * @return {?}\r\n     */\r\n    listen(target, eventName, callback) {\r\n        return this.delegate.listen(target, eventName, callback);\r\n    }\r\n    /**\r\n     * @protected\r\n     * @param {?} element\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    disableAnimations(element, value) {\r\n        this.engine.disableAnimations(element, value);\r\n    }\r\n}\r\nif (false) {\r\n    /** @type {?} */\r\n    BaseAnimationRenderer.prototype.destroyNode;\r\n    /**\r\n     * @type {?}\r\n     * @protected\r\n     */\r\n    BaseAnimationRenderer.prototype.namespaceId;\r\n    /** @type {?} */\r\n    BaseAnimationRenderer.prototype.delegate;\r\n    /** @type {?} */\r\n    BaseAnimationRenderer.prototype.engine;\r\n}\r\nclass AnimationRenderer extends BaseAnimationRenderer {\r\n    /**\r\n     * @param {?} factory\r\n     * @param {?} namespaceId\r\n     * @param {?} delegate\r\n     * @param {?} engine\r\n     */\r\n    constructor(factory, namespaceId, delegate, engine) {\r\n        super(namespaceId, delegate, engine);\r\n        this.factory = factory;\r\n        this.namespaceId = namespaceId;\r\n    }\r\n    /**\r\n     * @param {?} el\r\n     * @param {?} name\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    setProperty(el, name, value) {\r\n        if (name.charAt(0) == ANIMATION_PREFIX) {\r\n            if (name.charAt(1) == '.' && name == DISABLE_ANIMATIONS_FLAG) {\r\n                value = value === undefined ? true : !!value;\r\n                this.disableAnimations(el, (/** @type {?} */ (value)));\r\n            }\r\n            else {\r\n                this.engine.process(this.namespaceId, el, name.substr(1), value);\r\n            }\r\n        }\r\n        else {\r\n            this.delegate.setProperty(el, name, value);\r\n        }\r\n    }\r\n    /**\r\n     * @param {?} target\r\n     * @param {?} eventName\r\n     * @param {?} callback\r\n     * @return {?}\r\n     */\r\n    listen(target, eventName, callback) {\r\n        if (eventName.charAt(0) == ANIMATION_PREFIX) {\r\n            /** @type {?} */\r\n            const element = resolveElementFromTarget(target);\r\n            /** @type {?} */\r\n            let name = eventName.substr(1);\r\n            /** @type {?} */\r\n            let phase = '';\r\n            // @listener.phase is for trigger animation callbacks\r\n            // @@listener is for animation builder callbacks\r\n            if (name.charAt(0) != ANIMATION_PREFIX) {\r\n                [name, phase] = parseTriggerCallbackName(name);\r\n            }\r\n            return this.engine.listen(this.namespaceId, element, name, phase, (/**\r\n             * @param {?} event\r\n             * @return {?}\r\n             */\r\n            event => {\r\n                /** @type {?} */\r\n                const countId = ((/** @type {?} */ (event)))['_data'] || -1;\r\n                this.factory.scheduleListenerCallback(countId, callback, event);\r\n            }));\r\n        }\r\n        return this.delegate.listen(target, eventName, callback);\r\n    }\r\n}\r\nif (false) {\r\n    /** @type {?} */\r\n    AnimationRenderer.prototype.factory;\r\n}\r\n/**\r\n * @param {?} target\r\n * @return {?}\r\n */\r\nfunction resolveElementFromTarget(target) {\r\n    switch (target) {\r\n        case 'body':\r\n            return document.body;\r\n        case 'document':\r\n            return document;\r\n        case 'window':\r\n            return window;\r\n        default:\r\n            return target;\r\n    }\r\n}\r\n/**\r\n * @param {?} triggerName\r\n * @return {?}\r\n */\r\nfunction parseTriggerCallbackName(triggerName) {\r\n    /** @type {?} */\r\n    const dotIndex = triggerName.indexOf('.');\r\n    /** @type {?} */\r\n    const trigger = triggerName.substring(0, dotIndex);\r\n    /** @type {?} */\r\n    const phase = triggerName.substr(dotIndex + 1);\r\n    return [trigger, phase];\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass InjectableAnimationEngine extends ɵAnimationEngine {\r\n    /**\r\n     * @param {?} doc\r\n     * @param {?} driver\r\n     * @param {?} normalizer\r\n     */\r\n    constructor(doc, driver, normalizer) {\r\n        super(doc.body, driver, normalizer);\r\n    }\r\n}\r\nInjectableAnimationEngine.decorators = [\r\n    { type: Injectable }\r\n];\r\n/** @nocollapse */\r\nInjectableAnimationEngine.ctorParameters = () => [\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\r\n    { type: AnimationDriver },\r\n    { type: ɵAnimationStyleNormalizer }\r\n];\r\n/**\r\n * @return {?}\r\n */\r\nfunction instantiateSupportedAnimationDriver() {\r\n    return ɵsupportsWebAnimations() ? new ɵWebAnimationsDriver() : new ɵCssKeyframesDriver();\r\n}\r\n/**\r\n * @return {?}\r\n */\r\nfunction instantiateDefaultStyleNormalizer() {\r\n    return new ɵWebAnimationsStyleNormalizer();\r\n}\r\n/**\r\n * @param {?} renderer\r\n * @param {?} engine\r\n * @param {?} zone\r\n * @return {?}\r\n */\r\nfunction instantiateRendererFactory(renderer, engine, zone) {\r\n    return new AnimationRendererFactory(renderer, engine, zone);\r\n}\r\n/**\r\n * \\@publicApi\r\n * @type {?}\r\n */\r\nconst ANIMATION_MODULE_TYPE = new InjectionToken('AnimationModuleType');\r\n/** @type {?} */\r\nconst SHARED_ANIMATION_PROVIDERS = [\r\n    { provide: AnimationBuilder, useClass: BrowserAnimationBuilder },\r\n    { provide: ɵAnimationStyleNormalizer, useFactory: instantiateDefaultStyleNormalizer },\r\n    { provide: ɵAnimationEngine, useClass: InjectableAnimationEngine }, {\r\n        provide: RendererFactory2,\r\n        useFactory: instantiateRendererFactory,\r\n        deps: [ɵDomRendererFactory2, ɵAnimationEngine, NgZone]\r\n    }\r\n];\r\n/**\r\n * Separate providers from the actual module so that we can do a local modification in Google3 to\r\n * include them in the BrowserModule.\r\n * @type {?}\r\n */\r\nconst BROWSER_ANIMATIONS_PROVIDERS = [\r\n    { provide: AnimationDriver, useFactory: instantiateSupportedAnimationDriver },\r\n    { provide: ANIMATION_MODULE_TYPE, useValue: 'BrowserAnimations' }, ...SHARED_ANIMATION_PROVIDERS\r\n];\r\n/**\r\n * Separate providers from the actual module so that we can do a local modification in Google3 to\r\n * include them in the BrowserTestingModule.\r\n * @type {?}\r\n */\r\nconst BROWSER_NOOP_ANIMATIONS_PROVIDERS = [\r\n    { provide: AnimationDriver, useClass: ɵNoopAnimationDriver },\r\n    { provide: ANIMATION_MODULE_TYPE, useValue: 'NoopAnimations' }, ...SHARED_ANIMATION_PROVIDERS\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Exports `BrowserModule` with additional [dependency-injection providers](guide/glossary#provider)\r\n * for use with animations. See [Animations](guide/animations).\r\n * \\@publicApi\r\n */\r\nclass BrowserAnimationsModule {\r\n}\r\nBrowserAnimationsModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                exports: [BrowserModule],\r\n                providers: BROWSER_ANIMATIONS_PROVIDERS,\r\n            },] }\r\n];\r\n/**\r\n * A null player that must be imported to allow disabling of animations.\r\n * \\@publicApi\r\n */\r\nclass NoopAnimationsModule {\r\n}\r\nNoopAnimationsModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                exports: [BrowserModule],\r\n                providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS,\r\n            },] }\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { BaseAnimationRenderer as ɵangular_packages_platform_browser_animations_animations_f, BROWSER_ANIMATIONS_PROVIDERS as ɵangular_packages_platform_browser_animations_animations_d, BROWSER_NOOP_ANIMATIONS_PROVIDERS as ɵangular_packages_platform_browser_animations_animations_e, instantiateDefaultStyleNormalizer as ɵangular_packages_platform_browser_animations_animations_b, instantiateRendererFactory as ɵangular_packages_platform_browser_animations_animations_c, instantiateSupportedAnimationDriver as ɵangular_packages_platform_browser_animations_animations_a, BrowserAnimationsModule, NoopAnimationsModule, ANIMATION_MODULE_TYPE, BrowserAnimationBuilder as ɵBrowserAnimationBuilder, BrowserAnimationFactory as ɵBrowserAnimationFactory, AnimationRenderer as ɵAnimationRenderer, AnimationRendererFactory as ɵAnimationRendererFactory, InjectableAnimationEngine as ɵInjectableAnimationEngine };\r\n\r\n"]}