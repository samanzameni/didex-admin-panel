{"version":3,"sources":["d:/Angular Project/Didex/didex-admin-panel/node_modules/@angular/core/fesm2015/testing.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;AAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAysGC,6LAGC","file":"testing.js","sourcesContent":["/**\r\n * @license Angular v8.2.14\r\n * (c) 2010-2019 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { getDebugNode, RendererFactory2, InjectionToken, ɵstringify, ɵReflectionCapabilities, Directive, Component, Pipe, NgModule, ɵgetInjectableDef, ɵNG_COMPONENT_DEF, ɵRender3NgModuleRef, LOCALE_ID, ɵDEFAULT_LOCALE_ID, ɵsetLocaleId, ApplicationInitStatus, ɵRender3ComponentFactory, ɵcompileComponent, ɵNG_DIRECTIVE_DEF, ɵcompileDirective, ɵNG_PIPE_DEF, ɵcompilePipe, ɵtransitiveScopesFor, ɵpatchComponentDefWithScope, ɵNG_INJECTOR_DEF, ɵNG_MODULE_DEF, ɵcompileNgModuleDefs, NgZone, Compiler, COMPILER_OPTIONS, ɵNgModuleFactory, ModuleWithComponentFactories, Injector, InjectFlags, ɵresetCompiledComponents, ɵflushModuleScopingQueueAsMuchAsPossible, Injectable, ɵclearOverrides, ɵoverrideComponentView, ɵAPP_ROOT, Optional, SkipSelf, ɵoverrideProvider, ɵivyEnabled } from '@angular/core';\r\nimport { __awaiter } from 'tslib';\r\nimport { ResourceLoader } from '@angular/compiler';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** @type {?} */\r\nconst _global = (/** @type {?} */ ((typeof window === 'undefined' ? global : window)));\r\n/**\r\n * Wraps a test function in an asynchronous test zone. The test will automatically\r\n * complete when all asynchronous calls within this zone are done. Can be used\r\n * to wrap an {\\@link inject} call.\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * it('...', async(inject([AClass], (object) => {\r\n *   object.doSomething.then(() => {\r\n *     expect(...);\r\n *   })\r\n * });\r\n * ```\r\n *\r\n *\r\n * @param {?} fn\r\n * @return {?}\r\n */\r\nfunction asyncFallback(fn) {\r\n    // If we're running using the Jasmine test framework, adapt to call the 'done'\r\n    // function when asynchronous activity is finished.\r\n    if (_global.jasmine) {\r\n        // Not using an arrow function to preserve context passed from call site\r\n        return (/**\r\n         * @this {?}\r\n         * @param {?} done\r\n         * @return {?}\r\n         */\r\n        function (done) {\r\n            if (!done) {\r\n                // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\r\n                // fake it here and assume sync.\r\n                done = (/**\r\n                 * @return {?}\r\n                 */\r\n                function () { });\r\n                done.fail = (/**\r\n                 * @param {?} e\r\n                 * @return {?}\r\n                 */\r\n                function (e) { throw e; });\r\n            }\r\n            runInTestZone(fn, this, done, (/**\r\n             * @param {?} err\r\n             * @return {?}\r\n             */\r\n            (err) => {\r\n                if (typeof err === 'string') {\r\n                    return done.fail(new Error((/** @type {?} */ (err))));\r\n                }\r\n                else {\r\n                    done.fail(err);\r\n                }\r\n            }));\r\n        });\r\n    }\r\n    // Otherwise, return a promise which will resolve when asynchronous activity\r\n    // is finished. This will be correctly consumed by the Mocha framework with\r\n    // it('...', async(myFn)); or can be used in a custom framework.\r\n    // Not using an arrow function to preserve context passed from call site\r\n    return (/**\r\n     * @this {?}\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        return new Promise((/**\r\n         * @param {?} finishCallback\r\n         * @param {?} failCallback\r\n         * @return {?}\r\n         */\r\n        (finishCallback, failCallback) => {\r\n            runInTestZone(fn, this, finishCallback, failCallback);\r\n        }));\r\n    });\r\n}\r\n/**\r\n * @param {?} fn\r\n * @param {?} context\r\n * @param {?} finishCallback\r\n * @param {?} failCallback\r\n * @return {?}\r\n */\r\nfunction runInTestZone(fn, context, finishCallback, failCallback) {\r\n    /** @type {?} */\r\n    const currentZone = Zone.current;\r\n    /** @type {?} */\r\n    const AsyncTestZoneSpec = ((/** @type {?} */ (Zone)))['AsyncTestZoneSpec'];\r\n    if (AsyncTestZoneSpec === undefined) {\r\n        throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\r\n            'Please make sure that your environment includes zone.js/dist/async-test.js');\r\n    }\r\n    /** @type {?} */\r\n    const ProxyZoneSpec = (/** @type {?} */ (((/** @type {?} */ (Zone)))['ProxyZoneSpec']));\r\n    if (ProxyZoneSpec === undefined) {\r\n        throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\r\n            'Please make sure that your environment includes zone.js/dist/proxy.js');\r\n    }\r\n    /** @type {?} */\r\n    const proxyZoneSpec = ProxyZoneSpec.get();\r\n    ProxyZoneSpec.assertPresent();\r\n    // We need to create the AsyncTestZoneSpec outside the ProxyZone.\r\n    // If we do it in ProxyZone then we will get to infinite recursion.\r\n    /** @type {?} */\r\n    const proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\r\n    /** @type {?} */\r\n    const previousDelegate = proxyZoneSpec.getDelegate();\r\n    (/** @type {?} */ ((/** @type {?} */ (proxyZone)).parent)).run((/**\r\n     * @return {?}\r\n     */\r\n    () => {\r\n        /** @type {?} */\r\n        const testZoneSpec = new AsyncTestZoneSpec((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            // Need to restore the original zone.\r\n            currentZone.run((/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                if (proxyZoneSpec.getDelegate() == testZoneSpec) {\r\n                    // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\r\n                    proxyZoneSpec.setDelegate(previousDelegate);\r\n                }\r\n                finishCallback();\r\n            }));\r\n        }), (/**\r\n         * @param {?} error\r\n         * @return {?}\r\n         */\r\n        (error) => {\r\n            // Need to restore the original zone.\r\n            currentZone.run((/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                if (proxyZoneSpec.getDelegate() == testZoneSpec) {\r\n                    // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\r\n                    proxyZoneSpec.setDelegate(previousDelegate);\r\n                }\r\n                failCallback(error);\r\n            }));\r\n        }), 'test');\r\n        proxyZoneSpec.setDelegate(testZoneSpec);\r\n    }));\r\n    return Zone.current.runGuarded(fn, context);\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Wraps a test function in an asynchronous test zone. The test will automatically\r\n * complete when all asynchronous calls within this zone are done. Can be used\r\n * to wrap an {\\@link inject} call.\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * it('...', async(inject([AClass], (object) => {\r\n *   object.doSomething.then(() => {\r\n *     expect(...);\r\n *   })\r\n * });\r\n * ```\r\n *\r\n * \\@publicApi\r\n * @param {?} fn\r\n * @return {?}\r\n */\r\nfunction async(fn) {\r\n    /** @type {?} */\r\n    const _Zone = typeof Zone !== 'undefined' ? Zone : null;\r\n    if (!_Zone) {\r\n        return (/**\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            return Promise.reject('Zone is needed for the async() test helper but could not be found. ' +\r\n                'Please make sure that your environment includes zone.js/dist/zone.js');\r\n        });\r\n    }\r\n    /** @type {?} */\r\n    const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\r\n    if (typeof asyncTest === 'function') {\r\n        return asyncTest(fn);\r\n    }\r\n    // not using new version of zone.js\r\n    // TODO @JiaLiPassion, remove this after all library updated to\r\n    // newest version of zone.js(0.8.25)\r\n    return asyncFallback(fn);\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Fixture for debugging and testing a component.\r\n *\r\n * \\@publicApi\r\n * @template T\r\n */\r\nclass ComponentFixture {\r\n    /**\r\n     * @param {?} componentRef\r\n     * @param {?} ngZone\r\n     * @param {?} _autoDetect\r\n     */\r\n    constructor(componentRef, ngZone, _autoDetect) {\r\n        this.componentRef = componentRef;\r\n        this.ngZone = ngZone;\r\n        this._autoDetect = _autoDetect;\r\n        this._isStable = true;\r\n        this._isDestroyed = false;\r\n        this._resolve = null;\r\n        this._promise = null;\r\n        this._onUnstableSubscription = null;\r\n        this._onStableSubscription = null;\r\n        this._onMicrotaskEmptySubscription = null;\r\n        this._onErrorSubscription = null;\r\n        this.changeDetectorRef = componentRef.changeDetectorRef;\r\n        this.elementRef = componentRef.location;\r\n        this.debugElement = (/** @type {?} */ (getDebugNode(this.elementRef.nativeElement)));\r\n        this.componentInstance = componentRef.instance;\r\n        this.nativeElement = this.elementRef.nativeElement;\r\n        this.componentRef = componentRef;\r\n        this.ngZone = ngZone;\r\n        if (ngZone) {\r\n            // Create subscriptions outside the NgZone so that the callbacks run oustide\r\n            // of NgZone.\r\n            ngZone.runOutsideAngular((/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                this._onUnstableSubscription =\r\n                    ngZone.onUnstable.subscribe({ next: (/**\r\n                         * @return {?}\r\n                         */\r\n                        () => { this._isStable = false; }) });\r\n                this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({\r\n                    next: (/**\r\n                     * @return {?}\r\n                     */\r\n                    () => {\r\n                        if (this._autoDetect) {\r\n                            // Do a change detection run with checkNoChanges set to true to check\r\n                            // there are no changes on the second run.\r\n                            this.detectChanges(true);\r\n                        }\r\n                    })\r\n                });\r\n                this._onStableSubscription = ngZone.onStable.subscribe({\r\n                    next: (/**\r\n                     * @return {?}\r\n                     */\r\n                    () => {\r\n                        this._isStable = true;\r\n                        // Check whether there is a pending whenStable() completer to resolve.\r\n                        if (this._promise !== null) {\r\n                            // If so check whether there are no pending macrotasks before resolving.\r\n                            // Do this check in the next tick so that ngZone gets a chance to update the state of\r\n                            // pending macrotasks.\r\n                            scheduleMicroTask((/**\r\n                             * @return {?}\r\n                             */\r\n                            () => {\r\n                                if (!ngZone.hasPendingMacrotasks) {\r\n                                    if (this._promise !== null) {\r\n                                        (/** @type {?} */ (this._resolve))(true);\r\n                                        this._resolve = null;\r\n                                        this._promise = null;\r\n                                    }\r\n                                }\r\n                            }));\r\n                        }\r\n                    })\r\n                });\r\n                this._onErrorSubscription =\r\n                    ngZone.onError.subscribe({ next: (/**\r\n                         * @param {?} error\r\n                         * @return {?}\r\n                         */\r\n                        (error) => { throw error; }) });\r\n            }));\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} checkNoChanges\r\n     * @return {?}\r\n     */\r\n    _tick(checkNoChanges) {\r\n        this.changeDetectorRef.detectChanges();\r\n        if (checkNoChanges) {\r\n            this.checkNoChanges();\r\n        }\r\n    }\r\n    /**\r\n     * Trigger a change detection cycle for the component.\r\n     * @param {?=} checkNoChanges\r\n     * @return {?}\r\n     */\r\n    detectChanges(checkNoChanges = true) {\r\n        if (this.ngZone != null) {\r\n            // Run the change detection inside the NgZone so that any async tasks as part of the change\r\n            // detection are captured by the zone and can be waited for in isStable.\r\n            this.ngZone.run((/**\r\n             * @return {?}\r\n             */\r\n            () => { this._tick(checkNoChanges); }));\r\n        }\r\n        else {\r\n            // Running without zone. Just do the change detection.\r\n            this._tick(checkNoChanges);\r\n        }\r\n    }\r\n    /**\r\n     * Do a change detection run to make sure there were no changes.\r\n     * @return {?}\r\n     */\r\n    checkNoChanges() { this.changeDetectorRef.checkNoChanges(); }\r\n    /**\r\n     * Set whether the fixture should autodetect changes.\r\n     *\r\n     * Also runs detectChanges once so that any existing change is detected.\r\n     * @param {?=} autoDetect\r\n     * @return {?}\r\n     */\r\n    autoDetectChanges(autoDetect = true) {\r\n        if (this.ngZone == null) {\r\n            throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\r\n        }\r\n        this._autoDetect = autoDetect;\r\n        this.detectChanges();\r\n    }\r\n    /**\r\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\r\n     * yet.\r\n     * @return {?}\r\n     */\r\n    isStable() { return this._isStable && !(/** @type {?} */ (this.ngZone)).hasPendingMacrotasks; }\r\n    /**\r\n     * Get a promise that resolves when the fixture is stable.\r\n     *\r\n     * This can be used to resume testing after events have triggered asynchronous activity or\r\n     * asynchronous change detection.\r\n     * @return {?}\r\n     */\r\n    whenStable() {\r\n        if (this.isStable()) {\r\n            return Promise.resolve(false);\r\n        }\r\n        else if (this._promise !== null) {\r\n            return this._promise;\r\n        }\r\n        else {\r\n            this._promise = new Promise((/**\r\n             * @param {?} res\r\n             * @return {?}\r\n             */\r\n            res => { this._resolve = res; }));\r\n            return this._promise;\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _getRenderer() {\r\n        if (this._renderer === undefined) {\r\n            this._renderer = this.componentRef.injector.get(RendererFactory2, null);\r\n        }\r\n        return (/** @type {?} */ (this._renderer));\r\n    }\r\n    /**\r\n     * Get a promise that resolves when the ui state is stable following animations.\r\n     * @return {?}\r\n     */\r\n    whenRenderingDone() {\r\n        /** @type {?} */\r\n        const renderer = this._getRenderer();\r\n        if (renderer && renderer.whenRenderingDone) {\r\n            return renderer.whenRenderingDone();\r\n        }\r\n        return this.whenStable();\r\n    }\r\n    /**\r\n     * Trigger component destruction.\r\n     * @return {?}\r\n     */\r\n    destroy() {\r\n        if (!this._isDestroyed) {\r\n            this.componentRef.destroy();\r\n            if (this._onUnstableSubscription != null) {\r\n                this._onUnstableSubscription.unsubscribe();\r\n                this._onUnstableSubscription = null;\r\n            }\r\n            if (this._onStableSubscription != null) {\r\n                this._onStableSubscription.unsubscribe();\r\n                this._onStableSubscription = null;\r\n            }\r\n            if (this._onMicrotaskEmptySubscription != null) {\r\n                this._onMicrotaskEmptySubscription.unsubscribe();\r\n                this._onMicrotaskEmptySubscription = null;\r\n            }\r\n            if (this._onErrorSubscription != null) {\r\n                this._onErrorSubscription.unsubscribe();\r\n                this._onErrorSubscription = null;\r\n            }\r\n            this._isDestroyed = true;\r\n        }\r\n    }\r\n}\r\nif (false) {\r\n    /**\r\n     * The DebugElement associated with the root element of this component.\r\n     * @type {?}\r\n     */\r\n    ComponentFixture.prototype.debugElement;\r\n    /**\r\n     * The instance of the root component class.\r\n     * @type {?}\r\n     */\r\n    ComponentFixture.prototype.componentInstance;\r\n    /**\r\n     * The native element at the root of the component.\r\n     * @type {?}\r\n     */\r\n    ComponentFixture.prototype.nativeElement;\r\n    /**\r\n     * The ElementRef for the element at the root of the component.\r\n     * @type {?}\r\n     */\r\n    ComponentFixture.prototype.elementRef;\r\n    /**\r\n     * The ChangeDetectorRef for the component\r\n     * @type {?}\r\n     */\r\n    ComponentFixture.prototype.changeDetectorRef;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ComponentFixture.prototype._renderer;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ComponentFixture.prototype._isStable;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ComponentFixture.prototype._isDestroyed;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ComponentFixture.prototype._resolve;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ComponentFixture.prototype._promise;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ComponentFixture.prototype._onUnstableSubscription;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ComponentFixture.prototype._onStableSubscription;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ComponentFixture.prototype._onMicrotaskEmptySubscription;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ComponentFixture.prototype._onErrorSubscription;\r\n    /** @type {?} */\r\n    ComponentFixture.prototype.componentRef;\r\n    /** @type {?} */\r\n    ComponentFixture.prototype.ngZone;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    ComponentFixture.prototype._autoDetect;\r\n}\r\n/**\r\n * @param {?} fn\r\n * @return {?}\r\n */\r\nfunction scheduleMicroTask(fn) {\r\n    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * fakeAsync has been moved to zone.js\r\n * this file is for fallback in case old version of zone.js is used\r\n * @type {?}\r\n */\r\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\r\n/** @type {?} */\r\nconst FakeAsyncTestZoneSpec = _Zone && _Zone['FakeAsyncTestZoneSpec'];\r\n/** @type {?} */\r\nconst ProxyZoneSpec = _Zone && _Zone['ProxyZoneSpec'];\r\n/** @type {?} */\r\nlet _fakeAsyncTestZoneSpec = null;\r\n/**\r\n * Clears out the shared fake async zone for a test.\r\n * To be called in a global `beforeEach`.\r\n *\r\n * \\@publicApi\r\n * @return {?}\r\n */\r\nfunction resetFakeAsyncZoneFallback() {\r\n    _fakeAsyncTestZoneSpec = null;\r\n    // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\r\n    ProxyZoneSpec && ProxyZoneSpec.assertPresent().resetDelegate();\r\n}\r\n/** @type {?} */\r\nlet _inFakeAsyncCall = false;\r\n/**\r\n * Wraps a function to be executed in the fakeAsync zone:\r\n * - microtasks are manually executed by calling `flushMicrotasks()`,\r\n * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\r\n *\r\n * If there are any pending timers at the end of the function, an exception will be thrown.\r\n *\r\n * Can be used to wrap inject() calls.\r\n *\r\n * \\@usageNotes\r\n * ### Example\r\n *\r\n * {\\@example core/testing/ts/fake_async.ts region='basic'}\r\n *\r\n * \\@publicApi\r\n * @param {?} fn\r\n * @return {?} The function wrapped to be executed in the fakeAsync zone\r\n *\r\n */\r\nfunction fakeAsyncFallback(fn) {\r\n    // Not using an arrow function to preserve context passed from call site\r\n    return (/**\r\n     * @this {?}\r\n     * @param {...?} args\r\n     * @return {?}\r\n     */\r\n    function (...args) {\r\n        /** @type {?} */\r\n        const proxyZoneSpec = ProxyZoneSpec.assertPresent();\r\n        if (_inFakeAsyncCall) {\r\n            throw new Error('fakeAsync() calls can not be nested');\r\n        }\r\n        _inFakeAsyncCall = true;\r\n        try {\r\n            if (!_fakeAsyncTestZoneSpec) {\r\n                if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\r\n                    throw new Error('fakeAsync() calls can not be nested');\r\n                }\r\n                _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\r\n            }\r\n            /** @type {?} */\r\n            let res;\r\n            /** @type {?} */\r\n            const lastProxyZoneSpec = proxyZoneSpec.getDelegate();\r\n            proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\r\n            try {\r\n                res = fn.apply(this, args);\r\n                flushMicrotasksFallback();\r\n            }\r\n            finally {\r\n                proxyZoneSpec.setDelegate(lastProxyZoneSpec);\r\n            }\r\n            if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\r\n                throw new Error(`${_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length} ` +\r\n                    `periodic timer(s) still in the queue.`);\r\n            }\r\n            if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\r\n                throw new Error(`${_fakeAsyncTestZoneSpec.pendingTimers.length} timer(s) still in the queue.`);\r\n            }\r\n            return res;\r\n        }\r\n        finally {\r\n            _inFakeAsyncCall = false;\r\n            resetFakeAsyncZoneFallback();\r\n        }\r\n    });\r\n}\r\n/**\r\n * @return {?}\r\n */\r\nfunction _getFakeAsyncZoneSpec() {\r\n    if (_fakeAsyncTestZoneSpec == null) {\r\n        throw new Error('The code should be running in the fakeAsync zone to call this function');\r\n    }\r\n    return _fakeAsyncTestZoneSpec;\r\n}\r\n/**\r\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\r\n *\r\n * The microtasks queue is drained at the very start of this function and after any timer callback\r\n * has been executed.\r\n *\r\n * \\@usageNotes\r\n * ### Example\r\n *\r\n * {\\@example core/testing/ts/fake_async.ts region='basic'}\r\n *\r\n * \\@publicApi\r\n * @param {?=} millis\r\n * @return {?}\r\n */\r\nfunction tickFallback(millis = 0) {\r\n    _getFakeAsyncZoneSpec().tick(millis);\r\n}\r\n/**\r\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\r\n * draining the macrotask queue until it is empty. The returned value is the milliseconds\r\n * of time that would have been elapsed.\r\n *\r\n * \\@publicApi\r\n * @param {?=} maxTurns\r\n * @return {?} The simulated time elapsed, in millis.\r\n *\r\n */\r\nfunction flushFallback(maxTurns) {\r\n    return _getFakeAsyncZoneSpec().flush(maxTurns);\r\n}\r\n/**\r\n * Discard all remaining periodic tasks.\r\n *\r\n * \\@publicApi\r\n * @return {?}\r\n */\r\nfunction discardPeriodicTasksFallback() {\r\n    /** @type {?} */\r\n    const zoneSpec = _getFakeAsyncZoneSpec();\r\n    zoneSpec.pendingPeriodicTimers.length = 0;\r\n}\r\n/**\r\n * Flush any pending microtasks.\r\n *\r\n * \\@publicApi\r\n * @return {?}\r\n */\r\nfunction flushMicrotasksFallback() {\r\n    _getFakeAsyncZoneSpec().flushMicrotasks();\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @type {?} */\r\nconst _Zone$1 = typeof Zone !== 'undefined' ? Zone : null;\r\n/** @type {?} */\r\nconst fakeAsyncTestModule = _Zone$1 && _Zone$1[_Zone$1.__symbol__('fakeAsyncTest')];\r\n/**\r\n * Clears out the shared fake async zone for a test.\r\n * To be called in a global `beforeEach`.\r\n *\r\n * \\@publicApi\r\n * @return {?}\r\n */\r\nfunction resetFakeAsyncZone() {\r\n    if (fakeAsyncTestModule) {\r\n        return fakeAsyncTestModule.resetFakeAsyncZone();\r\n    }\r\n    else {\r\n        return resetFakeAsyncZoneFallback();\r\n    }\r\n}\r\n/**\r\n * Wraps a function to be executed in the fakeAsync zone:\r\n * - microtasks are manually executed by calling `flushMicrotasks()`,\r\n * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\r\n *\r\n * If there are any pending timers at the end of the function, an exception will be thrown.\r\n *\r\n * Can be used to wrap inject() calls.\r\n *\r\n * \\@usageNotes\r\n * ### Example\r\n *\r\n * {\\@example core/testing/ts/fake_async.ts region='basic'}\r\n *\r\n * \\@publicApi\r\n * @param {?} fn\r\n * @return {?} The function wrapped to be executed in the fakeAsync zone\r\n *\r\n */\r\nfunction fakeAsync(fn) {\r\n    if (fakeAsyncTestModule) {\r\n        return fakeAsyncTestModule.fakeAsync(fn);\r\n    }\r\n    else {\r\n        return fakeAsyncFallback(fn);\r\n    }\r\n}\r\n/**\r\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\r\n *\r\n * The microtasks queue is drained at the very start of this function and after any timer callback\r\n * has been executed.\r\n *\r\n * \\@usageNotes\r\n * ### Example\r\n *\r\n * {\\@example core/testing/ts/fake_async.ts region='basic'}\r\n *\r\n * \\@publicApi\r\n * @param {?=} millis\r\n * @return {?}\r\n */\r\nfunction tick(millis = 0) {\r\n    if (fakeAsyncTestModule) {\r\n        return fakeAsyncTestModule.tick(millis);\r\n    }\r\n    else {\r\n        return tickFallback(millis);\r\n    }\r\n}\r\n/**\r\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\r\n * draining the macrotask queue until it is empty. The returned value is the milliseconds\r\n * of time that would have been elapsed.\r\n *\r\n * \\@publicApi\r\n * @param {?=} maxTurns\r\n * @return {?} The simulated time elapsed, in millis.\r\n *\r\n */\r\nfunction flush(maxTurns) {\r\n    if (fakeAsyncTestModule) {\r\n        return fakeAsyncTestModule.flush(maxTurns);\r\n    }\r\n    else {\r\n        return flushFallback(maxTurns);\r\n    }\r\n}\r\n/**\r\n * Discard all remaining periodic tasks.\r\n *\r\n * \\@publicApi\r\n * @return {?}\r\n */\r\nfunction discardPeriodicTasks() {\r\n    if (fakeAsyncTestModule) {\r\n        return fakeAsyncTestModule.discardPeriodicTasks();\r\n    }\r\n    else {\r\n        discardPeriodicTasksFallback();\r\n    }\r\n}\r\n/**\r\n * Flush any pending microtasks.\r\n *\r\n * \\@publicApi\r\n * @return {?}\r\n */\r\nfunction flushMicrotasks() {\r\n    if (fakeAsyncTestModule) {\r\n        return fakeAsyncTestModule.flushMicrotasks();\r\n    }\r\n    else {\r\n        return flushMicrotasksFallback();\r\n    }\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Injectable completer that allows signaling completion of an asynchronous test. Used internally.\r\n */\r\nclass AsyncTestCompleter {\r\n    constructor() {\r\n        this._promise = new Promise((/**\r\n         * @param {?} res\r\n         * @param {?} rej\r\n         * @return {?}\r\n         */\r\n        (res, rej) => {\r\n            this._resolve = res;\r\n            this._reject = rej;\r\n        }));\r\n    }\r\n    /**\r\n     * @param {?=} value\r\n     * @return {?}\r\n     */\r\n    done(value) { this._resolve(value); }\r\n    /**\r\n     * @param {?=} error\r\n     * @param {?=} stackTrace\r\n     * @return {?}\r\n     */\r\n    fail(error, stackTrace) { this._reject(error); }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get promise() { return this._promise; }\r\n}\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    AsyncTestCompleter.prototype._resolve;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    AsyncTestCompleter.prototype._reject;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    AsyncTestCompleter.prototype._promise;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * An abstract class for inserting the root test component element in a platform independent way.\r\n *\r\n * \\@publicApi\r\n */\r\nclass TestComponentRenderer {\r\n    /**\r\n     * @param {?} rootElementId\r\n     * @return {?}\r\n     */\r\n    insertRootElement(rootElementId) { }\r\n}\r\n/**\r\n * \\@publicApi\r\n * @type {?}\r\n */\r\nconst ComponentFixtureAutoDetect = new InjectionToken('ComponentFixtureAutoDetect');\r\n/**\r\n * \\@publicApi\r\n * @type {?}\r\n */\r\nconst ComponentFixtureNoNgZone = new InjectionToken('ComponentFixtureNoNgZone');\r\n/**\r\n * Static methods implemented by the `TestBedViewEngine` and `TestBedRender3`\r\n *\r\n * \\@publicApi\r\n * @record\r\n */\r\nfunction TestBedStatic() { }\r\nif (false) {\r\n    /* Skipping unhandled member: new (...args: any[]): TestBed;*/\r\n    /**\r\n     * @param {?} ngModule\r\n     * @param {?} platform\r\n     * @param {?=} aotSummaries\r\n     * @return {?}\r\n     */\r\n    TestBedStatic.prototype.initTestEnvironment = function (ngModule, platform, aotSummaries) { };\r\n    /**\r\n     * Reset the providers for the test injector.\r\n     * @return {?}\r\n     */\r\n    TestBedStatic.prototype.resetTestEnvironment = function () { };\r\n    /**\r\n     * @return {?}\r\n     */\r\n    TestBedStatic.prototype.resetTestingModule = function () { };\r\n    /**\r\n     * Allows overriding default compiler providers and settings\r\n     * which are defined in test_injector.js\r\n     * @param {?} config\r\n     * @return {?}\r\n     */\r\n    TestBedStatic.prototype.configureCompiler = function (config) { };\r\n    /**\r\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\r\n     * which are defined in test_injector.js\r\n     * @param {?} moduleDef\r\n     * @return {?}\r\n     */\r\n    TestBedStatic.prototype.configureTestingModule = function (moduleDef) { };\r\n    /**\r\n     * Compile components with a `templateUrl` for the test's NgModule.\r\n     * It is necessary to call this function\r\n     * as fetching urls is asynchronous.\r\n     * @return {?}\r\n     */\r\n    TestBedStatic.prototype.compileComponents = function () { };\r\n    /**\r\n     * @param {?} ngModule\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    TestBedStatic.prototype.overrideModule = function (ngModule, override) { };\r\n    /**\r\n     * @param {?} component\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    TestBedStatic.prototype.overrideComponent = function (component, override) { };\r\n    /**\r\n     * @param {?} directive\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    TestBedStatic.prototype.overrideDirective = function (directive, override) { };\r\n    /**\r\n     * @param {?} pipe\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    TestBedStatic.prototype.overridePipe = function (pipe, override) { };\r\n    /**\r\n     * @param {?} component\r\n     * @param {?} template\r\n     * @return {?}\r\n     */\r\n    TestBedStatic.prototype.overrideTemplate = function (component, template) { };\r\n    /**\r\n     * Overrides the template of the given component, compiling the template\r\n     * in the context of the TestingModule.\r\n     *\r\n     * Note: This works for JIT and AOTed components as well.\r\n     * @param {?} component\r\n     * @param {?} template\r\n     * @return {?}\r\n     */\r\n    TestBedStatic.prototype.overrideTemplateUsingTestingModule = function (component, template) { };\r\n    /**\r\n     * Overwrites all providers for the given token with the given provider definition.\r\n     *\r\n     * Note: This works for JIT and AOTed components as well.\r\n     * @param {?} token\r\n     * @param {?} provider\r\n     * @return {?}\r\n     */\r\n    TestBedStatic.prototype.overrideProvider = function (token, provider) { };\r\n    /**\r\n     * @param {?} token\r\n     * @param {?} provider\r\n     * @return {?}\r\n     */\r\n    TestBedStatic.prototype.overrideProvider = function (token, provider) { };\r\n    /**\r\n     * @param {?} token\r\n     * @param {?} provider\r\n     * @return {?}\r\n     */\r\n    TestBedStatic.prototype.overrideProvider = function (token, provider) { };\r\n    /**\r\n     * @template T\r\n     * @param {?} token\r\n     * @param {?=} notFoundValue\r\n     * @param {?=} flags\r\n     * @return {?}\r\n     */\r\n    TestBedStatic.prototype.get = function (token, notFoundValue, flags) { };\r\n    /**\r\n     * deprecated from v8.0.0 use Type<T> or InjectionToken<T>\r\n     * This does not use the deprecated jsdoc tag on purpose\r\n     * because it renders all overloads as deprecated in TSLint\r\n     * due to https://github.com/palantir/tslint/issues/4522.\r\n     * @param {?} token\r\n     * @param {?=} notFoundValue\r\n     * @return {?}\r\n     */\r\n    TestBedStatic.prototype.get = function (token, notFoundValue) { };\r\n    /**\r\n     * @template T\r\n     * @param {?} component\r\n     * @return {?}\r\n     */\r\n    TestBedStatic.prototype.createComponent = function (component) { };\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Used to resolve resource URLs on `\\@Component` when used with JIT compilation.\r\n *\r\n * Example:\r\n * ```\r\n * \\@Component({\r\n *   selector: 'my-comp',\r\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\r\n * })\r\n * class MyComponent{\r\n * }\r\n *\r\n * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process\r\n * // and `MyComponent`'s `\\@Component.templateUrl` needs to be resolved asynchronously.\r\n *\r\n * // Calling `resolveComponentResources()` will resolve `\\@Component.templateUrl` into\r\n * // `\\@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.\r\n *\r\n * // Use browser's `fetch()` function as the default resource resolution strategy.\r\n * resolveComponentResources(fetch).then(() => {\r\n *   // After resolution all URLs have been converted into `template` strings.\r\n *   renderComponent(MyComponent);\r\n * });\r\n *\r\n * ```\r\n *\r\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\r\n * to call this method outside JIT mode.\r\n *\r\n * @param {?} resourceResolver a function which is responsible for returning a `Promise` to the\r\n * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.\r\n * @return {?}\r\n */\r\nfunction resolveComponentResources(resourceResolver) {\r\n    // Store all promises which are fetching the resources.\r\n    /** @type {?} */\r\n    const componentResolved = [];\r\n    // Cache so that we don't fetch the same resource more than once.\r\n    /** @type {?} */\r\n    const urlMap = new Map();\r\n    /**\r\n     * @param {?} url\r\n     * @return {?}\r\n     */\r\n    function cachedResourceResolve(url) {\r\n        /** @type {?} */\r\n        let promise = urlMap.get(url);\r\n        if (!promise) {\r\n            /** @type {?} */\r\n            const resp = resourceResolver(url);\r\n            urlMap.set(url, promise = resp.then(unwrapResponse));\r\n        }\r\n        return promise;\r\n    }\r\n    componentResourceResolutionQueue.forEach((/**\r\n     * @param {?} component\r\n     * @param {?} type\r\n     * @return {?}\r\n     */\r\n    (component, type) => {\r\n        /** @type {?} */\r\n        const promises = [];\r\n        if (component.templateUrl) {\r\n            promises.push(cachedResourceResolve(component.templateUrl).then((/**\r\n             * @param {?} template\r\n             * @return {?}\r\n             */\r\n            (template) => {\r\n                component.template = template;\r\n            })));\r\n        }\r\n        /** @type {?} */\r\n        const styleUrls = component.styleUrls;\r\n        /** @type {?} */\r\n        const styles = component.styles || (component.styles = []);\r\n        /** @type {?} */\r\n        const styleOffset = component.styles.length;\r\n        styleUrls && styleUrls.forEach((/**\r\n         * @param {?} styleUrl\r\n         * @param {?} index\r\n         * @return {?}\r\n         */\r\n        (styleUrl, index) => {\r\n            styles.push(''); // pre-allocate array.\r\n            promises.push(cachedResourceResolve(styleUrl).then((/**\r\n             * @param {?} style\r\n             * @return {?}\r\n             */\r\n            (style) => {\r\n                styles[styleOffset + index] = style;\r\n                styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\r\n                if (styleUrls.length == 0) {\r\n                    component.styleUrls = undefined;\r\n                }\r\n            })));\r\n        }));\r\n        /** @type {?} */\r\n        const fullyResolved = Promise.all(promises).then((/**\r\n         * @return {?}\r\n         */\r\n        () => componentDefResolved(type)));\r\n        componentResolved.push(fullyResolved);\r\n    }));\r\n    clearResolutionOfComponentResourcesQueue();\r\n    return Promise.all(componentResolved).then((/**\r\n     * @return {?}\r\n     */\r\n    () => undefined));\r\n}\r\n/** @type {?} */\r\nlet componentResourceResolutionQueue = new Map();\r\n// Track when existing ngComponentDef for a Type is waiting on resources.\r\n/** @type {?} */\r\nconst componentDefPendingResolution = new Set();\r\n/**\r\n * @param {?} type\r\n * @param {?} metadata\r\n * @return {?}\r\n */\r\nfunction maybeQueueResolutionOfComponentResources(type, metadata) {\r\n    if (componentNeedsResolution(metadata)) {\r\n        componentResourceResolutionQueue.set(type, metadata);\r\n        componentDefPendingResolution.add(type);\r\n    }\r\n}\r\n/**\r\n * @param {?} type\r\n * @return {?}\r\n */\r\nfunction isComponentDefPendingResolution(type) {\r\n    return componentDefPendingResolution.has(type);\r\n}\r\n/**\r\n * @param {?} component\r\n * @return {?}\r\n */\r\nfunction componentNeedsResolution(component) {\r\n    return !!((component.templateUrl && !component.hasOwnProperty('template')) ||\r\n        component.styleUrls && component.styleUrls.length);\r\n}\r\n/**\r\n * @return {?}\r\n */\r\nfunction clearResolutionOfComponentResourcesQueue() {\r\n    /** @type {?} */\r\n    const old = componentResourceResolutionQueue;\r\n    componentResourceResolutionQueue = new Map();\r\n    return old;\r\n}\r\n/**\r\n * @param {?} queue\r\n * @return {?}\r\n */\r\nfunction restoreComponentResolutionQueue(queue) {\r\n    componentDefPendingResolution.clear();\r\n    queue.forEach((/**\r\n     * @param {?} _\r\n     * @param {?} type\r\n     * @return {?}\r\n     */\r\n    (_, type) => componentDefPendingResolution.add(type)));\r\n    componentResourceResolutionQueue = queue;\r\n}\r\n/**\r\n * @return {?}\r\n */\r\nfunction isComponentResourceResolutionQueueEmpty() {\r\n    return componentResourceResolutionQueue.size === 0;\r\n}\r\n/**\r\n * @param {?} response\r\n * @return {?}\r\n */\r\nfunction unwrapResponse(response) {\r\n    return typeof response == 'string' ? response : response.text();\r\n}\r\n/**\r\n * @param {?} type\r\n * @return {?}\r\n */\r\nfunction componentDefResolved(type) {\r\n    componentDefPendingResolution.delete(type);\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @type {?} */\r\nlet _nextReferenceId = 0;\r\nclass MetadataOverrider {\r\n    constructor() {\r\n        this._references = new Map();\r\n    }\r\n    /**\r\n     * Creates a new instance for the given metadata class\r\n     * based on an old instance and overrides.\r\n     * @template C, T\r\n     * @param {?} metadataClass\r\n     * @param {?} oldMetadata\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    overrideMetadata(metadataClass, oldMetadata, override) {\r\n        /** @type {?} */\r\n        const props = {};\r\n        if (oldMetadata) {\r\n            _valueProps(oldMetadata).forEach((/**\r\n             * @param {?} prop\r\n             * @return {?}\r\n             */\r\n            (prop) => props[prop] = ((/** @type {?} */ (oldMetadata)))[prop]));\r\n        }\r\n        if (override.set) {\r\n            if (override.remove || override.add) {\r\n                throw new Error(`Cannot set and add/remove ${ɵstringify(metadataClass)} at the same time!`);\r\n            }\r\n            setMetadata(props, override.set);\r\n        }\r\n        if (override.remove) {\r\n            removeMetadata(props, override.remove, this._references);\r\n        }\r\n        if (override.add) {\r\n            addMetadata(props, override.add);\r\n        }\r\n        return new metadataClass((/** @type {?} */ (props)));\r\n    }\r\n}\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MetadataOverrider.prototype._references;\r\n}\r\n/**\r\n * @param {?} metadata\r\n * @param {?} remove\r\n * @param {?} references\r\n * @return {?}\r\n */\r\nfunction removeMetadata(metadata, remove, references) {\r\n    /** @type {?} */\r\n    const removeObjects = new Set();\r\n    for (const prop in remove) {\r\n        /** @type {?} */\r\n        const removeValue = remove[prop];\r\n        if (removeValue instanceof Array) {\r\n            removeValue.forEach((/**\r\n             * @param {?} value\r\n             * @return {?}\r\n             */\r\n            (value) => { removeObjects.add(_propHashKey(prop, value, references)); }));\r\n        }\r\n        else {\r\n            removeObjects.add(_propHashKey(prop, removeValue, references));\r\n        }\r\n    }\r\n    for (const prop in metadata) {\r\n        /** @type {?} */\r\n        const propValue = metadata[prop];\r\n        if (propValue instanceof Array) {\r\n            metadata[prop] = propValue.filter((/**\r\n             * @param {?} value\r\n             * @return {?}\r\n             */\r\n            (value) => !removeObjects.has(_propHashKey(prop, value, references))));\r\n        }\r\n        else {\r\n            if (removeObjects.has(_propHashKey(prop, propValue, references))) {\r\n                metadata[prop] = undefined;\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * @param {?} metadata\r\n * @param {?} add\r\n * @return {?}\r\n */\r\nfunction addMetadata(metadata, add) {\r\n    for (const prop in add) {\r\n        /** @type {?} */\r\n        const addValue = add[prop];\r\n        /** @type {?} */\r\n        const propValue = metadata[prop];\r\n        if (propValue != null && propValue instanceof Array) {\r\n            metadata[prop] = propValue.concat(addValue);\r\n        }\r\n        else {\r\n            metadata[prop] = addValue;\r\n        }\r\n    }\r\n}\r\n/**\r\n * @param {?} metadata\r\n * @param {?} set\r\n * @return {?}\r\n */\r\nfunction setMetadata(metadata, set) {\r\n    for (const prop in set) {\r\n        metadata[prop] = set[prop];\r\n    }\r\n}\r\n/**\r\n * @param {?} propName\r\n * @param {?} propValue\r\n * @param {?} references\r\n * @return {?}\r\n */\r\nfunction _propHashKey(propName, propValue, references) {\r\n    /** @type {?} */\r\n    const replacer = (/**\r\n     * @param {?} key\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    (key, value) => {\r\n        if (typeof value === 'function') {\r\n            value = _serializeReference(value, references);\r\n        }\r\n        return value;\r\n    });\r\n    return `${propName}:${JSON.stringify(propValue, replacer)}`;\r\n}\r\n/**\r\n * @param {?} ref\r\n * @param {?} references\r\n * @return {?}\r\n */\r\nfunction _serializeReference(ref, references) {\r\n    /** @type {?} */\r\n    let id = references.get(ref);\r\n    if (!id) {\r\n        id = `${ɵstringify(ref)}${_nextReferenceId++}`;\r\n        references.set(ref, id);\r\n    }\r\n    return id;\r\n}\r\n/**\r\n * @param {?} obj\r\n * @return {?}\r\n */\r\nfunction _valueProps(obj) {\r\n    /** @type {?} */\r\n    const props = [];\r\n    // regular public props\r\n    Object.keys(obj).forEach((/**\r\n     * @param {?} prop\r\n     * @return {?}\r\n     */\r\n    (prop) => {\r\n        if (!prop.startsWith('_')) {\r\n            props.push(prop);\r\n        }\r\n    }));\r\n    // getters\r\n    /** @type {?} */\r\n    let proto = obj;\r\n    while (proto = Object.getPrototypeOf(proto)) {\r\n        Object.keys(proto).forEach((/**\r\n         * @param {?} protoProp\r\n         * @return {?}\r\n         */\r\n        (protoProp) => {\r\n            /** @type {?} */\r\n            const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\r\n            if (!protoProp.startsWith('_') && desc && 'get' in desc) {\r\n                props.push(protoProp);\r\n            }\r\n        }));\r\n    }\r\n    return props;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @type {?} */\r\nconst reflection = new ɵReflectionCapabilities();\r\n/**\r\n * Base interface to resolve `\\@Component`, `\\@Directive`, `\\@Pipe` and `\\@NgModule`.\r\n * @record\r\n * @template T\r\n */\r\nfunction Resolver() { }\r\nif (false) {\r\n    /**\r\n     * @param {?} type\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    Resolver.prototype.addOverride = function (type, override) { };\r\n    /**\r\n     * @param {?} overrides\r\n     * @return {?}\r\n     */\r\n    Resolver.prototype.setOverrides = function (overrides) { };\r\n    /**\r\n     * @param {?} type\r\n     * @return {?}\r\n     */\r\n    Resolver.prototype.resolve = function (type) { };\r\n}\r\n/**\r\n * Allows to override ivy metadata for tests (via the `TestBed`).\r\n * @abstract\r\n * @template T\r\n */\r\nclass OverrideResolver {\r\n    constructor() {\r\n        this.overrides = new Map();\r\n        this.resolved = new Map();\r\n    }\r\n    /**\r\n     * @param {?} type\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    addOverride(type, override) {\r\n        /** @type {?} */\r\n        const overrides = this.overrides.get(type) || [];\r\n        overrides.push(override);\r\n        this.overrides.set(type, overrides);\r\n        this.resolved.delete(type);\r\n    }\r\n    /**\r\n     * @param {?} overrides\r\n     * @return {?}\r\n     */\r\n    setOverrides(overrides) {\r\n        this.overrides.clear();\r\n        overrides.forEach((/**\r\n         * @param {?} __0\r\n         * @return {?}\r\n         */\r\n        ([type, override]) => { this.addOverride(type, override); }));\r\n    }\r\n    /**\r\n     * @param {?} type\r\n     * @return {?}\r\n     */\r\n    getAnnotation(type) {\r\n        /** @type {?} */\r\n        const annotations = reflection.annotations(type);\r\n        // Try to find the nearest known Type annotation and make sure that this annotation is an\r\n        // instance of the type we are looking for, so we can use it for resolution. Note: there might\r\n        // be multiple known annotations found due to the fact that Components can extend Directives (so\r\n        // both Directive and Component annotations would be present), so we always check if the known\r\n        // annotation has the right type.\r\n        for (let i = annotations.length - 1; i >= 0; i--) {\r\n            /** @type {?} */\r\n            const annotation = annotations[i];\r\n            /** @type {?} */\r\n            const isKnownType = annotation instanceof Directive || annotation instanceof Component ||\r\n                annotation instanceof Pipe || annotation instanceof NgModule;\r\n            if (isKnownType) {\r\n                return annotation instanceof this.type ? annotation : null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * @param {?} type\r\n     * @return {?}\r\n     */\r\n    resolve(type) {\r\n        /** @type {?} */\r\n        let resolved = this.resolved.get(type) || null;\r\n        if (!resolved) {\r\n            resolved = this.getAnnotation(type);\r\n            if (resolved) {\r\n                /** @type {?} */\r\n                const overrides = this.overrides.get(type);\r\n                if (overrides) {\r\n                    /** @type {?} */\r\n                    const overrider = new MetadataOverrider();\r\n                    overrides.forEach((/**\r\n                     * @param {?} override\r\n                     * @return {?}\r\n                     */\r\n                    override => {\r\n                        resolved = overrider.overrideMetadata(this.type, (/** @type {?} */ (resolved)), override);\r\n                    }));\r\n                }\r\n            }\r\n            this.resolved.set(type, resolved);\r\n        }\r\n        return resolved;\r\n    }\r\n}\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    OverrideResolver.prototype.overrides;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    OverrideResolver.prototype.resolved;\r\n    /**\r\n     * @abstract\r\n     * @return {?}\r\n     */\r\n    OverrideResolver.prototype.type = function () { };\r\n}\r\nclass DirectiveResolver extends OverrideResolver {\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get type() { return Directive; }\r\n}\r\nclass ComponentResolver extends OverrideResolver {\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get type() { return Component; }\r\n}\r\nclass PipeResolver extends OverrideResolver {\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get type() { return Pipe; }\r\n}\r\nclass NgModuleResolver extends OverrideResolver {\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get type() { return NgModule; }\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @enum {number} */\r\nconst TestingModuleOverride = {\r\n    DECLARATION: 0,\r\n    OVERRIDE_TEMPLATE: 1,\r\n};\r\nTestingModuleOverride[TestingModuleOverride.DECLARATION] = 'DECLARATION';\r\nTestingModuleOverride[TestingModuleOverride.OVERRIDE_TEMPLATE] = 'OVERRIDE_TEMPLATE';\r\n/**\r\n * @param {?} value\r\n * @return {?}\r\n */\r\nfunction isTestingModuleOverride(value) {\r\n    return value === TestingModuleOverride.DECLARATION ||\r\n        value === TestingModuleOverride.OVERRIDE_TEMPLATE;\r\n}\r\n/**\r\n * @record\r\n */\r\nfunction CleanupOperation() { }\r\nif (false) {\r\n    /** @type {?} */\r\n    CleanupOperation.prototype.field;\r\n    /** @type {?} */\r\n    CleanupOperation.prototype.def;\r\n    /** @type {?} */\r\n    CleanupOperation.prototype.original;\r\n}\r\nclass R3TestBedCompiler {\r\n    /**\r\n     * @param {?} platform\r\n     * @param {?} additionalModuleTypes\r\n     */\r\n    constructor(platform, additionalModuleTypes) {\r\n        this.platform = platform;\r\n        this.additionalModuleTypes = additionalModuleTypes;\r\n        this.originalComponentResolutionQueue = null;\r\n        // Testing module configuration\r\n        this.declarations = [];\r\n        this.imports = [];\r\n        this.providers = [];\r\n        this.schemas = [];\r\n        // Queues of components/directives/pipes that should be recompiled.\r\n        this.pendingComponents = new Set();\r\n        this.pendingDirectives = new Set();\r\n        this.pendingPipes = new Set();\r\n        // Keep track of all components and directives, so we can patch Providers onto defs later.\r\n        this.seenComponents = new Set();\r\n        this.seenDirectives = new Set();\r\n        // Store resolved styles for Components that have template overrides present and `styleUrls`\r\n        // defined at the same time.\r\n        this.existingComponentStyles = new Map();\r\n        this.resolvers = initResolvers();\r\n        this.componentToModuleScope = new Map();\r\n        // Map that keeps initial version of component/directive/pipe defs in case\r\n        // we compile a Type again, thus overriding respective static fields. This is\r\n        // required to make sure we restore defs to their initial states between test runs\r\n        // TODO: we should support the case with multiple defs on a type\r\n        this.initialNgDefs = new Map();\r\n        // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\r\n        // defs in case TestBed makes changes to the originals.\r\n        this.defCleanupOps = [];\r\n        this._injector = null;\r\n        this.compilerProviders = null;\r\n        this.providerOverrides = [];\r\n        this.rootProviderOverrides = [];\r\n        this.providerOverridesByToken = new Map();\r\n        this.moduleProvidersOverridden = new Set();\r\n        this.testModuleRef = null;\r\n        class DynamicTestModule {\r\n        }\r\n        this.testModuleType = (/** @type {?} */ (DynamicTestModule));\r\n    }\r\n    /**\r\n     * @param {?} providers\r\n     * @return {?}\r\n     */\r\n    setCompilerProviders(providers) {\r\n        this.compilerProviders = providers;\r\n        this._injector = null;\r\n    }\r\n    /**\r\n     * @param {?} moduleDef\r\n     * @return {?}\r\n     */\r\n    configureTestingModule(moduleDef) {\r\n        // Enqueue any compilation tasks for the directly declared component.\r\n        if (moduleDef.declarations !== undefined) {\r\n            this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\r\n            this.declarations.push(...moduleDef.declarations);\r\n        }\r\n        // Enqueue any compilation tasks for imported modules.\r\n        if (moduleDef.imports !== undefined) {\r\n            this.queueTypesFromModulesArray(moduleDef.imports);\r\n            this.imports.push(...moduleDef.imports);\r\n        }\r\n        if (moduleDef.providers !== undefined) {\r\n            this.providers.push(...moduleDef.providers);\r\n        }\r\n        if (moduleDef.schemas !== undefined) {\r\n            this.schemas.push(...moduleDef.schemas);\r\n        }\r\n    }\r\n    /**\r\n     * @param {?} ngModule\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    overrideModule(ngModule, override) {\r\n        // Compile the module right away.\r\n        this.resolvers.module.addOverride(ngModule, override);\r\n        /** @type {?} */\r\n        const metadata = this.resolvers.module.resolve(ngModule);\r\n        if (metadata === null) {\r\n            throw new Error(`${ngModule.name} is not an @NgModule or is missing metadata`);\r\n        }\r\n        this.recompileNgModule(ngModule);\r\n        // At this point, the module has a valid .ngModuleDef, but the override may have introduced\r\n        // new declarations or imported modules. Ingest any possible new types and add them to the\r\n        // current queue.\r\n        this.queueTypesFromModulesArray([ngModule]);\r\n    }\r\n    /**\r\n     * @param {?} component\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    overrideComponent(component, override) {\r\n        this.resolvers.component.addOverride(component, override);\r\n        this.pendingComponents.add(component);\r\n    }\r\n    /**\r\n     * @param {?} directive\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    overrideDirective(directive, override) {\r\n        this.resolvers.directive.addOverride(directive, override);\r\n        this.pendingDirectives.add(directive);\r\n    }\r\n    /**\r\n     * @param {?} pipe\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    overridePipe(pipe, override) {\r\n        this.resolvers.pipe.addOverride(pipe, override);\r\n        this.pendingPipes.add(pipe);\r\n    }\r\n    /**\r\n     * @param {?} token\r\n     * @param {?} provider\r\n     * @return {?}\r\n     */\r\n    overrideProvider(token, provider) {\r\n        /** @type {?} */\r\n        const providerDef = provider.useFactory ?\r\n            {\r\n                provide: token,\r\n                useFactory: provider.useFactory,\r\n                deps: provider.deps || [],\r\n                multi: provider.multi,\r\n            } :\r\n            { provide: token, useValue: provider.useValue, multi: provider.multi };\r\n        /** @type {?} */\r\n        let injectableDef;\r\n        /** @type {?} */\r\n        const isRoot = (typeof token !== 'string' && (injectableDef = ɵgetInjectableDef(token)) &&\r\n            injectableDef.providedIn === 'root');\r\n        /** @type {?} */\r\n        const overridesBucket = isRoot ? this.rootProviderOverrides : this.providerOverrides;\r\n        overridesBucket.push(providerDef);\r\n        // Keep overrides grouped by token as well for fast lookups using token\r\n        this.providerOverridesByToken.set(token, providerDef);\r\n    }\r\n    /**\r\n     * @param {?} type\r\n     * @param {?} template\r\n     * @return {?}\r\n     */\r\n    overrideTemplateUsingTestingModule(type, template) {\r\n        /** @type {?} */\r\n        const def = ((/** @type {?} */ (type)))[ɵNG_COMPONENT_DEF];\r\n        /** @type {?} */\r\n        const hasStyleUrls = (/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            /** @type {?} */\r\n            const metadata = (/** @type {?} */ ((/** @type {?} */ (this.resolvers.component.resolve(type)))));\r\n            return !!metadata.styleUrls && metadata.styleUrls.length > 0;\r\n        });\r\n        /** @type {?} */\r\n        const overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls();\r\n        // In Ivy, compiling a component does not require knowing the module providing the\r\n        // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\r\n        // overrideComponent. Important: overriding template requires full Component re-compilation,\r\n        // which may fail in case styleUrls are also present (thus Component is considered as required\r\n        // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\r\n        // preserve current styles available on Component def and restore styles back once compilation\r\n        // is complete.\r\n        /** @type {?} */\r\n        const override = overrideStyleUrls ? { template, styles: [], styleUrls: [] } : { template };\r\n        this.overrideComponent(type, { set: override });\r\n        if (overrideStyleUrls && def.styles && def.styles.length > 0) {\r\n            this.existingComponentStyles.set(type, def.styles);\r\n        }\r\n        // Set the component's scope to be the testing module.\r\n        this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    compileComponents() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.clearComponentResolutionQueue();\r\n            // Run compilers for all queued types.\r\n            /** @type {?} */\r\n            let needsAsyncResources = this.compileTypesSync();\r\n            // compileComponents() should not be async unless it needs to be.\r\n            if (needsAsyncResources) {\r\n                /** @type {?} */\r\n                let resourceLoader;\r\n                /** @type {?} */\r\n                let resolver = (/**\r\n                 * @param {?} url\r\n                 * @return {?}\r\n                 */\r\n                (url) => {\r\n                    if (!resourceLoader) {\r\n                        resourceLoader = this.injector.get(ResourceLoader);\r\n                    }\r\n                    return Promise.resolve(resourceLoader.get(url));\r\n                });\r\n                yield resolveComponentResources(resolver);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    finalize() {\r\n        // One last compile\r\n        this.compileTypesSync();\r\n        // Create the testing module itself.\r\n        this.compileTestModule();\r\n        this.applyTransitiveScopes();\r\n        this.applyProviderOverrides();\r\n        // Patch previously stored `styles` Component values (taken from ngComponentDef), in case these\r\n        // Components have `styleUrls` fields defined and template override was requested.\r\n        this.patchComponentsWithExistingStyles();\r\n        // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\r\n        // every component.\r\n        this.componentToModuleScope.clear();\r\n        /** @type {?} */\r\n        const parentInjector = this.platform.injector;\r\n        this.testModuleRef = new ɵRender3NgModuleRef(this.testModuleType, parentInjector);\r\n        // Set the locale ID, it can be overridden for the tests\r\n        /** @type {?} */\r\n        const localeId = this.testModuleRef.injector.get(LOCALE_ID, ɵDEFAULT_LOCALE_ID);\r\n        ɵsetLocaleId(localeId);\r\n        // ApplicationInitStatus.runInitializers() is marked @internal to core.\r\n        // Cast it to any before accessing it.\r\n        ((/** @type {?} */ (this.testModuleRef.injector.get(ApplicationInitStatus)))).runInitializers();\r\n        return this.testModuleRef;\r\n    }\r\n    /**\r\n     * \\@internal\r\n     * @param {?} moduleType\r\n     * @return {?}\r\n     */\r\n    _compileNgModuleSync(moduleType) {\r\n        this.queueTypesFromModulesArray([moduleType]);\r\n        this.compileTypesSync();\r\n        this.applyProviderOverrides();\r\n        this.applyProviderOverridesToModule(moduleType);\r\n        this.applyTransitiveScopes();\r\n    }\r\n    /**\r\n     * \\@internal\r\n     * @param {?} moduleType\r\n     * @return {?}\r\n     */\r\n    _compileNgModuleAsync(moduleType) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.queueTypesFromModulesArray([moduleType]);\r\n            yield this.compileComponents();\r\n            this.applyProviderOverrides();\r\n            this.applyProviderOverridesToModule(moduleType);\r\n            this.applyTransitiveScopes();\r\n        });\r\n    }\r\n    /**\r\n     * \\@internal\r\n     * @return {?}\r\n     */\r\n    _getModuleResolver() { return this.resolvers.module; }\r\n    /**\r\n     * \\@internal\r\n     * @param {?} moduleType\r\n     * @return {?}\r\n     */\r\n    _getComponentFactories(moduleType) {\r\n        return maybeUnwrapFn(moduleType.ngModuleDef.declarations).reduce((/**\r\n         * @param {?} factories\r\n         * @param {?} declaration\r\n         * @return {?}\r\n         */\r\n        (factories, declaration) => {\r\n            /** @nocollapse @type {?} */\r\n            const componentDef = ((/** @type {?} */ (declaration))).ngComponentDef;\r\n            componentDef && factories.push(new ɵRender3ComponentFactory(componentDef, (/** @type {?} */ (this.testModuleRef))));\r\n            return factories;\r\n        }), (/** @type {?} */ ([])));\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    compileTypesSync() {\r\n        // Compile all queued components, directives, pipes.\r\n        /** @type {?} */\r\n        let needsAsyncResources = false;\r\n        this.pendingComponents.forEach((/**\r\n         * @param {?} declaration\r\n         * @return {?}\r\n         */\r\n        declaration => {\r\n            needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);\r\n            /** @type {?} */\r\n            const metadata = (/** @type {?} */ (this.resolvers.component.resolve(declaration)));\r\n            this.maybeStoreNgDef(ɵNG_COMPONENT_DEF, declaration);\r\n            ɵcompileComponent(declaration, metadata);\r\n        }));\r\n        this.pendingComponents.clear();\r\n        this.pendingDirectives.forEach((/**\r\n         * @param {?} declaration\r\n         * @return {?}\r\n         */\r\n        declaration => {\r\n            /** @type {?} */\r\n            const metadata = (/** @type {?} */ (this.resolvers.directive.resolve(declaration)));\r\n            this.maybeStoreNgDef(ɵNG_DIRECTIVE_DEF, declaration);\r\n            ɵcompileDirective(declaration, metadata);\r\n        }));\r\n        this.pendingDirectives.clear();\r\n        this.pendingPipes.forEach((/**\r\n         * @param {?} declaration\r\n         * @return {?}\r\n         */\r\n        declaration => {\r\n            /** @type {?} */\r\n            const metadata = (/** @type {?} */ (this.resolvers.pipe.resolve(declaration)));\r\n            this.maybeStoreNgDef(ɵNG_PIPE_DEF, declaration);\r\n            ɵcompilePipe(declaration, metadata);\r\n        }));\r\n        this.pendingPipes.clear();\r\n        return needsAsyncResources;\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    applyTransitiveScopes() {\r\n        /** @type {?} */\r\n        const moduleToScope = new Map();\r\n        /** @type {?} */\r\n        const getScopeOfModule = (/**\r\n         * @param {?} moduleType\r\n         * @return {?}\r\n         */\r\n        (moduleType) => {\r\n            if (!moduleToScope.has(moduleType)) {\r\n                /** @type {?} */\r\n                const realType = isTestingModuleOverride(moduleType) ? this.testModuleType : moduleType;\r\n                moduleToScope.set(moduleType, ɵtransitiveScopesFor(realType));\r\n            }\r\n            return (/** @type {?} */ (moduleToScope.get(moduleType)));\r\n        });\r\n        this.componentToModuleScope.forEach((/**\r\n         * @param {?} moduleType\r\n         * @param {?} componentType\r\n         * @return {?}\r\n         */\r\n        (moduleType, componentType) => {\r\n            /** @type {?} */\r\n            const moduleScope = getScopeOfModule(moduleType);\r\n            this.storeFieldOfDefOnType(componentType, ɵNG_COMPONENT_DEF, 'directiveDefs');\r\n            this.storeFieldOfDefOnType(componentType, ɵNG_COMPONENT_DEF, 'pipeDefs');\r\n            ɵpatchComponentDefWithScope(((/** @type {?} */ (componentType))).ngComponentDef, moduleScope);\r\n        }));\r\n        this.componentToModuleScope.clear();\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    applyProviderOverrides() {\r\n        /** @type {?} */\r\n        const maybeApplyOverrides = (/**\r\n         * @param {?} field\r\n         * @return {?}\r\n         */\r\n        (field) => (/**\r\n         * @param {?} type\r\n         * @return {?}\r\n         */\r\n        (type) => {\r\n            /** @type {?} */\r\n            const resolver = field === ɵNG_COMPONENT_DEF ? this.resolvers.component : this.resolvers.directive;\r\n            /** @type {?} */\r\n            const metadata = (/** @type {?} */ (resolver.resolve(type)));\r\n            if (this.hasProviderOverrides(metadata.providers)) {\r\n                this.patchDefWithProviderOverrides(type, field);\r\n            }\r\n        }));\r\n        this.seenComponents.forEach(maybeApplyOverrides(ɵNG_COMPONENT_DEF));\r\n        this.seenDirectives.forEach(maybeApplyOverrides(ɵNG_DIRECTIVE_DEF));\r\n        this.seenComponents.clear();\r\n        this.seenDirectives.clear();\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} moduleType\r\n     * @return {?}\r\n     */\r\n    applyProviderOverridesToModule(moduleType) {\r\n        if (this.moduleProvidersOverridden.has(moduleType)) {\r\n            return;\r\n        }\r\n        this.moduleProvidersOverridden.add(moduleType);\r\n        /** @type {?} */\r\n        const injectorDef = ((/** @type {?} */ (moduleType)))[ɵNG_INJECTOR_DEF];\r\n        if (this.providerOverridesByToken.size > 0) {\r\n            // Extract the list of providers from ModuleWithProviders, so we can define the final list of\r\n            // providers that might have overrides.\r\n            // Note: second `flatten` operation is needed to convert an array of providers\r\n            // (e.g. `[[], []]`) into one flat list, also eliminating empty arrays.\r\n            /** @type {?} */\r\n            const providersFromModules = flatten(flatten(injectorDef.imports, (/**\r\n             * @param {?} imported\r\n             * @return {?}\r\n             */\r\n            (imported) => isModuleWithProviders(imported) ? imported.providers : [])));\r\n            /** @type {?} */\r\n            const providers = [...providersFromModules, ...injectorDef.providers];\r\n            if (this.hasProviderOverrides(providers)) {\r\n                this.maybeStoreNgDef(ɵNG_INJECTOR_DEF, moduleType);\r\n                this.storeFieldOfDefOnType(moduleType, ɵNG_INJECTOR_DEF, 'providers');\r\n                injectorDef.providers = this.getOverriddenProviders(providers);\r\n            }\r\n            // Apply provider overrides to imported modules recursively\r\n            /** @type {?} */\r\n            const moduleDef = ((/** @type {?} */ (moduleType)))[ɵNG_MODULE_DEF];\r\n            for (const importType of moduleDef.imports) {\r\n                this.applyProviderOverridesToModule(importType);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    patchComponentsWithExistingStyles() {\r\n        this.existingComponentStyles.forEach((/**\r\n         * @param {?} styles\r\n         * @param {?} type\r\n         * @return {?}\r\n         */\r\n        (styles, type) => ((/** @type {?} */ (type)))[ɵNG_COMPONENT_DEF].styles = styles));\r\n        this.existingComponentStyles.clear();\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} arr\r\n     * @param {?} moduleType\r\n     * @return {?}\r\n     */\r\n    queueTypeArray(arr, moduleType) {\r\n        for (const value of arr) {\r\n            if (Array.isArray(value)) {\r\n                this.queueTypeArray(value, moduleType);\r\n            }\r\n            else {\r\n                this.queueType(value, moduleType);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} ngModule\r\n     * @return {?}\r\n     */\r\n    recompileNgModule(ngModule) {\r\n        /** @type {?} */\r\n        const metadata = this.resolvers.module.resolve(ngModule);\r\n        if (metadata === null) {\r\n            throw new Error(`Unable to resolve metadata for NgModule: ${ngModule.name}`);\r\n        }\r\n        // Cache the initial ngModuleDef as it will be overwritten.\r\n        this.maybeStoreNgDef(ɵNG_MODULE_DEF, ngModule);\r\n        this.maybeStoreNgDef(ɵNG_INJECTOR_DEF, ngModule);\r\n        ɵcompileNgModuleDefs((/** @type {?} */ (ngModule)), metadata);\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} type\r\n     * @param {?} moduleType\r\n     * @return {?}\r\n     */\r\n    queueType(type, moduleType) {\r\n        /** @type {?} */\r\n        const component = this.resolvers.component.resolve(type);\r\n        if (component) {\r\n            // Check whether a give Type has respective NG def (ngComponentDef) and compile if def is\r\n            // missing. That might happen in case a class without any Angular decorators extends another\r\n            // class where Component/Directive/Pipe decorator is defined.\r\n            if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(ɵNG_COMPONENT_DEF)) {\r\n                this.pendingComponents.add(type);\r\n            }\r\n            this.seenComponents.add(type);\r\n            // Keep track of the module which declares this component, so later the component's scope\r\n            // can be set correctly. If the component has already been recorded here, then one of several\r\n            // cases is true:\r\n            // * the module containing the component was imported multiple times (common).\r\n            // * the component is declared in multiple modules (which is an error).\r\n            // * the component was in 'declarations' of the testing module, and also in an imported module\r\n            //   in which case the module scope will be TestingModuleOverride.DECLARATION.\r\n            // * overrideTemplateUsingTestingModule was called for the component in which case the module\r\n            //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\r\n            //\r\n            // If the component was previously in the testing module's 'declarations' (meaning the\r\n            // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\r\n            // real module, which was imported. This pattern is understood to mean that the component\r\n            // should use its original scope, but that the testing module should also contain the\r\n            // component in its scope.\r\n            if (!this.componentToModuleScope.has(type) ||\r\n                this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {\r\n                this.componentToModuleScope.set(type, moduleType);\r\n            }\r\n            return;\r\n        }\r\n        /** @type {?} */\r\n        const directive = this.resolvers.directive.resolve(type);\r\n        if (directive) {\r\n            if (!type.hasOwnProperty(ɵNG_DIRECTIVE_DEF)) {\r\n                this.pendingDirectives.add(type);\r\n            }\r\n            this.seenDirectives.add(type);\r\n            return;\r\n        }\r\n        /** @type {?} */\r\n        const pipe = this.resolvers.pipe.resolve(type);\r\n        if (pipe && !type.hasOwnProperty(ɵNG_PIPE_DEF)) {\r\n            this.pendingPipes.add(type);\r\n            return;\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} arr\r\n     * @return {?}\r\n     */\r\n    queueTypesFromModulesArray(arr) {\r\n        for (const value of arr) {\r\n            if (Array.isArray(value)) {\r\n                this.queueTypesFromModulesArray(value);\r\n            }\r\n            else if (hasNgModuleDef(value)) {\r\n                /** @nocollapse @type {?} */\r\n                const def = value.ngModuleDef;\r\n                // Look through declarations, imports, and exports, and queue everything found there.\r\n                this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\r\n                this.queueTypesFromModulesArray(maybeUnwrapFn(def.imports));\r\n                this.queueTypesFromModulesArray(maybeUnwrapFn(def.exports));\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} prop\r\n     * @param {?} type\r\n     * @return {?}\r\n     */\r\n    maybeStoreNgDef(prop, type) {\r\n        if (!this.initialNgDefs.has(type)) {\r\n            /** @type {?} */\r\n            const currentDef = Object.getOwnPropertyDescriptor(type, prop);\r\n            this.initialNgDefs.set(type, [prop, currentDef]);\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} type\r\n     * @param {?} defField\r\n     * @param {?} field\r\n     * @return {?}\r\n     */\r\n    storeFieldOfDefOnType(type, defField, field) {\r\n        /** @type {?} */\r\n        const def = ((/** @type {?} */ (type)))[defField];\r\n        /** @type {?} */\r\n        const original = def[field];\r\n        this.defCleanupOps.push({ field, def, original });\r\n    }\r\n    /**\r\n     * Clears current components resolution queue, but stores the state of the queue, so we can\r\n     * restore it later. Clearing the queue is required before we try to compile components (via\r\n     * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    clearComponentResolutionQueue() {\r\n        if (this.originalComponentResolutionQueue === null) {\r\n            this.originalComponentResolutionQueue = new Map();\r\n        }\r\n        clearResolutionOfComponentResourcesQueue().forEach((/**\r\n         * @param {?} value\r\n         * @param {?} key\r\n         * @return {?}\r\n         */\r\n        (value, key) => (/** @type {?} */ (this.originalComponentResolutionQueue)).set(key, value)));\r\n    }\r\n    /*\r\n       * Restores component resolution queue to the previously saved state. This operation is performed\r\n       * as a part of restoring the state after completion of the current set of tests (that might\r\n       * potentially mutate the state).\r\n       */\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    restoreComponentResolutionQueue() {\r\n        if (this.originalComponentResolutionQueue !== null) {\r\n            restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\r\n            this.originalComponentResolutionQueue = null;\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    restoreOriginalState() {\r\n        for (const op of this.defCleanupOps) {\r\n            op.def[op.field] = op.original;\r\n        }\r\n        // Restore initial component/directive/pipe defs\r\n        this.initialNgDefs.forEach((/**\r\n         * @param {?} value\r\n         * @param {?} type\r\n         * @return {?}\r\n         */\r\n        (value, type) => {\r\n            const [prop, descriptor] = value;\r\n            if (!descriptor) {\r\n                // Delete operations are generally undesirable since they have performance implications\r\n                // on objects they were applied to. In this particular case, situations where this code\r\n                // is invoked should be quite rare to cause any noticeable impact, since it's applied\r\n                // only to some test cases (for example when class with no annotations extends some\r\n                // @Component) when we need to clear 'ngComponentDef' field on a given class to restore\r\n                // its original state (before applying overrides and running tests).\r\n                delete ((/** @type {?} */ (type)))[prop];\r\n            }\r\n            else {\r\n                Object.defineProperty(type, prop, descriptor);\r\n            }\r\n        }));\r\n        this.initialNgDefs.clear();\r\n        this.moduleProvidersOverridden.clear();\r\n        this.restoreComponentResolutionQueue();\r\n        // Restore the locale ID to the default value, this shouldn't be necessary but we never know\r\n        ɵsetLocaleId(ɵDEFAULT_LOCALE_ID);\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    compileTestModule() {\r\n        class RootScopeModule {\r\n        }\r\n        ɵcompileNgModuleDefs((/** @type {?} */ (RootScopeModule)), {\r\n            providers: [...this.rootProviderOverrides],\r\n        });\r\n        /** @type {?} */\r\n        const ngZone = new NgZone({ enableLongStackTrace: true });\r\n        /** @type {?} */\r\n        const providers = [\r\n            { provide: NgZone, useValue: ngZone },\r\n            { provide: Compiler, useFactory: (/**\r\n                 * @return {?}\r\n                 */\r\n                () => new R3TestCompiler(this)) },\r\n            ...this.providers,\r\n            ...this.providerOverrides,\r\n        ];\r\n        /** @type {?} */\r\n        const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\r\n        // clang-format off\r\n        ɵcompileNgModuleDefs(this.testModuleType, {\r\n            declarations: this.declarations,\r\n            imports,\r\n            schemas: this.schemas,\r\n            providers,\r\n        }, /* allowDuplicateDeclarationsInRoot */ true);\r\n        // clang-format on\r\n        this.applyProviderOverridesToModule(this.testModuleType);\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get injector() {\r\n        if (this._injector !== null) {\r\n            return this._injector;\r\n        }\r\n        /** @type {?} */\r\n        const providers = [];\r\n        /** @type {?} */\r\n        const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS);\r\n        compilerOptions.forEach((/**\r\n         * @param {?} opts\r\n         * @return {?}\r\n         */\r\n        opts => {\r\n            if (opts.providers) {\r\n                providers.push(opts.providers);\r\n            }\r\n        }));\r\n        if (this.compilerProviders !== null) {\r\n            providers.push(...this.compilerProviders);\r\n        }\r\n        // TODO(ocombe): make this work with an Injector directly instead of creating a module for it\r\n        class CompilerModule {\r\n        }\r\n        ɵcompileNgModuleDefs((/** @type {?} */ (CompilerModule)), { providers });\r\n        /** @type {?} */\r\n        const CompilerModuleFactory = new ɵNgModuleFactory(CompilerModule);\r\n        this._injector = CompilerModuleFactory.create(this.platform.injector).injector;\r\n        return this._injector;\r\n    }\r\n    // get overrides for a specific provider (if any)\r\n    /**\r\n     * @private\r\n     * @param {?} provider\r\n     * @return {?}\r\n     */\r\n    getSingleProviderOverrides(provider) {\r\n        /** @type {?} */\r\n        const token = getProviderToken(provider);\r\n        return this.providerOverridesByToken.get(token) || null;\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?=} providers\r\n     * @return {?}\r\n     */\r\n    getProviderOverrides(providers) {\r\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\r\n            return [];\r\n        // There are two flattening operations here. The inner flatten() operates on the metadata's\r\n        // providers and applies a mapping function which retrieves overrides for each incoming\r\n        // provider. The outer flatten() then flattens the produced overrides array. If this is not\r\n        // done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\r\n        // providers array and contaminate any error messages that might be generated.\r\n        return flatten(flatten(providers, (/**\r\n         * @param {?} provider\r\n         * @return {?}\r\n         */\r\n        (provider) => this.getSingleProviderOverrides(provider) || [])));\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?=} providers\r\n     * @return {?}\r\n     */\r\n    getOverriddenProviders(providers) {\r\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\r\n            return [];\r\n        /** @type {?} */\r\n        const overrides = this.getProviderOverrides(providers);\r\n        /** @type {?} */\r\n        const hasMultiProviderOverrides = overrides.some(isMultiProvider);\r\n        /** @type {?} */\r\n        const overriddenProviders = [...providers, ...overrides];\r\n        // No additional processing is required in case we have no multi providers to override\r\n        if (!hasMultiProviderOverrides) {\r\n            return overriddenProviders;\r\n        }\r\n        /** @type {?} */\r\n        const final = [];\r\n        /** @type {?} */\r\n        const seenMultiProviders = new Set();\r\n        // We iterate through the list of providers in reverse order to make sure multi provider\r\n        // overrides take precedence over the values defined in provider list. We also fiter out all\r\n        // multi providers that have overrides, keeping overridden values only.\r\n        forEachRight(overriddenProviders, (/**\r\n         * @param {?} provider\r\n         * @return {?}\r\n         */\r\n        (provider) => {\r\n            /** @type {?} */\r\n            const token = getProviderToken(provider);\r\n            if (isMultiProvider(provider) && this.providerOverridesByToken.has(token)) {\r\n                if (!seenMultiProviders.has(token)) {\r\n                    seenMultiProviders.add(token);\r\n                    if (provider && provider.useValue && Array.isArray(provider.useValue)) {\r\n                        forEachRight(provider.useValue, (/**\r\n                         * @param {?} value\r\n                         * @return {?}\r\n                         */\r\n                        (value) => {\r\n                            // Unwrap provider override array into individual providers in final set.\r\n                            final.unshift({ provide: token, useValue: value, multi: true });\r\n                        }));\r\n                    }\r\n                    else {\r\n                        final.unshift(provider);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                final.unshift(provider);\r\n            }\r\n        }));\r\n        return final;\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?=} providers\r\n     * @return {?}\r\n     */\r\n    hasProviderOverrides(providers) {\r\n        return this.getProviderOverrides(providers).length > 0;\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} declaration\r\n     * @param {?} field\r\n     * @return {?}\r\n     */\r\n    patchDefWithProviderOverrides(declaration, field) {\r\n        /** @type {?} */\r\n        const def = ((/** @type {?} */ (declaration)))[field];\r\n        if (def && def.providersResolver) {\r\n            this.maybeStoreNgDef(field, declaration);\r\n            /** @type {?} */\r\n            const resolver = def.providersResolver;\r\n            /** @type {?} */\r\n            const processProvidersFn = (/**\r\n             * @param {?} providers\r\n             * @return {?}\r\n             */\r\n            (providers) => this.getOverriddenProviders(providers));\r\n            this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\r\n            def.providersResolver = (/**\r\n             * @param {?} ngDef\r\n             * @return {?}\r\n             */\r\n            (ngDef) => resolver(ngDef, processProvidersFn));\r\n        }\r\n    }\r\n}\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.originalComponentResolutionQueue;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.declarations;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.imports;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.providers;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.schemas;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.pendingComponents;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.pendingDirectives;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.pendingPipes;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.seenComponents;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.seenDirectives;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.existingComponentStyles;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.resolvers;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.componentToModuleScope;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.initialNgDefs;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.defCleanupOps;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype._injector;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.compilerProviders;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.providerOverrides;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.rootProviderOverrides;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.providerOverridesByToken;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.moduleProvidersOverridden;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.testModuleType;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.testModuleRef;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.platform;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestBedCompiler.prototype.additionalModuleTypes;\r\n}\r\n/**\r\n * @return {?}\r\n */\r\nfunction initResolvers() {\r\n    return {\r\n        module: new NgModuleResolver(),\r\n        component: new ComponentResolver(),\r\n        directive: new DirectiveResolver(),\r\n        pipe: new PipeResolver()\r\n    };\r\n}\r\n/**\r\n * @template T\r\n * @param {?} value\r\n * @return {?}\r\n */\r\nfunction hasNgModuleDef(value) {\r\n    return value.hasOwnProperty('ngModuleDef');\r\n}\r\n/**\r\n * @template T\r\n * @param {?} maybeFn\r\n * @return {?}\r\n */\r\nfunction maybeUnwrapFn(maybeFn) {\r\n    return maybeFn instanceof Function ? maybeFn() : maybeFn;\r\n}\r\n/**\r\n * @template T\r\n * @param {?} values\r\n * @param {?=} mapFn\r\n * @return {?}\r\n */\r\nfunction flatten(values, mapFn) {\r\n    /** @type {?} */\r\n    const out = [];\r\n    values.forEach((/**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    value => {\r\n        if (Array.isArray(value)) {\r\n            out.push(...flatten(value, mapFn));\r\n        }\r\n        else {\r\n            out.push(mapFn ? mapFn(value) : value);\r\n        }\r\n    }));\r\n    return out;\r\n}\r\n/**\r\n * @param {?} provider\r\n * @param {?} field\r\n * @return {?}\r\n */\r\nfunction getProviderField(provider, field) {\r\n    return provider && typeof provider === 'object' && ((/** @type {?} */ (provider)))[field];\r\n}\r\n/**\r\n * @param {?} provider\r\n * @return {?}\r\n */\r\nfunction getProviderToken(provider) {\r\n    return getProviderField(provider, 'provide') || provider;\r\n}\r\n/**\r\n * @param {?} provider\r\n * @return {?}\r\n */\r\nfunction isMultiProvider(provider) {\r\n    return !!getProviderField(provider, 'multi');\r\n}\r\n/**\r\n * @param {?} value\r\n * @return {?}\r\n */\r\nfunction isModuleWithProviders(value) {\r\n    return value.hasOwnProperty('ngModule');\r\n}\r\n/**\r\n * @template T\r\n * @param {?} values\r\n * @param {?} fn\r\n * @return {?}\r\n */\r\nfunction forEachRight(values, fn) {\r\n    for (let idx = values.length - 1; idx >= 0; idx--) {\r\n        fn(values[idx], idx);\r\n    }\r\n}\r\nclass R3TestCompiler {\r\n    /**\r\n     * @param {?} testBed\r\n     */\r\n    constructor(testBed) {\r\n        this.testBed = testBed;\r\n    }\r\n    /**\r\n     * @template T\r\n     * @param {?} moduleType\r\n     * @return {?}\r\n     */\r\n    compileModuleSync(moduleType) {\r\n        this.testBed._compileNgModuleSync(moduleType);\r\n        return new ɵNgModuleFactory(moduleType);\r\n    }\r\n    /**\r\n     * @template T\r\n     * @param {?} moduleType\r\n     * @return {?}\r\n     */\r\n    compileModuleAsync(moduleType) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.testBed._compileNgModuleAsync(moduleType);\r\n            return new ɵNgModuleFactory(moduleType);\r\n        });\r\n    }\r\n    /**\r\n     * @template T\r\n     * @param {?} moduleType\r\n     * @return {?}\r\n     */\r\n    compileModuleAndAllComponentsSync(moduleType) {\r\n        /** @type {?} */\r\n        const ngModuleFactory = this.compileModuleSync(moduleType);\r\n        /** @type {?} */\r\n        const componentFactories = this.testBed._getComponentFactories((/** @type {?} */ (moduleType)));\r\n        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\r\n    }\r\n    /**\r\n     * @template T\r\n     * @param {?} moduleType\r\n     * @return {?}\r\n     */\r\n    compileModuleAndAllComponentsAsync(moduleType) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            /** @type {?} */\r\n            const ngModuleFactory = yield this.compileModuleAsync(moduleType);\r\n            /** @type {?} */\r\n            const componentFactories = this.testBed._getComponentFactories((/** @type {?} */ (moduleType)));\r\n            return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\r\n        });\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    clearCache() { }\r\n    /**\r\n     * @param {?} type\r\n     * @return {?}\r\n     */\r\n    clearCacheFor(type) { }\r\n    /**\r\n     * @param {?} moduleType\r\n     * @return {?}\r\n     */\r\n    getModuleId(moduleType) {\r\n        /** @type {?} */\r\n        const meta = this.testBed._getModuleResolver().resolve(moduleType);\r\n        return meta && meta.id || undefined;\r\n    }\r\n}\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    R3TestCompiler.prototype.testBed;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @type {?} */\r\nlet _nextRootElementId = 0;\r\n/** @type {?} */\r\nconst UNDEFINED = Symbol('UNDEFINED');\r\n/**\r\n * \\@description\r\n * Configures and initializes environment for unit testing and provides methods for\r\n * creating components and services in unit tests.\r\n *\r\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\r\n *\r\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\r\n * according to the compiler used.\r\n */\r\nclass TestBedRender3 {\r\n    constructor() {\r\n        // Properties\r\n        this.platform = (/** @type {?} */ (null));\r\n        this.ngModule = (/** @type {?} */ (null));\r\n        this._compiler = null;\r\n        this._testModuleRef = null;\r\n        this._activeFixtures = [];\r\n        this._globalCompilationChecked = false;\r\n    }\r\n    /**\r\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\r\n     * angular module. These are common to every test in the suite.\r\n     *\r\n     * This may only be called once, to set up the common providers for the current test\r\n     * suite on the current platform. If you absolutely need to change the providers,\r\n     * first use `resetTestEnvironment`.\r\n     *\r\n     * Test modules and platforms for individual platforms are available from\r\n     * '\\@angular/<platform_name>/testing'.\r\n     *\r\n     * \\@publicApi\r\n     * @param {?} ngModule\r\n     * @param {?} platform\r\n     * @param {?=} aotSummaries\r\n     * @return {?}\r\n     */\r\n    static initTestEnvironment(ngModule, platform, aotSummaries) {\r\n        /** @type {?} */\r\n        const testBed = _getTestBedRender3();\r\n        testBed.initTestEnvironment(ngModule, platform, aotSummaries);\r\n        return testBed;\r\n    }\r\n    /**\r\n     * Reset the providers for the test injector.\r\n     *\r\n     * \\@publicApi\r\n     * @return {?}\r\n     */\r\n    static resetTestEnvironment() { _getTestBedRender3().resetTestEnvironment(); }\r\n    /**\r\n     * @param {?} config\r\n     * @return {?}\r\n     */\r\n    static configureCompiler(config) {\r\n        _getTestBedRender3().configureCompiler(config);\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\r\n    }\r\n    /**\r\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\r\n     * which are defined in test_injector.js\r\n     * @param {?} moduleDef\r\n     * @return {?}\r\n     */\r\n    static configureTestingModule(moduleDef) {\r\n        _getTestBedRender3().configureTestingModule(moduleDef);\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\r\n    }\r\n    /**\r\n     * Compile components with a `templateUrl` for the test's NgModule.\r\n     * It is necessary to call this function\r\n     * as fetching urls is asynchronous.\r\n     * @return {?}\r\n     */\r\n    static compileComponents() { return _getTestBedRender3().compileComponents(); }\r\n    /**\r\n     * @param {?} ngModule\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    static overrideModule(ngModule, override) {\r\n        _getTestBedRender3().overrideModule(ngModule, override);\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\r\n    }\r\n    /**\r\n     * @param {?} component\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    static overrideComponent(component, override) {\r\n        _getTestBedRender3().overrideComponent(component, override);\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\r\n    }\r\n    /**\r\n     * @param {?} directive\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    static overrideDirective(directive, override) {\r\n        _getTestBedRender3().overrideDirective(directive, override);\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\r\n    }\r\n    /**\r\n     * @param {?} pipe\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    static overridePipe(pipe, override) {\r\n        _getTestBedRender3().overridePipe(pipe, override);\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\r\n    }\r\n    /**\r\n     * @param {?} component\r\n     * @param {?} template\r\n     * @return {?}\r\n     */\r\n    static overrideTemplate(component, template) {\r\n        _getTestBedRender3().overrideComponent(component, { set: { template, templateUrl: (/** @type {?} */ (null)) } });\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\r\n    }\r\n    /**\r\n     * Overrides the template of the given component, compiling the template\r\n     * in the context of the TestingModule.\r\n     *\r\n     * Note: This works for JIT and AOTed components as well.\r\n     * @param {?} component\r\n     * @param {?} template\r\n     * @return {?}\r\n     */\r\n    static overrideTemplateUsingTestingModule(component, template) {\r\n        _getTestBedRender3().overrideTemplateUsingTestingModule(component, template);\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\r\n    }\r\n    /**\r\n     * @param {?} token\r\n     * @param {?} provider\r\n     * @return {?}\r\n     */\r\n    static overrideProvider(token, provider) {\r\n        _getTestBedRender3().overrideProvider(token, provider);\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\r\n    }\r\n    /**\r\n     * @param {?} token\r\n     * @param {?=} notFoundValue\r\n     * @param {?=} flags\r\n     * @return {?}\r\n     */\r\n    static get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\r\n        return _getTestBedRender3().get(token, notFoundValue);\r\n    }\r\n    /**\r\n     * @template T\r\n     * @param {?} component\r\n     * @return {?}\r\n     */\r\n    static createComponent(component) {\r\n        return _getTestBedRender3().createComponent(component);\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    static resetTestingModule() {\r\n        _getTestBedRender3().resetTestingModule();\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedRender3))));\r\n    }\r\n    /**\r\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\r\n     * angular module. These are common to every test in the suite.\r\n     *\r\n     * This may only be called once, to set up the common providers for the current test\r\n     * suite on the current platform. If you absolutely need to change the providers,\r\n     * first use `resetTestEnvironment`.\r\n     *\r\n     * Test modules and platforms for individual platforms are available from\r\n     * '\\@angular/<platform_name>/testing'.\r\n     *\r\n     * \\@publicApi\r\n     * @param {?} ngModule\r\n     * @param {?} platform\r\n     * @param {?=} aotSummaries\r\n     * @return {?}\r\n     */\r\n    initTestEnvironment(ngModule, platform, aotSummaries) {\r\n        if (this.platform || this.ngModule) {\r\n            throw new Error('Cannot set base providers because it has already been called');\r\n        }\r\n        this.platform = platform;\r\n        this.ngModule = ngModule;\r\n        this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);\r\n    }\r\n    /**\r\n     * Reset the providers for the test injector.\r\n     *\r\n     * \\@publicApi\r\n     * @return {?}\r\n     */\r\n    resetTestEnvironment() {\r\n        this.resetTestingModule();\r\n        this._compiler = null;\r\n        this.platform = (/** @type {?} */ (null));\r\n        this.ngModule = (/** @type {?} */ (null));\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    resetTestingModule() {\r\n        this.checkGlobalCompilationFinished();\r\n        ɵresetCompiledComponents();\r\n        if (this._compiler !== null) {\r\n            this.compiler.restoreOriginalState();\r\n        }\r\n        this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);\r\n        this._testModuleRef = null;\r\n        this.destroyActiveFixtures();\r\n    }\r\n    /**\r\n     * @param {?} config\r\n     * @return {?}\r\n     */\r\n    configureCompiler(config) {\r\n        if (config.useJit != null) {\r\n            throw new Error('the Render3 compiler JiT mode is not configurable !');\r\n        }\r\n        if (config.providers !== undefined) {\r\n            this.compiler.setCompilerProviders(config.providers);\r\n        }\r\n    }\r\n    /**\r\n     * @param {?} moduleDef\r\n     * @return {?}\r\n     */\r\n    configureTestingModule(moduleDef) {\r\n        this.assertNotInstantiated('R3TestBed.configureTestingModule', 'configure the test module');\r\n        this.compiler.configureTestingModule(moduleDef);\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    compileComponents() { return this.compiler.compileComponents(); }\r\n    /**\r\n     * @param {?} token\r\n     * @param {?=} notFoundValue\r\n     * @param {?=} flags\r\n     * @return {?}\r\n     */\r\n    get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\r\n        if (token === TestBedRender3) {\r\n            return this;\r\n        }\r\n        /** @type {?} */\r\n        const result = this.testModuleRef.injector.get(token, UNDEFINED, flags);\r\n        return result === UNDEFINED ? this.compiler.injector.get(token, notFoundValue, flags) : result;\r\n    }\r\n    /**\r\n     * @param {?} tokens\r\n     * @param {?} fn\r\n     * @param {?=} context\r\n     * @return {?}\r\n     */\r\n    execute(tokens, fn, context) {\r\n        /** @type {?} */\r\n        const params = tokens.map((/**\r\n         * @param {?} t\r\n         * @return {?}\r\n         */\r\n        t => this.get(t)));\r\n        return fn.apply(context, params);\r\n    }\r\n    /**\r\n     * @param {?} ngModule\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    overrideModule(ngModule, override) {\r\n        this.assertNotInstantiated('overrideModule', 'override module metadata');\r\n        this.compiler.overrideModule(ngModule, override);\r\n    }\r\n    /**\r\n     * @param {?} component\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    overrideComponent(component, override) {\r\n        this.assertNotInstantiated('overrideComponent', 'override component metadata');\r\n        this.compiler.overrideComponent(component, override);\r\n    }\r\n    /**\r\n     * @param {?} component\r\n     * @param {?} template\r\n     * @return {?}\r\n     */\r\n    overrideTemplateUsingTestingModule(component, template) {\r\n        this.assertNotInstantiated('R3TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\r\n        this.compiler.overrideTemplateUsingTestingModule(component, template);\r\n    }\r\n    /**\r\n     * @param {?} directive\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    overrideDirective(directive, override) {\r\n        this.assertNotInstantiated('overrideDirective', 'override directive metadata');\r\n        this.compiler.overrideDirective(directive, override);\r\n    }\r\n    /**\r\n     * @param {?} pipe\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    overridePipe(pipe, override) {\r\n        this.assertNotInstantiated('overridePipe', 'override pipe metadata');\r\n        this.compiler.overridePipe(pipe, override);\r\n    }\r\n    /**\r\n     * Overwrites all providers for the given token with the given provider definition.\r\n     * @param {?} token\r\n     * @param {?} provider\r\n     * @return {?}\r\n     */\r\n    overrideProvider(token, provider) {\r\n        this.compiler.overrideProvider(token, provider);\r\n    }\r\n    /**\r\n     * @template T\r\n     * @param {?} type\r\n     * @return {?}\r\n     */\r\n    createComponent(type) {\r\n        /** @type {?} */\r\n        const testComponentRenderer = this.get(TestComponentRenderer);\r\n        /** @type {?} */\r\n        const rootElId = `root-ng-internal-isolated-${_nextRootElementId++}`;\r\n        testComponentRenderer.insertRootElement(rootElId);\r\n        /** @nocollapse @type {?} */\r\n        const componentDef = ((/** @type {?} */ (type))).ngComponentDef;\r\n        if (!componentDef) {\r\n            throw new Error(`It looks like '${ɵstringify(type)}' has not been IVY compiled - it has no 'ngComponentDef' field`);\r\n        }\r\n        // TODO: Don't cast as `any`, proper type is boolean[]\r\n        /** @type {?} */\r\n        const noNgZone = this.get((/** @type {?} */ (ComponentFixtureNoNgZone)), false);\r\n        // TODO: Don't cast as `any`, proper type is boolean[]\r\n        /** @type {?} */\r\n        const autoDetect = this.get((/** @type {?} */ (ComponentFixtureAutoDetect)), false);\r\n        /** @type {?} */\r\n        const ngZone = noNgZone ? null : this.get((/** @type {?} */ (NgZone)), null);\r\n        /** @type {?} */\r\n        const componentFactory = new ɵRender3ComponentFactory(componentDef);\r\n        /** @type {?} */\r\n        const initComponent = (/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            /** @type {?} */\r\n            const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this.testModuleRef);\r\n            return new ComponentFixture(componentRef, ngZone, autoDetect);\r\n        });\r\n        /** @type {?} */\r\n        const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\r\n        this._activeFixtures.push(fixture);\r\n        return fixture;\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    get compiler() {\r\n        if (this._compiler === null) {\r\n            throw new Error(`Need to call TestBed.initTestEnvironment() first`);\r\n        }\r\n        return this._compiler;\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    get testModuleRef() {\r\n        if (this._testModuleRef === null) {\r\n            this._testModuleRef = this.compiler.finalize();\r\n        }\r\n        return this._testModuleRef;\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} methodName\r\n     * @param {?} methodDescription\r\n     * @return {?}\r\n     */\r\n    assertNotInstantiated(methodName, methodDescription) {\r\n        if (this._testModuleRef !== null) {\r\n            throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` +\r\n                `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\r\n        }\r\n    }\r\n    /**\r\n     * Check whether the module scoping queue should be flushed, and flush it if needed.\r\n     *\r\n     * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\r\n     * in-progress module compilation. This creates a potential hazard - the very first time the\r\n     * TestBed is initialized (or if it's reset without being initialized), there may be pending\r\n     * compilations of modules declared in global scope. These compilations should be finished.\r\n     *\r\n     * To ensure that globally declared modules have their components scoped properly, this function\r\n     * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\r\n     * to any other operations, the scoping queue is flushed.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    checkGlobalCompilationFinished() {\r\n        // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\r\n        // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\r\n        if (!this._globalCompilationChecked && this._testModuleRef === null) {\r\n            ɵflushModuleScopingQueueAsMuchAsPossible();\r\n        }\r\n        this._globalCompilationChecked = true;\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    destroyActiveFixtures() {\r\n        this._activeFixtures.forEach((/**\r\n         * @param {?} fixture\r\n         * @return {?}\r\n         */\r\n        (fixture) => {\r\n            try {\r\n                fixture.destroy();\r\n            }\r\n            catch (e) {\r\n                console.error('Error during cleanup of component', {\r\n                    component: fixture.componentInstance,\r\n                    stacktrace: e,\r\n                });\r\n            }\r\n        }));\r\n        this._activeFixtures = [];\r\n    }\r\n}\r\nif (false) {\r\n    /** @type {?} */\r\n    TestBedRender3.prototype.platform;\r\n    /** @type {?} */\r\n    TestBedRender3.prototype.ngModule;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedRender3.prototype._compiler;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedRender3.prototype._testModuleRef;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedRender3.prototype._activeFixtures;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedRender3.prototype._globalCompilationChecked;\r\n}\r\n/** @type {?} */\r\nlet testBed;\r\n/**\r\n * @return {?}\r\n */\r\nfunction _getTestBedRender3() {\r\n    return testBed = testBed || new TestBedRender3();\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @return {?}\r\n */\r\nfunction unimplemented() {\r\n    throw Error('unimplemented');\r\n}\r\n/**\r\n * Special interface to the compiler only used by testing\r\n *\r\n * \\@publicApi\r\n */\r\nclass TestingCompiler extends Compiler {\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get injector() { throw unimplemented(); }\r\n    /**\r\n     * @param {?} module\r\n     * @param {?} overrides\r\n     * @return {?}\r\n     */\r\n    overrideModule(module, overrides) {\r\n        throw unimplemented();\r\n    }\r\n    /**\r\n     * @param {?} directive\r\n     * @param {?} overrides\r\n     * @return {?}\r\n     */\r\n    overrideDirective(directive, overrides) {\r\n        throw unimplemented();\r\n    }\r\n    /**\r\n     * @param {?} component\r\n     * @param {?} overrides\r\n     * @return {?}\r\n     */\r\n    overrideComponent(component, overrides) {\r\n        throw unimplemented();\r\n    }\r\n    /**\r\n     * @param {?} directive\r\n     * @param {?} overrides\r\n     * @return {?}\r\n     */\r\n    overridePipe(directive, overrides) {\r\n        throw unimplemented();\r\n    }\r\n    /**\r\n     * Allows to pass the compile summary from AOT compilation to the JIT compiler,\r\n     * so that it can use the code generated by AOT.\r\n     * @param {?} summaries\r\n     * @return {?}\r\n     */\r\n    loadAotSummaries(summaries) { throw unimplemented(); }\r\n    /**\r\n     * Gets the component factory for the given component.\r\n     * This assumes that the component has been compiled before calling this call using\r\n     * `compileModuleAndAllComponents*`.\r\n     * @template T\r\n     * @param {?} component\r\n     * @return {?}\r\n     */\r\n    getComponentFactory(component) { throw unimplemented(); }\r\n    /**\r\n     * Returns the component type that is stored in the given error.\r\n     * This can be used for errors created by compileModule...\r\n     * @param {?} error\r\n     * @return {?}\r\n     */\r\n    getComponentFromError(error) { throw unimplemented(); }\r\n}\r\nTestingCompiler.decorators = [\r\n    { type: Injectable }\r\n];\r\n/**\r\n * A factory for creating a Compiler\r\n *\r\n * \\@publicApi\r\n * @abstract\r\n */\r\nclass TestingCompilerFactory {\r\n}\r\nif (false) {\r\n    /**\r\n     * @abstract\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    TestingCompilerFactory.prototype.createTestingCompiler = function (options) { };\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @type {?} */\r\nconst UNDEFINED$1 = new Object();\r\n/** @type {?} */\r\nlet _nextRootElementId$1 = 0;\r\n// WARNING: interface has both a type and a value, skipping emit\r\n/**\r\n * \\@description\r\n * Configures and initializes environment for unit testing and provides methods for\r\n * creating components and services in unit tests.\r\n *\r\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\r\n *\r\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\r\n * according to the compiler used.\r\n */\r\nclass TestBedViewEngine {\r\n    constructor() {\r\n        this._instantiated = false;\r\n        this._compiler = (/** @type {?} */ (null));\r\n        this._moduleRef = (/** @type {?} */ (null));\r\n        this._moduleFactory = (/** @type {?} */ (null));\r\n        this._compilerOptions = [];\r\n        this._moduleOverrides = [];\r\n        this._componentOverrides = [];\r\n        this._directiveOverrides = [];\r\n        this._pipeOverrides = [];\r\n        this._providers = [];\r\n        this._declarations = [];\r\n        this._imports = [];\r\n        this._schemas = [];\r\n        this._activeFixtures = [];\r\n        this._testEnvAotSummaries = (/**\r\n         * @return {?}\r\n         */\r\n        () => []);\r\n        this._aotSummaries = [];\r\n        this._templateOverrides = [];\r\n        this._isRoot = true;\r\n        this._rootProviderOverrides = [];\r\n        this.platform = (/** @type {?} */ (null));\r\n        this.ngModule = (/** @type {?} */ (null));\r\n    }\r\n    /**\r\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\r\n     * angular module. These are common to every test in the suite.\r\n     *\r\n     * This may only be called once, to set up the common providers for the current test\r\n     * suite on the current platform. If you absolutely need to change the providers,\r\n     * first use `resetTestEnvironment`.\r\n     *\r\n     * Test modules and platforms for individual platforms are available from\r\n     * '\\@angular/<platform_name>/testing'.\r\n     * @param {?} ngModule\r\n     * @param {?} platform\r\n     * @param {?=} aotSummaries\r\n     * @return {?}\r\n     */\r\n    static initTestEnvironment(ngModule, platform, aotSummaries) {\r\n        /** @type {?} */\r\n        const testBed = _getTestBedViewEngine();\r\n        testBed.initTestEnvironment(ngModule, platform, aotSummaries);\r\n        return testBed;\r\n    }\r\n    /**\r\n     * Reset the providers for the test injector.\r\n     * @return {?}\r\n     */\r\n    static resetTestEnvironment() { _getTestBedViewEngine().resetTestEnvironment(); }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    static resetTestingModule() {\r\n        _getTestBedViewEngine().resetTestingModule();\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\r\n    }\r\n    /**\r\n     * Allows overriding default compiler providers and settings\r\n     * which are defined in test_injector.js\r\n     * @param {?} config\r\n     * @return {?}\r\n     */\r\n    static configureCompiler(config) {\r\n        _getTestBedViewEngine().configureCompiler(config);\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\r\n    }\r\n    /**\r\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\r\n     * which are defined in test_injector.js\r\n     * @param {?} moduleDef\r\n     * @return {?}\r\n     */\r\n    static configureTestingModule(moduleDef) {\r\n        _getTestBedViewEngine().configureTestingModule(moduleDef);\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\r\n    }\r\n    /**\r\n     * Compile components with a `templateUrl` for the test's NgModule.\r\n     * It is necessary to call this function\r\n     * as fetching urls is asynchronous.\r\n     * @return {?}\r\n     */\r\n    static compileComponents() { return getTestBed().compileComponents(); }\r\n    /**\r\n     * @param {?} ngModule\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    static overrideModule(ngModule, override) {\r\n        _getTestBedViewEngine().overrideModule(ngModule, override);\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\r\n    }\r\n    /**\r\n     * @param {?} component\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    static overrideComponent(component, override) {\r\n        _getTestBedViewEngine().overrideComponent(component, override);\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\r\n    }\r\n    /**\r\n     * @param {?} directive\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    static overrideDirective(directive, override) {\r\n        _getTestBedViewEngine().overrideDirective(directive, override);\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\r\n    }\r\n    /**\r\n     * @param {?} pipe\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    static overridePipe(pipe, override) {\r\n        _getTestBedViewEngine().overridePipe(pipe, override);\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\r\n    }\r\n    /**\r\n     * @param {?} component\r\n     * @param {?} template\r\n     * @return {?}\r\n     */\r\n    static overrideTemplate(component, template) {\r\n        _getTestBedViewEngine().overrideComponent(component, { set: { template, templateUrl: (/** @type {?} */ (null)) } });\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\r\n    }\r\n    /**\r\n     * Overrides the template of the given component, compiling the template\r\n     * in the context of the TestingModule.\r\n     *\r\n     * Note: This works for JIT and AOTed components as well.\r\n     * @param {?} component\r\n     * @param {?} template\r\n     * @return {?}\r\n     */\r\n    static overrideTemplateUsingTestingModule(component, template) {\r\n        _getTestBedViewEngine().overrideTemplateUsingTestingModule(component, template);\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\r\n    }\r\n    /**\r\n     * @param {?} token\r\n     * @param {?} provider\r\n     * @return {?}\r\n     */\r\n    static overrideProvider(token, provider) {\r\n        _getTestBedViewEngine().overrideProvider(token, (/** @type {?} */ (provider)));\r\n        return (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\r\n    }\r\n    /**\r\n     * @param {?} token\r\n     * @param {?=} notFoundValue\r\n     * @param {?=} flags\r\n     * @return {?}\r\n     */\r\n    static get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\r\n        return _getTestBedViewEngine().get(token, notFoundValue, flags);\r\n    }\r\n    /**\r\n     * @template T\r\n     * @param {?} component\r\n     * @return {?}\r\n     */\r\n    static createComponent(component) {\r\n        return _getTestBedViewEngine().createComponent(component);\r\n    }\r\n    /**\r\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\r\n     * angular module. These are common to every test in the suite.\r\n     *\r\n     * This may only be called once, to set up the common providers for the current test\r\n     * suite on the current platform. If you absolutely need to change the providers,\r\n     * first use `resetTestEnvironment`.\r\n     *\r\n     * Test modules and platforms for individual platforms are available from\r\n     * '\\@angular/<platform_name>/testing'.\r\n     * @param {?} ngModule\r\n     * @param {?} platform\r\n     * @param {?=} aotSummaries\r\n     * @return {?}\r\n     */\r\n    initTestEnvironment(ngModule, platform, aotSummaries) {\r\n        if (this.platform || this.ngModule) {\r\n            throw new Error('Cannot set base providers because it has already been called');\r\n        }\r\n        this.platform = platform;\r\n        this.ngModule = ngModule;\r\n        if (aotSummaries) {\r\n            this._testEnvAotSummaries = aotSummaries;\r\n        }\r\n    }\r\n    /**\r\n     * Reset the providers for the test injector.\r\n     * @return {?}\r\n     */\r\n    resetTestEnvironment() {\r\n        this.resetTestingModule();\r\n        this.platform = (/** @type {?} */ (null));\r\n        this.ngModule = (/** @type {?} */ (null));\r\n        this._testEnvAotSummaries = (/**\r\n         * @return {?}\r\n         */\r\n        () => []);\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    resetTestingModule() {\r\n        ɵclearOverrides();\r\n        this._aotSummaries = [];\r\n        this._templateOverrides = [];\r\n        this._compiler = (/** @type {?} */ (null));\r\n        this._moduleOverrides = [];\r\n        this._componentOverrides = [];\r\n        this._directiveOverrides = [];\r\n        this._pipeOverrides = [];\r\n        this._isRoot = true;\r\n        this._rootProviderOverrides = [];\r\n        this._moduleRef = (/** @type {?} */ (null));\r\n        this._moduleFactory = (/** @type {?} */ (null));\r\n        this._compilerOptions = [];\r\n        this._providers = [];\r\n        this._declarations = [];\r\n        this._imports = [];\r\n        this._schemas = [];\r\n        this._instantiated = false;\r\n        this._activeFixtures.forEach((/**\r\n         * @param {?} fixture\r\n         * @return {?}\r\n         */\r\n        (fixture) => {\r\n            try {\r\n                fixture.destroy();\r\n            }\r\n            catch (e) {\r\n                console.error('Error during cleanup of component', {\r\n                    component: fixture.componentInstance,\r\n                    stacktrace: e,\r\n                });\r\n            }\r\n        }));\r\n        this._activeFixtures = [];\r\n    }\r\n    /**\r\n     * @param {?} config\r\n     * @return {?}\r\n     */\r\n    configureCompiler(config) {\r\n        this._assertNotInstantiated('TestBed.configureCompiler', 'configure the compiler');\r\n        this._compilerOptions.push(config);\r\n    }\r\n    /**\r\n     * @param {?} moduleDef\r\n     * @return {?}\r\n     */\r\n    configureTestingModule(moduleDef) {\r\n        this._assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\r\n        if (moduleDef.providers) {\r\n            this._providers.push(...moduleDef.providers);\r\n        }\r\n        if (moduleDef.declarations) {\r\n            this._declarations.push(...moduleDef.declarations);\r\n        }\r\n        if (moduleDef.imports) {\r\n            this._imports.push(...moduleDef.imports);\r\n        }\r\n        if (moduleDef.schemas) {\r\n            this._schemas.push(...moduleDef.schemas);\r\n        }\r\n        if (moduleDef.aotSummaries) {\r\n            this._aotSummaries.push(moduleDef.aotSummaries);\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    compileComponents() {\r\n        if (this._moduleFactory || this._instantiated) {\r\n            return Promise.resolve(null);\r\n        }\r\n        /** @type {?} */\r\n        const moduleType = this._createCompilerAndModule();\r\n        return this._compiler.compileModuleAndAllComponentsAsync(moduleType)\r\n            .then((/**\r\n         * @param {?} moduleAndComponentFactories\r\n         * @return {?}\r\n         */\r\n        (moduleAndComponentFactories) => {\r\n            this._moduleFactory = moduleAndComponentFactories.ngModuleFactory;\r\n        }));\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _initIfNeeded() {\r\n        if (this._instantiated) {\r\n            return;\r\n        }\r\n        if (!this._moduleFactory) {\r\n            try {\r\n                /** @type {?} */\r\n                const moduleType = this._createCompilerAndModule();\r\n                this._moduleFactory =\r\n                    this._compiler.compileModuleAndAllComponentsSync(moduleType).ngModuleFactory;\r\n            }\r\n            catch (e) {\r\n                /** @type {?} */\r\n                const errorCompType = this._compiler.getComponentFromError(e);\r\n                if (errorCompType) {\r\n                    throw new Error(`This test module uses the component ${ɵstringify(errorCompType)} which is using a \"templateUrl\" or \"styleUrls\", but they were never compiled. ` +\r\n                        `Please call \"TestBed.compileComponents\" before your test.`);\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        for (const { component, templateOf } of this._templateOverrides) {\r\n            /** @type {?} */\r\n            const compFactory = this._compiler.getComponentFactory(templateOf);\r\n            ɵoverrideComponentView(component, compFactory);\r\n        }\r\n        /** @type {?} */\r\n        const ngZone = new NgZone({ enableLongStackTrace: true });\r\n        /** @type {?} */\r\n        const providers = [{ provide: NgZone, useValue: ngZone }];\r\n        /** @type {?} */\r\n        const ngZoneInjector = Injector.create({\r\n            providers: providers,\r\n            parent: this.platform.injector,\r\n            name: this._moduleFactory.moduleType.name\r\n        });\r\n        this._moduleRef = this._moduleFactory.create(ngZoneInjector);\r\n        // ApplicationInitStatus.runInitializers() is marked @internal to core. So casting to any\r\n        // before accessing it.\r\n        ((/** @type {?} */ (this._moduleRef.injector.get(ApplicationInitStatus)))).runInitializers();\r\n        this._instantiated = true;\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _createCompilerAndModule() {\r\n        /** @type {?} */\r\n        const providers = this._providers.concat([{ provide: TestBed, useValue: this }]);\r\n        /** @type {?} */\r\n        const declarations = [...this._declarations, ...this._templateOverrides.map((/**\r\n             * @param {?} entry\r\n             * @return {?}\r\n             */\r\n            entry => entry.templateOf))];\r\n        /** @type {?} */\r\n        const rootScopeImports = [];\r\n        /** @type {?} */\r\n        const rootProviderOverrides = this._rootProviderOverrides;\r\n        if (this._isRoot) {\r\n            class RootScopeModule {\r\n            }\r\n            RootScopeModule.decorators = [\r\n                { type: NgModule, args: [{\r\n                            providers: [\r\n                                ...rootProviderOverrides,\r\n                            ],\r\n                            jit: true,\r\n                        },] },\r\n            ];\r\n            rootScopeImports.push(RootScopeModule);\r\n        }\r\n        providers.push({ provide: ɵAPP_ROOT, useValue: this._isRoot });\r\n        /** @type {?} */\r\n        const imports = [rootScopeImports, this.ngModule, this._imports];\r\n        /** @type {?} */\r\n        const schemas = this._schemas;\r\n        class DynamicTestModule {\r\n        }\r\n        DynamicTestModule.decorators = [\r\n            { type: NgModule, args: [{ providers, declarations, imports, schemas, jit: true },] },\r\n        ];\r\n        /** @type {?} */\r\n        const compilerFactory = this.platform.injector.get(TestingCompilerFactory);\r\n        this._compiler = compilerFactory.createTestingCompiler(this._compilerOptions);\r\n        for (const summary of [this._testEnvAotSummaries, ...this._aotSummaries]) {\r\n            this._compiler.loadAotSummaries(summary);\r\n        }\r\n        this._moduleOverrides.forEach((/**\r\n         * @param {?} entry\r\n         * @return {?}\r\n         */\r\n        (entry) => this._compiler.overrideModule(entry[0], entry[1])));\r\n        this._componentOverrides.forEach((/**\r\n         * @param {?} entry\r\n         * @return {?}\r\n         */\r\n        (entry) => this._compiler.overrideComponent(entry[0], entry[1])));\r\n        this._directiveOverrides.forEach((/**\r\n         * @param {?} entry\r\n         * @return {?}\r\n         */\r\n        (entry) => this._compiler.overrideDirective(entry[0], entry[1])));\r\n        this._pipeOverrides.forEach((/**\r\n         * @param {?} entry\r\n         * @return {?}\r\n         */\r\n        (entry) => this._compiler.overridePipe(entry[0], entry[1])));\r\n        return DynamicTestModule;\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} methodName\r\n     * @param {?} methodDescription\r\n     * @return {?}\r\n     */\r\n    _assertNotInstantiated(methodName, methodDescription) {\r\n        if (this._instantiated) {\r\n            throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` +\r\n                `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\r\n        }\r\n    }\r\n    /**\r\n     * @param {?} token\r\n     * @param {?=} notFoundValue\r\n     * @param {?=} flags\r\n     * @return {?}\r\n     */\r\n    get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\r\n        this._initIfNeeded();\r\n        if (token === TestBed) {\r\n            return this;\r\n        }\r\n        // Tests can inject things from the ng module and from the compiler,\r\n        // but the ng module can't inject things from the compiler and vice versa.\r\n        /** @type {?} */\r\n        const result = this._moduleRef.injector.get(token, UNDEFINED$1, flags);\r\n        return result === UNDEFINED$1 ? this._compiler.injector.get(token, notFoundValue, flags) : result;\r\n    }\r\n    /**\r\n     * @param {?} tokens\r\n     * @param {?} fn\r\n     * @param {?=} context\r\n     * @return {?}\r\n     */\r\n    execute(tokens, fn, context) {\r\n        this._initIfNeeded();\r\n        /** @type {?} */\r\n        const params = tokens.map((/**\r\n         * @param {?} t\r\n         * @return {?}\r\n         */\r\n        t => this.get(t)));\r\n        return fn.apply(context, params);\r\n    }\r\n    /**\r\n     * @param {?} ngModule\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    overrideModule(ngModule, override) {\r\n        this._assertNotInstantiated('overrideModule', 'override module metadata');\r\n        this._moduleOverrides.push([ngModule, override]);\r\n    }\r\n    /**\r\n     * @param {?} component\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    overrideComponent(component, override) {\r\n        this._assertNotInstantiated('overrideComponent', 'override component metadata');\r\n        this._componentOverrides.push([component, override]);\r\n    }\r\n    /**\r\n     * @param {?} directive\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    overrideDirective(directive, override) {\r\n        this._assertNotInstantiated('overrideDirective', 'override directive metadata');\r\n        this._directiveOverrides.push([directive, override]);\r\n    }\r\n    /**\r\n     * @param {?} pipe\r\n     * @param {?} override\r\n     * @return {?}\r\n     */\r\n    overridePipe(pipe, override) {\r\n        this._assertNotInstantiated('overridePipe', 'override pipe metadata');\r\n        this._pipeOverrides.push([pipe, override]);\r\n    }\r\n    /**\r\n     * @param {?} token\r\n     * @param {?} provider\r\n     * @return {?}\r\n     */\r\n    overrideProvider(token, provider) {\r\n        this.overrideProviderImpl(token, provider);\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} token\r\n     * @param {?} provider\r\n     * @param {?=} deprecated\r\n     * @return {?}\r\n     */\r\n    overrideProviderImpl(token, provider, deprecated = false) {\r\n        /** @type {?} */\r\n        let def = null;\r\n        if (typeof token !== 'string' && (def = ɵgetInjectableDef(token)) && def.providedIn === 'root') {\r\n            if (provider.useFactory) {\r\n                this._rootProviderOverrides.push({ provide: token, useFactory: provider.useFactory, deps: provider.deps || [] });\r\n            }\r\n            else {\r\n                this._rootProviderOverrides.push({ provide: token, useValue: provider.useValue });\r\n            }\r\n        }\r\n        /** @type {?} */\r\n        let flags = 0;\r\n        /** @type {?} */\r\n        let value;\r\n        if (provider.useFactory) {\r\n            flags |= 1024 /* TypeFactoryProvider */;\r\n            value = provider.useFactory;\r\n        }\r\n        else {\r\n            flags |= 256 /* TypeValueProvider */;\r\n            value = provider.useValue;\r\n        }\r\n        /** @type {?} */\r\n        const deps = (provider.deps || []).map((/**\r\n         * @param {?} dep\r\n         * @return {?}\r\n         */\r\n        (dep) => {\r\n            /** @type {?} */\r\n            let depFlags = 0 /* None */;\r\n            /** @type {?} */\r\n            let depToken;\r\n            if (Array.isArray(dep)) {\r\n                dep.forEach((/**\r\n                 * @param {?} entry\r\n                 * @return {?}\r\n                 */\r\n                (entry) => {\r\n                    if (entry instanceof Optional) {\r\n                        depFlags |= 2 /* Optional */;\r\n                    }\r\n                    else if (entry instanceof SkipSelf) {\r\n                        depFlags |= 1 /* SkipSelf */;\r\n                    }\r\n                    else {\r\n                        depToken = entry;\r\n                    }\r\n                }));\r\n            }\r\n            else {\r\n                depToken = dep;\r\n            }\r\n            return [depFlags, depToken];\r\n        }));\r\n        ɵoverrideProvider({ token, flags, deps, value, deprecatedBehavior: deprecated });\r\n    }\r\n    /**\r\n     * @param {?} component\r\n     * @param {?} template\r\n     * @return {?}\r\n     */\r\n    overrideTemplateUsingTestingModule(component, template) {\r\n        this._assertNotInstantiated('overrideTemplateUsingTestingModule', 'override template');\r\n        class OverrideComponent {\r\n        }\r\n        OverrideComponent.decorators = [\r\n            { type: Component, args: [{ selector: 'empty', template, jit: true },] },\r\n        ];\r\n        this._templateOverrides.push({ component, templateOf: OverrideComponent });\r\n    }\r\n    /**\r\n     * @template T\r\n     * @param {?} component\r\n     * @return {?}\r\n     */\r\n    createComponent(component) {\r\n        this._initIfNeeded();\r\n        /** @type {?} */\r\n        const componentFactory = this._compiler.getComponentFactory(component);\r\n        if (!componentFactory) {\r\n            throw new Error(`Cannot create the component ${ɵstringify(component)} as it was not imported into the testing module!`);\r\n        }\r\n        // TODO: Don't cast as `any`, proper type is boolean[]\r\n        /** @type {?} */\r\n        const noNgZone = this.get((/** @type {?} */ (ComponentFixtureNoNgZone)), false);\r\n        // TODO: Don't cast as `any`, proper type is boolean[]\r\n        /** @type {?} */\r\n        const autoDetect = this.get((/** @type {?} */ (ComponentFixtureAutoDetect)), false);\r\n        /** @type {?} */\r\n        const ngZone = noNgZone ? null : this.get((/** @type {?} */ (NgZone)), null);\r\n        /** @type {?} */\r\n        const testComponentRenderer = this.get(TestComponentRenderer);\r\n        /** @type {?} */\r\n        const rootElId = `root${_nextRootElementId$1++}`;\r\n        testComponentRenderer.insertRootElement(rootElId);\r\n        /** @type {?} */\r\n        const initComponent = (/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            /** @type {?} */\r\n            const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this._moduleRef);\r\n            return new ComponentFixture(componentRef, ngZone, autoDetect);\r\n        });\r\n        /** @type {?} */\r\n        const fixture = !ngZone ? initComponent() : ngZone.run(initComponent);\r\n        this._activeFixtures.push(fixture);\r\n        return fixture;\r\n    }\r\n}\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedViewEngine.prototype._instantiated;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedViewEngine.prototype._compiler;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedViewEngine.prototype._moduleRef;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedViewEngine.prototype._moduleFactory;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedViewEngine.prototype._compilerOptions;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedViewEngine.prototype._moduleOverrides;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedViewEngine.prototype._componentOverrides;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedViewEngine.prototype._directiveOverrides;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedViewEngine.prototype._pipeOverrides;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedViewEngine.prototype._providers;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedViewEngine.prototype._declarations;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedViewEngine.prototype._imports;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedViewEngine.prototype._schemas;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedViewEngine.prototype._activeFixtures;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedViewEngine.prototype._testEnvAotSummaries;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedViewEngine.prototype._aotSummaries;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedViewEngine.prototype._templateOverrides;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedViewEngine.prototype._isRoot;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    TestBedViewEngine.prototype._rootProviderOverrides;\r\n    /** @type {?} */\r\n    TestBedViewEngine.prototype.platform;\r\n    /** @type {?} */\r\n    TestBedViewEngine.prototype.ngModule;\r\n}\r\n/**\r\n * \\@description\r\n * Configures and initializes environment for unit testing and provides methods for\r\n * creating components and services in unit tests.\r\n *\r\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\r\n *\r\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\r\n * according to the compiler used.\r\n *\r\n * \\@publicApi\r\n * @type {?}\r\n */\r\nconst TestBed = ɵivyEnabled ? (/** @type {?} */ ((/** @type {?} */ (TestBedRender3)))) : (/** @type {?} */ ((/** @type {?} */ (TestBedViewEngine))));\r\n/**\r\n * Returns a singleton of the applicable `TestBed`.\r\n *\r\n * It will be either an instance of `TestBedViewEngine` or `TestBedRender3`.\r\n *\r\n * \\@publicApi\r\n * @type {?}\r\n */\r\nconst getTestBed = ɵivyEnabled ? _getTestBedRender3 : _getTestBedViewEngine;\r\n/** @type {?} */\r\nlet testBed$1;\r\n/**\r\n * @return {?}\r\n */\r\nfunction _getTestBedViewEngine() {\r\n    return testBed$1 = testBed$1 || new TestBedViewEngine();\r\n}\r\n/**\r\n * Allows injecting dependencies in `beforeEach()` and `it()`.\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\r\n *   // some code that uses `dep` and `object`\r\n *   // ...\r\n * }));\r\n *\r\n * it('...', inject([AClass], (object) => {\r\n *   object.doSomething();\r\n *   expect(...);\r\n * })\r\n * ```\r\n *\r\n * Notes:\r\n * - inject is currently a function because of some Traceur limitation the syntax should\r\n * eventually\r\n *   becomes `it('...', \\@Inject (object: AClass, async: AsyncTestCompleter) => { ... });`\r\n *\r\n * \\@publicApi\r\n * @param {?} tokens\r\n * @param {?} fn\r\n * @return {?}\r\n */\r\nfunction inject(tokens, fn) {\r\n    /** @type {?} */\r\n    const testBed = getTestBed();\r\n    if (tokens.indexOf(AsyncTestCompleter) >= 0) {\r\n        // Not using an arrow function to preserve context passed from call site\r\n        return (/**\r\n         * @this {?}\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            // Return an async test method that returns a Promise if AsyncTestCompleter is one of\r\n            // the injected tokens.\r\n            return testBed.compileComponents().then((/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                /** @type {?} */\r\n                const completer = testBed.get(AsyncTestCompleter);\r\n                testBed.execute(tokens, fn, this);\r\n                return completer.promise;\r\n            }));\r\n        });\r\n    }\r\n    else {\r\n        // Not using an arrow function to preserve context passed from call site\r\n        return (/**\r\n         * @this {?}\r\n         * @return {?}\r\n         */\r\n        function () { return testBed.execute(tokens, fn, this); });\r\n    }\r\n}\r\n/**\r\n * \\@publicApi\r\n */\r\nclass InjectSetupWrapper {\r\n    /**\r\n     * @param {?} _moduleDef\r\n     */\r\n    constructor(_moduleDef) {\r\n        this._moduleDef = _moduleDef;\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _addModule() {\r\n        /** @type {?} */\r\n        const moduleDef = this._moduleDef();\r\n        if (moduleDef) {\r\n            getTestBed().configureTestingModule(moduleDef);\r\n        }\r\n    }\r\n    /**\r\n     * @param {?} tokens\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    inject(tokens, fn) {\r\n        /** @type {?} */\r\n        const self = this;\r\n        // Not using an arrow function to preserve context passed from call site\r\n        return (/**\r\n         * @this {?}\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            self._addModule();\r\n            return inject(tokens, fn).call(this);\r\n        });\r\n    }\r\n}\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    InjectSetupWrapper.prototype._moduleDef;\r\n}\r\n/**\r\n * @param {?} moduleDef\r\n * @param {?=} fn\r\n * @return {?}\r\n */\r\nfunction withModule(moduleDef, fn) {\r\n    if (fn) {\r\n        // Not using an arrow function to preserve context passed from call site\r\n        return (/**\r\n         * @this {?}\r\n         * @return {?}\r\n         */\r\n        function () {\r\n            /** @type {?} */\r\n            const testBed = getTestBed();\r\n            if (moduleDef) {\r\n                testBed.configureTestingModule(moduleDef);\r\n            }\r\n            return fn.apply(this);\r\n        });\r\n    }\r\n    return new InjectSetupWrapper((/**\r\n     * @return {?}\r\n     */\r\n    () => moduleDef));\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @type {?} */\r\nconst _global$1 = (/** @type {?} */ ((typeof window === 'undefined' ? global : window)));\r\n// Reset the test providers and the fake async zone before each test.\r\nif (_global$1.beforeEach) {\r\n    _global$1.beforeEach((/**\r\n     * @return {?}\r\n     */\r\n    () => {\r\n        TestBed.resetTestingModule();\r\n        resetFakeAsyncZone();\r\n    }));\r\n}\r\n// TODO(juliemr): remove this, only used because we need to export something to have compilation\r\n// work.\r\n/** @type {?} */\r\nconst __core_private_testing_placeholder__ = '';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { TestBedRender3 as ɵangular_packages_core_testing_testing_b, _getTestBedRender3 as ɵangular_packages_core_testing_testing_c, TestBedViewEngine as ɵangular_packages_core_testing_testing_a, TestBed, getTestBed, inject, InjectSetupWrapper, withModule, MetadataOverrider as ɵMetadataOverrider, async, ComponentFixture, resetFakeAsyncZone, fakeAsync, tick, flush, discardPeriodicTasks, flushMicrotasks, TestComponentRenderer, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, __core_private_testing_placeholder__, TestingCompiler as ɵTestingCompiler, TestingCompilerFactory as ɵTestingCompilerFactory };\r\n\r\n"]}