/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { stringify } from '../util/stringify';
import { resolveForwardRef } from './forward_ref';
import { INJECTOR, NG_TEMP_TOKEN_PATH, NullInjector, THROW_IF_NOT_FOUND, USE_VALUE, catchInjectorError, formatError, ɵɵinject } from './injector_compatibility';
import { ɵɵdefineInjectable } from './interface/defs';
import { InjectFlags } from './interface/injector';
import { Inject, Optional, Self, SkipSelf } from './metadata';
import { createInjector } from './r3_injector';
/**
 * @param {?} providers
 * @param {?} parent
 * @param {?} name
 * @return {?}
 */
export function INJECTOR_IMPL__PRE_R3__(providers, parent, name) {
    return new StaticInjector(providers, parent, name);
}
/**
 * @param {?} providers
 * @param {?} parent
 * @param {?} name
 * @return {?}
 */
export function INJECTOR_IMPL__POST_R3__(providers, parent, name) {
    return createInjector({ name: name }, parent, providers, name);
}
/** @type {?} */
export const INJECTOR_IMPL = INJECTOR_IMPL__POST_R3__;
/**
 * Concrete injectors implement this interface.
 *
 * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
 *
 * \@usageNotes
 * ### Example
 *
 * {\@example core/di/ts/injector_spec.ts region='Injector'}
 *
 * `Injector` returns itself when given `Injector` as a token:
 *
 * {\@example core/di/ts/injector_spec.ts region='injectInjector'}
 *
 * \@publicApi
 * @abstract
 */
export class Injector {
    /**
     * Create a new Injector which is configure using `StaticProvider`s.
     *
     * \@usageNotes
     * ### Example
     *
     * {\@example core/di/ts/provider_spec.ts region='ConstructorProvider'}
     * @param {?} options
     * @param {?=} parent
     * @return {?}
     */
    static create(options, parent) {
        if (Array.isArray(options)) {
            return INJECTOR_IMPL(options, parent, '');
        }
        else {
            return INJECTOR_IMPL(options.providers, options.parent, options.name || '');
        }
    }
}
Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
Injector.NULL = new NullInjector();
/** @nocollapse */
/** @nocollapse */ Injector.ngInjectableDef = ɵɵdefineInjectable({
    token: Injector,
    providedIn: (/** @type {?} */ ('any')),
    factory: (/**
     * @return {?}
     */
    () => ɵɵinject(INJECTOR)),
});
/**
 * \@internal
 * @nocollapse
 */
Injector.__NG_ELEMENT_ID__ = -1;
if (false) {
    /** @type {?} */
    Injector.THROW_IF_NOT_FOUND;
    /** @type {?} */
    Injector.NULL;
    /**
     * @nocollapse
     * @type {?}
     */
    Injector.ngInjectableDef;
    /**
     * \@internal
     * @nocollapse
     * @type {?}
     */
    Injector.__NG_ELEMENT_ID__;
    /**
     * Retrieves an instance from the injector based on the provided token.
     * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.
     * @abstract
     * @template T
     * @param {?} token
     * @param {?=} notFoundValue
     * @param {?=} flags
     * @return {?} The instance from the injector if defined, otherwise the `notFoundValue`.
     */
    Injector.prototype.get = function (token, notFoundValue, flags) { };
    /**
     * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>
     * @suppress {duplicate}
     * @abstract
     * @param {?} token
     * @param {?=} notFoundValue
     * @return {?}
     */
    Injector.prototype.get = function (token, notFoundValue) { };
}
/** @type {?} */
const IDENT = (/**
 * @template T
 * @param {?} value
 * @return {?}
 */
function (value) {
    return value;
});
const ɵ0 = IDENT;
/** @type {?} */
const EMPTY = (/** @type {?} */ ([]));
/** @type {?} */
const CIRCULAR = IDENT;
/** @type {?} */
const MULTI_PROVIDER_FN = (/**
 * @return {?}
 */
function () {
    return Array.prototype.slice.call(arguments);
});
const ɵ1 = MULTI_PROVIDER_FN;
/** @enum {number} */
const OptionFlags = {
    Optional: 1,
    CheckSelf: 2,
    CheckParent: 4,
    Default: 6,
};
/** @type {?} */
const NO_NEW_LINE = 'ɵ';
export class StaticInjector {
    /**
     * @param {?} providers
     * @param {?=} parent
     * @param {?=} source
     */
    constructor(providers, parent = Injector.NULL, source = null) {
        this.parent = parent;
        this.source = source;
        /** @type {?} */
        const records = this._records = new Map();
        records.set(Injector, (/** @type {?} */ ({ token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false })));
        records.set(INJECTOR, (/** @type {?} */ ({ token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false })));
        recursivelyProcessProviders(records, providers);
    }
    /**
     * @param {?} token
     * @param {?=} notFoundValue
     * @param {?=} flags
     * @return {?}
     */
    get(token, notFoundValue, flags = InjectFlags.Default) {
        /** @type {?} */
        const record = this._records.get(token);
        try {
            return tryResolveToken(token, record, this._records, this.parent, notFoundValue, flags);
        }
        catch (e) {
            return catchInjectorError(e, token, 'StaticInjectorError', this.source);
        }
    }
    /**
     * @return {?}
     */
    toString() {
        /** @type {?} */
        const tokens = (/** @type {?} */ ([]));
        /** @type {?} */
        const records = this._records;
        records.forEach((/**
         * @param {?} v
         * @param {?} token
         * @return {?}
         */
        (v, token) => tokens.push(stringify(token))));
        return `StaticInjector[${tokens.join(', ')}]`;
    }
}
if (false) {
    /** @type {?} */
    StaticInjector.prototype.parent;
    /** @type {?} */
    StaticInjector.prototype.source;
    /**
     * @type {?}
     * @private
     */
    StaticInjector.prototype._records;
}
/**
 * @record
 */
function Record() { }
if (false) {
    /** @type {?} */
    Record.prototype.fn;
    /** @type {?} */
    Record.prototype.useNew;
    /** @type {?} */
    Record.prototype.deps;
    /** @type {?} */
    Record.prototype.value;
}
/**
 * @record
 */
function DependencyRecord() { }
if (false) {
    /** @type {?} */
    DependencyRecord.prototype.token;
    /** @type {?} */
    DependencyRecord.prototype.options;
}
/**
 * @param {?} provider
 * @return {?}
 */
function resolveProvider(provider) {
    /** @type {?} */
    const deps = computeDeps(provider);
    /** @type {?} */
    let fn = IDENT;
    /** @type {?} */
    let value = EMPTY;
    /** @type {?} */
    let useNew = false;
    /** @type {?} */
    let provide = resolveForwardRef(provider.provide);
    if (USE_VALUE in provider) {
        // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.
        value = ((/** @type {?} */ (provider))).useValue;
    }
    else if (((/** @type {?} */ (provider))).useFactory) {
        fn = ((/** @type {?} */ (provider))).useFactory;
    }
    else if (((/** @type {?} */ (provider))).useExisting) {
        // Just use IDENT
    }
    else if (((/** @type {?} */ (provider))).useClass) {
        useNew = true;
        fn = resolveForwardRef(((/** @type {?} */ (provider))).useClass);
    }
    else if (typeof provide == 'function') {
        useNew = true;
        fn = provide;
    }
    else {
        throw staticError('StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable', provider);
    }
    return { deps, fn, useNew, value };
}
/**
 * @param {?} token
 * @return {?}
 */
function multiProviderMixError(token) {
    return staticError('Cannot mix multi providers and regular providers', token);
}
/**
 * @param {?} records
 * @param {?} provider
 * @return {?}
 */
function recursivelyProcessProviders(records, provider) {
    if (provider) {
        provider = resolveForwardRef(provider);
        if (provider instanceof Array) {
            // if we have an array recurse into the array
            for (let i = 0; i < provider.length; i++) {
                recursivelyProcessProviders(records, provider[i]);
            }
        }
        else if (typeof provider === 'function') {
            // Functions were supported in ReflectiveInjector, but are not here. For safety give useful
            // error messages
            throw staticError('Function/Class not supported', provider);
        }
        else if (provider && typeof provider === 'object' && provider.provide) {
            // At this point we have what looks like a provider: {provide: ?, ....}
            /** @type {?} */
            let token = resolveForwardRef(provider.provide);
            /** @type {?} */
            const resolvedProvider = resolveProvider(provider);
            if (provider.multi === true) {
                // This is a multi provider.
                /** @type {?} */
                let multiProvider = records.get(token);
                if (multiProvider) {
                    if (multiProvider.fn !== MULTI_PROVIDER_FN) {
                        throw multiProviderMixError(token);
                    }
                }
                else {
                    // Create a placeholder factory which will look up the constituents of the multi provider.
                    records.set(token, multiProvider = (/** @type {?} */ ({
                        token: provider.provide,
                        deps: [],
                        useNew: false,
                        fn: MULTI_PROVIDER_FN,
                        value: EMPTY
                    })));
                }
                // Treat the provider as the token.
                token = provider;
                multiProvider.deps.push({ token, options: 6 /* Default */ });
            }
            /** @type {?} */
            const record = records.get(token);
            if (record && record.fn == MULTI_PROVIDER_FN) {
                throw multiProviderMixError(token);
            }
            records.set(token, resolvedProvider);
        }
        else {
            throw staticError('Unexpected provider', provider);
        }
    }
}
/**
 * @param {?} token
 * @param {?} record
 * @param {?} records
 * @param {?} parent
 * @param {?} notFoundValue
 * @param {?} flags
 * @return {?}
 */
function tryResolveToken(token, record, records, parent, notFoundValue, flags) {
    try {
        return resolveToken(token, record, records, parent, notFoundValue, flags);
    }
    catch (e) {
        // ensure that 'e' is of type Error.
        if (!(e instanceof Error)) {
            e = new Error(e);
        }
        /** @type {?} */
        const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
        path.unshift(token);
        if (record && record.value == CIRCULAR) {
            // Reset the Circular flag.
            record.value = EMPTY;
        }
        throw e;
    }
}
/**
 * @param {?} token
 * @param {?} record
 * @param {?} records
 * @param {?} parent
 * @param {?} notFoundValue
 * @param {?} flags
 * @return {?}
 */
function resolveToken(token, record, records, parent, notFoundValue, flags) {
    /** @type {?} */
    let value;
    if (record && !(flags & InjectFlags.SkipSelf)) {
        // If we don't have a record, this implies that we don't own the provider hence don't know how
        // to resolve it.
        value = record.value;
        if (value == CIRCULAR) {
            throw Error(NO_NEW_LINE + 'Circular dependency');
        }
        else if (value === EMPTY) {
            record.value = CIRCULAR;
            /** @type {?} */
            let obj = undefined;
            /** @type {?} */
            let useNew = record.useNew;
            /** @type {?} */
            let fn = record.fn;
            /** @type {?} */
            let depRecords = record.deps;
            /** @type {?} */
            let deps = EMPTY;
            if (depRecords.length) {
                deps = [];
                for (let i = 0; i < depRecords.length; i++) {
                    /** @type {?} */
                    const depRecord = depRecords[i];
                    /** @type {?} */
                    const options = depRecord.options;
                    /** @type {?} */
                    const childRecord = options & 2 /* CheckSelf */ ? records.get(depRecord.token) : undefined;
                    deps.push(tryResolveToken(
                    // Current Token to resolve
                    depRecord.token, 
                    // A record which describes how to resolve the token.
                    // If undefined, this means we don't have such a record
                    childRecord, 
                    // Other records we know about.
                    records, 
                    // If we don't know how to resolve dependency and we should not check parent for it,
                    // than pass in Null injector.
                    !childRecord && !(options & 4 /* CheckParent */) ? Injector.NULL : parent, options & 1 /* Optional */ ? null : Injector.THROW_IF_NOT_FOUND, InjectFlags.Default));
                }
            }
            record.value = value = useNew ? new ((/** @type {?} */ (fn)))(...deps) : fn.apply(obj, deps);
        }
    }
    else if (!(flags & InjectFlags.Self)) {
        value = parent.get(token, notFoundValue, InjectFlags.Default);
    }
    return value;
}
/**
 * @param {?} provider
 * @return {?}
 */
function computeDeps(provider) {
    /** @type {?} */
    let deps = EMPTY;
    /** @type {?} */
    const providerDeps = ((/** @type {?} */ (provider))).deps;
    if (providerDeps && providerDeps.length) {
        deps = [];
        for (let i = 0; i < providerDeps.length; i++) {
            /** @type {?} */
            let options = 6 /* Default */;
            /** @type {?} */
            let token = resolveForwardRef(providerDeps[i]);
            if (token instanceof Array) {
                for (let j = 0, annotations = token; j < annotations.length; j++) {
                    /** @type {?} */
                    const annotation = annotations[j];
                    if (annotation instanceof Optional || annotation == Optional) {
                        options = options | 1 /* Optional */;
                    }
                    else if (annotation instanceof SkipSelf || annotation == SkipSelf) {
                        options = options & ~2 /* CheckSelf */;
                    }
                    else if (annotation instanceof Self || annotation == Self) {
                        options = options & ~4 /* CheckParent */;
                    }
                    else if (annotation instanceof Inject) {
                        token = ((/** @type {?} */ (annotation))).token;
                    }
                    else {
                        token = resolveForwardRef(annotation);
                    }
                }
            }
            deps.push({ token, options });
        }
    }
    else if (((/** @type {?} */ (provider))).useExisting) {
        /** @type {?} */
        const token = resolveForwardRef(((/** @type {?} */ (provider))).useExisting);
        deps = [{ token, options: 6 /* Default */ }];
    }
    else if (!providerDeps && !(USE_VALUE in provider)) {
        // useValue & useExisting are the only ones which are exempt from deps all others need it.
        throw staticError('\'deps\' required', provider);
    }
    return deps;
}
/**
 * @param {?} text
 * @param {?} obj
 * @return {?}
 */
function staticError(text, obj) {
    return new Error(formatError(text, obj, 'StaticInjectorError'));
}
export { ɵ0, ɵ1 };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9lc20yMDE1L3NyYy9kaS9pbmplY3Rvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2QkFxQzZCLHdCQUF1QiIsImZpbGUiOiJpbmplY3Rvci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGNvbnN0YW50UHJvcGVydHksZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICcuLi91dGlsL3N0cmluZ2lmeSc7XHJcbmltcG9ydCB7IHJlc29sdmVGb3J3YXJkUmVmIH0gZnJvbSAnLi9mb3J3YXJkX3JlZic7XHJcbmltcG9ydCB7IElOSkVDVE9SLCBOR19URU1QX1RPS0VOX1BBVEgsIE51bGxJbmplY3RvciwgVEhST1dfSUZfTk9UX0ZPVU5ELCBVU0VfVkFMVUUsIGNhdGNoSW5qZWN0b3JFcnJvciwgZm9ybWF0RXJyb3IsIMm1ybVpbmplY3QgfSBmcm9tICcuL2luamVjdG9yX2NvbXBhdGliaWxpdHknO1xyXG5pbXBvcnQgeyDJtcm1ZGVmaW5lSW5qZWN0YWJsZSB9IGZyb20gJy4vaW50ZXJmYWNlL2RlZnMnO1xyXG5pbXBvcnQgeyBJbmplY3RGbGFncyB9IGZyb20gJy4vaW50ZXJmYWNlL2luamVjdG9yJztcclxuaW1wb3J0IHsgSW5qZWN0LCBPcHRpb25hbCwgU2VsZiwgU2tpcFNlbGYgfSBmcm9tICcuL21ldGFkYXRhJztcclxuaW1wb3J0IHsgY3JlYXRlSW5qZWN0b3IgfSBmcm9tICcuL3IzX2luamVjdG9yJztcclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gcHJvdmlkZXJzXHJcbiAqIEBwYXJhbSB7P30gcGFyZW50XHJcbiAqIEBwYXJhbSB7P30gbmFtZVxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIElOSkVDVE9SX0lNUExfX1BSRV9SM19fKHByb3ZpZGVycywgcGFyZW50LCBuYW1lKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0YXRpY0luamVjdG9yKHByb3ZpZGVycywgcGFyZW50LCBuYW1lKTtcclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSBwcm92aWRlcnNcclxuICogQHBhcmFtIHs/fSBwYXJlbnRcclxuICogQHBhcmFtIHs/fSBuYW1lXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gSU5KRUNUT1JfSU1QTF9fUE9TVF9SM19fKHByb3ZpZGVycywgcGFyZW50LCBuYW1lKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlSW5qZWN0b3IoeyBuYW1lOiBuYW1lIH0sIHBhcmVudCwgcHJvdmlkZXJzLCBuYW1lKTtcclxufVxyXG4vKiogQHR5cGUgez99ICovXHJcbmV4cG9ydCBjb25zdCBJTkpFQ1RPUl9JTVBMID0gSU5KRUNUT1JfSU1QTF9fUFJFX1IzX187XHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBpbmplY3RvcnMgaW1wbGVtZW50IHRoaXMgaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlIFtcIkRlcGVuZGVuY3kgSW5qZWN0aW9uIEd1aWRlXCJdKGd1aWRlL2RlcGVuZGVuY3ktaW5qZWN0aW9uKS5cclxuICpcclxuICogXFxAdXNhZ2VOb3Rlc1xyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiB7XFxAZXhhbXBsZSBjb3JlL2RpL3RzL2luamVjdG9yX3NwZWMudHMgcmVnaW9uPSdJbmplY3Rvcid9XHJcbiAqXHJcbiAqIGBJbmplY3RvcmAgcmV0dXJucyBpdHNlbGYgd2hlbiBnaXZlbiBgSW5qZWN0b3JgIGFzIGEgdG9rZW46XHJcbiAqXHJcbiAqIHtcXEBleGFtcGxlIGNvcmUvZGkvdHMvaW5qZWN0b3Jfc3BlYy50cyByZWdpb249J2luamVjdEluamVjdG9yJ31cclxuICpcclxuICogXFxAcHVibGljQXBpXHJcbiAqIEBhYnN0cmFjdFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEluamVjdG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IEluamVjdG9yIHdoaWNoIGlzIGNvbmZpZ3VyZSB1c2luZyBgU3RhdGljUHJvdmlkZXJgcy5cclxuICAgICAqXHJcbiAgICAgKiBcXEB1c2FnZU5vdGVzXHJcbiAgICAgKiAjIyMgRXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHtcXEBleGFtcGxlIGNvcmUvZGkvdHMvcHJvdmlkZXJfc3BlYy50cyByZWdpb249J0NvbnN0cnVjdG9yUHJvdmlkZXInfVxyXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gez89fSBwYXJlbnRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGUob3B0aW9ucywgcGFyZW50KSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIElOSkVDVE9SX0lNUEwob3B0aW9ucywgcGFyZW50LCAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gSU5KRUNUT1JfSU1QTChvcHRpb25zLnByb3ZpZGVycywgb3B0aW9ucy5wYXJlbnQsIG9wdGlvbnMubmFtZSB8fCAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbkluamVjdG9yLlRIUk9XX0lGX05PVF9GT1VORCA9IFRIUk9XX0lGX05PVF9GT1VORDtcclxuSW5qZWN0b3IuTlVMTCA9IG5ldyBOdWxsSW5qZWN0b3IoKTtcclxuLyoqIEBub2NvbGxhcHNlICovXHJcbi8qKiBAbm9jb2xsYXBzZSAqLyBJbmplY3Rvci5uZ0luamVjdGFibGVEZWYgPSDJtcm1ZGVmaW5lSW5qZWN0YWJsZSh7XHJcbiAgICB0b2tlbjogSW5qZWN0b3IsXHJcbiAgICBwcm92aWRlZEluOiAoLyoqIEB0eXBlIHs/fSAqLyAoJ2FueScpKSxcclxuICAgIGZhY3Rvcnk6ICgvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgICgpID0+IMm1ybVpbmplY3QoSU5KRUNUT1IpKSxcclxufSk7XHJcbi8qKlxyXG4gKiBcXEBpbnRlcm5hbFxyXG4gKiBAbm9jb2xsYXBzZVxyXG4gKi9cclxuSW5qZWN0b3IuX19OR19FTEVNRU5UX0lEX18gPSAtMTtcclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBJbmplY3Rvci5USFJPV19JRl9OT1RfRk9VTkQ7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBJbmplY3Rvci5OVUxMO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbm9jb2xsYXBzZVxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIEluamVjdG9yLm5nSW5qZWN0YWJsZURlZjtcclxuICAgIC8qKlxyXG4gICAgICogXFxAaW50ZXJuYWxcclxuICAgICAqIEBub2NvbGxhcHNlXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgSW5qZWN0b3IuX19OR19FTEVNRU5UX0lEX187XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhbiBpbnN0YW5jZSBmcm9tIHRoZSBpbmplY3RvciBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgdG9rZW4uXHJcbiAgICAgKiBAdGhyb3dzIFdoZW4gdGhlIGBub3RGb3VuZFZhbHVlYCBpcyBgdW5kZWZpbmVkYCBvciBgSW5qZWN0b3IuVEhST1dfSUZfTk9UX0ZPVU5EYC5cclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHRlbXBsYXRlIFRcclxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cclxuICAgICAqIEBwYXJhbSB7Pz19IG5vdEZvdW5kVmFsdWVcclxuICAgICAqIEBwYXJhbSB7Pz19IGZsYWdzXHJcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgaW5zdGFuY2UgZnJvbSB0aGUgaW5qZWN0b3IgaWYgZGVmaW5lZCwgb3RoZXJ3aXNlIHRoZSBgbm90Rm91bmRWYWx1ZWAuXHJcbiAgICAgKi9cclxuICAgIEluamVjdG9yLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9rZW4sIG5vdEZvdW5kVmFsdWUsIGZsYWdzKSB7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBkZXByZWNhdGVkIGZyb20gdjQuMC4wIHVzZSBUeXBlPFQ+IG9yIEluamVjdGlvblRva2VuPFQ+XHJcbiAgICAgKiBAc3VwcHJlc3Mge2R1cGxpY2F0ZX1cclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblxyXG4gICAgICogQHBhcmFtIHs/PX0gbm90Rm91bmRWYWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgSW5qZWN0b3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSkgeyB9O1xyXG59XHJcbi8qKiBAdHlwZSB7P30gKi9cclxuY29uc3QgSURFTlQgPSAoLyoqXHJcbiAqIEB0ZW1wbGF0ZSBUXHJcbiAqIEBwYXJhbSB7P30gdmFsdWVcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59KTtcclxuY29uc3QgybUwID0gSURFTlQ7XHJcbi8qKiBAdHlwZSB7P30gKi9cclxuY29uc3QgRU1QVFkgPSAoLyoqIEB0eXBlIHs/fSAqLyAoW10pKTtcclxuLyoqIEB0eXBlIHs/fSAqL1xyXG5jb25zdCBDSVJDVUxBUiA9IElERU5UO1xyXG4vKiogQHR5cGUgez99ICovXHJcbmNvbnN0IE1VTFRJX1BST1ZJREVSX0ZOID0gKC8qKlxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbn0pO1xyXG5jb25zdCDJtTEgPSBNVUxUSV9QUk9WSURFUl9GTjtcclxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXHJcbmNvbnN0IE9wdGlvbkZsYWdzID0ge1xyXG4gICAgT3B0aW9uYWw6IDEsXHJcbiAgICBDaGVja1NlbGY6IDIsXHJcbiAgICBDaGVja1BhcmVudDogNCxcclxuICAgIERlZmF1bHQ6IDYsXHJcbn07XHJcbi8qKiBAdHlwZSB7P30gKi9cclxuY29uc3QgTk9fTkVXX0xJTkUgPSAnybUnO1xyXG5leHBvcnQgY2xhc3MgU3RhdGljSW5qZWN0b3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyc1xyXG4gICAgICogQHBhcmFtIHs/PX0gcGFyZW50XHJcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXJzLCBwYXJlbnQgPSBJbmplY3Rvci5OVUxMLCBzb3VyY2UgPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIGNvbnN0IHJlY29yZHMgPSB0aGlzLl9yZWNvcmRzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHJlY29yZHMuc2V0KEluamVjdG9yLCAoLyoqIEB0eXBlIHs/fSAqLyAoeyB0b2tlbjogSW5qZWN0b3IsIGZuOiBJREVOVCwgZGVwczogRU1QVFksIHZhbHVlOiB0aGlzLCB1c2VOZXc6IGZhbHNlIH0pKSk7XHJcbiAgICAgICAgcmVjb3Jkcy5zZXQoSU5KRUNUT1IsICgvKiogQHR5cGUgez99ICovICh7IHRva2VuOiBJTkpFQ1RPUiwgZm46IElERU5ULCBkZXBzOiBFTVBUWSwgdmFsdWU6IHRoaXMsIHVzZU5ldzogZmFsc2UgfSkpKTtcclxuICAgICAgICByZWN1cnNpdmVseVByb2Nlc3NQcm92aWRlcnMocmVjb3JkcywgcHJvdmlkZXJzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblxyXG4gICAgICogQHBhcmFtIHs/PX0gbm90Rm91bmRWYWx1ZVxyXG4gICAgICogQHBhcmFtIHs/PX0gZmxhZ3NcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGdldCh0b2tlbiwgbm90Rm91bmRWYWx1ZSwgZmxhZ3MgPSBJbmplY3RGbGFncy5EZWZhdWx0KSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIGNvbnN0IHJlY29yZCA9IHRoaXMuX3JlY29yZHMuZ2V0KHRva2VuKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ5UmVzb2x2ZVRva2VuKHRva2VuLCByZWNvcmQsIHRoaXMuX3JlY29yZHMsIHRoaXMucGFyZW50LCBub3RGb3VuZFZhbHVlLCBmbGFncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYXRjaEluamVjdG9yRXJyb3IoZSwgdG9rZW4sICdTdGF0aWNJbmplY3RvckVycm9yJywgdGhpcy5zb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIGNvbnN0IHRva2VucyA9ICgvKiogQHR5cGUgez99ICovIChbXSkpO1xyXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICBjb25zdCByZWNvcmRzID0gdGhpcy5fcmVjb3JkcztcclxuICAgICAgICByZWNvcmRzLmZvckVhY2goKC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gdG9rZW5cclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgICh2LCB0b2tlbikgPT4gdG9rZW5zLnB1c2goc3RyaW5naWZ5KHRva2VuKSkpKTtcclxuICAgICAgICByZXR1cm4gYFN0YXRpY0luamVjdG9yWyR7dG9rZW5zLmpvaW4oJywgJyl9XWA7XHJcbiAgICB9XHJcbn1cclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBTdGF0aWNJbmplY3Rvci5wcm90b3R5cGUucGFyZW50O1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgU3RhdGljSW5qZWN0b3IucHJvdG90eXBlLnNvdXJjZTtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBTdGF0aWNJbmplY3Rvci5wcm90b3R5cGUuX3JlY29yZHM7XHJcbn1cclxuLyoqXHJcbiAqIEByZWNvcmRcclxuICovXHJcbmZ1bmN0aW9uIFJlY29yZCgpIHsgfVxyXG5pZiAoZmFsc2UpIHtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIFJlY29yZC5wcm90b3R5cGUuZm47XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBSZWNvcmQucHJvdG90eXBlLnVzZU5ldztcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIFJlY29yZC5wcm90b3R5cGUuZGVwcztcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIFJlY29yZC5wcm90b3R5cGUudmFsdWU7XHJcbn1cclxuLyoqXHJcbiAqIEByZWNvcmRcclxuICovXHJcbmZ1bmN0aW9uIERlcGVuZGVuY3lSZWNvcmQoKSB7IH1cclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBEZXBlbmRlbmN5UmVjb3JkLnByb3RvdHlwZS50b2tlbjtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIERlcGVuZGVuY3lSZWNvcmQucHJvdG90eXBlLm9wdGlvbnM7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gcHJvdmlkZXJcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVQcm92aWRlcihwcm92aWRlcikge1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgY29uc3QgZGVwcyA9IGNvbXB1dGVEZXBzKHByb3ZpZGVyKTtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIGxldCBmbiA9IElERU5UO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgbGV0IHZhbHVlID0gRU1QVFk7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBsZXQgdXNlTmV3ID0gZmFsc2U7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBsZXQgcHJvdmlkZSA9IHJlc29sdmVGb3J3YXJkUmVmKHByb3ZpZGVyLnByb3ZpZGUpO1xyXG4gICAgaWYgKFVTRV9WQUxVRSBpbiBwcm92aWRlcikge1xyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gdXNlIFVTRV9WQUxVRSBpbiBwcm92aWRlciBzaW5jZSBwcm92aWRlci51c2VWYWx1ZSBjb3VsZCBiZSBkZWZpbmVkIGFzIHVuZGVmaW5lZC5cclxuICAgICAgICB2YWx1ZSA9ICgoLyoqIEB0eXBlIHs/fSAqLyAocHJvdmlkZXIpKSkudXNlVmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgoKC8qKiBAdHlwZSB7P30gKi8gKHByb3ZpZGVyKSkpLnVzZUZhY3RvcnkpIHtcclxuICAgICAgICBmbiA9ICgoLyoqIEB0eXBlIHs/fSAqLyAocHJvdmlkZXIpKSkudXNlRmFjdG9yeTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgoLyoqIEB0eXBlIHs/fSAqLyAocHJvdmlkZXIpKSkudXNlRXhpc3RpbmcpIHtcclxuICAgICAgICAvLyBKdXN0IHVzZSBJREVOVFxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKCgvKiogQHR5cGUgez99ICovIChwcm92aWRlcikpKS51c2VDbGFzcykge1xyXG4gICAgICAgIHVzZU5ldyA9IHRydWU7XHJcbiAgICAgICAgZm4gPSByZXNvbHZlRm9yd2FyZFJlZigoKC8qKiBAdHlwZSB7P30gKi8gKHByb3ZpZGVyKSkpLnVzZUNsYXNzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBwcm92aWRlID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB1c2VOZXcgPSB0cnVlO1xyXG4gICAgICAgIGZuID0gcHJvdmlkZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IHN0YXRpY0Vycm9yKCdTdGF0aWNQcm92aWRlciBkb2VzIG5vdCBoYXZlIFt1c2VWYWx1ZXx1c2VGYWN0b3J5fHVzZUV4aXN0aW5nfHVzZUNsYXNzXSBvciBbcHJvdmlkZV0gaXMgbm90IG5ld2FibGUnLCBwcm92aWRlcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBkZXBzLCBmbiwgdXNlTmV3LCB2YWx1ZSB9O1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHRva2VuXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBtdWx0aVByb3ZpZGVyTWl4RXJyb3IodG9rZW4pIHtcclxuICAgIHJldHVybiBzdGF0aWNFcnJvcignQ2Fubm90IG1peCBtdWx0aSBwcm92aWRlcnMgYW5kIHJlZ3VsYXIgcHJvdmlkZXJzJywgdG9rZW4pO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHJlY29yZHNcclxuICogQHBhcmFtIHs/fSBwcm92aWRlclxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gcmVjdXJzaXZlbHlQcm9jZXNzUHJvdmlkZXJzKHJlY29yZHMsIHByb3ZpZGVyKSB7XHJcbiAgICBpZiAocHJvdmlkZXIpIHtcclxuICAgICAgICBwcm92aWRlciA9IHJlc29sdmVGb3J3YXJkUmVmKHByb3ZpZGVyKTtcclxuICAgICAgICBpZiAocHJvdmlkZXIgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGFuIGFycmF5IHJlY3Vyc2UgaW50byB0aGUgYXJyYXlcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm92aWRlci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlQcm9jZXNzUHJvdmlkZXJzKHJlY29yZHMsIHByb3ZpZGVyW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcHJvdmlkZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgLy8gRnVuY3Rpb25zIHdlcmUgc3VwcG9ydGVkIGluIFJlZmxlY3RpdmVJbmplY3RvciwgYnV0IGFyZSBub3QgaGVyZS4gRm9yIHNhZmV0eSBnaXZlIHVzZWZ1bFxyXG4gICAgICAgICAgICAvLyBlcnJvciBtZXNzYWdlc1xyXG4gICAgICAgICAgICB0aHJvdyBzdGF0aWNFcnJvcignRnVuY3Rpb24vQ2xhc3Mgbm90IHN1cHBvcnRlZCcsIHByb3ZpZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIgJiYgdHlwZW9mIHByb3ZpZGVyID09PSAnb2JqZWN0JyAmJiBwcm92aWRlci5wcm92aWRlKSB7XHJcbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSB3aGF0IGxvb2tzIGxpa2UgYSBwcm92aWRlcjoge3Byb3ZpZGU6ID8sIC4uLi59XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgbGV0IHRva2VuID0gcmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXIucHJvdmlkZSk7XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRQcm92aWRlciA9IHJlc29sdmVQcm92aWRlcihwcm92aWRlcik7XHJcbiAgICAgICAgICAgIGlmIChwcm92aWRlci5tdWx0aSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG11bHRpIHByb3ZpZGVyLlxyXG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICAgICAgbGV0IG11bHRpUHJvdmlkZXIgPSByZWNvcmRzLmdldCh0b2tlbik7XHJcbiAgICAgICAgICAgICAgICBpZiAobXVsdGlQcm92aWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aVByb3ZpZGVyLmZuICE9PSBNVUxUSV9QUk9WSURFUl9GTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBtdWx0aVByb3ZpZGVyTWl4RXJyb3IodG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHBsYWNlaG9sZGVyIGZhY3Rvcnkgd2hpY2ggd2lsbCBsb29rIHVwIHRoZSBjb25zdGl0dWVudHMgb2YgdGhlIG11bHRpIHByb3ZpZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZHMuc2V0KHRva2VuLCBtdWx0aVByb3ZpZGVyID0gKC8qKiBAdHlwZSB7P30gKi8gKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IHByb3ZpZGVyLnByb3ZpZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VOZXc6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbjogTVVMVElfUFJPVklERVJfRk4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBFTVBUWVxyXG4gICAgICAgICAgICAgICAgICAgIH0pKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUcmVhdCB0aGUgcHJvdmlkZXIgYXMgdGhlIHRva2VuLlxyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSBwcm92aWRlcjtcclxuICAgICAgICAgICAgICAgIG11bHRpUHJvdmlkZXIuZGVwcy5wdXNoKHsgdG9rZW4sIG9wdGlvbnM6IDYgLyogRGVmYXVsdCAqLyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IHJlY29yZHMuZ2V0KHRva2VuKTtcclxuICAgICAgICAgICAgaWYgKHJlY29yZCAmJiByZWNvcmQuZm4gPT0gTVVMVElfUFJPVklERVJfRk4pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG11bHRpUHJvdmlkZXJNaXhFcnJvcih0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVjb3Jkcy5zZXQodG9rZW4sIHJlc29sdmVkUHJvdmlkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgc3RhdGljRXJyb3IoJ1VuZXhwZWN0ZWQgcHJvdmlkZXInLCBwcm92aWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHRva2VuXHJcbiAqIEBwYXJhbSB7P30gcmVjb3JkXHJcbiAqIEBwYXJhbSB7P30gcmVjb3Jkc1xyXG4gKiBAcGFyYW0gez99IHBhcmVudFxyXG4gKiBAcGFyYW0gez99IG5vdEZvdW5kVmFsdWVcclxuICogQHBhcmFtIHs/fSBmbGFnc1xyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gdHJ5UmVzb2x2ZVRva2VuKHRva2VuLCByZWNvcmQsIHJlY29yZHMsIHBhcmVudCwgbm90Rm91bmRWYWx1ZSwgZmxhZ3MpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmVUb2tlbih0b2tlbiwgcmVjb3JkLCByZWNvcmRzLCBwYXJlbnQsIG5vdEZvdW5kVmFsdWUsIGZsYWdzKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgJ2UnIGlzIG9mIHR5cGUgRXJyb3IuXHJcbiAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIEVycm9yKSkge1xyXG4gICAgICAgICAgICBlID0gbmV3IEVycm9yKGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGVbTkdfVEVNUF9UT0tFTl9QQVRIXSA9IGVbTkdfVEVNUF9UT0tFTl9QQVRIXSB8fCBbXTtcclxuICAgICAgICBwYXRoLnVuc2hpZnQodG9rZW4pO1xyXG4gICAgICAgIGlmIChyZWNvcmQgJiYgcmVjb3JkLnZhbHVlID09IENJUkNVTEFSKSB7XHJcbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBDaXJjdWxhciBmbGFnLlxyXG4gICAgICAgICAgICByZWNvcmQudmFsdWUgPSBFTVBUWTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSB0b2tlblxyXG4gKiBAcGFyYW0gez99IHJlY29yZFxyXG4gKiBAcGFyYW0gez99IHJlY29yZHNcclxuICogQHBhcmFtIHs/fSBwYXJlbnRcclxuICogQHBhcmFtIHs/fSBub3RGb3VuZFZhbHVlXHJcbiAqIEBwYXJhbSB7P30gZmxhZ3NcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVUb2tlbih0b2tlbiwgcmVjb3JkLCByZWNvcmRzLCBwYXJlbnQsIG5vdEZvdW5kVmFsdWUsIGZsYWdzKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBsZXQgdmFsdWU7XHJcbiAgICBpZiAocmVjb3JkICYmICEoZmxhZ3MgJiBJbmplY3RGbGFncy5Ta2lwU2VsZikpIHtcclxuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgcmVjb3JkLCB0aGlzIGltcGxpZXMgdGhhdCB3ZSBkb24ndCBvd24gdGhlIHByb3ZpZGVyIGhlbmNlIGRvbid0IGtub3cgaG93XHJcbiAgICAgICAgLy8gdG8gcmVzb2x2ZSBpdC5cclxuICAgICAgICB2YWx1ZSA9IHJlY29yZC52YWx1ZTtcclxuICAgICAgICBpZiAodmFsdWUgPT0gQ0lSQ1VMQVIpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoTk9fTkVXX0xJTkUgKyAnQ2lyY3VsYXIgZGVwZW5kZW5jeScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gRU1QVFkpIHtcclxuICAgICAgICAgICAgcmVjb3JkLnZhbHVlID0gQ0lSQ1VMQVI7XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgbGV0IG9iaiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICBsZXQgdXNlTmV3ID0gcmVjb3JkLnVzZU5ldztcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICBsZXQgZm4gPSByZWNvcmQuZm47XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgbGV0IGRlcFJlY29yZHMgPSByZWNvcmQuZGVwcztcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICBsZXQgZGVwcyA9IEVNUFRZO1xyXG4gICAgICAgICAgICBpZiAoZGVwUmVjb3Jkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGRlcHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwUmVjb3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXBSZWNvcmQgPSBkZXBSZWNvcmRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gZGVwUmVjb3JkLm9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUmVjb3JkID0gb3B0aW9ucyAmIDIgLyogQ2hlY2tTZWxmICovID8gcmVjb3Jkcy5nZXQoZGVwUmVjb3JkLnRva2VuKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICBkZXBzLnB1c2godHJ5UmVzb2x2ZVRva2VuKFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEN1cnJlbnQgVG9rZW4gdG8gcmVzb2x2ZVxyXG4gICAgICAgICAgICAgICAgICAgIGRlcFJlY29yZC50b2tlbiwgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQSByZWNvcmQgd2hpY2ggZGVzY3JpYmVzIGhvdyB0byByZXNvbHZlIHRoZSB0b2tlbi5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB1bmRlZmluZWQsIHRoaXMgbWVhbnMgd2UgZG9uJ3QgaGF2ZSBzdWNoIGEgcmVjb3JkXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRSZWNvcmQsIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyIHJlY29yZHMgd2Uga25vdyBhYm91dC5cclxuICAgICAgICAgICAgICAgICAgICByZWNvcmRzLCBcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBrbm93IGhvdyB0byByZXNvbHZlIGRlcGVuZGVuY3kgYW5kIHdlIHNob3VsZCBub3QgY2hlY2sgcGFyZW50IGZvciBpdCxcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGFuIHBhc3MgaW4gTnVsbCBpbmplY3Rvci5cclxuICAgICAgICAgICAgICAgICAgICAhY2hpbGRSZWNvcmQgJiYgIShvcHRpb25zICYgNCAvKiBDaGVja1BhcmVudCAqLykgPyBJbmplY3Rvci5OVUxMIDogcGFyZW50LCBvcHRpb25zICYgMSAvKiBPcHRpb25hbCAqLyA/IG51bGwgOiBJbmplY3Rvci5USFJPV19JRl9OT1RfRk9VTkQsIEluamVjdEZsYWdzLkRlZmF1bHQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZWNvcmQudmFsdWUgPSB2YWx1ZSA9IHVzZU5ldyA/IG5ldyAoKC8qKiBAdHlwZSB7P30gKi8gKGZuKSkpKC4uLmRlcHMpIDogZm4uYXBwbHkob2JqLCBkZXBzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghKGZsYWdzICYgSW5qZWN0RmxhZ3MuU2VsZikpIHtcclxuICAgICAgICB2YWx1ZSA9IHBhcmVudC5nZXQodG9rZW4sIG5vdEZvdW5kVmFsdWUsIEluamVjdEZsYWdzLkRlZmF1bHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHByb3ZpZGVyXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wdXRlRGVwcyhwcm92aWRlcikge1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgbGV0IGRlcHMgPSBFTVBUWTtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIGNvbnN0IHByb3ZpZGVyRGVwcyA9ICgoLyoqIEB0eXBlIHs/fSAqLyAocHJvdmlkZXIpKSkuZGVwcztcclxuICAgIGlmIChwcm92aWRlckRlcHMgJiYgcHJvdmlkZXJEZXBzLmxlbmd0aCkge1xyXG4gICAgICAgIGRlcHMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3ZpZGVyRGVwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgIGxldCBvcHRpb25zID0gNiAvKiBEZWZhdWx0ICovO1xyXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgIGxldCB0b2tlbiA9IHJlc29sdmVGb3J3YXJkUmVmKHByb3ZpZGVyRGVwc1tpXSk7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbiBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgYW5ub3RhdGlvbnMgPSB0b2tlbjsgaiA8IGFubm90YXRpb25zLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFubm90YXRpb24gPSBhbm5vdGF0aW9uc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvbiBpbnN0YW5jZW9mIE9wdGlvbmFsIHx8IGFubm90YXRpb24gPT0gT3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfCAxIC8qIE9wdGlvbmFsICovO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhbm5vdGF0aW9uIGluc3RhbmNlb2YgU2tpcFNlbGYgfHwgYW5ub3RhdGlvbiA9PSBTa2lwU2VsZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyAmIH4yIC8qIENoZWNrU2VsZiAqLztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYW5ub3RhdGlvbiBpbnN0YW5jZW9mIFNlbGYgfHwgYW5ub3RhdGlvbiA9PSBTZWxmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zICYgfjQgLyogQ2hlY2tQYXJlbnQgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFubm90YXRpb24gaW5zdGFuY2VvZiBJbmplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSAoKC8qKiBAdHlwZSB7P30gKi8gKGFubm90YXRpb24pKSkudG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHJlc29sdmVGb3J3YXJkUmVmKGFubm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZXBzLnB1c2goeyB0b2tlbiwgb3B0aW9ucyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgoKC8qKiBAdHlwZSB7P30gKi8gKHByb3ZpZGVyKSkpLnVzZUV4aXN0aW5nKSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIGNvbnN0IHRva2VuID0gcmVzb2x2ZUZvcndhcmRSZWYoKCgvKiogQHR5cGUgez99ICovIChwcm92aWRlcikpKS51c2VFeGlzdGluZyk7XHJcbiAgICAgICAgZGVwcyA9IFt7IHRva2VuLCBvcHRpb25zOiA2IC8qIERlZmF1bHQgKi8gfV07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghcHJvdmlkZXJEZXBzICYmICEoVVNFX1ZBTFVFIGluIHByb3ZpZGVyKSkge1xyXG4gICAgICAgIC8vIHVzZVZhbHVlICYgdXNlRXhpc3RpbmcgYXJlIHRoZSBvbmx5IG9uZXMgd2hpY2ggYXJlIGV4ZW1wdCBmcm9tIGRlcHMgYWxsIG90aGVycyBuZWVkIGl0LlxyXG4gICAgICAgIHRocm93IHN0YXRpY0Vycm9yKCdcXCdkZXBzXFwnIHJlcXVpcmVkJywgcHJvdmlkZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlcHM7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gdGV4dFxyXG4gKiBAcGFyYW0gez99IG9ialxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gc3RhdGljRXJyb3IodGV4dCwgb2JqKSB7XHJcbiAgICByZXR1cm4gbmV3IEVycm9yKGZvcm1hdEVycm9yKHRleHQsIG9iaiwgJ1N0YXRpY0luamVjdG9yRXJyb3InKSk7XHJcbn1cclxuZXhwb3J0IHsgybUwLCDJtTEgfTtcciJdfQ==