/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Injectable } from '../di';
import { scheduleMicroTask } from '../util/microtask';
import { NgZone } from '../zone/ng_zone';
/**
 * @record
 */
import * as ɵngcc0 from '../r3_symbols';
export function PendingMacrotask() { }
if (false) {
    /** @type {?} */
    PendingMacrotask.prototype.source;
    /** @type {?} */
    PendingMacrotask.prototype.creationLocation;
    /** @type {?|undefined} */
    PendingMacrotask.prototype.runCount;
    /** @type {?|undefined} */
    PendingMacrotask.prototype.data;
}
/**
 * @record
 */
export function TaskData() { }
if (false) {
    /** @type {?|undefined} */
    TaskData.prototype.target;
    /** @type {?|undefined} */
    TaskData.prototype.delay;
    /** @type {?|undefined} */
    TaskData.prototype.isPeriodic;
}
/**
 * @record
 */
function WaitCallback() { }
if (false) {
    /** @type {?} */
    WaitCallback.prototype.timeoutId;
    /** @type {?} */
    WaitCallback.prototype.doneCb;
    /** @type {?|undefined} */
    WaitCallback.prototype.updateCb;
}
/**
 * The Testability service provides testing hooks that can be accessed from
 * the browser and by services such as Protractor. Each bootstrapped Angular
 * application on the page will have an instance of Testability.
 * \@publicApi
 */
export class Testability {
    /**
     * @param {?} _ngZone
     */
    constructor(_ngZone) {
        this._ngZone = _ngZone;
        this._pendingCount = 0;
        this._isZoneStable = true;
        /**
         * Whether any work was done since the last 'whenStable' callback. This is
         * useful to detect if this could have potentially destabilized another
         * component while it is stabilizing.
         * \@internal
         */
        this._didWork = false;
        this._callbacks = [];
        this.taskTrackingZone = null;
        this._watchAngularEvents();
        _ngZone.run((/**
         * @return {?}
         */
        () => {
            this.taskTrackingZone =
                typeof Zone == 'undefined' ? null : Zone.current.get('TaskTrackingZone');
        }));
    }
    /**
     * @private
     * @return {?}
     */
    _watchAngularEvents() {
        this._ngZone.onUnstable.subscribe({
            next: (/**
             * @return {?}
             */
            () => {
                this._didWork = true;
                this._isZoneStable = false;
            })
        });
        this._ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this._ngZone.onStable.subscribe({
                next: (/**
                 * @return {?}
                 */
                () => {
                    NgZone.assertNotInAngularZone();
                    scheduleMicroTask((/**
                     * @return {?}
                     */
                    () => {
                        this._isZoneStable = true;
                        this._runCallbacksIfReady();
                    }));
                })
            });
        }));
    }
    /**
     * Increases the number of pending request
     * @deprecated pending requests are now tracked with zones.
     * @return {?}
     */
    increasePendingRequestCount() {
        this._pendingCount += 1;
        this._didWork = true;
        return this._pendingCount;
    }
    /**
     * Decreases the number of pending request
     * @deprecated pending requests are now tracked with zones
     * @return {?}
     */
    decreasePendingRequestCount() {
        this._pendingCount -= 1;
        if (this._pendingCount < 0) {
            throw new Error('pending async requests below zero');
        }
        this._runCallbacksIfReady();
        return this._pendingCount;
    }
    /**
     * Whether an associated application is stable
     * @return {?}
     */
    isStable() {
        return this._isZoneStable && this._pendingCount === 0 && !this._ngZone.hasPendingMacrotasks;
    }
    /**
     * @private
     * @return {?}
     */
    _runCallbacksIfReady() {
        if (this.isStable()) {
            // Schedules the call backs in a new frame so that it is always async.
            scheduleMicroTask((/**
             * @return {?}
             */
            () => {
                while (this._callbacks.length !== 0) {
                    /** @type {?} */
                    let cb = (/** @type {?} */ (this._callbacks.pop()));
                    clearTimeout(cb.timeoutId);
                    cb.doneCb(this._didWork);
                }
                this._didWork = false;
            }));
        }
        else {
            // Still not stable, send updates.
            /** @type {?} */
            let pending = this.getPendingTasks();
            this._callbacks = this._callbacks.filter((/**
             * @param {?} cb
             * @return {?}
             */
            (cb) => {
                if (cb.updateCb && cb.updateCb(pending)) {
                    clearTimeout(cb.timeoutId);
                    return false;
                }
                return true;
            }));
            this._didWork = true;
        }
    }
    /**
     * @private
     * @return {?}
     */
    getPendingTasks() {
        if (!this.taskTrackingZone) {
            return [];
        }
        // Copy the tasks data so that we don't leak tasks.
        return this.taskTrackingZone.macroTasks.map((/**
         * @param {?} t
         * @return {?}
         */
        (t) => {
            return {
                source: t.source,
                // From TaskTrackingZone:
                // https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40
                creationLocation: (/** @type {?} */ (((/** @type {?} */ (t))).creationLocation)),
                data: t.data
            };
        }));
    }
    /**
     * @private
     * @param {?} cb
     * @param {?=} timeout
     * @param {?=} updateCb
     * @return {?}
     */
    addCallback(cb, timeout, updateCb) {
        /** @type {?} */
        let timeoutId = -1;
        if (timeout && timeout > 0) {
            timeoutId = setTimeout((/**
             * @return {?}
             */
            () => {
                this._callbacks = this._callbacks.filter((/**
                 * @param {?} cb
                 * @return {?}
                 */
                (cb) => cb.timeoutId !== timeoutId));
                cb(this._didWork, this.getPendingTasks());
            }), timeout);
        }
        this._callbacks.push((/** @type {?} */ ({ doneCb: cb, timeoutId: timeoutId, updateCb: updateCb })));
    }
    /**
     * Wait for the application to be stable with a timeout. If the timeout is reached before that
     * happens, the callback receives a list of the macro tasks that were pending, otherwise null.
     *
     * @param {?} doneCb The callback to invoke when Angular is stable or the timeout expires
     *    whichever comes first.
     * @param {?=} timeout Optional. The maximum time to wait for Angular to become stable. If not
     *    specified, whenStable() will wait forever.
     * @param {?=} updateCb Optional. If specified, this callback will be invoked whenever the set of
     *    pending macrotasks changes. If this callback returns true doneCb will not be invoked
     *    and no further updates will be issued.
     * @return {?}
     */
    whenStable(doneCb, timeout, updateCb) {
        if (updateCb && !this.taskTrackingZone) {
            throw new Error('Task tracking zone is required when passing an update callback to ' +
                'whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');
        }
        // These arguments are 'Function' above to keep the public API simple.
        this.addCallback((/** @type {?} */ (doneCb)), timeout, (/** @type {?} */ (updateCb)));
        this._runCallbacksIfReady();
    }
    /**
     * Get the number of pending requests
     * @deprecated pending requests are now tracked with zones
     * @return {?}
     */
    getPendingRequestCount() { return this._pendingCount; }
    /**
     * Find providers by name
     * @param {?} using The root element to search from
     * @param {?} provider The name of binding variable
     * @param {?} exactMatch Whether using exactMatch
     * @return {?}
     */
    findProviders(using, provider, exactMatch) {
        // TODO(juliemr): implement.
        return [];
    }
}
Testability.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: Testability, factory: function Testability_Factory(t) { return new (t || Testability)(ɵngcc0.ɵɵinject(NgZone)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.setClassMetadata(Testability, [{
        type: Injectable
    }], function () { return [{ type: NgZone }]; }, { constructor: [], _ngZone: [], _pendingCount: [], _isZoneStable: [], _didWork: [], _callbacks: [], taskTrackingZone: [], _watchAngularEvents: [], increasePendingRequestCount: [], decreasePendingRequestCount: [], isStable: [], _runCallbacksIfReady: [], getPendingTasks: [], addCallback: [], whenStable: [], getPendingRequestCount: [], findProviders: [] });
/** @nocollapse */
Testability.ctorParameters = () => [
    { type: NgZone }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    Testability.prototype._pendingCount;
    /**
     * @type {?}
     * @private
     */
    Testability.prototype._isZoneStable;
    /**
     * Whether any work was done since the last 'whenStable' callback. This is
     * useful to detect if this could have potentially destabilized another
     * component while it is stabilizing.
     * \@internal
     * @type {?}
     * @private
     */
    Testability.prototype._didWork;
    /**
     * @type {?}
     * @private
     */
    Testability.prototype._callbacks;
    /**
     * @type {?}
     * @private
     */
    Testability.prototype.taskTrackingZone;
    /**
     * @type {?}
     * @private
     */
    Testability.prototype._ngZone;
}
/**
 * A global registry of {\@link Testability} instances for specific elements.
 * \@publicApi
 */
export class TestabilityRegistry {
    constructor() {
        /**
         * \@internal
         */
        this._applications = new Map();
        _testabilityGetter.addToWindow(this);
    }
    /**
     * Registers an application with a testability hook so that it can be tracked
     * @param {?} token token of application, root element
     * @param {?} testability Testability hook
     * @return {?}
     */
    registerApplication(token, testability) {
        this._applications.set(token, testability);
    }
    /**
     * Unregisters an application.
     * @param {?} token token of application, root element
     * @return {?}
     */
    unregisterApplication(token) { this._applications.delete(token); }
    /**
     * Unregisters all applications
     * @return {?}
     */
    unregisterAllApplications() { this._applications.clear(); }
    /**
     * Get a testability hook associated with the application
     * @param {?} elem root element
     * @return {?}
     */
    getTestability(elem) { return this._applications.get(elem) || null; }
    /**
     * Get all registered testabilities
     * @return {?}
     */
    getAllTestabilities() { return Array.from(this._applications.values()); }
    /**
     * Get all registered applications(root elements)
     * @return {?}
     */
    getAllRootElements() { return Array.from(this._applications.keys()); }
    /**
     * Find testability of a node in the Tree
     * @param {?} elem node
     * @param {?=} findInAncestors whether finding testability in ancestors if testability was not found in
     * current node
     * @return {?}
     */
    findTestabilityInTree(elem, findInAncestors = true) {
        return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
    }
}
TestabilityRegistry.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: TestabilityRegistry, factory: function TestabilityRegistry_Factory(t) { return new (t || TestabilityRegistry)(); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.setClassMetadata(TestabilityRegistry, [{
        type: Injectable
    }], function () { return []; }, { constructor: [], _applications: [], registerApplication: [], unregisterApplication: [], unregisterAllApplications: [], getTestability: [], getAllTestabilities: [], getAllRootElements: [], findTestabilityInTree: [] });
/** @nocollapse */
TestabilityRegistry.ctorParameters = () => [];
if (false) {
    /**
     * \@internal
     * @type {?}
     */
    TestabilityRegistry.prototype._applications;
}
/**
 * Adapter interface for retrieving the `Testability` service associated for a
 * particular context.
 *
 * \@publicApi
 * @record
 */
export function GetTestability() { }
if (false) {
    /**
     * @param {?} registry
     * @return {?}
     */
    GetTestability.prototype.addToWindow = function (registry) { };
    /**
     * @param {?} registry
     * @param {?} elem
     * @param {?} findInAncestors
     * @return {?}
     */
    GetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) { };
}
class _NoopGetTestability {
    /**
     * @param {?} registry
     * @return {?}
     */
    addToWindow(registry) { }
    /**
     * @param {?} registry
     * @param {?} elem
     * @param {?} findInAncestors
     * @return {?}
     */
    findTestabilityInTree(registry, elem, findInAncestors) {
        return null;
    }
}
/**
 * Set the {\@link GetTestability} implementation used by the Angular testing framework.
 * \@publicApi
 * @param {?} getter
 * @return {?}
 */
export function setTestabilityGetter(getter) {
    _testabilityGetter = getter;
}
/** @type {?} */
let _testabilityGetter = new _NoopGetTestability();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9lc20yMDE1L3NyYy90ZXN0YWJpbGl0eS90ZXN0YWJpbGl0eS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpUUMsdVpBR0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtR0QsOFBBR0MiLCJmaWxlIjoidGVzdGFiaWxpdHkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJy4uL2RpJztcclxuaW1wb3J0IHsgc2NoZWR1bGVNaWNyb1Rhc2sgfSBmcm9tICcuLi91dGlsL21pY3JvdGFzayc7XHJcbmltcG9ydCB7IE5nWm9uZSB9IGZyb20gJy4uL3pvbmUvbmdfem9uZSc7XHJcbi8qKlxyXG4gKiBAcmVjb3JkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gUGVuZGluZ01hY3JvdGFzaygpIHsgfVxyXG5pZiAoZmFsc2UpIHtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIFBlbmRpbmdNYWNyb3Rhc2sucHJvdG90eXBlLnNvdXJjZTtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIFBlbmRpbmdNYWNyb3Rhc2sucHJvdG90eXBlLmNyZWF0aW9uTG9jYXRpb247XHJcbiAgICAvKiogQHR5cGUgez98dW5kZWZpbmVkfSAqL1xyXG4gICAgUGVuZGluZ01hY3JvdGFzay5wcm90b3R5cGUucnVuQ291bnQ7XHJcbiAgICAvKiogQHR5cGUgez98dW5kZWZpbmVkfSAqL1xyXG4gICAgUGVuZGluZ01hY3JvdGFzay5wcm90b3R5cGUuZGF0YTtcclxufVxyXG4vKipcclxuICogQHJlY29yZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFRhc2tEYXRhKCkgeyB9XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqIEB0eXBlIHs/fHVuZGVmaW5lZH0gKi9cclxuICAgIFRhc2tEYXRhLnByb3RvdHlwZS50YXJnZXQ7XHJcbiAgICAvKiogQHR5cGUgez98dW5kZWZpbmVkfSAqL1xyXG4gICAgVGFza0RhdGEucHJvdG90eXBlLmRlbGF5O1xyXG4gICAgLyoqIEB0eXBlIHs/fHVuZGVmaW5lZH0gKi9cclxuICAgIFRhc2tEYXRhLnByb3RvdHlwZS5pc1BlcmlvZGljO1xyXG59XHJcbi8qKlxyXG4gKiBAcmVjb3JkXHJcbiAqL1xyXG5mdW5jdGlvbiBXYWl0Q2FsbGJhY2soKSB7IH1cclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBXYWl0Q2FsbGJhY2sucHJvdG90eXBlLnRpbWVvdXRJZDtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIFdhaXRDYWxsYmFjay5wcm90b3R5cGUuZG9uZUNiO1xyXG4gICAgLyoqIEB0eXBlIHs/fHVuZGVmaW5lZH0gKi9cclxuICAgIFdhaXRDYWxsYmFjay5wcm90b3R5cGUudXBkYXRlQ2I7XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBUZXN0YWJpbGl0eSBzZXJ2aWNlIHByb3ZpZGVzIHRlc3RpbmcgaG9va3MgdGhhdCBjYW4gYmUgYWNjZXNzZWQgZnJvbVxyXG4gKiB0aGUgYnJvd3NlciBhbmQgYnkgc2VydmljZXMgc3VjaCBhcyBQcm90cmFjdG9yLiBFYWNoIGJvb3RzdHJhcHBlZCBBbmd1bGFyXHJcbiAqIGFwcGxpY2F0aW9uIG9uIHRoZSBwYWdlIHdpbGwgaGF2ZSBhbiBpbnN0YW5jZSBvZiBUZXN0YWJpbGl0eS5cclxuICogXFxAcHVibGljQXBpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVGVzdGFiaWxpdHkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IF9uZ1pvbmVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoX25nWm9uZSkge1xyXG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NvdW50ID0gMDtcclxuICAgICAgICB0aGlzLl9pc1pvbmVTdGFibGUgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgYW55IHdvcmsgd2FzIGRvbmUgc2luY2UgdGhlIGxhc3QgJ3doZW5TdGFibGUnIGNhbGxiYWNrLiBUaGlzIGlzXHJcbiAgICAgICAgICogdXNlZnVsIHRvIGRldGVjdCBpZiB0aGlzIGNvdWxkIGhhdmUgcG90ZW50aWFsbHkgZGVzdGFiaWxpemVkIGFub3RoZXJcclxuICAgICAgICAgKiBjb21wb25lbnQgd2hpbGUgaXQgaXMgc3RhYmlsaXppbmcuXHJcbiAgICAgICAgICogXFxAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9kaWRXb3JrID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgdGhpcy50YXNrVHJhY2tpbmdab25lID0gbnVsbDtcclxuICAgICAgICB0aGlzLl93YXRjaEFuZ3VsYXJFdmVudHMoKTtcclxuICAgICAgICBfbmdab25lLnJ1bigoLyoqXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudGFza1RyYWNraW5nWm9uZSA9XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgWm9uZSA9PSAndW5kZWZpbmVkJyA/IG51bGwgOiBab25lLmN1cnJlbnQuZ2V0KCdUYXNrVHJhY2tpbmdab25lJyk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgX3dhdGNoQW5ndWxhckV2ZW50cygpIHtcclxuICAgICAgICB0aGlzLl9uZ1pvbmUub25VbnN0YWJsZS5zdWJzY3JpYmUoe1xyXG4gICAgICAgICAgICBuZXh0OiAoLyoqXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaWRXb3JrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzWm9uZVN0YWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoLyoqXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5vblN0YWJsZS5zdWJzY3JpYmUoe1xyXG4gICAgICAgICAgICAgICAgbmV4dDogKC8qKlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIE5nWm9uZS5hc3NlcnROb3RJbkFuZ3VsYXJab25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVNaWNyb1Rhc2soKC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1pvbmVTdGFibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ydW5DYWxsYmFja3NJZlJlYWR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmNyZWFzZXMgdGhlIG51bWJlciBvZiBwZW5kaW5nIHJlcXVlc3RcclxuICAgICAqIEBkZXByZWNhdGVkIHBlbmRpbmcgcmVxdWVzdHMgYXJlIG5vdyB0cmFja2VkIHdpdGggem9uZXMuXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBpbmNyZWFzZVBlbmRpbmdSZXF1ZXN0Q291bnQoKSB7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NvdW50ICs9IDE7XHJcbiAgICAgICAgdGhpcy5fZGlkV29yayA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdDb3VudDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVjcmVhc2VzIHRoZSBudW1iZXIgb2YgcGVuZGluZyByZXF1ZXN0XHJcbiAgICAgKiBAZGVwcmVjYXRlZCBwZW5kaW5nIHJlcXVlc3RzIGFyZSBub3cgdHJhY2tlZCB3aXRoIHpvbmVzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBkZWNyZWFzZVBlbmRpbmdSZXF1ZXN0Q291bnQoKSB7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NvdW50IC09IDE7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdDb3VudCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwZW5kaW5nIGFzeW5jIHJlcXVlc3RzIGJlbG93IHplcm8nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcnVuQ2FsbGJhY2tzSWZSZWFkeSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQ291bnQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgYW4gYXNzb2NpYXRlZCBhcHBsaWNhdGlvbiBpcyBzdGFibGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGlzU3RhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc1pvbmVTdGFibGUgJiYgdGhpcy5fcGVuZGluZ0NvdW50ID09PSAwICYmICF0aGlzLl9uZ1pvbmUuaGFzUGVuZGluZ01hY3JvdGFza3M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBfcnVuQ2FsbGJhY2tzSWZSZWFkeSgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1N0YWJsZSgpKSB7XHJcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlcyB0aGUgY2FsbCBiYWNrcyBpbiBhIG5ldyBmcmFtZSBzbyB0aGF0IGl0IGlzIGFsd2F5cyBhc3luYy5cclxuICAgICAgICAgICAgc2NoZWR1bGVNaWNyb1Rhc2soKC8qKlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2NhbGxiYWNrcy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNiID0gKC8qKiBAdHlwZSB7P30gKi8gKHRoaXMuX2NhbGxiYWNrcy5wb3AoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjYi50aW1lb3V0SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNiLmRvbmVDYih0aGlzLl9kaWRXb3JrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpZFdvcmsgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gU3RpbGwgbm90IHN0YWJsZSwgc2VuZCB1cGRhdGVzLlxyXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgIGxldCBwZW5kaW5nID0gdGhpcy5nZXRQZW5kaW5nVGFza3MoKTtcclxuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzLmZpbHRlcigoLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gY2JcclxuICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIChjYikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNiLnVwZGF0ZUNiICYmIGNiLnVwZGF0ZUNiKHBlbmRpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNiLnRpbWVvdXRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlkV29yayA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZ2V0UGVuZGluZ1Rhc2tzKCkge1xyXG4gICAgICAgIGlmICghdGhpcy50YXNrVHJhY2tpbmdab25lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29weSB0aGUgdGFza3MgZGF0YSBzbyB0aGF0IHdlIGRvbid0IGxlYWsgdGFza3MuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFza1RyYWNraW5nWm9uZS5tYWNyb1Rhc2tzLm1hcCgoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSB0XHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICAodCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc291cmNlOiB0LnNvdXJjZSxcclxuICAgICAgICAgICAgICAgIC8vIEZyb20gVGFza1RyYWNraW5nWm9uZTpcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL3pvbmUuanMvYmxvYi9tYXN0ZXIvbGliL3pvbmUtc3BlYy90YXNrLXRyYWNraW5nLnRzI0w0MFxyXG4gICAgICAgICAgICAgICAgY3JlYXRpb25Mb2NhdGlvbjogKC8qKiBAdHlwZSB7P30gKi8gKCgoLyoqIEB0eXBlIHs/fSAqLyAodCkpKS5jcmVhdGlvbkxvY2F0aW9uKSksXHJcbiAgICAgICAgICAgICAgICBkYXRhOiB0LmRhdGFcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IGNiXHJcbiAgICAgKiBAcGFyYW0gez89fSB0aW1lb3V0XHJcbiAgICAgKiBAcGFyYW0gez89fSB1cGRhdGVDYlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgYWRkQ2FsbGJhY2soY2IsIHRpbWVvdXQsIHVwZGF0ZUNiKSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIGxldCB0aW1lb3V0SWQgPSAtMTtcclxuICAgICAgICBpZiAodGltZW91dCAmJiB0aW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgvKipcclxuICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcy5maWx0ZXIoKC8qKlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHs/fSBjYlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgKGNiKSA9PiBjYi50aW1lb3V0SWQgIT09IHRpbWVvdXRJZCkpO1xyXG4gICAgICAgICAgICAgICAgY2IodGhpcy5fZGlkV29yaywgdGhpcy5nZXRQZW5kaW5nVGFza3MoKSk7XHJcbiAgICAgICAgICAgIH0pLCB0aW1lb3V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goKC8qKiBAdHlwZSB7P30gKi8gKHsgZG9uZUNiOiBjYiwgdGltZW91dElkOiB0aW1lb3V0SWQsIHVwZGF0ZUNiOiB1cGRhdGVDYiB9KSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXYWl0IGZvciB0aGUgYXBwbGljYXRpb24gdG8gYmUgc3RhYmxlIHdpdGggYSB0aW1lb3V0LiBJZiB0aGUgdGltZW91dCBpcyByZWFjaGVkIGJlZm9yZSB0aGF0XHJcbiAgICAgKiBoYXBwZW5zLCB0aGUgY2FsbGJhY2sgcmVjZWl2ZXMgYSBsaXN0IG9mIHRoZSBtYWNybyB0YXNrcyB0aGF0IHdlcmUgcGVuZGluZywgb3RoZXJ3aXNlIG51bGwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHs/fSBkb25lQ2IgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIEFuZ3VsYXIgaXMgc3RhYmxlIG9yIHRoZSB0aW1lb3V0IGV4cGlyZXNcclxuICAgICAqICAgIHdoaWNoZXZlciBjb21lcyBmaXJzdC5cclxuICAgICAqIEBwYXJhbSB7Pz19IHRpbWVvdXQgT3B0aW9uYWwuIFRoZSBtYXhpbXVtIHRpbWUgdG8gd2FpdCBmb3IgQW5ndWxhciB0byBiZWNvbWUgc3RhYmxlLiBJZiBub3RcclxuICAgICAqICAgIHNwZWNpZmllZCwgd2hlblN0YWJsZSgpIHdpbGwgd2FpdCBmb3JldmVyLlxyXG4gICAgICogQHBhcmFtIHs/PX0gdXBkYXRlQ2IgT3B0aW9uYWwuIElmIHNwZWNpZmllZCwgdGhpcyBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgd2hlbmV2ZXIgdGhlIHNldCBvZlxyXG4gICAgICogICAgcGVuZGluZyBtYWNyb3Rhc2tzIGNoYW5nZXMuIElmIHRoaXMgY2FsbGJhY2sgcmV0dXJucyB0cnVlIGRvbmVDYiB3aWxsIG5vdCBiZSBpbnZva2VkXHJcbiAgICAgKiAgICBhbmQgbm8gZnVydGhlciB1cGRhdGVzIHdpbGwgYmUgaXNzdWVkLlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgd2hlblN0YWJsZShkb25lQ2IsIHRpbWVvdXQsIHVwZGF0ZUNiKSB7XHJcbiAgICAgICAgaWYgKHVwZGF0ZUNiICYmICF0aGlzLnRhc2tUcmFja2luZ1pvbmUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYXNrIHRyYWNraW5nIHpvbmUgaXMgcmVxdWlyZWQgd2hlbiBwYXNzaW5nIGFuIHVwZGF0ZSBjYWxsYmFjayB0byAnICtcclxuICAgICAgICAgICAgICAgICd3aGVuU3RhYmxlKCkuIElzIFwiem9uZS5qcy9kaXN0L3Rhc2stdHJhY2tpbmcuanNcIiBsb2FkZWQ/Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoZXNlIGFyZ3VtZW50cyBhcmUgJ0Z1bmN0aW9uJyBhYm92ZSB0byBrZWVwIHRoZSBwdWJsaWMgQVBJIHNpbXBsZS5cclxuICAgICAgICB0aGlzLmFkZENhbGxiYWNrKCgvKiogQHR5cGUgez99ICovIChkb25lQ2IpKSwgdGltZW91dCwgKC8qKiBAdHlwZSB7P30gKi8gKHVwZGF0ZUNiKSkpO1xyXG4gICAgICAgIHRoaXMuX3J1bkNhbGxiYWNrc0lmUmVhZHkoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgcGVuZGluZyByZXF1ZXN0c1xyXG4gICAgICogQGRlcHJlY2F0ZWQgcGVuZGluZyByZXF1ZXN0cyBhcmUgbm93IHRyYWNrZWQgd2l0aCB6b25lc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZ2V0UGVuZGluZ1JlcXVlc3RDb3VudCgpIHsgcmV0dXJuIHRoaXMuX3BlbmRpbmdDb3VudDsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHByb3ZpZGVycyBieSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IHVzaW5nIFRoZSByb290IGVsZW1lbnQgdG8gc2VhcmNoIGZyb21cclxuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXIgVGhlIG5hbWUgb2YgYmluZGluZyB2YXJpYWJsZVxyXG4gICAgICogQHBhcmFtIHs/fSBleGFjdE1hdGNoIFdoZXRoZXIgdXNpbmcgZXhhY3RNYXRjaFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZmluZFByb3ZpZGVycyh1c2luZywgcHJvdmlkZXIsIGV4YWN0TWF0Y2gpIHtcclxuICAgICAgICAvLyBUT0RPKGp1bGllbXIpOiBpbXBsZW1lbnQuXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcblRlc3RhYmlsaXR5LmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxyXG5dO1xyXG4vKiogQG5vY29sbGFwc2UgKi9cclxuVGVzdGFiaWxpdHkuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXHJcbiAgICB7IHR5cGU6IE5nWm9uZSB9XHJcbl07XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5fcGVuZGluZ0NvdW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5faXNab25lU3RhYmxlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIGFueSB3b3JrIHdhcyBkb25lIHNpbmNlIHRoZSBsYXN0ICd3aGVuU3RhYmxlJyBjYWxsYmFjay4gVGhpcyBpc1xyXG4gICAgICogdXNlZnVsIHRvIGRldGVjdCBpZiB0aGlzIGNvdWxkIGhhdmUgcG90ZW50aWFsbHkgZGVzdGFiaWxpemVkIGFub3RoZXJcclxuICAgICAqIGNvbXBvbmVudCB3aGlsZSBpdCBpcyBzdGFiaWxpemluZy5cclxuICAgICAqIFxcQGludGVybmFsXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5fZGlkV29yaztcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuX2NhbGxiYWNrcztcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUudGFza1RyYWNraW5nWm9uZTtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuX25nWm9uZTtcclxufVxyXG4vKipcclxuICogQSBnbG9iYWwgcmVnaXN0cnkgb2Yge1xcQGxpbmsgVGVzdGFiaWxpdHl9IGluc3RhbmNlcyBmb3Igc3BlY2lmaWMgZWxlbWVudHMuXHJcbiAqIFxcQHB1YmxpY0FwaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRlc3RhYmlsaXR5UmVnaXN0cnkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogXFxAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9hcHBsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgX3Rlc3RhYmlsaXR5R2V0dGVyLmFkZFRvV2luZG93KHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgYW4gYXBwbGljYXRpb24gd2l0aCBhIHRlc3RhYmlsaXR5IGhvb2sgc28gdGhhdCBpdCBjYW4gYmUgdHJhY2tlZFxyXG4gICAgICogQHBhcmFtIHs/fSB0b2tlbiB0b2tlbiBvZiBhcHBsaWNhdGlvbiwgcm9vdCBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IHRlc3RhYmlsaXR5IFRlc3RhYmlsaXR5IGhvb2tcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIHJlZ2lzdGVyQXBwbGljYXRpb24odG9rZW4sIHRlc3RhYmlsaXR5KSB7XHJcbiAgICAgICAgdGhpcy5fYXBwbGljYXRpb25zLnNldCh0b2tlbiwgdGVzdGFiaWxpdHkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnJlZ2lzdGVycyBhbiBhcHBsaWNhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7P30gdG9rZW4gdG9rZW4gb2YgYXBwbGljYXRpb24sIHJvb3QgZWxlbWVudFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgdW5yZWdpc3RlckFwcGxpY2F0aW9uKHRva2VuKSB7IHRoaXMuX2FwcGxpY2F0aW9ucy5kZWxldGUodG9rZW4pOyB9XHJcbiAgICAvKipcclxuICAgICAqIFVucmVnaXN0ZXJzIGFsbCBhcHBsaWNhdGlvbnNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIHVucmVnaXN0ZXJBbGxBcHBsaWNhdGlvbnMoKSB7IHRoaXMuX2FwcGxpY2F0aW9ucy5jbGVhcigpOyB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIHRlc3RhYmlsaXR5IGhvb2sgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHBsaWNhdGlvblxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtIHJvb3QgZWxlbWVudFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZ2V0VGVzdGFiaWxpdHkoZWxlbSkgeyByZXR1cm4gdGhpcy5fYXBwbGljYXRpb25zLmdldChlbGVtKSB8fCBudWxsOyB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgcmVnaXN0ZXJlZCB0ZXN0YWJpbGl0aWVzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBnZXRBbGxUZXN0YWJpbGl0aWVzKCkgeyByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9hcHBsaWNhdGlvbnMudmFsdWVzKCkpOyB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgcmVnaXN0ZXJlZCBhcHBsaWNhdGlvbnMocm9vdCBlbGVtZW50cylcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGdldEFsbFJvb3RFbGVtZW50cygpIHsgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fYXBwbGljYXRpb25zLmtleXMoKSk7IH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZCB0ZXN0YWJpbGl0eSBvZiBhIG5vZGUgaW4gdGhlIFRyZWVcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbSBub2RlXHJcbiAgICAgKiBAcGFyYW0gez89fSBmaW5kSW5BbmNlc3RvcnMgd2hldGhlciBmaW5kaW5nIHRlc3RhYmlsaXR5IGluIGFuY2VzdG9ycyBpZiB0ZXN0YWJpbGl0eSB3YXMgbm90IGZvdW5kIGluXHJcbiAgICAgKiBjdXJyZW50IG5vZGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZpbmRUZXN0YWJpbGl0eUluVHJlZShlbGVtLCBmaW5kSW5BbmNlc3RvcnMgPSB0cnVlKSB7XHJcbiAgICAgICAgcmV0dXJuIF90ZXN0YWJpbGl0eUdldHRlci5maW5kVGVzdGFiaWxpdHlJblRyZWUodGhpcywgZWxlbSwgZmluZEluQW5jZXN0b3JzKTtcclxuICAgIH1cclxufVxyXG5UZXN0YWJpbGl0eVJlZ2lzdHJ5LmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxyXG5dO1xyXG4vKiogQG5vY29sbGFwc2UgKi9cclxuVGVzdGFiaWxpdHlSZWdpc3RyeS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtdO1xyXG5pZiAoZmFsc2UpIHtcclxuICAgIC8qKlxyXG4gICAgICogXFxAaW50ZXJuYWxcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LnByb3RvdHlwZS5fYXBwbGljYXRpb25zO1xyXG59XHJcbi8qKlxyXG4gKiBBZGFwdGVyIGludGVyZmFjZSBmb3IgcmV0cmlldmluZyB0aGUgYFRlc3RhYmlsaXR5YCBzZXJ2aWNlIGFzc29jaWF0ZWQgZm9yIGFcclxuICogcGFydGljdWxhciBjb250ZXh0LlxyXG4gKlxyXG4gKiBcXEBwdWJsaWNBcGlcclxuICogQHJlY29yZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEdldFRlc3RhYmlsaXR5KCkgeyB9XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHJlZ2lzdHJ5XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBHZXRUZXN0YWJpbGl0eS5wcm90b3R5cGUuYWRkVG9XaW5kb3cgPSBmdW5jdGlvbiAocmVnaXN0cnkpIHsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSByZWdpc3RyeVxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtXHJcbiAgICAgKiBAcGFyYW0gez99IGZpbmRJbkFuY2VzdG9yc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgR2V0VGVzdGFiaWxpdHkucHJvdG90eXBlLmZpbmRUZXN0YWJpbGl0eUluVHJlZSA9IGZ1bmN0aW9uIChyZWdpc3RyeSwgZWxlbSwgZmluZEluQW5jZXN0b3JzKSB7IH07XHJcbn1cclxuY2xhc3MgX05vb3BHZXRUZXN0YWJpbGl0eSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcmVnaXN0cnlcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGFkZFRvV2luZG93KHJlZ2lzdHJ5KSB7IH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSByZWdpc3RyeVxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtXHJcbiAgICAgKiBAcGFyYW0gez99IGZpbmRJbkFuY2VzdG9yc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZmluZFRlc3RhYmlsaXR5SW5UcmVlKHJlZ2lzdHJ5LCBlbGVtLCBmaW5kSW5BbmNlc3RvcnMpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogU2V0IHRoZSB7XFxAbGluayBHZXRUZXN0YWJpbGl0eX0gaW1wbGVtZW50YXRpb24gdXNlZCBieSB0aGUgQW5ndWxhciB0ZXN0aW5nIGZyYW1ld29yay5cclxuICogXFxAcHVibGljQXBpXHJcbiAqIEBwYXJhbSB7P30gZ2V0dGVyXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2V0VGVzdGFiaWxpdHlHZXR0ZXIoZ2V0dGVyKSB7XHJcbiAgICBfdGVzdGFiaWxpdHlHZXR0ZXIgPSBnZXR0ZXI7XHJcbn1cclxuLyoqIEB0eXBlIHs/fSAqL1xyXG5sZXQgX3Rlc3RhYmlsaXR5R2V0dGVyID0gbmV3IF9Ob29wR2V0VGVzdGFiaWxpdHkoKTtcciJdfQ==