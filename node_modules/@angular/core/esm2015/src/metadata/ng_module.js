/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ɵɵdefineInjector } from '../di/interface/defs';
import { convertInjectableProviderToFactory } from '../di/util';
import { compileNgModule as render3CompileNgModule } from '../render3/jit/module';
import { makeDecorator } from '../util/decorators';
/**
 * Represents the expansion of an `NgModule` into its scopes.
 *
 * A scope is a set of directives and pipes that are visible in a particular context. Each
 * `NgModule` has two scopes. The `compilation` scope is the set of directives and pipes that will
 * be recognized in the templates of components declared by the module. The `exported` scope is the
 * set of directives and pipes exported by a module (that is, module B's exported scope gets added
 * to module A's compilation scope when module A imports B).
 * @record
 */
export function NgModuleTransitiveScopes() { }
if (false) {
    /** @type {?} */
    NgModuleTransitiveScopes.prototype.compilation;
    /** @type {?} */
    NgModuleTransitiveScopes.prototype.exported;
    /** @type {?} */
    NgModuleTransitiveScopes.prototype.schemas;
}
/**
 * Runtime link information for NgModules.
 *
 * This is the internal data structure used by the runtime to assemble components, directives,
 * pipes, and injectors.
 *
 * NOTE: Always use `ɵɵdefineNgModule` function to create this object,
 * never create the object directly since the shape of this object
 * can change between versions.
 * @record
 * @template T
 */
export function NgModuleDef() { }
if (false) {
    /**
     * Token representing the module. Used by DI.
     * @type {?}
     */
    NgModuleDef.prototype.type;
    /**
     * List of components to bootstrap.
     * @type {?}
     */
    NgModuleDef.prototype.bootstrap;
    /**
     * List of components, directives, and pipes declared by this module.
     * @type {?}
     */
    NgModuleDef.prototype.declarations;
    /**
     * List of modules or `ModuleWithProviders` imported by this module.
     * @type {?}
     */
    NgModuleDef.prototype.imports;
    /**
     * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this
     * module.
     * @type {?}
     */
    NgModuleDef.prototype.exports;
    /**
     * Cached value of computed `transitiveCompileScopes` for this module.
     *
     * This should never be read directly, but accessed via `transitiveScopesFor`.
     * @type {?}
     */
    NgModuleDef.prototype.transitiveCompileScopes;
    /**
     * The set of schemas that declare elements to be allowed in the NgModule.
     * @type {?}
     */
    NgModuleDef.prototype.schemas;
    /**
     * Unique ID for the module with which it should be registered.
     * @type {?}
     */
    NgModuleDef.prototype.id;
}
/**
 * A wrapper around an NgModule that associates it with the providers.
 *
 * @param T the module type. In Ivy applications, this must be explicitly
 * provided.
 *
 * \@publicApi
 * @record
 * @template T
 */
export function ModuleWithProviders() { }
if (false) {
    /** @type {?} */
    ModuleWithProviders.prototype.ngModule;
    /** @type {?|undefined} */
    ModuleWithProviders.prototype.providers;
}
/**
 * Type of the NgModule decorator / constructor function.
 *
 * \@publicApi
 * @record
 */
export function NgModuleDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ0 = /**
 * @param {?} ngModule
 * @return {?}
 */
(ngModule) => ngModule, ɵ1 = /**
 * Decorator that marks the following class as an NgModule, and supplies
 * configuration metadata for it.
 *
 * * The `declarations` and `entryComponents` options configure the compiler
 * with information about what belongs to the NgModule.
 * * The `providers` options configures the NgModule's injector to provide
 * dependencies the NgModule members.
 * * The `imports` and `exports` options bring in members from other modules, and make
 * this module's members available to others.
 * @param {?} type
 * @param {?} meta
 * @return {?}
 */
(type, meta) => SWITCH_COMPILE_NGMODULE(type, meta);
/**
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const NgModule = makeDecorator('NgModule', (ɵ0), undefined, undefined, (ɵ1));
/**
 * \@description
 * Hook for manual bootstrapping of the application instead of using bootstrap array in \@NgModule
 * annotation.
 *
 * Reference to the current application is provided as a parameter.
 *
 * See ["Bootstrapping"](guide/bootstrapping) and ["Entry components"](guide/entry-components).
 *
 * \@usageNotes
 * ```typescript
 * class AppModule implements DoBootstrap {
 *   ngDoBootstrap(appRef: ApplicationRef) {
 *     appRef.bootstrap(AppComponent); // Or some other component
 *   }
 * }
 * ```
 *
 * \@publicApi
 * @record
 */
export function DoBootstrap() { }
if (false) {
    /**
     * @param {?} appRef
     * @return {?}
     */
    DoBootstrap.prototype.ngDoBootstrap = function (appRef) { };
}
/**
 * @param {?} moduleType
 * @param {?=} metadata
 * @return {?}
 */
function preR3NgModuleCompile(moduleType, metadata) {
    /** @type {?} */
    let imports = (metadata && metadata.imports) || [];
    if (metadata && metadata.exports) {
        imports = [...imports, metadata.exports];
    }
    ((/** @type {?} */ (moduleType))).ngInjectorDef = ɵɵdefineInjector({
        factory: convertInjectableProviderToFactory(moduleType, { useClass: moduleType }),
        providers: metadata && metadata.providers,
        imports: imports,
    });
}
/** @type {?} */
export const SWITCH_COMPILE_NGMODULE__POST_R3__ = render3CompileNgModule;
/** @type {?} */
const SWITCH_COMPILE_NGMODULE__PRE_R3__ = preR3NgModuleCompile;
/** @type {?} */
const SWITCH_COMPILE_NGMODULE = SWITCH_COMPILE_NGMODULE__POST_R3__;
export { ɵ0, ɵ1 };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9lc20yMDE1L3NyYy9tZXRhZGF0YS9uZ19tb2R1bGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0NBaU1nQyxrQ0FBaUMiLCJmaWxlIjoibmdfbW9kdWxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxyXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsY29uc3RhbnRQcm9wZXJ0eSxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXHJcbiAqL1xyXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7IMm1ybVkZWZpbmVJbmplY3RvciB9IGZyb20gJy4uL2RpL2ludGVyZmFjZS9kZWZzJztcclxuaW1wb3J0IHsgY29udmVydEluamVjdGFibGVQcm92aWRlclRvRmFjdG9yeSB9IGZyb20gJy4uL2RpL3V0aWwnO1xyXG5pbXBvcnQgeyBjb21waWxlTmdNb2R1bGUgYXMgcmVuZGVyM0NvbXBpbGVOZ01vZHVsZSB9IGZyb20gJy4uL3JlbmRlcjMvaml0L21vZHVsZSc7XHJcbmltcG9ydCB7IG1ha2VEZWNvcmF0b3IgfSBmcm9tICcuLi91dGlsL2RlY29yYXRvcnMnO1xyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgZXhwYW5zaW9uIG9mIGFuIGBOZ01vZHVsZWAgaW50byBpdHMgc2NvcGVzLlxyXG4gKlxyXG4gKiBBIHNjb3BlIGlzIGEgc2V0IG9mIGRpcmVjdGl2ZXMgYW5kIHBpcGVzIHRoYXQgYXJlIHZpc2libGUgaW4gYSBwYXJ0aWN1bGFyIGNvbnRleHQuIEVhY2hcclxuICogYE5nTW9kdWxlYCBoYXMgdHdvIHNjb3Blcy4gVGhlIGBjb21waWxhdGlvbmAgc2NvcGUgaXMgdGhlIHNldCBvZiBkaXJlY3RpdmVzIGFuZCBwaXBlcyB0aGF0IHdpbGxcclxuICogYmUgcmVjb2duaXplZCBpbiB0aGUgdGVtcGxhdGVzIG9mIGNvbXBvbmVudHMgZGVjbGFyZWQgYnkgdGhlIG1vZHVsZS4gVGhlIGBleHBvcnRlZGAgc2NvcGUgaXMgdGhlXHJcbiAqIHNldCBvZiBkaXJlY3RpdmVzIGFuZCBwaXBlcyBleHBvcnRlZCBieSBhIG1vZHVsZSAodGhhdCBpcywgbW9kdWxlIEIncyBleHBvcnRlZCBzY29wZSBnZXRzIGFkZGVkXHJcbiAqIHRvIG1vZHVsZSBBJ3MgY29tcGlsYXRpb24gc2NvcGUgd2hlbiBtb2R1bGUgQSBpbXBvcnRzIEIpLlxyXG4gKiBAcmVjb3JkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gTmdNb2R1bGVUcmFuc2l0aXZlU2NvcGVzKCkgeyB9XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgTmdNb2R1bGVUcmFuc2l0aXZlU2NvcGVzLnByb3RvdHlwZS5jb21waWxhdGlvbjtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE5nTW9kdWxlVHJhbnNpdGl2ZVNjb3Blcy5wcm90b3R5cGUuZXhwb3J0ZWQ7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ01vZHVsZVRyYW5zaXRpdmVTY29wZXMucHJvdG90eXBlLnNjaGVtYXM7XHJcbn1cclxuLyoqXHJcbiAqIFJ1bnRpbWUgbGluayBpbmZvcm1hdGlvbiBmb3IgTmdNb2R1bGVzLlxyXG4gKlxyXG4gKiBUaGlzIGlzIHRoZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZSB1c2VkIGJ5IHRoZSBydW50aW1lIHRvIGFzc2VtYmxlIGNvbXBvbmVudHMsIGRpcmVjdGl2ZXMsXHJcbiAqIHBpcGVzLCBhbmQgaW5qZWN0b3JzLlxyXG4gKlxyXG4gKiBOT1RFOiBBbHdheXMgdXNlIGDJtcm1ZGVmaW5lTmdNb2R1bGVgIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGlzIG9iamVjdCxcclxuICogbmV2ZXIgY3JlYXRlIHRoZSBvYmplY3QgZGlyZWN0bHkgc2luY2UgdGhlIHNoYXBlIG9mIHRoaXMgb2JqZWN0XHJcbiAqIGNhbiBjaGFuZ2UgYmV0d2VlbiB2ZXJzaW9ucy5cclxuICogQHJlY29yZFxyXG4gKiBAdGVtcGxhdGUgVFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE5nTW9kdWxlRGVmKCkgeyB9XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUb2tlbiByZXByZXNlbnRpbmcgdGhlIG1vZHVsZS4gVXNlZCBieSBESS5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ01vZHVsZURlZi5wcm90b3R5cGUudHlwZTtcclxuICAgIC8qKlxyXG4gICAgICogTGlzdCBvZiBjb21wb25lbnRzIHRvIGJvb3RzdHJhcC5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ01vZHVsZURlZi5wcm90b3R5cGUuYm9vdHN0cmFwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaXN0IG9mIGNvbXBvbmVudHMsIGRpcmVjdGl2ZXMsIGFuZCBwaXBlcyBkZWNsYXJlZCBieSB0aGlzIG1vZHVsZS5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ01vZHVsZURlZi5wcm90b3R5cGUuZGVjbGFyYXRpb25zO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaXN0IG9mIG1vZHVsZXMgb3IgYE1vZHVsZVdpdGhQcm92aWRlcnNgIGltcG9ydGVkIGJ5IHRoaXMgbW9kdWxlLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nTW9kdWxlRGVmLnByb3RvdHlwZS5pbXBvcnRzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaXN0IG9mIG1vZHVsZXMsIGBNb2R1bGVXaXRoUHJvdmlkZXJzYCwgY29tcG9uZW50cywgZGlyZWN0aXZlcywgb3IgcGlwZXMgZXhwb3J0ZWQgYnkgdGhpc1xyXG4gICAgICogbW9kdWxlLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nTW9kdWxlRGVmLnByb3RvdHlwZS5leHBvcnRzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWNoZWQgdmFsdWUgb2YgY29tcHV0ZWQgYHRyYW5zaXRpdmVDb21waWxlU2NvcGVzYCBmb3IgdGhpcyBtb2R1bGUuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBzaG91bGQgbmV2ZXIgYmUgcmVhZCBkaXJlY3RseSwgYnV0IGFjY2Vzc2VkIHZpYSBgdHJhbnNpdGl2ZVNjb3Blc0ZvcmAuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdNb2R1bGVEZWYucHJvdG90eXBlLnRyYW5zaXRpdmVDb21waWxlU2NvcGVzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2V0IG9mIHNjaGVtYXMgdGhhdCBkZWNsYXJlIGVsZW1lbnRzIHRvIGJlIGFsbG93ZWQgaW4gdGhlIE5nTW9kdWxlLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nTW9kdWxlRGVmLnByb3RvdHlwZS5zY2hlbWFzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbmlxdWUgSUQgZm9yIHRoZSBtb2R1bGUgd2l0aCB3aGljaCBpdCBzaG91bGQgYmUgcmVnaXN0ZXJlZC5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ01vZHVsZURlZi5wcm90b3R5cGUuaWQ7XHJcbn1cclxuLyoqXHJcbiAqIEEgd3JhcHBlciBhcm91bmQgYW4gTmdNb2R1bGUgdGhhdCBhc3NvY2lhdGVzIGl0IHdpdGggdGhlIHByb3ZpZGVycy5cclxuICpcclxuICogQHBhcmFtIFQgdGhlIG1vZHVsZSB0eXBlLiBJbiBJdnkgYXBwbGljYXRpb25zLCB0aGlzIG11c3QgYmUgZXhwbGljaXRseVxyXG4gKiBwcm92aWRlZC5cclxuICpcclxuICogXFxAcHVibGljQXBpXHJcbiAqIEByZWNvcmRcclxuICogQHRlbXBsYXRlIFRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBNb2R1bGVXaXRoUHJvdmlkZXJzKCkgeyB9XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgTW9kdWxlV2l0aFByb3ZpZGVycy5wcm90b3R5cGUubmdNb2R1bGU7XHJcbiAgICAvKiogQHR5cGUgez98dW5kZWZpbmVkfSAqL1xyXG4gICAgTW9kdWxlV2l0aFByb3ZpZGVycy5wcm90b3R5cGUucHJvdmlkZXJzO1xyXG59XHJcbi8qKlxyXG4gKiBUeXBlIG9mIHRoZSBOZ01vZHVsZSBkZWNvcmF0b3IgLyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cclxuICpcclxuICogXFxAcHVibGljQXBpXHJcbiAqIEByZWNvcmRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBOZ01vZHVsZURlY29yYXRvcigpIHsgfVxyXG4vLyBXQVJOSU5HOiBpbnRlcmZhY2UgaGFzIGJvdGggYSB0eXBlIGFuZCBhIHZhbHVlLCBza2lwcGluZyBlbWl0XHJcbmNvbnN0IMm1MCA9IC8qKlxyXG4gKiBAcGFyYW0gez99IG5nTW9kdWxlXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG4obmdNb2R1bGUpID0+IG5nTW9kdWxlLCDJtTEgPSAvKipcclxuICogRGVjb3JhdG9yIHRoYXQgbWFya3MgdGhlIGZvbGxvd2luZyBjbGFzcyBhcyBhbiBOZ01vZHVsZSwgYW5kIHN1cHBsaWVzXHJcbiAqIGNvbmZpZ3VyYXRpb24gbWV0YWRhdGEgZm9yIGl0LlxyXG4gKlxyXG4gKiAqIFRoZSBgZGVjbGFyYXRpb25zYCBhbmQgYGVudHJ5Q29tcG9uZW50c2Agb3B0aW9ucyBjb25maWd1cmUgdGhlIGNvbXBpbGVyXHJcbiAqIHdpdGggaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBiZWxvbmdzIHRvIHRoZSBOZ01vZHVsZS5cclxuICogKiBUaGUgYHByb3ZpZGVyc2Agb3B0aW9ucyBjb25maWd1cmVzIHRoZSBOZ01vZHVsZSdzIGluamVjdG9yIHRvIHByb3ZpZGVcclxuICogZGVwZW5kZW5jaWVzIHRoZSBOZ01vZHVsZSBtZW1iZXJzLlxyXG4gKiAqIFRoZSBgaW1wb3J0c2AgYW5kIGBleHBvcnRzYCBvcHRpb25zIGJyaW5nIGluIG1lbWJlcnMgZnJvbSBvdGhlciBtb2R1bGVzLCBhbmQgbWFrZVxyXG4gKiB0aGlzIG1vZHVsZSdzIG1lbWJlcnMgYXZhaWxhYmxlIHRvIG90aGVycy5cclxuICogQHBhcmFtIHs/fSB0eXBlXHJcbiAqIEBwYXJhbSB7P30gbWV0YVxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuKHR5cGUsIG1ldGEpID0+IFNXSVRDSF9DT01QSUxFX05HTU9EVUxFKHR5cGUsIG1ldGEpO1xyXG4vKipcclxuICogXFxAQW5ub3RhdGlvblxyXG4gKiBcXEBwdWJsaWNBcGlcclxuICogQHR5cGUgez99XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgTmdNb2R1bGUgPSBtYWtlRGVjb3JhdG9yKCdOZ01vZHVsZScsICjJtTApLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgKMm1MSkpO1xyXG4vKipcclxuICogXFxAZGVzY3JpcHRpb25cclxuICogSG9vayBmb3IgbWFudWFsIGJvb3RzdHJhcHBpbmcgb2YgdGhlIGFwcGxpY2F0aW9uIGluc3RlYWQgb2YgdXNpbmcgYm9vdHN0cmFwIGFycmF5IGluIFxcQE5nTW9kdWxlXHJcbiAqIGFubm90YXRpb24uXHJcbiAqXHJcbiAqIFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBhcHBsaWNhdGlvbiBpcyBwcm92aWRlZCBhcyBhIHBhcmFtZXRlci5cclxuICpcclxuICogU2VlIFtcIkJvb3RzdHJhcHBpbmdcIl0oZ3VpZGUvYm9vdHN0cmFwcGluZykgYW5kIFtcIkVudHJ5IGNvbXBvbmVudHNcIl0oZ3VpZGUvZW50cnktY29tcG9uZW50cykuXHJcbiAqXHJcbiAqIFxcQHVzYWdlTm90ZXNcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBBcHBNb2R1bGUgaW1wbGVtZW50cyBEb0Jvb3RzdHJhcCB7XHJcbiAqICAgbmdEb0Jvb3RzdHJhcChhcHBSZWY6IEFwcGxpY2F0aW9uUmVmKSB7XHJcbiAqICAgICBhcHBSZWYuYm9vdHN0cmFwKEFwcENvbXBvbmVudCk7IC8vIE9yIHNvbWUgb3RoZXIgY29tcG9uZW50XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBcXEBwdWJsaWNBcGlcclxuICogQHJlY29yZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIERvQm9vdHN0cmFwKCkgeyB9XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGFwcFJlZlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRG9Cb290c3RyYXAucHJvdG90eXBlLm5nRG9Cb290c3RyYXAgPSBmdW5jdGlvbiAoYXBwUmVmKSB7IH07XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxyXG4gKiBAcGFyYW0gez89fSBtZXRhZGF0YVxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gcHJlUjNOZ01vZHVsZUNvbXBpbGUobW9kdWxlVHlwZSwgbWV0YWRhdGEpIHtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIGxldCBpbXBvcnRzID0gKG1ldGFkYXRhICYmIG1ldGFkYXRhLmltcG9ydHMpIHx8IFtdO1xyXG4gICAgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhLmV4cG9ydHMpIHtcclxuICAgICAgICBpbXBvcnRzID0gWy4uLmltcG9ydHMsIG1ldGFkYXRhLmV4cG9ydHNdO1xyXG4gICAgfVxyXG4gICAgKCgvKiogQHR5cGUgez99ICovIChtb2R1bGVUeXBlKSkpLm5nSW5qZWN0b3JEZWYgPSDJtcm1ZGVmaW5lSW5qZWN0b3Ioe1xyXG4gICAgICAgIGZhY3Rvcnk6IGNvbnZlcnRJbmplY3RhYmxlUHJvdmlkZXJUb0ZhY3RvcnkobW9kdWxlVHlwZSwgeyB1c2VDbGFzczogbW9kdWxlVHlwZSB9KSxcclxuICAgICAgICBwcm92aWRlcnM6IG1ldGFkYXRhICYmIG1ldGFkYXRhLnByb3ZpZGVycyxcclxuICAgICAgICBpbXBvcnRzOiBpbXBvcnRzLFxyXG4gICAgfSk7XHJcbn1cclxuLyoqIEB0eXBlIHs/fSAqL1xyXG5leHBvcnQgY29uc3QgU1dJVENIX0NPTVBJTEVfTkdNT0RVTEVfX1BPU1RfUjNfXyA9IHJlbmRlcjNDb21waWxlTmdNb2R1bGU7XHJcbi8qKiBAdHlwZSB7P30gKi9cclxuY29uc3QgU1dJVENIX0NPTVBJTEVfTkdNT0RVTEVfX1BSRV9SM19fID0gcHJlUjNOZ01vZHVsZUNvbXBpbGU7XHJcbi8qKiBAdHlwZSB7P30gKi9cclxuY29uc3QgU1dJVENIX0NPTVBJTEVfTkdNT0RVTEUgPSBTV0lUQ0hfQ09NUElMRV9OR01PRFVMRV9fUFJFX1IzX187XHJcbmV4cG9ydCB7IMm1MCwgybUxIH07XHIiXX0=