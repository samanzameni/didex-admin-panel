/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ChangeDetectionStrategy } from '../change_detection/constants';
import { compileComponent as render3CompileComponent, compileDirective as render3CompileDirective } from '../render3/jit/directive';
import { compilePipe as render3CompilePipe } from '../render3/jit/pipe';
import { makeDecorator, makePropDecorator } from '../util/decorators';
import { noop } from '../util/noop';
/**
 * Type of the Directive decorator / constructor function.
 * \@publicApi
 * @record
 */
export function DirectiveDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ0 = /**
 * @param {?=} dir
 * @return {?}
 */
(dir = {}) => dir, ɵ1 = /**
 * @param {?} type
 * @param {?} meta
 * @return {?}
 */
(type, meta) => SWITCH_COMPILE_DIRECTIVE(type, meta);
/**
 * Type of the Directive metadata.
 *
 * \@publicApi
 * @type {?}
 */
export const Directive = makeDecorator('Directive', (ɵ0), undefined, undefined, (ɵ1));
/**
 * Component decorator interface
 *
 * \@publicApi
 * @record
 */
export function ComponentDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ2 = /**
 * @param {?=} c
 * @return {?}
 */
(c = {}) => (Object.assign({ changeDetection: ChangeDetectionStrategy.Default }, c)), ɵ3 = /**
 * @param {?} type
 * @param {?} meta
 * @return {?}
 */
(type, meta) => SWITCH_COMPILE_COMPONENT(type, meta);
/**
 * Component decorator and metadata.
 *
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const Component = makeDecorator('Component', (ɵ2), Directive, undefined, (ɵ3));
/**
 * Type of the Pipe decorator / constructor function.
 *
 * \@publicApi
 * @record
 */
export function PipeDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ4 = /**
 * @param {?} p
 * @return {?}
 */
(p) => (Object.assign({ pure: true }, p)), ɵ5 = /**
 * @param {?} type
 * @param {?} meta
 * @return {?}
 */
(type, meta) => SWITCH_COMPILE_PIPE(type, meta);
/**
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const Pipe = makeDecorator('Pipe', (ɵ4), undefined, undefined, (ɵ5));
/**
 * \@publicApi
 * @record
 */
export function InputDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ6 = /**
 * @param {?=} bindingPropertyName
 * @return {?}
 */
(bindingPropertyName) => ({ bindingPropertyName });
/**
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const Input = makePropDecorator('Input', (ɵ6));
/**
 * Type of the Output decorator / constructor function.
 *
 * \@publicApi
 * @record
 */
export function OutputDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ7 = /**
 * @param {?=} bindingPropertyName
 * @return {?}
 */
(bindingPropertyName) => ({ bindingPropertyName });
/**
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const Output = makePropDecorator('Output', (ɵ7));
/**
 * Type of the HostBinding decorator / constructor function.
 *
 * \@publicApi
 * @record
 */
export function HostBindingDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ8 = /**
 * @param {?=} hostPropertyName
 * @return {?}
 */
(hostPropertyName) => ({ hostPropertyName });
/**
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const HostBinding = makePropDecorator('HostBinding', (ɵ8));
/**
 * Type of the HostListener decorator / constructor function.
 *
 * \@publicApi
 * @record
 */
export function HostListenerDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ9 = /**
 * @param {?=} eventName
 * @param {?=} args
 * @return {?}
 */
(eventName, args) => ({ eventName, args });
/**
 * Decorator that binds a DOM event to a host listener and supplies configuration metadata.
 * Angular invokes the supplied handler method when the host element emits the specified event,
 * and updates the bound element with the result.
 *
 * If the handler method returns false, applies `preventDefault` on the bound element.
 *
 * \@usageNotes
 *
 * The following example declares a directive
 * that attaches a click listener to a button and counts clicks.
 *
 * ```ts
 * \@Directive({selector: 'button[counting]'})
 * class CountClicks {
 *   numberOfClicks = 0;
 *
 * \@HostListener('click', ['$event.target'])
 *   onClick(btn) {
 *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);
 *  }
 * }
 *
 * \@Component({
 *   selector: 'app',
 *   template: '<button counting>Increment</button>',
 * })
 * class App {}
 * ```
 *
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const HostListener = makePropDecorator('HostListener', (ɵ9));
/** @type {?} */
export const SWITCH_COMPILE_COMPONENT__POST_R3__ = render3CompileComponent;
/** @type {?} */
export const SWITCH_COMPILE_DIRECTIVE__POST_R3__ = render3CompileDirective;
/** @type {?} */
export const SWITCH_COMPILE_PIPE__POST_R3__ = render3CompilePipe;
/** @type {?} */
const SWITCH_COMPILE_COMPONENT__PRE_R3__ = noop;
/** @type {?} */
const SWITCH_COMPILE_DIRECTIVE__PRE_R3__ = noop;
/** @type {?} */
const SWITCH_COMPILE_PIPE__PRE_R3__ = noop;
/** @type {?} */
const SWITCH_COMPILE_COMPONENT = SWITCH_COMPILE_COMPONENT__POST_R3__;
/** @type {?} */
const SWITCH_COMPILE_DIRECTIVE = SWITCH_COMPILE_DIRECTIVE__POST_R3__;
/** @type {?} */
const SWITCH_COMPILE_PIPE = SWITCH_COMPILE_PIPE__POST_R3__;
export { ɵ0, ɵ1, ɵ2, ɵ3, ɵ4, ɵ5, ɵ6, ɵ7, ɵ8, ɵ9 };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9lc20yMDE1L3NyYy9tZXRhZGF0YS9kaXJlY3RpdmVzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUNBK01pQyxtQ0FBa0M7O2lDQUVsQyxtQ0FBa0M7OzRCQUV2Qyw4QkFBNkIiLCJmaWxlIjoiZGlyZWN0aXZlcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGNvbnN0YW50UHJvcGVydHksZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJy4uL2NoYW5nZV9kZXRlY3Rpb24vY29uc3RhbnRzJztcclxuaW1wb3J0IHsgY29tcGlsZUNvbXBvbmVudCBhcyByZW5kZXIzQ29tcGlsZUNvbXBvbmVudCwgY29tcGlsZURpcmVjdGl2ZSBhcyByZW5kZXIzQ29tcGlsZURpcmVjdGl2ZSB9IGZyb20gJy4uL3JlbmRlcjMvaml0L2RpcmVjdGl2ZSc7XHJcbmltcG9ydCB7IGNvbXBpbGVQaXBlIGFzIHJlbmRlcjNDb21waWxlUGlwZSB9IGZyb20gJy4uL3JlbmRlcjMvaml0L3BpcGUnO1xyXG5pbXBvcnQgeyBtYWtlRGVjb3JhdG9yLCBtYWtlUHJvcERlY29yYXRvciB9IGZyb20gJy4uL3V0aWwvZGVjb3JhdG9ycyc7XHJcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi91dGlsL25vb3AnO1xyXG4vKipcclxuICogVHlwZSBvZiB0aGUgRGlyZWN0aXZlIGRlY29yYXRvciAvIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG4gKiBcXEBwdWJsaWNBcGlcclxuICogQHJlY29yZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIERpcmVjdGl2ZURlY29yYXRvcigpIHsgfVxyXG4vLyBXQVJOSU5HOiBpbnRlcmZhY2UgaGFzIGJvdGggYSB0eXBlIGFuZCBhIHZhbHVlLCBza2lwcGluZyBlbWl0XHJcbmNvbnN0IMm1MCA9IC8qKlxyXG4gKiBAcGFyYW0gez89fSBkaXJcclxuICogQHJldHVybiB7P31cclxuICovXHJcbihkaXIgPSB7fSkgPT4gZGlyLCDJtTEgPSAvKipcclxuICogQHBhcmFtIHs/fSB0eXBlXHJcbiAqIEBwYXJhbSB7P30gbWV0YVxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuKHR5cGUsIG1ldGEpID0+IFNXSVRDSF9DT01QSUxFX0RJUkVDVElWRSh0eXBlLCBtZXRhKTtcclxuLyoqXHJcbiAqIFR5cGUgb2YgdGhlIERpcmVjdGl2ZSBtZXRhZGF0YS5cclxuICpcclxuICogXFxAcHVibGljQXBpXHJcbiAqIEB0eXBlIHs/fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IERpcmVjdGl2ZSA9IG1ha2VEZWNvcmF0b3IoJ0RpcmVjdGl2ZScsICjJtTApLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgKMm1MSkpO1xyXG4vKipcclxuICogQ29tcG9uZW50IGRlY29yYXRvciBpbnRlcmZhY2VcclxuICpcclxuICogXFxAcHVibGljQXBpXHJcbiAqIEByZWNvcmRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBDb21wb25lbnREZWNvcmF0b3IoKSB7IH1cclxuLy8gV0FSTklORzogaW50ZXJmYWNlIGhhcyBib3RoIGEgdHlwZSBhbmQgYSB2YWx1ZSwgc2tpcHBpbmcgZW1pdFxyXG5jb25zdCDJtTIgPSAvKipcclxuICogQHBhcmFtIHs/PX0gY1xyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuKGMgPSB7fSkgPT4gKE9iamVjdC5hc3NpZ24oeyBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQgfSwgYykpLCDJtTMgPSAvKipcclxuICogQHBhcmFtIHs/fSB0eXBlXHJcbiAqIEBwYXJhbSB7P30gbWV0YVxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuKHR5cGUsIG1ldGEpID0+IFNXSVRDSF9DT01QSUxFX0NPTVBPTkVOVCh0eXBlLCBtZXRhKTtcclxuLyoqXHJcbiAqIENvbXBvbmVudCBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxyXG4gKlxyXG4gKiBcXEBBbm5vdGF0aW9uXHJcbiAqIFxcQHB1YmxpY0FwaVxyXG4gKiBAdHlwZSB7P31cclxuICovXHJcbmV4cG9ydCBjb25zdCBDb21wb25lbnQgPSBtYWtlRGVjb3JhdG9yKCdDb21wb25lbnQnLCAoybUyKSwgRGlyZWN0aXZlLCB1bmRlZmluZWQsICjJtTMpKTtcclxuLyoqXHJcbiAqIFR5cGUgb2YgdGhlIFBpcGUgZGVjb3JhdG9yIC8gY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIFxcQHB1YmxpY0FwaVxyXG4gKiBAcmVjb3JkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gUGlwZURlY29yYXRvcigpIHsgfVxyXG4vLyBXQVJOSU5HOiBpbnRlcmZhY2UgaGFzIGJvdGggYSB0eXBlIGFuZCBhIHZhbHVlLCBza2lwcGluZyBlbWl0XHJcbmNvbnN0IMm1NCA9IC8qKlxyXG4gKiBAcGFyYW0gez99IHBcclxuICogQHJldHVybiB7P31cclxuICovXHJcbihwKSA9PiAoT2JqZWN0LmFzc2lnbih7IHB1cmU6IHRydWUgfSwgcCkpLCDJtTUgPSAvKipcclxuICogQHBhcmFtIHs/fSB0eXBlXHJcbiAqIEBwYXJhbSB7P30gbWV0YVxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuKHR5cGUsIG1ldGEpID0+IFNXSVRDSF9DT01QSUxFX1BJUEUodHlwZSwgbWV0YSk7XHJcbi8qKlxyXG4gKiBcXEBBbm5vdGF0aW9uXHJcbiAqIFxcQHB1YmxpY0FwaVxyXG4gKiBAdHlwZSB7P31cclxuICovXHJcbmV4cG9ydCBjb25zdCBQaXBlID0gbWFrZURlY29yYXRvcignUGlwZScsICjJtTQpLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgKMm1NSkpO1xyXG4vKipcclxuICogXFxAcHVibGljQXBpXHJcbiAqIEByZWNvcmRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBJbnB1dERlY29yYXRvcigpIHsgfVxyXG4vLyBXQVJOSU5HOiBpbnRlcmZhY2UgaGFzIGJvdGggYSB0eXBlIGFuZCBhIHZhbHVlLCBza2lwcGluZyBlbWl0XHJcbmNvbnN0IMm1NiA9IC8qKlxyXG4gKiBAcGFyYW0gez89fSBiaW5kaW5nUHJvcGVydHlOYW1lXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG4oYmluZGluZ1Byb3BlcnR5TmFtZSkgPT4gKHsgYmluZGluZ1Byb3BlcnR5TmFtZSB9KTtcclxuLyoqXHJcbiAqIFxcQEFubm90YXRpb25cclxuICogXFxAcHVibGljQXBpXHJcbiAqIEB0eXBlIHs/fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IElucHV0ID0gbWFrZVByb3BEZWNvcmF0b3IoJ0lucHV0JywgKMm1NikpO1xyXG4vKipcclxuICogVHlwZSBvZiB0aGUgT3V0cHV0IGRlY29yYXRvciAvIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBcXEBwdWJsaWNBcGlcclxuICogQHJlY29yZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE91dHB1dERlY29yYXRvcigpIHsgfVxyXG4vLyBXQVJOSU5HOiBpbnRlcmZhY2UgaGFzIGJvdGggYSB0eXBlIGFuZCBhIHZhbHVlLCBza2lwcGluZyBlbWl0XHJcbmNvbnN0IMm1NyA9IC8qKlxyXG4gKiBAcGFyYW0gez89fSBiaW5kaW5nUHJvcGVydHlOYW1lXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG4oYmluZGluZ1Byb3BlcnR5TmFtZSkgPT4gKHsgYmluZGluZ1Byb3BlcnR5TmFtZSB9KTtcclxuLyoqXHJcbiAqIFxcQEFubm90YXRpb25cclxuICogXFxAcHVibGljQXBpXHJcbiAqIEB0eXBlIHs/fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IE91dHB1dCA9IG1ha2VQcm9wRGVjb3JhdG9yKCdPdXRwdXQnLCAoybU3KSk7XHJcbi8qKlxyXG4gKiBUeXBlIG9mIHRoZSBIb3N0QmluZGluZyBkZWNvcmF0b3IgLyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cclxuICpcclxuICogXFxAcHVibGljQXBpXHJcbiAqIEByZWNvcmRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBIb3N0QmluZGluZ0RlY29yYXRvcigpIHsgfVxyXG4vLyBXQVJOSU5HOiBpbnRlcmZhY2UgaGFzIGJvdGggYSB0eXBlIGFuZCBhIHZhbHVlLCBza2lwcGluZyBlbWl0XHJcbmNvbnN0IMm1OCA9IC8qKlxyXG4gKiBAcGFyYW0gez89fSBob3N0UHJvcGVydHlOYW1lXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG4oaG9zdFByb3BlcnR5TmFtZSkgPT4gKHsgaG9zdFByb3BlcnR5TmFtZSB9KTtcclxuLyoqXHJcbiAqIFxcQEFubm90YXRpb25cclxuICogXFxAcHVibGljQXBpXHJcbiAqIEB0eXBlIHs/fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEhvc3RCaW5kaW5nID0gbWFrZVByb3BEZWNvcmF0b3IoJ0hvc3RCaW5kaW5nJywgKMm1OCkpO1xyXG4vKipcclxuICogVHlwZSBvZiB0aGUgSG9zdExpc3RlbmVyIGRlY29yYXRvciAvIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBcXEBwdWJsaWNBcGlcclxuICogQHJlY29yZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEhvc3RMaXN0ZW5lckRlY29yYXRvcigpIHsgfVxyXG4vLyBXQVJOSU5HOiBpbnRlcmZhY2UgaGFzIGJvdGggYSB0eXBlIGFuZCBhIHZhbHVlLCBza2lwcGluZyBlbWl0XHJcbmNvbnN0IMm1OSA9IC8qKlxyXG4gKiBAcGFyYW0gez89fSBldmVudE5hbWVcclxuICogQHBhcmFtIHs/PX0gYXJnc1xyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuKGV2ZW50TmFtZSwgYXJncykgPT4gKHsgZXZlbnROYW1lLCBhcmdzIH0pO1xyXG4vKipcclxuICogRGVjb3JhdG9yIHRoYXQgYmluZHMgYSBET00gZXZlbnQgdG8gYSBob3N0IGxpc3RlbmVyIGFuZCBzdXBwbGllcyBjb25maWd1cmF0aW9uIG1ldGFkYXRhLlxyXG4gKiBBbmd1bGFyIGludm9rZXMgdGhlIHN1cHBsaWVkIGhhbmRsZXIgbWV0aG9kIHdoZW4gdGhlIGhvc3QgZWxlbWVudCBlbWl0cyB0aGUgc3BlY2lmaWVkIGV2ZW50LFxyXG4gKiBhbmQgdXBkYXRlcyB0aGUgYm91bmQgZWxlbWVudCB3aXRoIHRoZSByZXN1bHQuXHJcbiAqXHJcbiAqIElmIHRoZSBoYW5kbGVyIG1ldGhvZCByZXR1cm5zIGZhbHNlLCBhcHBsaWVzIGBwcmV2ZW50RGVmYXVsdGAgb24gdGhlIGJvdW5kIGVsZW1lbnQuXHJcbiAqXHJcbiAqIFxcQHVzYWdlTm90ZXNcclxuICpcclxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGRlY2xhcmVzIGEgZGlyZWN0aXZlXHJcbiAqIHRoYXQgYXR0YWNoZXMgYSBjbGljayBsaXN0ZW5lciB0byBhIGJ1dHRvbiBhbmQgY291bnRzIGNsaWNrcy5cclxuICpcclxuICogYGBgdHNcclxuICogXFxARGlyZWN0aXZlKHtzZWxlY3RvcjogJ2J1dHRvbltjb3VudGluZ10nfSlcclxuICogY2xhc3MgQ291bnRDbGlja3Mge1xyXG4gKiAgIG51bWJlck9mQ2xpY2tzID0gMDtcclxuICpcclxuICogXFxASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50LnRhcmdldCddKVxyXG4gKiAgIG9uQ2xpY2soYnRuKSB7XHJcbiAqICAgICBjb25zb2xlLmxvZygnYnV0dG9uJywgYnRuLCAnbnVtYmVyIG9mIGNsaWNrczonLCB0aGlzLm51bWJlck9mQ2xpY2tzKyspO1xyXG4gKiAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIFxcQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdhcHAnLFxyXG4gKiAgIHRlbXBsYXRlOiAnPGJ1dHRvbiBjb3VudGluZz5JbmNyZW1lbnQ8L2J1dHRvbj4nLFxyXG4gKiB9KVxyXG4gKiBjbGFzcyBBcHAge31cclxuICogYGBgXHJcbiAqXHJcbiAqIFxcQEFubm90YXRpb25cclxuICogXFxAcHVibGljQXBpXHJcbiAqIEB0eXBlIHs/fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEhvc3RMaXN0ZW5lciA9IG1ha2VQcm9wRGVjb3JhdG9yKCdIb3N0TGlzdGVuZXInLCAoybU5KSk7XHJcbi8qKiBAdHlwZSB7P30gKi9cclxuZXhwb3J0IGNvbnN0IFNXSVRDSF9DT01QSUxFX0NPTVBPTkVOVF9fUE9TVF9SM19fID0gcmVuZGVyM0NvbXBpbGVDb21wb25lbnQ7XHJcbi8qKiBAdHlwZSB7P30gKi9cclxuZXhwb3J0IGNvbnN0IFNXSVRDSF9DT01QSUxFX0RJUkVDVElWRV9fUE9TVF9SM19fID0gcmVuZGVyM0NvbXBpbGVEaXJlY3RpdmU7XHJcbi8qKiBAdHlwZSB7P30gKi9cclxuZXhwb3J0IGNvbnN0IFNXSVRDSF9DT01QSUxFX1BJUEVfX1BPU1RfUjNfXyA9IHJlbmRlcjNDb21waWxlUGlwZTtcclxuLyoqIEB0eXBlIHs/fSAqL1xyXG5jb25zdCBTV0lUQ0hfQ09NUElMRV9DT01QT05FTlRfX1BSRV9SM19fID0gbm9vcDtcclxuLyoqIEB0eXBlIHs/fSAqL1xyXG5jb25zdCBTV0lUQ0hfQ09NUElMRV9ESVJFQ1RJVkVfX1BSRV9SM19fID0gbm9vcDtcclxuLyoqIEB0eXBlIHs/fSAqL1xyXG5jb25zdCBTV0lUQ0hfQ09NUElMRV9QSVBFX19QUkVfUjNfXyA9IG5vb3A7XHJcbi8qKiBAdHlwZSB7P30gKi9cclxuY29uc3QgU1dJVENIX0NPTVBJTEVfQ09NUE9ORU5UID0gU1dJVENIX0NPTVBJTEVfQ09NUE9ORU5UX19QUkVfUjNfXztcclxuLyoqIEB0eXBlIHs/fSAqL1xyXG5jb25zdCBTV0lUQ0hfQ09NUElMRV9ESVJFQ1RJVkUgPSBTV0lUQ0hfQ09NUElMRV9ESVJFQ1RJVkVfX1BSRV9SM19fO1xyXG4vKiogQHR5cGUgez99ICovXHJcbmNvbnN0IFNXSVRDSF9DT01QSUxFX1BJUEUgPSBTV0lUQ0hfQ09NUElMRV9QSVBFX19QUkVfUjNfXztcclxuZXhwb3J0IHsgybUwLCDJtTEsIMm1MiwgybUzLCDJtTQsIMm1NSwgybU2LCDJtTcsIMm1OCwgybU5IH07XHIiXX0=