{"version":3,"sources":["d:/Angular Project/Didex/didex-admin-panel/node_modules/@angular/core/bundles/core.umd.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;eA8lVe,6CAA4C;6CACd,6CAA4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oCAogBrD,oCAAmC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBAud/C,wBAAuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qCAo8MV,qCAAoC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mCA6GtC,mCAAkC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sCAgpC/B,sCAAqC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4CAoC/B,4CAA2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mCAytLpD,mCAAkC;mCAClC,mCAAkC;8BACvC,8BAA6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAwCzB,kCAAiC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UA+DzD;;;;;;;;;;;;;;;;;;yGAKwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAgFxB;;;;2DAGU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qBAgGC,6BAA4B;;;;;;;;;;;;;;;;;;;;;;;;;;;;qCA4BZ,qCAAoC;;;;;sCAKnC,sCAAqC;;;;;;;;;;;;;qDAatB,qDAAoD;;;;;sDAKnD,sDAAqD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qFA2CtB;;;;0NAGhE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UA2mBX;;;;;;;uYAIc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAoDd;;;;;;;8OAIsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iCA6BC,iCAAgC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BA6BvC,0BAAyB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;WA0OxC;;;;;;;gQAIa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4EA8VoD;;;;;;;;;;8jBAOjD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2BAoEA,2BAA0B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAmE3C;;;;;;;;;;;;qGAKyB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uBAuxBZ,uBAAsB;;;;;;;;;;;;;oBAazB,oBAAmB;;;;uBAIhB,uBAAsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SAuHpC;;;;;;;;;mNAIqB","file":"core.umd.js","sourcesContent":["/**\r\n * @license Angular v8.2.14\r\n * (c) 2010-2019 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\n(function (global, factory) {\r\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('rxjs/operators')) :\r\n    typeof define === 'function' && define.amd ? define('@angular/core', ['exports', 'rxjs', 'rxjs/operators'], factory) :\r\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.core = {}), global.rxjs, global.rxjs.operators));\r\n}(this, function (exports, rxjs, operators) { 'use strict';\r\n\r\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation. All rights reserved.\r\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n    this file except in compliance with the License. You may obtain a copy of the\r\n    License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n    MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n    and limitations under the License.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\r\n\r\n    function __rest(s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n                t[p[i]] = s[p[i]];\r\n        return t;\r\n    }\r\n\r\n    function __decorate(decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    }\r\n\r\n    function __param(paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    }\r\n\r\n    function __metadata(metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    }\r\n\r\n    function __awaiter(thisArg, _arguments, P, generator) {\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    }\r\n\r\n    function __generator(thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    }\r\n\r\n    function __exportStar(m, exports) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    }\r\n\r\n    function __values(o) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n        if (m) return m.call(o);\r\n        return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n    }\r\n\r\n    function __read(o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    }\r\n\r\n    function __spread() {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    }\r\n\r\n    function __await(v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    }\r\n\r\n    function __asyncGenerator(thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    }\r\n\r\n    function __asyncDelegator(o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n    }\r\n\r\n    function __asyncValues(o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator], i;\r\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n    }\r\n\r\n    function __makeTemplateObject(cooked, raw) {\r\n        if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n        return cooked;\r\n    };\r\n\r\n    function __importStar(mod) {\r\n        if (mod && mod.__esModule) return mod;\r\n        var result = {};\r\n        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n        result.default = mod;\r\n        return result;\r\n    }\r\n\r\n    function __importDefault(mod) {\r\n        return (mod && mod.__esModule) ? mod : { default: mod };\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var ANNOTATIONS = '__annotations__';\r\n    var PARAMETERS = '__parameters__';\r\n    var PROP_METADATA = '__prop__metadata__';\r\n    /**\r\n     * @suppress {globalThis}\r\n     */\r\n    function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {\r\n        var metaCtor = makeMetadataCtor(props);\r\n        function DecoratorFactory() {\r\n            var _a;\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            if (this instanceof DecoratorFactory) {\r\n                metaCtor.call.apply(metaCtor, __spread([this], args));\r\n                return this;\r\n            }\r\n            var annotationInstance = new ((_a = DecoratorFactory).bind.apply(_a, __spread([void 0], args)))();\r\n            return function TypeDecorator(cls) {\r\n                if (typeFn)\r\n                    typeFn.apply(void 0, __spread([cls], args));\r\n                // Use of Object.defineProperty is important since it creates non-enumerable property which\r\n                // prevents the property is copied during subclassing.\r\n                var annotations = cls.hasOwnProperty(ANNOTATIONS) ?\r\n                    cls[ANNOTATIONS] :\r\n                    Object.defineProperty(cls, ANNOTATIONS, { value: [] })[ANNOTATIONS];\r\n                annotations.push(annotationInstance);\r\n                if (additionalProcessing)\r\n                    additionalProcessing(cls);\r\n                return cls;\r\n            };\r\n        }\r\n        if (parentClass) {\r\n            DecoratorFactory.prototype = Object.create(parentClass.prototype);\r\n        }\r\n        DecoratorFactory.prototype.ngMetadataName = name;\r\n        DecoratorFactory.annotationCls = DecoratorFactory;\r\n        return DecoratorFactory;\r\n    }\r\n    function makeMetadataCtor(props) {\r\n        return function ctor() {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            if (props) {\r\n                var values = props.apply(void 0, __spread(args));\r\n                for (var propName in values) {\r\n                    this[propName] = values[propName];\r\n                }\r\n            }\r\n        };\r\n    }\r\n    function makeParamDecorator(name, props, parentClass) {\r\n        var metaCtor = makeMetadataCtor(props);\r\n        function ParamDecoratorFactory() {\r\n            var _a;\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            if (this instanceof ParamDecoratorFactory) {\r\n                metaCtor.apply(this, args);\r\n                return this;\r\n            }\r\n            var annotationInstance = new ((_a = ParamDecoratorFactory).bind.apply(_a, __spread([void 0], args)))();\r\n            ParamDecorator.annotation = annotationInstance;\r\n            return ParamDecorator;\r\n            function ParamDecorator(cls, unusedKey, index) {\r\n                // Use of Object.defineProperty is important since it creates non-enumerable property which\r\n                // prevents the property is copied during subclassing.\r\n                var parameters = cls.hasOwnProperty(PARAMETERS) ?\r\n                    cls[PARAMETERS] :\r\n                    Object.defineProperty(cls, PARAMETERS, { value: [] })[PARAMETERS];\r\n                // there might be gaps if some in between parameters do not have annotations.\r\n                // we pad with nulls.\r\n                while (parameters.length <= index) {\r\n                    parameters.push(null);\r\n                }\r\n                (parameters[index] = parameters[index] || []).push(annotationInstance);\r\n                return cls;\r\n            }\r\n        }\r\n        if (parentClass) {\r\n            ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);\r\n        }\r\n        ParamDecoratorFactory.prototype.ngMetadataName = name;\r\n        ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;\r\n        return ParamDecoratorFactory;\r\n    }\r\n    function makePropDecorator(name, props, parentClass, additionalProcessing) {\r\n        var metaCtor = makeMetadataCtor(props);\r\n        function PropDecoratorFactory() {\r\n            var _a;\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            if (this instanceof PropDecoratorFactory) {\r\n                metaCtor.apply(this, args);\r\n                return this;\r\n            }\r\n            var decoratorInstance = new ((_a = PropDecoratorFactory).bind.apply(_a, __spread([void 0], args)))();\r\n            function PropDecorator(target, name) {\r\n                var constructor = target.constructor;\r\n                // Use of Object.defineProperty is important since it creates non-enumerable property which\r\n                // prevents the property is copied during subclassing.\r\n                var meta = constructor.hasOwnProperty(PROP_METADATA) ?\r\n                    constructor[PROP_METADATA] :\r\n                    Object.defineProperty(constructor, PROP_METADATA, { value: {} })[PROP_METADATA];\r\n                meta[name] = meta.hasOwnProperty(name) && meta[name] || [];\r\n                meta[name].unshift(decoratorInstance);\r\n                if (additionalProcessing)\r\n                    additionalProcessing.apply(void 0, __spread([target, name], args));\r\n            }\r\n            return PropDecorator;\r\n        }\r\n        if (parentClass) {\r\n            PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\r\n        }\r\n        PropDecoratorFactory.prototype.ngMetadataName = name;\r\n        PropDecoratorFactory.annotationCls = PropDecoratorFactory;\r\n        return PropDecoratorFactory;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var ɵ0 = function (token) { return ({ token: token }); };\r\n    /**\r\n     * Inject decorator and metadata.\r\n     *\r\n     * @Annotation\r\n     * @publicApi\r\n     */\r\n    var Inject = makeParamDecorator('Inject', ɵ0);\r\n    /**\r\n     * Optional decorator and metadata.\r\n     *\r\n     * @Annotation\r\n     * @publicApi\r\n     */\r\n    var Optional = makeParamDecorator('Optional');\r\n    /**\r\n     * Self decorator and metadata.\r\n     *\r\n     * @Annotation\r\n     * @publicApi\r\n     */\r\n    var Self = makeParamDecorator('Self');\r\n    /**\r\n     * SkipSelf decorator and metadata.\r\n     *\r\n     * @Annotation\r\n     * @publicApi\r\n     */\r\n    var SkipSelf = makeParamDecorator('SkipSelf');\r\n    /**\r\n     * Host decorator and metadata.\r\n     *\r\n     * @Annotation\r\n     * @publicApi\r\n     */\r\n    var Host = makeParamDecorator('Host');\r\n    var ɵ1 = function (attributeName) { return ({ attributeName: attributeName }); };\r\n    /**\r\n     * Attribute decorator and metadata.\r\n     *\r\n     * @Annotation\r\n     * @publicApi\r\n     */\r\n    var Attribute = makeParamDecorator('Attribute', ɵ1);\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    (function (InjectFlags) {\r\n        // TODO(alxhub): make this 'const' when ngc no longer writes exports of it into ngfactory files.\r\n        /** Check self and check parent injector if needed */\r\n        InjectFlags[InjectFlags[\"Default\"] = 0] = \"Default\";\r\n        /**\r\n         * Specifies that an injector should retrieve a dependency from any injector until reaching the\r\n         * host element of the current component. (Only used with Element Injector)\r\n         */\r\n        InjectFlags[InjectFlags[\"Host\"] = 1] = \"Host\";\r\n        /** Don't ascend to ancestors of the node requesting injection. */\r\n        InjectFlags[InjectFlags[\"Self\"] = 2] = \"Self\";\r\n        /** Skip the node that is requesting injection. */\r\n        InjectFlags[InjectFlags[\"SkipSelf\"] = 4] = \"SkipSelf\";\r\n        /** Inject `defaultValue` instead if token not found. */\r\n        InjectFlags[InjectFlags[\"Optional\"] = 8] = \"Optional\";\r\n    })(exports.InjectFlags || (exports.InjectFlags = {}));\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function getClosureSafeProperty(objWithPropertyToExtract) {\r\n        for (var key in objWithPropertyToExtract) {\r\n            if (objWithPropertyToExtract[key] === getClosureSafeProperty) {\r\n                return key;\r\n            }\r\n        }\r\n        throw Error('Could not find renamed property on target object.');\r\n    }\r\n    /**\r\n     * Sets properties on a target object from a source object, but only if\r\n     * the property doesn't already exist on the target object.\r\n     * @param target The target to set properties on\r\n     * @param source The source of the property keys and values to set\r\n     */\r\n    function fillProperties(target, source) {\r\n        for (var key in source) {\r\n            if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\r\n                target[key] = source[key];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Construct an `InjectableDef` which defines how a token will be constructed by the DI system, and\r\n     * in which injectors (if any) it will be available.\r\n     *\r\n     * This should be assigned to a static `ngInjectableDef` field on a type, which will then be an\r\n     * `InjectableType`.\r\n     *\r\n     * Options:\r\n     * * `providedIn` determines which injectors will include the injectable, by either associating it\r\n     *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\r\n     *   provided in the `'root'` injector, which will be the application-level injector in most apps.\r\n     * * `factory` gives the zero argument function which will create an instance of the injectable.\r\n     *   The factory can call `inject` to access the `Injector` and request injection of dependencies.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵdefineInjectable(opts) {\r\n        return {\r\n            token: opts.token, providedIn: opts.providedIn || null, factory: opts.factory,\r\n            value: undefined,\r\n        };\r\n    }\r\n    /**\r\n     * @deprecated in v8, delete after v10. This API should be used only be generated code, and that\r\n     * code should now use ɵɵdefineInjectable instead.\r\n     * @publicApi\r\n     */\r\n    var defineInjectable = ɵɵdefineInjectable;\r\n    /**\r\n     * Construct an `InjectorDef` which configures an injector.\r\n     *\r\n     * This should be assigned to a static `ngInjectorDef` field on a type, which will then be an\r\n     * `InjectorType`.\r\n     *\r\n     * Options:\r\n     *\r\n     * * `factory`: an `InjectorType` is an instantiable type, so a zero argument `factory` function to\r\n     *   create the type must be provided. If that factory function needs to inject arguments, it can\r\n     *   use the `inject` function.\r\n     * * `providers`: an optional array of providers to add to the injector. Each provider must\r\n     *   either have a factory or point to a type which has an `ngInjectableDef` static property (the\r\n     *   type must be an `InjectableType`).\r\n     * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\r\n     *   whose providers will also be added to the injector. Locally provided types will override\r\n     *   providers from imports.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function ɵɵdefineInjector(options) {\r\n        return {\r\n            factory: options.factory, providers: options.providers || [], imports: options.imports || [],\r\n        };\r\n    }\r\n    /**\r\n     * Read the `ngInjectableDef` for `type` in a way which is immune to accidentally reading inherited\r\n     * value.\r\n     *\r\n     * @param type A type which may have its own (non-inherited) `ngInjectableDef`.\r\n     */\r\n    function getInjectableDef(type) {\r\n        var def = type[NG_INJECTABLE_DEF];\r\n        // The definition read above may come from a base class. `hasOwnProperty` is not sufficient to\r\n        // distinguish this case, as in older browsers (e.g. IE10) static property inheritance is\r\n        // implemented by copying the properties.\r\n        //\r\n        // Instead, the ngInjectableDef's token is compared to the type, and if they don't match then the\r\n        // property was not defined directly on the type itself, and was likely inherited. The definition\r\n        // is only returned if the type matches the def.token.\r\n        return def && def.token === type ? def : null;\r\n    }\r\n    /**\r\n     * Read the `ngInjectableDef` for `type` or read the `ngInjectableDef` from one of its ancestors.\r\n     *\r\n     * @param type A type which may have `ngInjectableDef`, via inheritance.\r\n     *\r\n     * @deprecated Will be removed in v10, where an error will occur in the scenario if we find the\r\n     * `ngInjectableDef` on an ancestor only.\r\n     */\r\n    function getInheritedInjectableDef(type) {\r\n        if (type && type[NG_INJECTABLE_DEF]) {\r\n            // TODO(FW-1307): Re-add ngDevMode when closure can handle it\r\n            // ngDevMode &&\r\n            console.warn(\"DEPRECATED: DI is instantiating a token \\\"\" + type.name + \"\\\" that inherits its @Injectable decorator but does not provide one itself.\\n\" +\r\n                (\"This will become an error in v10. Please add @Injectable() to the \\\"\" + type.name + \"\\\" class.\"));\r\n            return type[NG_INJECTABLE_DEF];\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Read the `ngInjectorDef` type in a way which is immune to accidentally reading inherited value.\r\n     *\r\n     * @param type type which may have `ngInjectorDef`\r\n     */\r\n    function getInjectorDef(type) {\r\n        return type && type.hasOwnProperty(NG_INJECTOR_DEF) ? type[NG_INJECTOR_DEF] : null;\r\n    }\r\n    var NG_INJECTABLE_DEF = getClosureSafeProperty({ ngInjectableDef: getClosureSafeProperty });\r\n    var NG_INJECTOR_DEF = getClosureSafeProperty({ ngInjectorDef: getClosureSafeProperty });\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function stringify(token) {\r\n        if (typeof token === 'string') {\r\n            return token;\r\n        }\r\n        if (token instanceof Array) {\r\n            return '[' + token.map(stringify).join(', ') + ']';\r\n        }\r\n        if (token == null) {\r\n            return '' + token;\r\n        }\r\n        if (token.overriddenName) {\r\n            return \"\" + token.overriddenName;\r\n        }\r\n        if (token.name) {\r\n            return \"\" + token.name;\r\n        }\r\n        var res = token.toString();\r\n        if (res == null) {\r\n            return '' + res;\r\n        }\r\n        var newLineIndex = res.indexOf('\\n');\r\n        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });\r\n    /**\r\n     * Allows to refer to references which are not yet defined.\r\n     *\r\n     * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\r\n     * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\r\n     * a query is not yet defined.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\r\n     * @publicApi\r\n     */\r\n    function forwardRef(forwardRefFn) {\r\n        forwardRefFn.__forward_ref__ = forwardRef;\r\n        forwardRefFn.toString = function () { return stringify(this()); };\r\n        return forwardRefFn;\r\n    }\r\n    /**\r\n     * Lazily retrieves the reference value from a forwardRef.\r\n     *\r\n     * Acts as the identity function when given a non-forward-ref value.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\r\n     *\r\n     * @see `forwardRef`\r\n     * @publicApi\r\n     */\r\n    function resolveForwardRef(type) {\r\n        var fn = type;\r\n        if (typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) &&\r\n            fn.__forward_ref__ === forwardRef) {\r\n            return fn();\r\n        }\r\n        else {\r\n            return type;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var __globalThis = typeof globalThis !== 'undefined' && globalThis;\r\n    var __window = typeof window !== 'undefined' && window;\r\n    var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\r\n        self instanceof WorkerGlobalScope && self;\r\n    var __global = typeof global !== 'undefined' && global;\r\n    // Always use __globalThis if available, which is the spec-defined global variable across all\r\n    // environments, then fallback to __global first, because in Node tests both __global and\r\n    // __window may be defined and _global should be __global in that case.\r\n    var _global = __globalThis || __global || __window || __self;\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var R3ResolvedDependencyType;\r\n    (function (R3ResolvedDependencyType) {\r\n        R3ResolvedDependencyType[R3ResolvedDependencyType[\"Token\"] = 0] = \"Token\";\r\n        R3ResolvedDependencyType[R3ResolvedDependencyType[\"Attribute\"] = 1] = \"Attribute\";\r\n        R3ResolvedDependencyType[R3ResolvedDependencyType[\"ChangeDetectorRef\"] = 2] = \"ChangeDetectorRef\";\r\n    })(R3ResolvedDependencyType || (R3ResolvedDependencyType = {}));\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function getCompilerFacade() {\r\n        var globalNg = _global['ng'];\r\n        if (!globalNg || !globalNg.ɵcompilerFacade) {\r\n            throw new Error(\"Angular JIT compilation failed: '@angular/compiler' not loaded!\\n\" +\r\n                \"  - JIT compilation is discouraged for production use-cases! Consider AOT mode instead.\\n\" +\r\n                \"  - Did you bootstrap using '@angular/platform-browser-dynamic' or '@angular/platform-server'?\\n\" +\r\n                \"  - Alternatively provide the compiler with 'import \\\"@angular/compiler\\\";' before bootstrapping.\");\r\n        }\r\n        return globalNg.ɵcompilerFacade;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Creates a token that can be used in a DI Provider.\r\n     *\r\n     * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\r\n     * runtime representation) such as when injecting an interface, callable type, array or\r\n     * parameterized type.\r\n     *\r\n     * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\r\n     * the `Injector`. This provides additional level of type safety.\r\n     *\r\n     * ```\r\n     * interface MyInterface {...}\r\n     * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\r\n     * // myInterface is inferred to be MyInterface.\r\n     * ```\r\n     *\r\n     * When creating an `InjectionToken`, you can optionally specify a factory function which returns\r\n     * (possibly by creating) a default value of the parameterized type `T`. This sets up the\r\n     * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\r\n     * application's root injector. If the factory function, which takes zero arguments, needs to inject\r\n     * dependencies, it can do so using the `inject` function. See below for an example.\r\n     *\r\n     * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\r\n     * overrides the above behavior and marks the token as belonging to a particular `@NgModule`. As\r\n     * mentioned above, `'root'` is the default value for `providedIn`.\r\n     *\r\n     * @usageNotes\r\n     * ### Basic Example\r\n     *\r\n     * ### Plain InjectionToken\r\n     *\r\n     * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\r\n     *\r\n     * ### Tree-shakable InjectionToken\r\n     *\r\n     * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\r\n     *\r\n     *\r\n     * @publicApi\r\n     */\r\n    var InjectionToken = /** @class */ (function () {\r\n        function InjectionToken(_desc, options) {\r\n            this._desc = _desc;\r\n            /** @internal */\r\n            this.ngMetadataName = 'InjectionToken';\r\n            this.ngInjectableDef = undefined;\r\n            if (typeof options == 'number') {\r\n                // This is a special hack to assign __NG_ELEMENT_ID__ to this instance.\r\n                // __NG_ELEMENT_ID__ is Used by Ivy to determine bloom filter id.\r\n                // We are using it to assign `-1` which is used to identify `Injector`.\r\n                this.__NG_ELEMENT_ID__ = options;\r\n            }\r\n            else if (options !== undefined) {\r\n                this.ngInjectableDef = ɵɵdefineInjectable({\r\n                    token: this,\r\n                    providedIn: options.providedIn || 'root',\r\n                    factory: options.factory,\r\n                });\r\n            }\r\n        }\r\n        InjectionToken.prototype.toString = function () { return \"InjectionToken \" + this._desc; };\r\n        return InjectionToken;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\r\n     *\r\n     * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\r\n     * project.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var INJECTOR = new InjectionToken('INJECTOR', -1 // `-1` is used by Ivy DI system as special value to recognize it as `Injector`.\r\n    );\r\n    var _THROW_IF_NOT_FOUND = new Object();\r\n    var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\r\n    var NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\r\n    var NG_TOKEN_PATH = 'ngTokenPath';\r\n    var NEW_LINE = /\\n/gm;\r\n    var NO_NEW_LINE = 'ɵ';\r\n    var SOURCE = '__source';\r\n    var ɵ0$1 = getClosureSafeProperty;\r\n    var USE_VALUE = getClosureSafeProperty({ provide: String, useValue: ɵ0$1 });\r\n    /**\r\n     * Current injector value used by `inject`.\r\n     * - `undefined`: it is an error to call `inject`\r\n     * - `null`: `inject` can be called but there is no injector (limp-mode).\r\n     * - Injector instance: Use the injector for resolution.\r\n     */\r\n    var _currentInjector = undefined;\r\n    function setCurrentInjector(injector) {\r\n        var former = _currentInjector;\r\n        _currentInjector = injector;\r\n        return former;\r\n    }\r\n    /**\r\n     * Current implementation of inject.\r\n     *\r\n     * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed\r\n     * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this\r\n     * way for two reasons:\r\n     *  1. `Injector` should not depend on ivy logic.\r\n     *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\r\n     */\r\n    var _injectImplementation;\r\n    /**\r\n     * Sets the current inject implementation.\r\n     */\r\n    function setInjectImplementation(impl) {\r\n        var previous = _injectImplementation;\r\n        _injectImplementation = impl;\r\n        return previous;\r\n    }\r\n    function injectInjectorOnly(token, flags) {\r\n        if (flags === void 0) { flags = exports.InjectFlags.Default; }\r\n        if (_currentInjector === undefined) {\r\n            throw new Error(\"inject() must be called from an injection context\");\r\n        }\r\n        else if (_currentInjector === null) {\r\n            return injectRootLimpMode(token, undefined, flags);\r\n        }\r\n        else {\r\n            return _currentInjector.get(token, flags & exports.InjectFlags.Optional ? null : undefined, flags);\r\n        }\r\n    }\r\n    function ɵɵinject(token, flags) {\r\n        if (flags === void 0) { flags = exports.InjectFlags.Default; }\r\n        return (_injectImplementation || injectInjectorOnly)(token, flags);\r\n    }\r\n    /**\r\n     * Injects a token from the currently active injector.\r\n     *\r\n     * Must be used in the context of a factory function such as one defined for an\r\n     * `InjectionToken`. Throws an error if not called from such a context.\r\n     *\r\n     * Within such a factory function, using this function to request injection of a dependency\r\n     * is faster and more type-safe than providing an additional array of dependencies\r\n     * (as has been common with `useFactory` providers).\r\n     *\r\n     * @param token The injection token for the dependency to be injected.\r\n     * @param flags Optional flags that control how injection is executed.\r\n     * The flags correspond to injection strategies that can be specified with\r\n     * parameter decorators `@Host`, `@Self`, `@SkipSef`, and `@Optional`.\r\n     * @returns True if injection is successful, null otherwise.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Example\r\n     *\r\n     * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\r\n     *\r\n     * @publicApi\r\n     */\r\n    var inject = ɵɵinject;\r\n    /**\r\n     * Injects `root` tokens in limp mode.\r\n     *\r\n     * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\r\n     * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\r\n     * `InjectableDef`.\r\n     */\r\n    function injectRootLimpMode(token, notFoundValue, flags) {\r\n        var injectableDef = getInjectableDef(token);\r\n        if (injectableDef && injectableDef.providedIn == 'root') {\r\n            return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() :\r\n                injectableDef.value;\r\n        }\r\n        if (flags & exports.InjectFlags.Optional)\r\n            return null;\r\n        if (notFoundValue !== undefined)\r\n            return notFoundValue;\r\n        throw new Error(\"Injector: NOT_FOUND [\" + stringify(token) + \"]\");\r\n    }\r\n    function injectArgs(types) {\r\n        var args = [];\r\n        for (var i = 0; i < types.length; i++) {\r\n            var arg = resolveForwardRef(types[i]);\r\n            if (Array.isArray(arg)) {\r\n                if (arg.length === 0) {\r\n                    throw new Error('Arguments array must have arguments.');\r\n                }\r\n                var type = undefined;\r\n                var flags = exports.InjectFlags.Default;\r\n                for (var j = 0; j < arg.length; j++) {\r\n                    var meta = arg[j];\r\n                    if (meta instanceof Optional || meta.ngMetadataName === 'Optional' || meta === Optional) {\r\n                        flags |= exports.InjectFlags.Optional;\r\n                    }\r\n                    else if (meta instanceof SkipSelf || meta.ngMetadataName === 'SkipSelf' || meta === SkipSelf) {\r\n                        flags |= exports.InjectFlags.SkipSelf;\r\n                    }\r\n                    else if (meta instanceof Self || meta.ngMetadataName === 'Self' || meta === Self) {\r\n                        flags |= exports.InjectFlags.Self;\r\n                    }\r\n                    else if (meta instanceof Inject || meta === Inject) {\r\n                        type = meta.token;\r\n                    }\r\n                    else {\r\n                        type = meta;\r\n                    }\r\n                }\r\n                args.push(ɵɵinject(type, flags));\r\n            }\r\n            else {\r\n                args.push(ɵɵinject(arg));\r\n            }\r\n        }\r\n        return args;\r\n    }\r\n    var NullInjector = /** @class */ (function () {\r\n        function NullInjector() {\r\n        }\r\n        NullInjector.prototype.get = function (token, notFoundValue) {\r\n            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }\r\n            if (notFoundValue === THROW_IF_NOT_FOUND) {\r\n                // Intentionally left behind: With dev tools open the debugger will stop here. There is no\r\n                // reason why correctly written application should cause this exception.\r\n                // TODO(misko): uncomment the next line once `ngDevMode` works with closure.\r\n                // if(ngDevMode) debugger;\r\n                var error = new Error(\"NullInjectorError: No provider for \" + stringify(token) + \"!\");\r\n                error.name = 'NullInjectorError';\r\n                throw error;\r\n            }\r\n            return notFoundValue;\r\n        };\r\n        return NullInjector;\r\n    }());\r\n    function catchInjectorError(e, token, injectorErrorName, source) {\r\n        var tokenPath = e[NG_TEMP_TOKEN_PATH];\r\n        if (token[SOURCE]) {\r\n            tokenPath.unshift(token[SOURCE]);\r\n        }\r\n        e.message = formatError('\\n' + e.message, tokenPath, injectorErrorName, source);\r\n        e[NG_TOKEN_PATH] = tokenPath;\r\n        e[NG_TEMP_TOKEN_PATH] = null;\r\n        throw e;\r\n    }\r\n    function formatError(text, obj, injectorErrorName, source) {\r\n        if (source === void 0) { source = null; }\r\n        text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;\r\n        var context = stringify(obj);\r\n        if (obj instanceof Array) {\r\n            context = obj.map(stringify).join(' -> ');\r\n        }\r\n        else if (typeof obj === 'object') {\r\n            var parts = [];\r\n            for (var key in obj) {\r\n                if (obj.hasOwnProperty(key)) {\r\n                    var value = obj[key];\r\n                    parts.push(key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\r\n                }\r\n            }\r\n            context = \"{\" + parts.join(', ') + \"}\";\r\n        }\r\n        return \"\" + injectorErrorName + (source ? '(' + source + ')' : '') + \"[\" + context + \"]: \" + text.replace(NEW_LINE, '\\n  ');\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\r\n     *\r\n     * This should be kept up to date with the public exports of @angular/core.\r\n     */\r\n    var angularCoreDiEnv = {\r\n        'ɵɵdefineInjectable': ɵɵdefineInjectable,\r\n        'ɵɵdefineInjector': ɵɵdefineInjector,\r\n        'ɵɵinject': ɵɵinject,\r\n        'ɵɵgetFactoryOf': getFactoryOf,\r\n    };\r\n    function getFactoryOf(type) {\r\n        var typeAny = type;\r\n        var def = getInjectableDef(typeAny) || getInjectorDef(typeAny);\r\n        if (!def || def.factory === undefined) {\r\n            return null;\r\n        }\r\n        return def.factory;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Represents an instance of an NgModule created via a {@link NgModuleFactory}.\r\n     *\r\n     * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this\r\n     * NgModule Instance.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var NgModuleRef = /** @class */ (function () {\r\n        function NgModuleRef() {\r\n        }\r\n        return NgModuleRef;\r\n    }());\r\n    /**\r\n     * @publicApi\r\n     */\r\n    var NgModuleFactory = /** @class */ (function () {\r\n        function NgModuleFactory() {\r\n        }\r\n        return NgModuleFactory;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n    * Equivalent to ES6 spread, add each item to an array.\r\n    *\r\n    * @param items The items to add\r\n    * @param arr The array to which you want to add the items\r\n    */\r\n    function addAllToArray(items, arr) {\r\n        for (var i = 0; i < items.length; i++) {\r\n            arr.push(items[i]);\r\n        }\r\n    }\r\n    /**\r\n     * Flattens an array.\r\n     */\r\n    function flatten(list, dst) {\r\n        if (dst === undefined)\r\n            dst = list;\r\n        for (var i = 0; i < list.length; i++) {\r\n            var item = list[i];\r\n            if (Array.isArray(item)) {\r\n                // we need to inline it.\r\n                if (dst === list) {\r\n                    // Our assumption that the list was already flat was wrong and\r\n                    // we need to clone flat since we need to write to it.\r\n                    dst = list.slice(0, i);\r\n                }\r\n                flatten(item, dst);\r\n            }\r\n            else if (dst !== list) {\r\n                dst.push(item);\r\n            }\r\n        }\r\n        return dst;\r\n    }\r\n    function deepForEach(input, fn) {\r\n        input.forEach(function (value) { return Array.isArray(value) ? deepForEach(value, fn) : fn(value); });\r\n    }\r\n    function addToArray(arr, index, value) {\r\n        // perf: array.push is faster than array.splice!\r\n        if (index >= arr.length) {\r\n            arr.push(value);\r\n        }\r\n        else {\r\n            arr.splice(index, 0, value);\r\n        }\r\n    }\r\n    function removeFromArray(arr, index) {\r\n        // perf: array.pop is faster than array.splice!\r\n        if (index >= arr.length - 1) {\r\n            return arr.pop();\r\n        }\r\n        else {\r\n            return arr.splice(index, 1)[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function assertNumber(actual, msg) {\r\n        if (typeof actual != 'number') {\r\n            throwError(msg);\r\n        }\r\n    }\r\n    function assertEqual(actual, expected, msg) {\r\n        if (actual != expected) {\r\n            throwError(msg);\r\n        }\r\n    }\r\n    function assertNotEqual(actual, expected, msg) {\r\n        if (actual == expected) {\r\n            throwError(msg);\r\n        }\r\n    }\r\n    function assertSame(actual, expected, msg) {\r\n        if (actual !== expected) {\r\n            throwError(msg);\r\n        }\r\n    }\r\n    function assertNotSame(actual, expected, msg) {\r\n        if (actual === expected) {\r\n            throwError(msg);\r\n        }\r\n    }\r\n    function assertLessThan(actual, expected, msg) {\r\n        if (actual >= expected) {\r\n            throwError(msg);\r\n        }\r\n    }\r\n    function assertGreaterThan(actual, expected, msg) {\r\n        if (actual <= expected) {\r\n            throwError(msg);\r\n        }\r\n    }\r\n    function assertNotDefined(actual, msg) {\r\n        if (actual != null) {\r\n            throwError(msg);\r\n        }\r\n    }\r\n    function assertDefined(actual, msg) {\r\n        if (actual == null) {\r\n            throwError(msg);\r\n        }\r\n    }\r\n    function throwError(msg) {\r\n        // tslint:disable-next-line\r\n        debugger; // Left intentionally for better debugger experience.\r\n        throw new Error(\"ASSERTION ERROR: \" + msg);\r\n    }\r\n    function assertDomNode(node) {\r\n        // If we're in a worker, `Node` will not be defined.\r\n        assertEqual((typeof Node !== 'undefined' && node instanceof Node) ||\r\n            (typeof node === 'object' && node != null &&\r\n                node.constructor.name === 'WebWorkerRenderNode'), true, \"The provided value must be an instance of a DOM Node but got \" + stringify(node));\r\n    }\r\n    function assertDataInRange(arr, index) {\r\n        var maxLen = arr ? arr.length : 0;\r\n        assertLessThan(index, maxLen, \"Index expected to be less than \" + maxLen + \" but got \" + index);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function ngDevModeResetPerfCounters() {\r\n        var locationString = typeof location !== 'undefined' ? location.toString() : '';\r\n        var newCounters = {\r\n            namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,\r\n            firstTemplatePass: 0,\r\n            tNode: 0,\r\n            tView: 0,\r\n            rendererCreateTextNode: 0,\r\n            rendererSetText: 0,\r\n            rendererCreateElement: 0,\r\n            rendererAddEventListener: 0,\r\n            rendererSetAttribute: 0,\r\n            rendererRemoveAttribute: 0,\r\n            rendererSetProperty: 0,\r\n            rendererSetClassName: 0,\r\n            rendererAddClass: 0,\r\n            rendererRemoveClass: 0,\r\n            rendererSetStyle: 0,\r\n            rendererRemoveStyle: 0,\r\n            rendererDestroy: 0,\r\n            rendererDestroyNode: 0,\r\n            rendererMoveNode: 0,\r\n            rendererRemoveNode: 0,\r\n            rendererAppendChild: 0,\r\n            rendererInsertBefore: 0,\r\n            rendererCreateComment: 0,\r\n            styleMap: 0,\r\n            styleMapCacheMiss: 0,\r\n            classMap: 0,\r\n            classMapCacheMiss: 0,\r\n            styleProp: 0,\r\n            stylePropCacheMiss: 0,\r\n            classProp: 0,\r\n            classPropCacheMiss: 0,\r\n            flushStyling: 0,\r\n            classesApplied: 0,\r\n            stylesApplied: 0,\r\n            stylingWritePersistedState: 0,\r\n            stylingReadPersistedState: 0,\r\n        };\r\n        // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\r\n        var allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\r\n        _global['ngDevMode'] = allowNgDevModeTrue && newCounters;\r\n        return newCounters;\r\n    }\r\n    /**\r\n     * This checks to see if the `ngDevMode` has been set. If yes,\r\n     * then we honor it, otherwise we default to dev mode with additional checks.\r\n     *\r\n     * The idea is that unless we are doing production build where we explicitly\r\n     * set `ngDevMode == false` we should be helping the developer by providing\r\n     * as much early warning and errors as possible.\r\n     *\r\n     * NOTE: changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.\r\n     */\r\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\r\n        ngDevModeResetPerfCounters();\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    (function (ChangeDetectionStrategy) {\r\n        /**\r\n         * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\r\n         * until reactivated by setting the strategy to `Default` (`CheckAlways`).\r\n         * Change detection can still be explicitly invoked.\r\n         * This strategy applies to all child directives and cannot be overridden.\r\n         */\r\n        ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\r\n        /**\r\n         * Use the default `CheckAlways` strategy, in which change detection is automatic until\r\n         * explicitly deactivated.\r\n         */\r\n        ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\r\n    })(exports.ChangeDetectionStrategy || (exports.ChangeDetectionStrategy = {}));\r\n    (function (ChangeDetectorStatus) {\r\n        /**\r\n         * A state in which, after calling `detectChanges()`, the change detector\r\n         * state becomes `Checked`, and must be explicitly invoked or reactivated.\r\n         */\r\n        ChangeDetectorStatus[ChangeDetectorStatus[\"CheckOnce\"] = 0] = \"CheckOnce\";\r\n        /**\r\n         * A state in which change detection is skipped until the change detector mode\r\n         * becomes `CheckOnce`.\r\n         */\r\n        ChangeDetectorStatus[ChangeDetectorStatus[\"Checked\"] = 1] = \"Checked\";\r\n        /**\r\n         * A state in which change detection continues automatically until explicitly\r\n         * deactivated.\r\n         */\r\n        ChangeDetectorStatus[ChangeDetectorStatus[\"CheckAlways\"] = 2] = \"CheckAlways\";\r\n        /**\r\n         * A state in which a change detector sub tree is not a part of the main tree and\r\n         * should be skipped.\r\n         */\r\n        ChangeDetectorStatus[ChangeDetectorStatus[\"Detached\"] = 3] = \"Detached\";\r\n        /**\r\n         * Indicates that the change detector encountered an error checking a binding\r\n         * or calling a directive lifecycle method and is now in an inconsistent state. Change\r\n         * detectors in this state do not detect changes.\r\n         */\r\n        ChangeDetectorStatus[ChangeDetectorStatus[\"Errored\"] = 4] = \"Errored\";\r\n        /**\r\n         * Indicates that the change detector has been destroyed.\r\n         */\r\n        ChangeDetectorStatus[ChangeDetectorStatus[\"Destroyed\"] = 5] = \"Destroyed\";\r\n    })(exports.ɵChangeDetectorStatus || (exports.ɵChangeDetectorStatus = {}));\r\n    /**\r\n     * Reports whether a given strategy is currently the default for change detection.\r\n     * @param changeDetectionStrategy The strategy to check.\r\n     * @returns True if the given strategy is the current default, false otherwise.\r\n     * @see `ChangeDetectorStatus`\r\n     * @see `ChangeDetectorRef`\r\n     */\r\n    function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {\r\n        return changeDetectionStrategy == null ||\r\n            changeDetectionStrategy === exports.ChangeDetectionStrategy.Default;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    (function (ViewEncapsulation) {\r\n        /**\r\n         * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host\r\n         * Element and pre-processing the style rules provided via {@link Component#styles styles} or\r\n         * {@link Component#styleUrls styleUrls}, and adding the new Host Element attribute to all\r\n         * selectors.\r\n         *\r\n         * This is the default option.\r\n         */\r\n        ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\r\n        /**\r\n         * @deprecated v6.1.0 - use {ViewEncapsulation.ShadowDom} instead.\r\n         * Use the native encapsulation mechanism of the renderer.\r\n         *\r\n         * For the DOM this means using the deprecated [Shadow DOM\r\n         * v0](https://w3c.github.io/webcomponents/spec/shadow/) and\r\n         * creating a ShadowRoot for Component's Host Element.\r\n         */\r\n        ViewEncapsulation[ViewEncapsulation[\"Native\"] = 1] = \"Native\";\r\n        /**\r\n         * Don't provide any template or style encapsulation.\r\n         */\r\n        ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\r\n        /**\r\n         * Use Shadow DOM to encapsulate styles.\r\n         *\r\n         * For the DOM this means using modern [Shadow\r\n         * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and\r\n         * creating a ShadowRoot for Component's Host Element.\r\n         */\r\n        ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\r\n    })(exports.ViewEncapsulation || (exports.ViewEncapsulation = {}));\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Convince closure compiler that the wrapped function has no side-effects.\r\n     *\r\n     * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to\r\n     * allow us to execute a function but have closure compiler mark the call as no-side-effects.\r\n     * It is important that the return value for the `noSideEffects` function be assigned\r\n     * to something which is retained otherwise the call to `noSideEffects` will be removed by closure\r\n     * compiler.\r\n     */\r\n    function noSideEffects(fn) {\r\n        return '' + { toString: fn };\r\n    }\r\n\r\n    /**\r\n    * @license\r\n    * Copyright Google Inc. All Rights Reserved.\r\n    *\r\n    * Use of this source code is governed by an MIT-style license that can be\r\n    * found in the LICENSE file at https://angular.io/license\r\n    */\r\n    /**\r\n     * This file contains reuseable \"empty\" symbols that can be used as default return values\r\n     * in different parts of the rendering code. Because the same symbols are returned, this\r\n     * allows for identity checks against these values to be consistently used by the framework\r\n     * code.\r\n     */\r\n    var EMPTY_OBJ = {};\r\n    var EMPTY_ARRAY = [];\r\n    // freezing the values prevents any code from accidentally inserting new values in\r\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\r\n        // These property accesses can be ignored because ngDevMode will be set to false\r\n        // when optimizing code and the whole if statement will be dropped.\r\n        // tslint:disable-next-line:no-toplevel-property-access\r\n        Object.freeze(EMPTY_OBJ);\r\n        // tslint:disable-next-line:no-toplevel-property-access\r\n        Object.freeze(EMPTY_ARRAY);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var NG_COMPONENT_DEF = getClosureSafeProperty({ ngComponentDef: getClosureSafeProperty });\r\n    var NG_DIRECTIVE_DEF = getClosureSafeProperty({ ngDirectiveDef: getClosureSafeProperty });\r\n    var NG_PIPE_DEF = getClosureSafeProperty({ ngPipeDef: getClosureSafeProperty });\r\n    var NG_MODULE_DEF = getClosureSafeProperty({ ngModuleDef: getClosureSafeProperty });\r\n    var NG_LOCALE_ID_DEF = getClosureSafeProperty({ ngLocaleIdDef: getClosureSafeProperty });\r\n    var NG_BASE_DEF = getClosureSafeProperty({ ngBaseDef: getClosureSafeProperty });\r\n    /**\r\n     * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\r\n     * the key and the directive's unique ID as the value. This allows us to map directives to their\r\n     * bloom filter bit for DI.\r\n     */\r\n    // TODO(misko): This is wrong. The NG_ELEMENT_ID should never be minified.\r\n    var NG_ELEMENT_ID = getClosureSafeProperty({ __NG_ELEMENT_ID__: getClosureSafeProperty });\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var _renderCompCount = 0;\r\n    /**\r\n     * Create a component definition object.\r\n     *\r\n     *\r\n     * # Example\r\n     * ```\r\n     * class MyDirective {\r\n     *   // Generated by Angular Template Compiler\r\n     *   // [Symbol] syntax will not be supported by TypeScript until v2.7\r\n     *   static ngComponentDef = defineComponent({\r\n     *     ...\r\n     *   });\r\n     * }\r\n     * ```\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵdefineComponent(componentDefinition) {\r\n        var type = componentDefinition.type;\r\n        var typePrototype = type.prototype;\r\n        var declaredInputs = {};\r\n        var def = {\r\n            type: type,\r\n            providersResolver: null,\r\n            consts: componentDefinition.consts,\r\n            vars: componentDefinition.vars,\r\n            factory: componentDefinition.factory,\r\n            template: componentDefinition.template || null,\r\n            ngContentSelectors: componentDefinition.ngContentSelectors,\r\n            hostBindings: componentDefinition.hostBindings || null,\r\n            contentQueries: componentDefinition.contentQueries || null,\r\n            declaredInputs: declaredInputs,\r\n            inputs: null,\r\n            outputs: null,\r\n            exportAs: componentDefinition.exportAs || null,\r\n            onChanges: null,\r\n            onInit: typePrototype.ngOnInit || null,\r\n            doCheck: typePrototype.ngDoCheck || null,\r\n            afterContentInit: typePrototype.ngAfterContentInit || null,\r\n            afterContentChecked: typePrototype.ngAfterContentChecked || null,\r\n            afterViewInit: typePrototype.ngAfterViewInit || null,\r\n            afterViewChecked: typePrototype.ngAfterViewChecked || null,\r\n            onDestroy: typePrototype.ngOnDestroy || null,\r\n            onPush: componentDefinition.changeDetection === exports.ChangeDetectionStrategy.OnPush,\r\n            directiveDefs: null,\r\n            pipeDefs: null,\r\n            selectors: componentDefinition.selectors,\r\n            viewQuery: componentDefinition.viewQuery || null,\r\n            features: componentDefinition.features || null,\r\n            data: componentDefinition.data || {},\r\n            // TODO(misko): convert ViewEncapsulation into const enum so that it can be used directly in the\r\n            // next line. Also `None` should be 0 not 2.\r\n            encapsulation: componentDefinition.encapsulation || exports.ViewEncapsulation.Emulated,\r\n            id: 'c',\r\n            styles: componentDefinition.styles || EMPTY_ARRAY,\r\n            _: null,\r\n            setInput: null,\r\n            schemas: componentDefinition.schemas || null,\r\n            tView: null,\r\n        };\r\n        def._ = noSideEffects(function () {\r\n            var directiveTypes = componentDefinition.directives;\r\n            var feature = componentDefinition.features;\r\n            var pipeTypes = componentDefinition.pipes;\r\n            def.id += _renderCompCount++;\r\n            def.inputs = invertObject(componentDefinition.inputs, declaredInputs),\r\n                def.outputs = invertObject(componentDefinition.outputs),\r\n                feature && feature.forEach(function (fn) { return fn(def); });\r\n            def.directiveDefs = directiveTypes ?\r\n                function () { return (typeof directiveTypes === 'function' ? directiveTypes() : directiveTypes)\r\n                    .map(extractDirectiveDef); } :\r\n                null;\r\n            def.pipeDefs = pipeTypes ?\r\n                function () { return (typeof pipeTypes === 'function' ? pipeTypes() : pipeTypes).map(extractPipeDef); } :\r\n                null;\r\n            // Add ngInjectableDef so components are reachable through the module injector by default\r\n            // (unless it has already been set by the @Injectable decorator). This is mostly to\r\n            // support injecting components in tests. In real application code, components should\r\n            // be retrieved through the node injector, so this isn't a problem.\r\n            if (!type.hasOwnProperty(NG_INJECTABLE_DEF)) {\r\n                type[NG_INJECTABLE_DEF] =\r\n                    ɵɵdefineInjectable({ token: type, factory: componentDefinition.factory });\r\n            }\r\n        });\r\n        return def;\r\n    }\r\n    /**\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵsetComponentScope(type, directives, pipes) {\r\n        var def = type.ngComponentDef;\r\n        def.directiveDefs = function () { return directives.map(extractDirectiveDef); };\r\n        def.pipeDefs = function () { return pipes.map(extractPipeDef); };\r\n    }\r\n    function extractDirectiveDef(type) {\r\n        var def = getComponentDef(type) || getDirectiveDef(type);\r\n        if (ngDevMode && !def) {\r\n            throw new Error(\"'\" + type.name + \"' is neither 'ComponentType' or 'DirectiveType'.\");\r\n        }\r\n        return def;\r\n    }\r\n    function extractPipeDef(type) {\r\n        var def = getPipeDef(type);\r\n        if (ngDevMode && !def) {\r\n            throw new Error(\"'\" + type.name + \"' is not a 'PipeType'.\");\r\n        }\r\n        return def;\r\n    }\r\n    /**\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵdefineNgModule(def) {\r\n        var res = {\r\n            type: def.type,\r\n            bootstrap: def.bootstrap || EMPTY_ARRAY,\r\n            declarations: def.declarations || EMPTY_ARRAY,\r\n            imports: def.imports || EMPTY_ARRAY,\r\n            exports: def.exports || EMPTY_ARRAY,\r\n            transitiveCompileScopes: null,\r\n            schemas: def.schemas || null,\r\n            id: def.id || null,\r\n        };\r\n        return res;\r\n    }\r\n    /**\r\n     * Adds the module metadata that is necessary to compute the module's transitive scope to an\r\n     * existing module definition.\r\n     *\r\n     * Scope metadata of modules is not used in production builds, so calls to this function can be\r\n     * marked pure to tree-shake it from the bundle, allowing for all referenced declarations\r\n     * to become eligible for tree-shaking as well.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵsetNgModuleScope(type, scope) {\r\n        return noSideEffects(function () {\r\n            var ngModuleDef = getNgModuleDef(type, true);\r\n            ngModuleDef.declarations = scope.declarations || EMPTY_ARRAY;\r\n            ngModuleDef.imports = scope.imports || EMPTY_ARRAY;\r\n            ngModuleDef.exports = scope.exports || EMPTY_ARRAY;\r\n        });\r\n    }\r\n    /**\r\n     * Inverts an inputs or outputs lookup such that the keys, which were the\r\n     * minified keys, are part of the values, and the values are parsed so that\r\n     * the publicName of the property is the new key\r\n     *\r\n     * e.g. for\r\n     *\r\n     * ```\r\n     * class Comp {\r\n     *   @Input()\r\n     *   propName1: string;\r\n     *\r\n     *   @Input('publicName2')\r\n     *   declaredPropName2: number;\r\n     * }\r\n     * ```\r\n     *\r\n     * will be serialized as\r\n     *\r\n     * ```\r\n     * {\r\n     *   propName1: 'propName1',\r\n     *   declaredPropName2: ['publicName2', 'declaredPropName2'],\r\n     * }\r\n     * ```\r\n     *\r\n     * which is than translated by the minifier as:\r\n     *\r\n     * ```\r\n     * {\r\n     *   minifiedPropName1: 'propName1',\r\n     *   minifiedPropName2: ['publicName2', 'declaredPropName2'],\r\n     * }\r\n     * ```\r\n     *\r\n     * becomes: (public name => minifiedName)\r\n     *\r\n     * ```\r\n     * {\r\n     *  'propName1': 'minifiedPropName1',\r\n     *  'publicName2': 'minifiedPropName2',\r\n     * }\r\n     * ```\r\n     *\r\n     * Optionally the function can take `secondary` which will result in: (public name => declared name)\r\n     *\r\n     * ```\r\n     * {\r\n     *  'propName1': 'propName1',\r\n     *  'publicName2': 'declaredPropName2',\r\n     * }\r\n     * ```\r\n     *\r\n\r\n     */\r\n    function invertObject(obj, secondary) {\r\n        if (obj == null)\r\n            return EMPTY_OBJ;\r\n        var newLookup = {};\r\n        for (var minifiedKey in obj) {\r\n            if (obj.hasOwnProperty(minifiedKey)) {\r\n                var publicName = obj[minifiedKey];\r\n                var declaredName = publicName;\r\n                if (Array.isArray(publicName)) {\r\n                    declaredName = publicName[1];\r\n                    publicName = publicName[0];\r\n                }\r\n                newLookup[publicName] = minifiedKey;\r\n                if (secondary) {\r\n                    (secondary[publicName] = declaredName);\r\n                }\r\n            }\r\n        }\r\n        return newLookup;\r\n    }\r\n    /**\r\n     * Create a base definition\r\n     *\r\n     * # Example\r\n     * ```ts\r\n     * class ShouldBeInherited {\r\n     *   static ngBaseDef = ɵɵdefineBase({\r\n     *      ...\r\n     *   })\r\n     * }\r\n     * ```\r\n     *\r\n     * @param baseDefinition The base definition parameters\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵdefineBase(baseDefinition) {\r\n        var declaredInputs = {};\r\n        return {\r\n            inputs: invertObject(baseDefinition.inputs, declaredInputs),\r\n            declaredInputs: declaredInputs,\r\n            outputs: invertObject(baseDefinition.outputs),\r\n            viewQuery: baseDefinition.viewQuery || null,\r\n            contentQueries: baseDefinition.contentQueries || null,\r\n            hostBindings: baseDefinition.hostBindings || null\r\n        };\r\n    }\r\n    /**\r\n     * Create a directive definition object.\r\n     *\r\n     * # Example\r\n     * ```ts\r\n     * class MyDirective {\r\n     *   // Generated by Angular Template Compiler\r\n     *   // [Symbol] syntax will not be supported by TypeScript until v2.7\r\n     *   static ngDirectiveDef = ɵɵdefineDirective({\r\n     *     ...\r\n     *   });\r\n     * }\r\n     * ```\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    var ɵɵdefineDirective = ɵɵdefineComponent;\r\n    /**\r\n     * Create a pipe definition object.\r\n     *\r\n     * # Example\r\n     * ```\r\n     * class MyPipe implements PipeTransform {\r\n     *   // Generated by Angular Template Compiler\r\n     *   static ngPipeDef = definePipe({\r\n     *     ...\r\n     *   });\r\n     * }\r\n     * ```\r\n     * @param pipeDef Pipe definition generated by the compiler\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵdefinePipe(pipeDef) {\r\n        return {\r\n            name: pipeDef.name,\r\n            factory: pipeDef.factory,\r\n            pure: pipeDef.pure !== false,\r\n            onDestroy: pipeDef.type.prototype.ngOnDestroy || null\r\n        };\r\n    }\r\n    /**\r\n     * The following getter methods retrieve the definition form the type. Currently the retrieval\r\n     * honors inheritance, but in the future we may change the rule to require that definitions are\r\n     * explicit. This would require some sort of migration strategy.\r\n     */\r\n    function getComponentDef(type) {\r\n        return type[NG_COMPONENT_DEF] || null;\r\n    }\r\n    function getDirectiveDef(type) {\r\n        return type[NG_DIRECTIVE_DEF] || null;\r\n    }\r\n    function getPipeDef(type) {\r\n        return type[NG_PIPE_DEF] || null;\r\n    }\r\n    function getBaseDef(type) {\r\n        return type[NG_BASE_DEF] || null;\r\n    }\r\n    function getNgModuleDef(type, throwNotFound) {\r\n        var ngModuleDef = type[NG_MODULE_DEF] || null;\r\n        if (!ngModuleDef && throwNotFound === true) {\r\n            throw new Error(\"Type \" + stringify(type) + \" does not have 'ngModuleDef' property.\");\r\n        }\r\n        return ngModuleDef;\r\n    }\r\n    function getNgLocaleIdDef(type) {\r\n        return type[NG_LOCALE_ID_DEF] || null;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    // Below are constants for LView indices to help us look up LView members\r\n    // without having to remember the specific indices.\r\n    // Uglify will inline these when minifying so there shouldn't be a cost.\r\n    var HOST = 0;\r\n    var TVIEW = 1;\r\n    var FLAGS = 2;\r\n    var PARENT = 3;\r\n    var NEXT = 4;\r\n    var QUERIES = 5;\r\n    var T_HOST = 6;\r\n    var BINDING_INDEX = 7;\r\n    var CLEANUP = 8;\r\n    var CONTEXT = 9;\r\n    var INJECTOR$1 = 10;\r\n    var RENDERER_FACTORY = 11;\r\n    var RENDERER = 12;\r\n    var SANITIZER = 13;\r\n    var CHILD_HEAD = 14;\r\n    var CHILD_TAIL = 15;\r\n    var DECLARATION_VIEW = 16;\r\n    var DECLARATION_LCONTAINER = 17;\r\n    var PREORDER_HOOK_FLAGS = 18;\r\n    /** Size of LView's header. Necessary to adjust for it when setting slots.  */\r\n    var HEADER_OFFSET = 19;\r\n    // Note: This hack is necessary so we don't erroneously get a circular dependency\r\n    // failure based on types.\r\n    var unusedValueExportToPlacateAjd = 1;\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Special location which allows easy identification of type. If we have an array which was\r\n     * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is\r\n     * `LContainer`.\r\n     */\r\n    var TYPE = 1;\r\n    /**\r\n     * Below are constants for LContainer indices to help us look up LContainer members\r\n     * without having to remember the specific indices.\r\n     * Uglify will inline these when minifying so there shouldn't be a cost.\r\n     */\r\n    var ACTIVE_INDEX = 2;\r\n    // PARENT and NEXT are indices 3 and 4\r\n    // As we already have these constants in LView, we don't need to re-create them.\r\n    var MOVED_VIEWS = 5;\r\n    // T_HOST is index 6\r\n    // We already have this constants in LView, we don't need to re-create it.\r\n    var NATIVE = 7;\r\n    var VIEW_REFS = 8;\r\n    /**\r\n     * Size of LContainer's header. Represents the index after which all views in the\r\n     * container will be inserted. We need to keep a record of current views so we know\r\n     * which views are already in the DOM (and don't need to be re-added) and so we can\r\n     * remove views from the DOM when they are no longer required.\r\n     */\r\n    var CONTAINER_HEADER_OFFSET = 9;\r\n    // Note: This hack is necessary so we don't erroneously get a circular dependency\r\n    // failure based on types.\r\n    var unusedValueExportToPlacateAjd$1 = 1;\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n    * True if `value` is `LView`.\r\n    * @param value wrapped value of `RNode`, `LView`, `LContainer`\r\n    */\r\n    function isLView(value) {\r\n        return Array.isArray(value) && typeof value[TYPE] === 'object';\r\n    }\r\n    /**\r\n     * True if `value` is `LContainer`.\r\n     * @param value wrapped value of `RNode`, `LView`, `LContainer`\r\n     */\r\n    function isLContainer(value) {\r\n        return Array.isArray(value) && value[TYPE] === true;\r\n    }\r\n    function isContentQueryHost(tNode) {\r\n        return (tNode.flags & 4 /* hasContentQuery */) !== 0;\r\n    }\r\n    function isComponent(tNode) {\r\n        return (tNode.flags & 1 /* isComponent */) === 1 /* isComponent */;\r\n    }\r\n    function isComponentDef(def) {\r\n        return def.template !== null;\r\n    }\r\n    function isRootView(target) {\r\n        return (target[FLAGS] & 512 /* IsRoot */) !== 0;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function assertTNodeForLView(tNode, lView) {\r\n        tNode.hasOwnProperty('tView_') && assertEqual(tNode.tView_, lView[TVIEW], 'This TNode does not belong to this LView.');\r\n    }\r\n    function assertComponentType(actual, msg) {\r\n        if (msg === void 0) { msg = 'Type passed in is not ComponentType, it does not have \\'ngComponentDef\\' property.'; }\r\n        if (!getComponentDef(actual)) {\r\n            throwError(msg);\r\n        }\r\n    }\r\n    function assertNgModuleType(actual, msg) {\r\n        if (msg === void 0) { msg = 'Type passed in is not NgModuleType, it does not have \\'ngModuleDef\\' property.'; }\r\n        if (!getNgModuleDef(actual)) {\r\n            throwError(msg);\r\n        }\r\n    }\r\n    function assertPreviousIsParent(isParent) {\r\n        assertEqual(isParent, true, 'previousOrParentTNode should be a parent');\r\n    }\r\n    function assertHasParent(tNode) {\r\n        assertDefined(tNode, 'previousOrParentTNode should exist!');\r\n        assertDefined(tNode.parent, 'previousOrParentTNode should have a parent');\r\n    }\r\n    function assertDataNext(lView, index, arr) {\r\n        if (arr == null)\r\n            arr = lView;\r\n        assertEqual(arr.length, index, \"index \" + index + \" expected to be at the end of arr (length \" + arr.length + \")\");\r\n    }\r\n    function assertLContainerOrUndefined(value) {\r\n        value && assertEqual(isLContainer(value), true, 'Expecting LContainer or undefined or null');\r\n    }\r\n    function assertLContainer(value) {\r\n        assertDefined(value, 'LContainer must be defined');\r\n        assertEqual(isLContainer(value), true, 'Expecting LContainer');\r\n    }\r\n    function assertLViewOrUndefined(value) {\r\n        value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');\r\n    }\r\n    function assertLView(value) {\r\n        assertDefined(value, 'LView must be defined');\r\n        assertEqual(isLView(value), true, 'Expecting LView');\r\n    }\r\n    function assertFirstTemplatePass(tView, errMessage) {\r\n        assertEqual(tView.firstTemplatePass, true, errMessage);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var TNODE = 8;\r\n    var PARENT_INJECTOR = 8;\r\n    var INJECTOR_BLOOM_PARENT_SIZE = 9;\r\n    var NO_PARENT_INJECTOR = -1;\r\n    /**\r\n     * Each injector is saved in 9 contiguous slots in `LView` and 9 contiguous slots in\r\n     * `TView.data`. This allows us to store information about the current node's tokens (which\r\n     * can be shared in `TView`) as well as the tokens of its ancestor nodes (which cannot be\r\n     * shared, so they live in `LView`).\r\n     *\r\n     * Each of these slots (aside from the last slot) contains a bloom filter. This bloom filter\r\n     * determines whether a directive is available on the associated node or not. This prevents us\r\n     * from searching the directives array at this level unless it's probable the directive is in it.\r\n     *\r\n     * See: https://en.wikipedia.org/wiki/Bloom_filter for more about bloom filters.\r\n     *\r\n     * Because all injectors have been flattened into `LView` and `TViewData`, they cannot typed\r\n     * using interfaces as they were previously. The start index of each `LInjector` and `TInjector`\r\n     * will differ based on where it is flattened into the main array, so it's not possible to know\r\n     * the indices ahead of time and save their types here. The interfaces are still included here\r\n     * for documentation purposes.\r\n     *\r\n     * export interface LInjector extends Array<any> {\r\n     *\r\n     *    // Cumulative bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\r\n     *    [0]: number;\r\n     *\r\n     *    // Cumulative bloom for directive IDs 32-63\r\n     *    [1]: number;\r\n     *\r\n     *    // Cumulative bloom for directive IDs 64-95\r\n     *    [2]: number;\r\n     *\r\n     *    // Cumulative bloom for directive IDs 96-127\r\n     *    [3]: number;\r\n     *\r\n     *    // Cumulative bloom for directive IDs 128-159\r\n     *    [4]: number;\r\n     *\r\n     *    // Cumulative bloom for directive IDs 160 - 191\r\n     *    [5]: number;\r\n     *\r\n     *    // Cumulative bloom for directive IDs 192 - 223\r\n     *    [6]: number;\r\n     *\r\n     *    // Cumulative bloom for directive IDs 224 - 255\r\n     *    [7]: number;\r\n     *\r\n     *    // We need to store a reference to the injector's parent so DI can keep looking up\r\n     *    // the injector tree until it finds the dependency it's looking for.\r\n     *    [PARENT_INJECTOR]: number;\r\n     * }\r\n     *\r\n     * export interface TInjector extends Array<any> {\r\n     *\r\n     *    // Shared node bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\r\n     *    [0]: number;\r\n     *\r\n     *    // Shared node bloom for directive IDs 32-63\r\n     *    [1]: number;\r\n     *\r\n     *    // Shared node bloom for directive IDs 64-95\r\n     *    [2]: number;\r\n     *\r\n     *    // Shared node bloom for directive IDs 96-127\r\n     *    [3]: number;\r\n     *\r\n     *    // Shared node bloom for directive IDs 128-159\r\n     *    [4]: number;\r\n     *\r\n     *    // Shared node bloom for directive IDs 160 - 191\r\n     *    [5]: number;\r\n     *\r\n     *    // Shared node bloom for directive IDs 192 - 223\r\n     *    [6]: number;\r\n     *\r\n     *    // Shared node bloom for directive IDs 224 - 255\r\n     *    [7]: number;\r\n     *\r\n     *    // Necessary to find directive indices for a particular node.\r\n     *    [TNODE]: TElementNode|TElementContainerNode|TContainerNode;\r\n     *  }\r\n     */\r\n    /**\r\n    * Factory for creating instances of injectors in the NodeInjector.\r\n    *\r\n    * This factory is complicated by the fact that it can resolve `multi` factories as well.\r\n    *\r\n    * NOTE: Some of the fields are optional which means that this class has two hidden classes.\r\n    * - One without `multi` support (most common)\r\n    * - One with `multi` values, (rare).\r\n    *\r\n    * Since VMs can cache up to 4 inline hidden classes this is OK.\r\n    *\r\n    * - Single factory: Only `resolving` and `factory` is defined.\r\n    * - `providers` factory: `componentProviders` is a number and `index = -1`.\r\n    * - `viewProviders` factory: `componentProviders` is a number and `index` points to `providers`.\r\n    */\r\n    var NodeInjectorFactory = /** @class */ (function () {\r\n        function NodeInjectorFactory(\r\n        /**\r\n         * Factory to invoke in order to create a new instance.\r\n         */\r\n        factory, \r\n        /**\r\n         * Set to `true` if the token is declared in `viewProviders` (or if it is component).\r\n         */\r\n        isViewProvider, injectImplementation) {\r\n            this.factory = factory;\r\n            /**\r\n             * Marker set to true during factory invocation to see if we get into recursive loop.\r\n             * Recursive loop causes an error to be displayed.\r\n             */\r\n            this.resolving = false;\r\n            this.canSeeViewProviders = isViewProvider;\r\n            this.injectImpl = injectImplementation;\r\n        }\r\n        return NodeInjectorFactory;\r\n    }());\r\n    function isFactory(obj) {\r\n        // See: https://jsperf.com/instanceof-vs-getprototypeof\r\n        return obj !== null && typeof obj == 'object' &&\r\n            Object.getPrototypeOf(obj) == NodeInjectorFactory.prototype;\r\n    }\r\n    // Note: This hack is necessary so we don't erroneously get a circular dependency\r\n    // failure based on types.\r\n    var unusedValueExportToPlacateAjd$2 = 1;\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function assertNodeType(tNode, type) {\r\n        assertDefined(tNode, 'should be called with a TNode');\r\n        assertEqual(tNode.type, type, \"should be a \" + typeName(type));\r\n    }\r\n    function assertNodeOfPossibleTypes(tNode) {\r\n        var types = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            types[_i - 1] = arguments[_i];\r\n        }\r\n        assertDefined(tNode, 'should be called with a TNode');\r\n        var found = types.some(function (type) { return tNode.type === type; });\r\n        assertEqual(found, true, \"Should be one of \" + types.map(typeName).join(', ') + \" but got \" + typeName(tNode.type));\r\n    }\r\n    function typeName(type) {\r\n        if (type == 1 /* Projection */)\r\n            return 'Projection';\r\n        if (type == 0 /* Container */)\r\n            return 'Container';\r\n        if (type == 2 /* View */)\r\n            return 'View';\r\n        if (type == 3 /* Element */)\r\n            return 'Element';\r\n        if (type == 4 /* ElementContainer */)\r\n            return 'ElementContainer';\r\n        return '<unknown>';\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Adds all directive lifecycle hooks from the given `DirectiveDef` to the given `TView`.\r\n     *\r\n     * Must be run *only* on the first template pass.\r\n     *\r\n     * Sets up the pre-order hooks on the provided `tView`,\r\n     * see {@link HookData} for details about the data structure.\r\n     *\r\n     * @param directiveIndex The index of the directive in LView\r\n     * @param directiveDef The definition containing the hooks to setup in tView\r\n     * @param tView The current TView\r\n     * @param nodeIndex The index of the node to which the directive is attached\r\n     * @param initialPreOrderHooksLength the number of pre-order hooks already registered before the\r\n     * current process, used to know if the node index has to be added to the array. If it is -1,\r\n     * the node index is never added.\r\n     * @param initialPreOrderCheckHooksLength same as previous for pre-order check hooks\r\n     */\r\n    function registerPreOrderHooks(directiveIndex, directiveDef, tView, nodeIndex, initialPreOrderHooksLength, initialPreOrderCheckHooksLength) {\r\n        ngDevMode &&\r\n            assertEqual(tView.firstTemplatePass, true, 'Should only be called on first template pass');\r\n        var onChanges = directiveDef.onChanges, onInit = directiveDef.onInit, doCheck = directiveDef.doCheck;\r\n        if (initialPreOrderHooksLength >= 0 &&\r\n            (!tView.preOrderHooks || initialPreOrderHooksLength === tView.preOrderHooks.length) &&\r\n            (onChanges || onInit || doCheck)) {\r\n            (tView.preOrderHooks || (tView.preOrderHooks = [])).push(nodeIndex);\r\n        }\r\n        if (initialPreOrderCheckHooksLength >= 0 &&\r\n            (!tView.preOrderCheckHooks ||\r\n                initialPreOrderCheckHooksLength === tView.preOrderCheckHooks.length) &&\r\n            (onChanges || doCheck)) {\r\n            (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(nodeIndex);\r\n        }\r\n        if (onChanges) {\r\n            (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, onChanges);\r\n            (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, onChanges);\r\n        }\r\n        if (onInit) {\r\n            (tView.preOrderHooks || (tView.preOrderHooks = [])).push(-directiveIndex, onInit);\r\n        }\r\n        if (doCheck) {\r\n            (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, doCheck);\r\n            (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, doCheck);\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * Loops through the directives on the provided `tNode` and queues hooks to be\r\n     * run that are not initialization hooks.\r\n     *\r\n     * Should be executed during `elementEnd()` and similar to\r\n     * preserve hook execution order. Content, view, and destroy hooks for projected\r\n     * components and directives must be called *before* their hosts.\r\n     *\r\n     * Sets up the content, view, and destroy hooks on the provided `tView`,\r\n     * see {@link HookData} for details about the data structure.\r\n     *\r\n     * NOTE: This does not set up `onChanges`, `onInit` or `doCheck`, those are set up\r\n     * separately at `elementStart`.\r\n     *\r\n     * @param tView The current TView\r\n     * @param tNode The TNode whose directives are to be searched for hooks to queue\r\n     */\r\n    function registerPostOrderHooks(tView, tNode) {\r\n        if (tView.firstTemplatePass) {\r\n            // It's necessary to loop through the directives at elementEnd() (rather than processing in\r\n            // directiveCreate) so we can preserve the current hook order. Content, view, and destroy\r\n            // hooks for projected components and directives must be called *before* their hosts.\r\n            for (var i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {\r\n                var directiveDef = tView.data[i];\r\n                if (directiveDef.afterContentInit) {\r\n                    (tView.contentHooks || (tView.contentHooks = [])).push(-i, directiveDef.afterContentInit);\r\n                }\r\n                if (directiveDef.afterContentChecked) {\r\n                    (tView.contentHooks || (tView.contentHooks = [])).push(i, directiveDef.afterContentChecked);\r\n                    (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, directiveDef.afterContentChecked);\r\n                }\r\n                if (directiveDef.afterViewInit) {\r\n                    (tView.viewHooks || (tView.viewHooks = [])).push(-i, directiveDef.afterViewInit);\r\n                }\r\n                if (directiveDef.afterViewChecked) {\r\n                    (tView.viewHooks || (tView.viewHooks = [])).push(i, directiveDef.afterViewChecked);\r\n                    (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, directiveDef.afterViewChecked);\r\n                }\r\n                if (directiveDef.onDestroy != null) {\r\n                    (tView.destroyHooks || (tView.destroyHooks = [])).push(i, directiveDef.onDestroy);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Executing hooks requires complex logic as we need to deal with 2 constraints.\r\n     *\r\n     * 1. Init hooks (ngOnInit, ngAfterContentInit, ngAfterViewInit) must all be executed once and only\r\n     * once, across many change detection cycles. This must be true even if some hooks throw, or if\r\n     * some recursively trigger a change detection cycle.\r\n     * To solve that, it is required to track the state of the execution of these init hooks.\r\n     * This is done by storing and maintaining flags in the view: the {@link InitPhaseState},\r\n     * and the index within that phase. They can be seen as a cursor in the following structure:\r\n     * [[onInit1, onInit2], [afterContentInit1], [afterViewInit1, afterViewInit2, afterViewInit3]]\r\n     * They are are stored as flags in LView[FLAGS].\r\n     *\r\n     * 2. Pre-order hooks can be executed in batches, because of the select instruction.\r\n     * To be able to pause and resume their execution, we also need some state about the hook's array\r\n     * that is being processed:\r\n     * - the index of the next hook to be executed\r\n     * - the number of init hooks already found in the processed part of the  array\r\n     * They are are stored as flags in LView[PREORDER_HOOK_FLAGS].\r\n     */\r\n    /**\r\n     * Executes necessary hooks at the start of executing a template.\r\n     *\r\n     * Executes hooks that are to be run during the initialization of a directive such\r\n     * as `onChanges`, `onInit`, and `doCheck`.\r\n     *\r\n     * @param lView The current view\r\n     * @param tView Static data for the view containing the hooks to be executed\r\n     * @param checkNoChangesMode Whether or not we're in checkNoChanges mode.\r\n     * @param @param currentNodeIndex 2 cases depending the the value:\r\n     * - undefined: execute hooks only from the saved index until the end of the array (pre-order case,\r\n     * when flushing the remaining hooks)\r\n     * - number: execute hooks only from the saved index until that node index exclusive (pre-order\r\n     * case, when executing select(number))\r\n     */\r\n    function executePreOrderHooks(currentView, tView, checkNoChangesMode, currentNodeIndex) {\r\n        if (!checkNoChangesMode) {\r\n            executeHooks(currentView, tView.preOrderHooks, tView.preOrderCheckHooks, checkNoChangesMode, 0 /* OnInitHooksToBeRun */, currentNodeIndex !== undefined ? currentNodeIndex : null);\r\n        }\r\n    }\r\n    /**\r\n     * Executes hooks against the given `LView` based off of whether or not\r\n     * This is the first pass.\r\n     *\r\n     * @param currentView The view instance data to run the hooks against\r\n     * @param firstPassHooks An array of hooks to run if we're in the first view pass\r\n     * @param checkHooks An Array of hooks to run if we're not in the first view pass.\r\n     * @param checkNoChangesMode Whether or not we're in no changes mode.\r\n     * @param initPhaseState the current state of the init phase\r\n     * @param currentNodeIndex 3 cases depending the the value:\r\n     * - undefined: all hooks from the array should be executed (post-order case)\r\n     * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\r\n     * flushing the remaining hooks)\r\n     * - number: execute hooks only from the saved index until that node index exclusive (pre-order\r\n     * case, when executing select(number))\r\n     */\r\n    function executeHooks(currentView, firstPassHooks, checkHooks, checkNoChangesMode, initPhaseState, currentNodeIndex) {\r\n        if (checkNoChangesMode)\r\n            return;\r\n        var hooksToCall = (currentView[FLAGS] & 3 /* InitPhaseStateMask */) === initPhaseState ?\r\n            firstPassHooks :\r\n            checkHooks;\r\n        if (hooksToCall) {\r\n            callHooks(currentView, hooksToCall, initPhaseState, currentNodeIndex);\r\n        }\r\n        // The init phase state must be always checked here as it may have been recursively updated\r\n        if (currentNodeIndex == null &&\r\n            (currentView[FLAGS] & 3 /* InitPhaseStateMask */) === initPhaseState &&\r\n            initPhaseState !== 3 /* InitPhaseCompleted */) {\r\n            currentView[FLAGS] &= 1023 /* IndexWithinInitPhaseReset */;\r\n            currentView[FLAGS] += 1 /* InitPhaseStateIncrementer */;\r\n        }\r\n    }\r\n    /**\r\n     * Calls lifecycle hooks with their contexts, skipping init hooks if it's not\r\n     * the first LView pass\r\n     *\r\n     * @param currentView The current view\r\n     * @param arr The array in which the hooks are found\r\n     * @param initPhaseState the current state of the init phase\r\n     * @param currentNodeIndex 3 cases depending the the value:\r\n     * - undefined: all hooks from the array should be executed (post-order case)\r\n     * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\r\n     * flushing the remaining hooks)\r\n     * - number: execute hooks only from the saved index until that node index exclusive (pre-order\r\n     * case, when executing select(number))\r\n     */\r\n    function callHooks(currentView, arr, initPhase, currentNodeIndex) {\r\n        var startIndex = currentNodeIndex !== undefined ?\r\n            (currentView[PREORDER_HOOK_FLAGS] & 65535 /* IndexOfTheNextPreOrderHookMaskMask */) :\r\n            0;\r\n        var nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;\r\n        var lastNodeIndexFound = 0;\r\n        for (var i = startIndex; i < arr.length; i++) {\r\n            var hook = arr[i + 1];\r\n            if (typeof hook === 'number') {\r\n                lastNodeIndexFound = arr[i];\r\n                if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                var isInitHook = arr[i] < 0;\r\n                if (isInitHook)\r\n                    currentView[PREORDER_HOOK_FLAGS] += 65536 /* NumberOfInitHooksCalledIncrementer */;\r\n                if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {\r\n                    callHook(currentView, initPhase, arr, i);\r\n                    currentView[PREORDER_HOOK_FLAGS] =\r\n                        (currentView[PREORDER_HOOK_FLAGS] & 4294901760 /* NumberOfInitHooksCalledMask */) + i +\r\n                            2;\r\n                }\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Execute one hook against the current `LView`.\r\n     *\r\n     * @param currentView The current view\r\n     * @param initPhaseState the current state of the init phase\r\n     * @param arr The array in which the hooks are found\r\n     * @param i The current index within the hook data array\r\n     */\r\n    function callHook(currentView, initPhase, arr, i) {\r\n        var isInitHook = arr[i] < 0;\r\n        var hook = arr[i + 1];\r\n        var directiveIndex = isInitHook ? -arr[i] : arr[i];\r\n        var directive = currentView[directiveIndex];\r\n        if (isInitHook) {\r\n            var indexWithintInitPhase = currentView[FLAGS] >> 10 /* IndexWithinInitPhaseShift */;\r\n            // The init phase state must be always checked here as it may have been recursively\r\n            // updated\r\n            if (indexWithintInitPhase <\r\n                (currentView[PREORDER_HOOK_FLAGS] >> 16 /* NumberOfInitHooksCalledShift */) &&\r\n                (currentView[FLAGS] & 3 /* InitPhaseStateMask */) === initPhase) {\r\n                currentView[FLAGS] += 1024 /* IndexWithinInitPhaseIncrementer */;\r\n                hook.call(directive);\r\n            }\r\n        }\r\n        else {\r\n            hook.call(directive);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @license\r\n    * Copyright Google Inc. All Rights Reserved.\r\n    *\r\n    * Use of this source code is governed by an MIT-style license that can be\r\n    * found in the LICENSE file at https://angular.io/license\r\n    */\r\n    /**\r\n     * --------\r\n     *\r\n     * // TODO(matsko): add updateMask info\r\n     *\r\n     * This file contains all state-based logic for styling in Angular.\r\n     *\r\n     * Styling in Angular is evaluated with a series of styling-specific\r\n     * template instructions which are called one after another each time\r\n     * change detection occurs in Angular.\r\n     *\r\n     * Styling makes use of various temporary, state-based variables between\r\n     * instructions so that it can better cache and optimize its values.\r\n     * These values are usually populated and cleared when an element is\r\n     * exited in change detection (once all the instructions are run for\r\n     * that element).\r\n     *\r\n     * There are, however, situations where the state-based values\r\n     * need to be stored and used at a later point. This ONLY occurs when\r\n     * there are template-level as well as host-binding-level styling\r\n     * instructions on the same element. The example below shows exactly\r\n     * what could be:\r\n     *\r\n     * ```html\r\n     * <!-- two sources of styling: the template and the directive -->\r\n     * <div [style.width]=\"width\" dir-that-sets-height></div>\r\n     * ```\r\n     *\r\n     * If and when this situation occurs, the current styling state is\r\n     * stored in a storage map value and then later accessed once the\r\n     * host bindings are evaluated. Once styling for the current element\r\n     * is over then the map entry will be cleared.\r\n     *\r\n     * To learn more about the algorithm see `TStylingContext`.\r\n     *\r\n     * --------\r\n     */\r\n    var _stylingState = null;\r\n    var _stateStorage = new Map();\r\n    // this value is not used outside this file and is only here\r\n    // as a caching check for when the element changes.\r\n    var _stylingElement = null;\r\n    var STYLING_INDEX_START_VALUE = 1;\r\n    var BIT_MASK_START_VALUE = 0;\r\n    function getStylingState(element, readFromMap) {\r\n        if (!_stylingElement || element !== _stylingElement) {\r\n            _stylingElement = element;\r\n            if (readFromMap) {\r\n                _stylingState = _stateStorage.get(element) || null;\r\n                ngDevMode && ngDevMode.stylingReadPersistedState++;\r\n            }\r\n            _stylingState = _stylingState || {\r\n                classesBitMask: BIT_MASK_START_VALUE,\r\n                classesIndex: STYLING_INDEX_START_VALUE,\r\n                stylesBitMask: BIT_MASK_START_VALUE,\r\n                stylesIndex: STYLING_INDEX_START_VALUE,\r\n            };\r\n        }\r\n        return _stylingState;\r\n    }\r\n    function resetStylingState() {\r\n        _stylingState = null;\r\n        _stylingElement = null;\r\n    }\r\n    function storeStylingState(element, state) {\r\n        ngDevMode && ngDevMode.stylingWritePersistedState++;\r\n        _stateStorage.set(element, state);\r\n    }\r\n    function deleteStylingStateFromStorage(element) {\r\n        _stateStorage.delete(element);\r\n    }\r\n    function resetAllStylingState() {\r\n        resetStylingState();\r\n        _stateStorage.clear();\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * This property will be monkey-patched on elements, components and directives\r\n     */\r\n    var MONKEY_PATCH_KEY_NAME = '__ngContext__';\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * For efficiency reasons we often put several different data types (`RNode`, `LView`, `LContainer`)\r\n     * in same location in `LView`. This is because we don't want to pre-allocate space for it\r\n     * because the storage is sparse. This file contains utilities for dealing with such data types.\r\n     *\r\n     * How do we know what is stored at a given location in `LView`.\r\n     * - `Array.isArray(value) === false` => `RNode` (The normal storage value)\r\n     * - `Array.isArray(value) === true` => then the `value[0]` represents the wrapped value.\r\n     *   - `typeof value[TYPE] === 'object'` => `LView`\r\n     *      - This happens when we have a component at a given location\r\n     *   - `typeof value[TYPE] === true` => `LContainer`\r\n     *      - This happens when we have `LContainer` binding at a given location.\r\n     *\r\n     *\r\n     * NOTE: it is assumed that `Array.isArray` and `typeof` operations are very efficient.\r\n     */\r\n    /**\r\n     * Returns `RNode`.\r\n     * @param value wrapped value of `RNode`, `LView`, `LContainer`\r\n     */\r\n    function unwrapRNode(value) {\r\n        while (Array.isArray(value)) {\r\n            value = value[HOST];\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n     * Returns `LView` or `null` if not found.\r\n     * @param value wrapped value of `RNode`, `LView`, `LContainer`\r\n     */\r\n    function unwrapLView(value) {\r\n        while (Array.isArray(value)) {\r\n            // This check is same as `isLView()` but we don't call at as we don't want to call\r\n            // `Array.isArray()` twice and give JITer more work for inlining.\r\n            if (typeof value[TYPE] === 'object')\r\n                return value;\r\n            value = value[HOST];\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Returns `LContainer` or `null` if not found.\r\n     * @param value wrapped value of `RNode`, `LView`, `LContainer`\r\n     */\r\n    function unwrapLContainer(value) {\r\n        while (Array.isArray(value)) {\r\n            // This check is same as `isLContainer()` but we don't call at as we don't want to call\r\n            // `Array.isArray()` twice and give JITer more work for inlining.\r\n            if (value[TYPE] === true)\r\n                return value;\r\n            value = value[HOST];\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Retrieves an element value from the provided `viewData`, by unwrapping\r\n     * from any containers, component views, or style contexts.\r\n     */\r\n    function getNativeByIndex(index, lView) {\r\n        return unwrapRNode(lView[index + HEADER_OFFSET]);\r\n    }\r\n    /**\r\n     * Retrieve an `RNode` for a given `TNode` and `LView`.\r\n     *\r\n     * This function guarantees in dev mode to retrieve a non-null `RNode`.\r\n     *\r\n     * @param tNode\r\n     * @param lView\r\n     */\r\n    function getNativeByTNode(tNode, lView) {\r\n        ngDevMode && assertTNodeForLView(tNode, lView);\r\n        ngDevMode && assertDataInRange(lView, tNode.index);\r\n        var node = unwrapRNode(lView[tNode.index]);\r\n        ngDevMode && assertDomNode(node);\r\n        return node;\r\n    }\r\n    /**\r\n     * Retrieve an `RNode` or `null` for a given `TNode` and `LView`.\r\n     *\r\n     * Some `TNode`s don't have associated `RNode`s. For example `Projection`\r\n     *\r\n     * @param tNode\r\n     * @param lView\r\n     */\r\n    function getNativeByTNodeOrNull(tNode, lView) {\r\n        ngDevMode && assertTNodeForLView(tNode, lView);\r\n        var index = tNode.index;\r\n        var node = index == -1 ? null : unwrapRNode(lView[index]);\r\n        ngDevMode && node !== null && assertDomNode(node);\r\n        return node;\r\n    }\r\n    /**\r\n     * A helper function that returns `true` if a given `TNode` has any matching directives.\r\n     */\r\n    function hasDirectives(tNode) {\r\n        return tNode.directiveEnd > tNode.directiveStart;\r\n    }\r\n    function getTNode(index, view) {\r\n        ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\r\n        ngDevMode && assertLessThan(index, view[TVIEW].data.length, 'wrong index for TNode');\r\n        return view[TVIEW].data[index + HEADER_OFFSET];\r\n    }\r\n    /** Retrieves a value from any `LView` or `TData`. */\r\n    function loadInternal(view, index) {\r\n        ngDevMode && assertDataInRange(view, index + HEADER_OFFSET);\r\n        return view[index + HEADER_OFFSET];\r\n    }\r\n    function getComponentViewByIndex(nodeIndex, hostView) {\r\n        // Could be an LView or an LContainer. If LContainer, unwrap to find LView.\r\n        var slotValue = hostView[nodeIndex];\r\n        var lView = isLView(slotValue) ? slotValue : slotValue[HOST];\r\n        return lView;\r\n    }\r\n    /**\r\n     * Returns the monkey-patch value data present on the target (which could be\r\n     * a component, directive or a DOM node).\r\n     */\r\n    function readPatchedData(target) {\r\n        ngDevMode && assertDefined(target, 'Target expected');\r\n        return target[MONKEY_PATCH_KEY_NAME];\r\n    }\r\n    function readPatchedLView(target) {\r\n        var value = readPatchedData(target);\r\n        if (value) {\r\n            return Array.isArray(value) ? value : value.lView;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Returns a boolean for whether the view is attached to the change detection tree.\r\n     *\r\n     * Note: This determines whether a view should be checked, not whether it's inserted\r\n     * into a container. For that, you'll want `viewAttachedToContainer` below.\r\n     */\r\n    function viewAttachedToChangeDetector(view) {\r\n        return (view[FLAGS] & 128 /* Attached */) === 128 /* Attached */;\r\n    }\r\n    /** Returns a boolean for whether the view is attached to a container. */\r\n    function viewAttachedToContainer(view) {\r\n        return isLContainer(view[PARENT]);\r\n    }\r\n    /**\r\n     * Resets the pre-order hook flags of the view.\r\n     * @param lView the LView on which the flags are reset\r\n     */\r\n    function resetPreOrderHookFlags(lView) {\r\n        lView[PREORDER_HOOK_FLAGS] = 0;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Store the element depth count. This is used to identify the root elements of the template\r\n     * so that we can than attach `LView` to only those elements.\r\n     */\r\n    var elementDepthCount;\r\n    function getElementDepthCount() {\r\n        // top level variables should not be exported for performance reasons (PERF_NOTES.md)\r\n        return elementDepthCount;\r\n    }\r\n    function increaseElementDepthCount() {\r\n        elementDepthCount++;\r\n    }\r\n    function decreaseElementDepthCount() {\r\n        elementDepthCount--;\r\n    }\r\n    var currentDirectiveDef = null;\r\n    function getCurrentDirectiveDef() {\r\n        // top level variables should not be exported for performance reasons (PERF_NOTES.md)\r\n        return currentDirectiveDef;\r\n    }\r\n    function setCurrentDirectiveDef(def) {\r\n        currentDirectiveDef = def;\r\n    }\r\n    /**\r\n     * Stores whether directives should be matched to elements.\r\n     *\r\n     * When template contains `ngNonBindable` than we need to prevent the runtime form matching\r\n     * directives on children of that element.\r\n     *\r\n     * Example:\r\n     * ```\r\n     * <my-comp my-directive>\r\n     *   Should match component / directive.\r\n     * </my-comp>\r\n     * <div ngNonBindable>\r\n     *   <my-comp my-directive>\r\n     *     Should not match component / directive because we are in ngNonBindable.\r\n     *   </my-comp>\r\n     * </div>\r\n     * ```\r\n     */\r\n    var bindingsEnabled;\r\n    function getBindingsEnabled() {\r\n        // top level variables should not be exported for performance reasons (PERF_NOTES.md)\r\n        return bindingsEnabled;\r\n    }\r\n    /**\r\n     * Enables directive matching on elements.\r\n     *\r\n     *  * Example:\r\n     * ```\r\n     * <my-comp my-directive>\r\n     *   Should match component / directive.\r\n     * </my-comp>\r\n     * <div ngNonBindable>\r\n     *   <!-- ɵɵdisableBindings() -->\r\n     *   <my-comp my-directive>\r\n     *     Should not match component / directive because we are in ngNonBindable.\r\n     *   </my-comp>\r\n     *   <!-- ɵɵenableBindings() -->\r\n     * </div>\r\n     * ```\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵenableBindings() {\r\n        bindingsEnabled = true;\r\n    }\r\n    /**\r\n     * Disables directive matching on element.\r\n     *\r\n     *  * Example:\r\n     * ```\r\n     * <my-comp my-directive>\r\n     *   Should match component / directive.\r\n     * </my-comp>\r\n     * <div ngNonBindable>\r\n     *   <!-- ɵɵdisableBindings() -->\r\n     *   <my-comp my-directive>\r\n     *     Should not match component / directive because we are in ngNonBindable.\r\n     *   </my-comp>\r\n     *   <!-- ɵɵenableBindings() -->\r\n     * </div>\r\n     * ```\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵdisableBindings() {\r\n        bindingsEnabled = false;\r\n    }\r\n    function getLView() {\r\n        return lView;\r\n    }\r\n    /**\r\n     * Used as the starting directive id value.\r\n     *\r\n     * All subsequent directives are incremented from this value onwards.\r\n     * The reason why this value is `1` instead of `0` is because the `0`\r\n     * value is reserved for the template.\r\n     */\r\n    var MIN_DIRECTIVE_ID = 1;\r\n    var activeDirectiveId = MIN_DIRECTIVE_ID;\r\n    /**\r\n     * Position depth (with respect from leaf to root) in a directive sub-class inheritance chain.\r\n     */\r\n    var activeDirectiveSuperClassDepthPosition = 0;\r\n    /**\r\n     * Total count of how many directives are a part of an inheritance chain.\r\n     *\r\n     * When directives are sub-classed (extended) from one to another, Angular\r\n     * needs to keep track of exactly how many were encountered so it can accurately\r\n     * generate the next directive id (once the next directive id is visited).\r\n     * Normally the next directive id just a single incremented value from the\r\n     * previous one, however, if the previous directive is a part of an inheritance\r\n     * chain (a series of sub-classed directives) then the incremented value must\r\n     * also take into account the total amount of sub-classed values.\r\n     *\r\n     * Note that this value resets back to zero once the next directive is\r\n     * visited (when `incrementActiveDirectiveId` or `setActiveHostElement`\r\n     * is called).\r\n     */\r\n    var activeDirectiveSuperClassHeight = 0;\r\n    /**\r\n     * Sets the active directive host element and resets the directive id value\r\n     * (when the provided elementIndex value has changed).\r\n     *\r\n     * @param elementIndex the element index value for the host element where\r\n     *                     the directive/component instance lives\r\n     */\r\n    function setActiveHostElement(elementIndex) {\r\n        if (elementIndex === void 0) { elementIndex = null; }\r\n        if (_selectedIndex !== elementIndex) {\r\n            setSelectedIndex(elementIndex == null ? -1 : elementIndex);\r\n            activeDirectiveId = elementIndex == null ? 0 : MIN_DIRECTIVE_ID;\r\n            activeDirectiveSuperClassDepthPosition = 0;\r\n            activeDirectiveSuperClassHeight = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Returns the current id value of the current directive.\r\n     *\r\n     * For example we have an element that has two directives on it:\r\n     * <div dir-one dir-two></div>\r\n     *\r\n     * dirOne->hostBindings() (id == 1)\r\n     * dirTwo->hostBindings() (id == 2)\r\n     *\r\n     * Note that this is only active when `hostBinding` functions are being processed.\r\n     *\r\n     * Note that directive id values are specific to an element (this means that\r\n     * the same id value could be present on another element with a completely\r\n     * different set of directives).\r\n     */\r\n    function getActiveDirectiveId() {\r\n        return activeDirectiveId;\r\n    }\r\n    /**\r\n     * Increments the current directive id value.\r\n     *\r\n     * For example we have an element that has two directives on it:\r\n     * <div dir-one dir-two></div>\r\n     *\r\n     * dirOne->hostBindings() (index = 1)\r\n     * // increment\r\n     * dirTwo->hostBindings() (index = 2)\r\n     *\r\n     * Depending on whether or not a previous directive had any inherited\r\n     * directives present, that value will be incremented in addition\r\n     * to the id jumping up by one.\r\n     *\r\n     * Note that this is only active when `hostBinding` functions are being processed.\r\n     *\r\n     * Note that directive id values are specific to an element (this means that\r\n     * the same id value could be present on another element with a completely\r\n     * different set of directives).\r\n     */\r\n    function incrementActiveDirectiveId() {\r\n        activeDirectiveId += 1 + activeDirectiveSuperClassHeight;\r\n        // because we are dealing with a new directive this\r\n        // means we have exited out of the inheritance chain\r\n        activeDirectiveSuperClassDepthPosition = 0;\r\n        activeDirectiveSuperClassHeight = 0;\r\n    }\r\n    /**\r\n     * Set the current super class (reverse inheritance) position depth for a directive.\r\n     *\r\n     * For example we have two directives: Child and Other (but Child is a sub-class of Parent)\r\n     * <div child-dir other-dir></div>\r\n     *\r\n     * // increment\r\n     * parentInstance->hostBindings() (depth = 1)\r\n     * // decrement\r\n     * childInstance->hostBindings() (depth = 0)\r\n     * otherInstance->hostBindings() (depth = 0 b/c it's a different directive)\r\n     *\r\n     * Note that this is only active when `hostBinding` functions are being processed.\r\n     */\r\n    function adjustActiveDirectiveSuperClassDepthPosition(delta) {\r\n        activeDirectiveSuperClassDepthPosition += delta;\r\n        // we keep track of the height value so that when the next directive is visited\r\n        // then Angular knows to generate a new directive id value which has taken into\r\n        // account how many sub-class directives were a part of the previous directive.\r\n        activeDirectiveSuperClassHeight =\r\n            Math.max(activeDirectiveSuperClassHeight, activeDirectiveSuperClassDepthPosition);\r\n    }\r\n    /**\r\n     * Returns he current depth of the super/sub class inheritance chain.\r\n     *\r\n     * This will return how many inherited directive/component classes\r\n     * exist in the current chain.\r\n     *\r\n     * ```typescript\r\n     * @Directive({ selector: '[super-dir]' })\r\n     * class SuperDir {}\r\n     *\r\n     * @Directive({ selector: '[sub-dir]' })\r\n     * class SubDir extends SuperDir {}\r\n     *\r\n     * // if `<div sub-dir>` is used then the super class height is `1`\r\n     * // if `<div super-dir>` is used then the super class height is `0`\r\n     * ```\r\n     */\r\n    function getActiveDirectiveSuperClassHeight() {\r\n        return activeDirectiveSuperClassHeight;\r\n    }\r\n    /**\r\n     * Returns the current super class (reverse inheritance) depth for a directive.\r\n     *\r\n     * This is designed to help instruction code distinguish different hostBindings\r\n     * calls from each other when a directive has extended from another directive.\r\n     * Normally using the directive id value is enough, but with the case\r\n     * of parent/sub-class directive inheritance more information is required.\r\n     *\r\n     * Note that this is only active when `hostBinding` functions are being processed.\r\n     */\r\n    function getActiveDirectiveSuperClassDepth() {\r\n        return activeDirectiveSuperClassDepthPosition;\r\n    }\r\n    /**\r\n     * Restores `contextViewData` to the given OpaqueViewState instance.\r\n     *\r\n     * Used in conjunction with the getCurrentView() instruction to save a snapshot\r\n     * of the current view and restore it when listeners are invoked. This allows\r\n     * walking the declaration view tree in listeners to get vars from parent views.\r\n     *\r\n     * @param viewToRestore The OpaqueViewState instance to restore.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵrestoreView(viewToRestore) {\r\n        contextLView = viewToRestore;\r\n    }\r\n    /** Used to set the parent property when nodes are created and track query results. */\r\n    var previousOrParentTNode;\r\n    function getPreviousOrParentTNode() {\r\n        // top level variables should not be exported for performance reasons (PERF_NOTES.md)\r\n        return previousOrParentTNode;\r\n    }\r\n    function setPreviousOrParentTNode(tNode, _isParent) {\r\n        previousOrParentTNode = tNode;\r\n        isParent = _isParent;\r\n    }\r\n    function setTNodeAndViewData(tNode, view) {\r\n        ngDevMode && assertLViewOrUndefined(view);\r\n        previousOrParentTNode = tNode;\r\n        lView = view;\r\n    }\r\n    /**\r\n     * If `isParent` is:\r\n     *  - `true`: then `previousOrParentTNode` points to a parent node.\r\n     *  - `false`: then `previousOrParentTNode` points to previous node (sibling).\r\n     */\r\n    var isParent;\r\n    function getIsParent() {\r\n        // top level variables should not be exported for performance reasons (PERF_NOTES.md)\r\n        return isParent;\r\n    }\r\n    function setIsNotParent() {\r\n        isParent = false;\r\n    }\r\n    function setIsParent() {\r\n        isParent = true;\r\n    }\r\n    /** Checks whether a given view is in creation mode */\r\n    function isCreationMode(view) {\r\n        if (view === void 0) { view = lView; }\r\n        return (view[FLAGS] & 4 /* CreationMode */) === 4 /* CreationMode */;\r\n    }\r\n    /**\r\n     * State of the current view being processed.\r\n     *\r\n     * An array of nodes (text, element, container, etc), pipes, their bindings, and\r\n     * any local variables that need to be stored between invocations.\r\n     */\r\n    var lView;\r\n    /**\r\n     * The last viewData retrieved by nextContext().\r\n     * Allows building nextContext() and reference() calls.\r\n     *\r\n     * e.g. const inner = x().$implicit; const outer = x().$implicit;\r\n     */\r\n    var contextLView = null;\r\n    function getContextLView() {\r\n        // top level variables should not be exported for performance reasons (PERF_NOTES.md)\r\n        return contextLView;\r\n    }\r\n    /**\r\n     * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\r\n     *\r\n     * Necessary to support ChangeDetectorRef.checkNoChanges().\r\n     */\r\n    var checkNoChangesMode = false;\r\n    function getCheckNoChangesMode() {\r\n        // top level variables should not be exported for performance reasons (PERF_NOTES.md)\r\n        return checkNoChangesMode;\r\n    }\r\n    function setCheckNoChangesMode(mode) {\r\n        checkNoChangesMode = mode;\r\n    }\r\n    /**\r\n     * The root index from which pure function instructions should calculate their binding\r\n     * indices. In component views, this is TView.bindingStartIndex. In a host binding\r\n     * context, this is the TView.expandoStartIndex + any dirs/hostVars before the given dir.\r\n     */\r\n    var bindingRootIndex = -1;\r\n    // top level variables should not be exported for performance reasons (PERF_NOTES.md)\r\n    function getBindingRoot() {\r\n        return bindingRootIndex;\r\n    }\r\n    function setBindingRoot(value) {\r\n        bindingRootIndex = value;\r\n    }\r\n    /**\r\n     * Current index of a View or Content Query which needs to be processed next.\r\n     * We iterate over the list of Queries and increment current query index at every step.\r\n     */\r\n    var currentQueryIndex = 0;\r\n    function getCurrentQueryIndex() {\r\n        // top level variables should not be exported for performance reasons (PERF_NOTES.md)\r\n        return currentQueryIndex;\r\n    }\r\n    function setCurrentQueryIndex(value) {\r\n        currentQueryIndex = value;\r\n    }\r\n    /**\r\n     * Swap the current state with a new state.\r\n     *\r\n     * For performance reasons we store the state in the top level of the module.\r\n     * This way we minimize the number of properties to read. Whenever a new view\r\n     * is entered we have to store the state for later, and when the view is\r\n     * exited the state has to be restored\r\n     *\r\n     * @param newView New state to become active\r\n     * @param host Element to which the View is a child of\r\n     * @returns the previous state;\r\n     */\r\n    function enterView(newView, hostTNode) {\r\n        ngDevMode && assertLViewOrUndefined(newView);\r\n        var oldView = lView;\r\n        if (newView) {\r\n            var tView = newView[TVIEW];\r\n            bindingRootIndex = tView.bindingStartIndex;\r\n        }\r\n        previousOrParentTNode = hostTNode;\r\n        isParent = true;\r\n        lView = contextLView = newView;\r\n        return oldView;\r\n    }\r\n    function nextContextImpl(level) {\r\n        if (level === void 0) { level = 1; }\r\n        contextLView = walkUpViews(level, contextLView);\r\n        return contextLView[CONTEXT];\r\n    }\r\n    function walkUpViews(nestingLevel, currentView) {\r\n        while (nestingLevel > 0) {\r\n            ngDevMode && assertDefined(currentView[DECLARATION_VIEW], 'Declaration view should be defined if nesting level is greater than 0.');\r\n            currentView = currentView[DECLARATION_VIEW];\r\n            nestingLevel--;\r\n        }\r\n        return currentView;\r\n    }\r\n    /**\r\n     * Resets the application state.\r\n     */\r\n    function resetComponentState() {\r\n        isParent = false;\r\n        previousOrParentTNode = null;\r\n        elementDepthCount = 0;\r\n        bindingsEnabled = true;\r\n        setCurrentStyleSanitizer(null);\r\n        resetAllStylingState();\r\n    }\r\n    /**\r\n     * Used in lieu of enterView to make it clear when we are exiting a child view. This makes\r\n     * the direction of traversal (up or down the view tree) a bit clearer.\r\n     *\r\n     * @param newView New state to become active\r\n     * @param safeToRunHooks Whether the runtime is in a state where running lifecycle hooks is valid.\r\n     * This is not always the case (for example, the application may have crashed and `leaveView` is\r\n     * being executed while unwinding the call stack).\r\n     */\r\n    function leaveView(newView, safeToRunHooks) {\r\n        var tView = lView[TVIEW];\r\n        if (isCreationMode(lView)) {\r\n            lView[FLAGS] &= ~4 /* CreationMode */;\r\n        }\r\n        else {\r\n            try {\r\n                resetPreOrderHookFlags(lView);\r\n                safeToRunHooks && executeHooks(lView, tView.viewHooks, tView.viewCheckHooks, checkNoChangesMode, 2 /* AfterViewInitHooksToBeRun */, undefined);\r\n            }\r\n            finally {\r\n                // Views are clean and in update mode after being checked, so these bits are cleared\r\n                lView[FLAGS] &= ~(64 /* Dirty */ | 8 /* FirstLViewPass */);\r\n                lView[BINDING_INDEX] = tView.bindingStartIndex;\r\n            }\r\n        }\r\n        enterView(newView, null);\r\n    }\r\n    var _selectedIndex = -1;\r\n    /**\r\n     * Gets the most recent index passed to {@link select}\r\n     *\r\n     * Used with {@link property} instruction (and more in the future) to identify the index in the\r\n     * current `LView` to act on.\r\n     */\r\n    function getSelectedIndex() {\r\n        return _selectedIndex;\r\n    }\r\n    /**\r\n     * Sets the most recent index passed to {@link select}\r\n     *\r\n     * Used with {@link property} instruction (and more in the future) to identify the index in the\r\n     * current `LView` to act on.\r\n     */\r\n    function setSelectedIndex(index) {\r\n        _selectedIndex = index;\r\n        // we have now jumped to another element\r\n        // therefore the state is stale\r\n        resetStylingState();\r\n    }\r\n    var _currentNamespace = null;\r\n    /**\r\n     * Sets the namespace used to create elements to `'http://www.w3.org/2000/svg'` in global state.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵnamespaceSVG() {\r\n        _currentNamespace = 'http://www.w3.org/2000/svg';\r\n    }\r\n    /**\r\n     * Sets the namespace used to create elements to `'http://www.w3.org/1998/MathML/'` in global state.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵnamespaceMathML() {\r\n        _currentNamespace = 'http://www.w3.org/1998/MathML/';\r\n    }\r\n    /**\r\n     * Sets the namespace used to create elements to `null`, which forces element creation to use\r\n     * `createElement` rather than `createElementNS`.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵnamespaceHTML() {\r\n        namespaceHTMLInternal();\r\n    }\r\n    /**\r\n     * Sets the namespace used to create elements to `null`, which forces element creation to use\r\n     * `createElement` rather than `createElementNS`.\r\n     */\r\n    function namespaceHTMLInternal() {\r\n        _currentNamespace = null;\r\n    }\r\n    function getNamespace() {\r\n        return _currentNamespace;\r\n    }\r\n    var _currentSanitizer;\r\n    function setCurrentStyleSanitizer(sanitizer) {\r\n        _currentSanitizer = sanitizer;\r\n    }\r\n    function getCurrentStyleSanitizer() {\r\n        return _currentSanitizer;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Returns whether the values are different from a change detection stand point.\r\n     *\r\n     * Constraints are relaxed in checkNoChanges mode. See `devModeEqual` for details.\r\n     */\r\n    function isDifferent(a, b) {\r\n        // NaN is the only value that is not equal to itself so the first\r\n        // test checks if both a and b are not NaN\r\n        return !(a !== a && b !== b) && a !== b;\r\n    }\r\n    /**\r\n     * Used for stringify render output in Ivy.\r\n     * Important! This function is very performance-sensitive and we should\r\n     * be extra careful not to introduce megamorphic reads in it.\r\n     */\r\n    function renderStringify(value) {\r\n        if (typeof value === 'string')\r\n            return value;\r\n        if (value == null)\r\n            return '';\r\n        return '' + value;\r\n    }\r\n    /**\r\n     * Used to stringify a value so that it can be displayed in an error message.\r\n     * Important! This function contains a megamorphic read and should only be\r\n     * used for error messages.\r\n     */\r\n    function stringifyForError(value) {\r\n        if (typeof value === 'function')\r\n            return value.name || value.toString();\r\n        if (typeof value === 'object' && value != null && typeof value.type === 'function') {\r\n            return value.type.name || value.type.toString();\r\n        }\r\n        return renderStringify(value);\r\n    }\r\n    var ɵ0$2 = function () {\r\n        return (typeof requestAnimationFrame !== 'undefined' && requestAnimationFrame || // browser only\r\n            setTimeout // everything else\r\n        ).bind(_global);\r\n    };\r\n    var defaultScheduler = (ɵ0$2)();\r\n    /**\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵresolveWindow(element) {\r\n        return { name: 'window', target: element.ownerDocument.defaultView };\r\n    }\r\n    /**\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵresolveDocument(element) {\r\n        return { name: 'document', target: element.ownerDocument };\r\n    }\r\n    /**\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵresolveBody(element) {\r\n        return { name: 'body', target: element.ownerDocument.body };\r\n    }\r\n    /**\r\n     * The special delimiter we use to separate property names, prefixes, and suffixes\r\n     * in property binding metadata. See storeBindingMetadata().\r\n     *\r\n     * We intentionally use the Unicode \"REPLACEMENT CHARACTER\" (U+FFFD) as a delimiter\r\n     * because it is a very uncommon character that is unlikely to be part of a user's\r\n     * property names or interpolation strings. If it is in fact used in a property\r\n     * binding, DebugElement.properties will not return the correct value for that\r\n     * binding. However, there should be no runtime effect for real applications.\r\n     *\r\n     * This character is typically rendered as a question mark inside of a diamond.\r\n     * See https://en.wikipedia.org/wiki/Specials_(Unicode_block)\r\n     *\r\n     */\r\n    var INTERPOLATION_DELIMITER = \"\\uFFFD\";\r\n    /**\r\n     * Determines whether or not the given string is a property metadata string.\r\n     * See storeBindingMetadata().\r\n     */\r\n    function isPropMetadataString(str) {\r\n        return str.indexOf(INTERPOLATION_DELIMITER) >= 0;\r\n    }\r\n    /**\r\n     * Unwrap a value which might be behind a closure (for forward declaration reasons).\r\n     */\r\n    function maybeUnwrapFn(value) {\r\n        if (value instanceof Function) {\r\n            return value();\r\n        }\r\n        else {\r\n            return value;\r\n        }\r\n    }\r\n\r\n    var MAP_BASED_ENTRY_PROP_NAME = '--MAP--';\r\n    var TEMPLATE_DIRECTIVE_INDEX = 0;\r\n    /**\r\n     * Creates a new instance of the `TStylingContext`.\r\n     *\r\n     * The `TStylingContext` is used as a manifest of all style or all class bindings on\r\n     * an element. Because it is a T-level data-structure, it is only created once per\r\n     * tNode for styles and for classes. This function allocates a new instance of a\r\n     * `TStylingContext` with the initial values (see `interfaces.ts` for more info).\r\n     */\r\n    function allocTStylingContext(initialStyling) {\r\n        // because map-based bindings deal with a dynamic set of values, there\r\n        // is no way to know ahead of time whether or not sanitization is required.\r\n        // For this reason the configuration will always mark sanitization as active\r\n        // (this means that when map-based values are applied then sanitization will\r\n        // be checked against each property).\r\n        var mapBasedConfig = 1 /* SanitizationRequired */;\r\n        return [\r\n            initialStyling || [''],\r\n            0 /* Initial */,\r\n            TEMPLATE_DIRECTIVE_INDEX,\r\n            mapBasedConfig,\r\n            0,\r\n            MAP_BASED_ENTRY_PROP_NAME,\r\n        ];\r\n    }\r\n    /**\r\n     * Sets the provided directive as the last directive index in the provided `TStylingContext`.\r\n     *\r\n     * Styling in Angular can be applied from the template as well as multiple sources of\r\n     * host bindings. This means that each binding function (the template function or the\r\n     * hostBindings functions) will generate styling instructions as well as a styling\r\n     * apply function (i.e. `stylingApply()`). Because host bindings functions and the\r\n     * template function are independent from one another this means that the styling apply\r\n     * function will be called multiple times. By tracking the last directive index (which\r\n     * is what happens in this function) the styling algorithm knows exactly when to flush\r\n     * styling (which is when the last styling apply function is executed).\r\n     */\r\n    function updateLastDirectiveIndex(context, lastDirectiveIndex) {\r\n        if (lastDirectiveIndex === TEMPLATE_DIRECTIVE_INDEX) {\r\n            var currentValue = context[2 /* LastDirectiveIndexPosition */];\r\n            if (currentValue > TEMPLATE_DIRECTIVE_INDEX) {\r\n                // This means that a directive or two contained a host bindings function, but\r\n                // now the template function also contains styling. When this combination of sources\r\n                // comes up then we need to tell the context to store the state between updates\r\n                // (because host bindings evaluation happens after template binding evaluation).\r\n                markContextToPersistState(context);\r\n            }\r\n        }\r\n        else {\r\n            context[2 /* LastDirectiveIndexPosition */] = lastDirectiveIndex;\r\n        }\r\n    }\r\n    function getConfig(context) {\r\n        return context[1 /* ConfigPosition */];\r\n    }\r\n    function setConfig(context, value) {\r\n        context[1 /* ConfigPosition */] = value;\r\n    }\r\n    function getProp(context, index) {\r\n        return context[index + 2 /* PropOffset */];\r\n    }\r\n    function getPropConfig(context, index) {\r\n        return context[index + 0 /* ConfigAndGuardOffset */] &\r\n            1 /* Mask */;\r\n    }\r\n    function isSanitizationRequired(context, index) {\r\n        return (getPropConfig(context, index) & 1 /* SanitizationRequired */) > 0;\r\n    }\r\n    function getGuardMask(context, index) {\r\n        var configGuardValue = context[index + 0 /* ConfigAndGuardOffset */];\r\n        return configGuardValue >> 1 /* TotalBits */;\r\n    }\r\n    function setGuardMask(context, index, maskValue) {\r\n        var config = getPropConfig(context, index);\r\n        var guardMask = maskValue << 1 /* TotalBits */;\r\n        context[index + 0 /* ConfigAndGuardOffset */] = config | guardMask;\r\n    }\r\n    function getValuesCount(context, index) {\r\n        return context[index + 1 /* ValuesCountOffset */];\r\n    }\r\n    function getBindingValue(context, index, offset) {\r\n        return context[index + 3 /* BindingsStartOffset */ + offset];\r\n    }\r\n    function getDefaultValue(context, index) {\r\n        var valuesCount = getValuesCount(context, index);\r\n        return context[index + 3 /* BindingsStartOffset */ + valuesCount - 1];\r\n    }\r\n    /**\r\n     * Temporary function which determines whether or not a context is\r\n     * allowed to be flushed based on the provided directive index.\r\n     */\r\n    function allowStylingFlush(context, index) {\r\n        return (context && index === context[2 /* LastDirectiveIndexPosition */]) ? true :\r\n            false;\r\n    }\r\n    function lockContext(context) {\r\n        setConfig(context, getConfig(context) | 1 /* Locked */);\r\n    }\r\n    function isContextLocked(context) {\r\n        return (getConfig(context) & 1 /* Locked */) > 0;\r\n    }\r\n    function stateIsPersisted(context) {\r\n        return (getConfig(context) & 2 /* PersistStateValues */) > 0;\r\n    }\r\n    function markContextToPersistState(context) {\r\n        setConfig(context, getConfig(context) | 2 /* PersistStateValues */);\r\n    }\r\n    function getPropValuesStartPosition(context) {\r\n        return 6 /* MapBindingsBindingsStartPosition */ +\r\n            context[4 /* MapBindingsValuesCountPosition */];\r\n    }\r\n    function isMapBased(prop) {\r\n        return prop === MAP_BASED_ENTRY_PROP_NAME;\r\n    }\r\n    function hasValueChanged(a, b) {\r\n        var compareValueA = Array.isArray(a) ? a[0 /* RawValuePosition */] : a;\r\n        var compareValueB = Array.isArray(b) ? b[0 /* RawValuePosition */] : b;\r\n        // these are special cases for String based values (which are created as artifacts\r\n        // when sanitization is bypassed on a particular value)\r\n        if (compareValueA instanceof String) {\r\n            compareValueA = compareValueA.toString();\r\n        }\r\n        if (compareValueB instanceof String) {\r\n            compareValueB = compareValueB.toString();\r\n        }\r\n        return isDifferent(compareValueA, compareValueB);\r\n    }\r\n    /**\r\n     * Determines whether the provided styling value is truthy or falsy.\r\n     */\r\n    function isStylingValueDefined(value) {\r\n        // the reason why null is compared against is because\r\n        // a CSS class value that is set to `false` must be\r\n        // respected (otherwise it would be treated as falsy).\r\n        // Empty string values are because developers usually\r\n        // set a value to an empty string to remove it.\r\n        return value != null && value !== '';\r\n    }\r\n    function concatString(a, b, separator) {\r\n        if (separator === void 0) { separator = ' '; }\r\n        return a + ((b.length && a.length) ? separator : '') + b;\r\n    }\r\n    function hyphenate(value) {\r\n        return value.replace(/[a-z][A-Z]/g, function (v) { return v.charAt(0) + '-' + v.charAt(1); }).toLowerCase();\r\n    }\r\n    /**\r\n     * Returns an instance of `StylingMapArray`.\r\n     *\r\n     * This function is designed to find an instance of `StylingMapArray` in case it is stored\r\n     * inside of an instance of `TStylingContext`. When a styling context is created it\r\n     * will copy over an initial styling values from the tNode (which are stored as a\r\n     * `StylingMapArray` on the `tNode.classes` or `tNode.styles` values).\r\n     */\r\n    function getStylingMapArray(value) {\r\n        return isStylingContext(value) ?\r\n            value[0 /* InitialStylingValuePosition */] :\r\n            value;\r\n    }\r\n    function isStylingContext(value) {\r\n        // the StylingMapArray is in the format of [initial, prop, string, prop, string]\r\n        // and this is the defining value to distinguish between arrays\r\n        return Array.isArray(value) &&\r\n            value.length >= 6 /* MapBindingsBindingsStartPosition */ &&\r\n            typeof value[1] !== 'string';\r\n    }\r\n    function getInitialStylingValue(context) {\r\n        var map = getStylingMapArray(context);\r\n        return map && map[0 /* RawValuePosition */] || '';\r\n    }\r\n    function hasClassInput(tNode) {\r\n        return (tNode.flags & 8 /* hasClassInput */) !== 0;\r\n    }\r\n    function hasStyleInput(tNode) {\r\n        return (tNode.flags & 16 /* hasStyleInput */) !== 0;\r\n    }\r\n    function getMapProp(map, index) {\r\n        return map[index + 0 /* PropOffset */];\r\n    }\r\n    function setMapValue(map, index, value) {\r\n        map[index + 1 /* ValueOffset */] = value;\r\n    }\r\n    function getMapValue(map, index) {\r\n        return map[index + 1 /* ValueOffset */];\r\n    }\r\n    function forceClassesAsString(classes) {\r\n        if (classes && typeof classes !== 'string') {\r\n            classes = Object.keys(classes).join(' ');\r\n        }\r\n        return classes || '';\r\n    }\r\n    function forceStylesAsString(styles) {\r\n        var str = '';\r\n        if (styles) {\r\n            var props = Object.keys(styles);\r\n            for (var i = 0; i < props.length; i++) {\r\n                var prop = props[i];\r\n                str = concatString(str, prop + \":\" + styles[prop], ';');\r\n            }\r\n        }\r\n        return str;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    // TODO: cleanup once the code is merged in angular/angular\r\n    var RendererStyleFlags3;\r\n    (function (RendererStyleFlags3) {\r\n        RendererStyleFlags3[RendererStyleFlags3[\"Important\"] = 1] = \"Important\";\r\n        RendererStyleFlags3[RendererStyleFlags3[\"DashCase\"] = 2] = \"DashCase\";\r\n    })(RendererStyleFlags3 || (RendererStyleFlags3 = {}));\r\n    /** Returns whether the `renderer` is a `ProceduralRenderer3` */\r\n    function isProceduralRenderer(renderer) {\r\n        return !!(renderer.listen);\r\n    }\r\n    var ɵ0$3 = function (hostElement, rendererType) { return document; };\r\n    var domRendererFactory3 = {\r\n        createRenderer: ɵ0$3\r\n    };\r\n    // Note: This hack is necessary so we don't erroneously get a circular dependency\r\n    // failure based on types.\r\n    var unusedValueExportToPlacateAjd$3 = 1;\r\n\r\n    /**\r\n     * Assigns all attribute values to the provided element via the inferred renderer.\r\n     *\r\n     * This function accepts two forms of attribute entries:\r\n     *\r\n     * default: (key, value):\r\n     *  attrs = [key1, value1, key2, value2]\r\n     *\r\n     * namespaced: (NAMESPACE_MARKER, uri, name, value)\r\n     *  attrs = [NAMESPACE_MARKER, uri, name, value, NAMESPACE_MARKER, uri, name, value]\r\n     *\r\n     * The `attrs` array can contain a mix of both the default and namespaced entries.\r\n     * The \"default\" values are set without a marker, but if the function comes across\r\n     * a marker value then it will attempt to set a namespaced value. If the marker is\r\n     * not of a namespaced value then the function will quit and return the index value\r\n     * where it stopped during the iteration of the attrs array.\r\n     *\r\n     * See [AttributeMarker] to understand what the namespace marker value is.\r\n     *\r\n     * Note that this instruction does not support assigning style and class values to\r\n     * an element. See `elementStart` and `elementHostAttrs` to learn how styling values\r\n     * are applied to an element.\r\n     *\r\n     * @param native The element that the attributes will be assigned to\r\n     * @param attrs The attribute array of values that will be assigned to the element\r\n     * @returns the index value that was last accessed in the attributes array\r\n     */\r\n    function setUpAttributes(native, attrs) {\r\n        var renderer = getLView()[RENDERER];\r\n        var isProc = isProceduralRenderer(renderer);\r\n        var i = 0;\r\n        while (i < attrs.length) {\r\n            var value = attrs[i];\r\n            if (typeof value === 'number') {\r\n                // only namespaces are supported. Other value types (such as style/class\r\n                // entries) are not supported in this function.\r\n                if (value !== 0 /* NamespaceURI */) {\r\n                    break;\r\n                }\r\n                // we just landed on the marker value ... therefore\r\n                // we should skip to the next entry\r\n                i++;\r\n                var namespaceURI = attrs[i++];\r\n                var attrName = attrs[i++];\r\n                var attrVal = attrs[i++];\r\n                ngDevMode && ngDevMode.rendererSetAttribute++;\r\n                isProc ?\r\n                    renderer.setAttribute(native, attrName, attrVal, namespaceURI) :\r\n                    native.setAttributeNS(namespaceURI, attrName, attrVal);\r\n            }\r\n            else {\r\n                // attrName is string;\r\n                var attrName = value;\r\n                var attrVal = attrs[++i];\r\n                // Standard attributes\r\n                ngDevMode && ngDevMode.rendererSetAttribute++;\r\n                if (isAnimationProp(attrName)) {\r\n                    if (isProc) {\r\n                        renderer.setProperty(native, attrName, attrVal);\r\n                    }\r\n                }\r\n                else {\r\n                    isProc ?\r\n                        renderer\r\n                            .setAttribute(native, attrName, attrVal) :\r\n                        native.setAttribute(attrName, attrVal);\r\n                }\r\n                i++;\r\n            }\r\n        }\r\n        // another piece of code may iterate over the same attributes array. Therefore\r\n        // it may be helpful to return the exact spot where the attributes array exited\r\n        // whether by running into an unsupported marker or if all the static values were\r\n        // iterated over.\r\n        return i;\r\n    }\r\n    function attrsStylingIndexOf(attrs, startIndex) {\r\n        for (var i = startIndex; i < attrs.length; i++) {\r\n            var val = attrs[i];\r\n            if (val === 1 /* Classes */ || val === 2 /* Styles */) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    /**\r\n     * Test whether the given value is a marker that indicates that the following\r\n     * attribute values in a `TAttributes` array are only the names of attributes,\r\n     * and not name-value pairs.\r\n     * @param marker The attribute marker to test.\r\n     * @returns true if the marker is a \"name-only\" marker (e.g. `Bindings`, `Template` or `I18n`).\r\n     */\r\n    function isNameOnlyAttributeMarker(marker) {\r\n        return marker === 3 /* Bindings */ || marker === 4 /* Template */ ||\r\n            marker === 6 /* I18n */;\r\n    }\r\n    var ANIMATION_PROP_PREFIX = '@';\r\n    function isAnimationProp(name) {\r\n        return name[0] === ANIMATION_PROP_PREFIX;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /// Parent Injector Utils ///////////////////////////////////////////////////////////////\r\n    function hasParentInjector(parentLocation) {\r\n        return parentLocation !== NO_PARENT_INJECTOR;\r\n    }\r\n    function getParentInjectorIndex(parentLocation) {\r\n        return parentLocation & 32767 /* InjectorIndexMask */;\r\n    }\r\n    function getParentInjectorViewOffset(parentLocation) {\r\n        return parentLocation >> 16 /* ViewOffsetShift */;\r\n    }\r\n    /**\r\n     * Unwraps a parent injector location number to find the view offset from the current injector,\r\n     * then walks up the declaration view tree until the view is found that contains the parent\r\n     * injector.\r\n     *\r\n     * @param location The location of the parent injector, which contains the view offset\r\n     * @param startView The LView instance from which to start walking up the view tree\r\n     * @returns The LView instance that contains the parent injector\r\n     */\r\n    function getParentInjectorView(location, startView) {\r\n        var viewOffset = getParentInjectorViewOffset(location);\r\n        var parentView = startView;\r\n        // For most cases, the parent injector can be found on the host node (e.g. for component\r\n        // or container), but we must keep the loop here to support the rarer case of deeply nested\r\n        // <ng-template> tags or inline views, where the parent injector might live many views\r\n        // above the child injector.\r\n        while (viewOffset > 0) {\r\n            parentView = parentView[DECLARATION_VIEW];\r\n            viewOffset--;\r\n        }\r\n        return parentView;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Gets the parent LView of the passed LView, if the PARENT is an LContainer, will get the parent of\r\n     * that LContainer, which is an LView\r\n     * @param lView the lView whose parent to get\r\n     */\r\n    function getLViewParent(lView) {\r\n        ngDevMode && assertLView(lView);\r\n        var parent = lView[PARENT];\r\n        return isLContainer(parent) ? parent[PARENT] : parent;\r\n    }\r\n    /**\r\n     * Retrieve the root view from any component or `LView` by walking the parent `LView` until\r\n     * reaching the root `LView`.\r\n     *\r\n     * @param componentOrLView any component or `LView`\r\n     */\r\n    function getRootView(componentOrLView) {\r\n        ngDevMode && assertDefined(componentOrLView, 'component');\r\n        var lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);\r\n        while (lView && !(lView[FLAGS] & 512 /* IsRoot */)) {\r\n            lView = getLViewParent(lView);\r\n        }\r\n        ngDevMode && assertLView(lView);\r\n        return lView;\r\n    }\r\n    /**\r\n     * Given an `LView`, find the closest declaration view which is not an embedded view.\r\n     *\r\n     * This method searches for the `LView` associated with the component which declared the `LView`.\r\n     *\r\n     * This function may return itself if the `LView` passed in is not an embedded `LView`. Otherwise\r\n     * it walks the declaration parents until it finds a component view (non-embedded-view.)\r\n     *\r\n     * @param lView LView for which we want a host element node\r\n     * @returns The host node\r\n     */\r\n    function findComponentView(lView) {\r\n        var rootTNode = lView[T_HOST];\r\n        while (rootTNode !== null && rootTNode.type === 2 /* View */) {\r\n            ngDevMode && assertDefined(lView[DECLARATION_VIEW], 'lView[DECLARATION_VIEW]');\r\n            lView = lView[DECLARATION_VIEW];\r\n            rootTNode = lView[T_HOST];\r\n        }\r\n        ngDevMode && assertLView(lView);\r\n        return lView;\r\n    }\r\n    /**\r\n     * Returns the `RootContext` instance that is associated with\r\n     * the application where the target is situated. It does this by walking the parent views until it\r\n     * gets to the root view, then getting the context off of that.\r\n     *\r\n     * @param viewOrComponent the `LView` or component to get the root context for.\r\n     */\r\n    function getRootContext(viewOrComponent) {\r\n        var rootView = getRootView(viewOrComponent);\r\n        ngDevMode &&\r\n            assertDefined(rootView[CONTEXT], 'RootView has no context. Perhaps it is disconnected?');\r\n        return rootView[CONTEXT];\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Defines if the call to `inject` should include `viewProviders` in its resolution.\r\n     *\r\n     * This is set to true when we try to instantiate a component. This value is reset in\r\n     * `getNodeInjectable` to a value which matches the declaration location of the token about to be\r\n     * instantiated. This is done so that if we are injecting a token which was declared outside of\r\n     * `viewProviders` we don't accidentally pull `viewProviders` in.\r\n     *\r\n     * Example:\r\n     *\r\n     * ```\r\n     * @Injectable()\r\n     * class MyService {\r\n     *   constructor(public value: String) {}\r\n     * }\r\n     *\r\n     * @Component({\r\n     *   providers: [\r\n     *     MyService,\r\n     *     {provide: String, value: 'providers' }\r\n     *   ]\r\n     *   viewProviders: [\r\n     *     {provide: String, value: 'viewProviders'}\r\n     *   ]\r\n     * })\r\n     * class MyComponent {\r\n     *   constructor(myService: MyService, value: String) {\r\n     *     // We expect that Component can see into `viewProviders`.\r\n     *     expect(value).toEqual('viewProviders');\r\n     *     // `MyService` was not declared in `viewProviders` hence it can't see it.\r\n     *     expect(myService.value).toEqual('providers');\r\n     *   }\r\n     * }\r\n     *\r\n     * ```\r\n     */\r\n    var includeViewProviders = true;\r\n    function setIncludeViewProviders(v) {\r\n        var oldValue = includeViewProviders;\r\n        includeViewProviders = v;\r\n        return oldValue;\r\n    }\r\n    /**\r\n     * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\r\n     * directives that will share slots, and thus, the fewer false positives when checking for\r\n     * the existence of a directive.\r\n     */\r\n    var BLOOM_SIZE = 256;\r\n    var BLOOM_MASK = BLOOM_SIZE - 1;\r\n    /** Counter used to generate unique IDs for directives. */\r\n    var nextNgElementId = 0;\r\n    /**\r\n     * Registers this directive as present in its node's injector by flipping the directive's\r\n     * corresponding bit in the injector's bloom filter.\r\n     *\r\n     * @param injectorIndex The index of the node injector where this token should be registered\r\n     * @param tView The TView for the injector's bloom filters\r\n     * @param type The directive token to register\r\n     */\r\n    function bloomAdd(injectorIndex, tView, type) {\r\n        ngDevMode && assertEqual(tView.firstTemplatePass, true, 'expected firstTemplatePass to be true');\r\n        var id = typeof type !== 'string' ? type[NG_ELEMENT_ID] : type.charCodeAt(0) || 0;\r\n        // Set a unique ID on the directive type, so if something tries to inject the directive,\r\n        // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\r\n        if (id == null) {\r\n            id = type[NG_ELEMENT_ID] = nextNgElementId++;\r\n        }\r\n        // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\r\n        // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\r\n        var bloomBit = id & BLOOM_MASK;\r\n        // Create a mask that targets the specific bit associated with the directive.\r\n        // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\r\n        // to bit positions 0 - 31 in a 32 bit integer.\r\n        var mask = 1 << bloomBit;\r\n        // Use the raw bloomBit number to determine which bloom filter bucket we should check\r\n        // e.g: bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc\r\n        var b7 = bloomBit & 0x80;\r\n        var b6 = bloomBit & 0x40;\r\n        var b5 = bloomBit & 0x20;\r\n        var tData = tView.data;\r\n        if (b7) {\r\n            b6 ? (b5 ? (tData[injectorIndex + 7] |= mask) : (tData[injectorIndex + 6] |= mask)) :\r\n                (b5 ? (tData[injectorIndex + 5] |= mask) : (tData[injectorIndex + 4] |= mask));\r\n        }\r\n        else {\r\n            b6 ? (b5 ? (tData[injectorIndex + 3] |= mask) : (tData[injectorIndex + 2] |= mask)) :\r\n                (b5 ? (tData[injectorIndex + 1] |= mask) : (tData[injectorIndex] |= mask));\r\n        }\r\n    }\r\n    /**\r\n     * Creates (or gets an existing) injector for a given element or container.\r\n     *\r\n     * @param tNode for which an injector should be retrieved / created.\r\n     * @param hostView View where the node is stored\r\n     * @returns Node injector\r\n     */\r\n    function getOrCreateNodeInjectorForNode(tNode, hostView) {\r\n        var existingInjectorIndex = getInjectorIndex(tNode, hostView);\r\n        if (existingInjectorIndex !== -1) {\r\n            return existingInjectorIndex;\r\n        }\r\n        var tView = hostView[TVIEW];\r\n        if (tView.firstTemplatePass) {\r\n            tNode.injectorIndex = hostView.length;\r\n            insertBloom(tView.data, tNode); // foundation for node bloom\r\n            insertBloom(hostView, null); // foundation for cumulative bloom\r\n            insertBloom(tView.blueprint, null);\r\n            ngDevMode && assertEqual(tNode.flags === 0 || tNode.flags === 1 /* isComponent */, true, 'expected tNode.flags to not be initialized');\r\n        }\r\n        var parentLoc = getParentInjectorLocation(tNode, hostView);\r\n        var parentIndex = getParentInjectorIndex(parentLoc);\r\n        var parentLView = getParentInjectorView(parentLoc, hostView);\r\n        var injectorIndex = tNode.injectorIndex;\r\n        // If a parent injector can't be found, its location is set to -1.\r\n        // In that case, we don't need to set up a cumulative bloom\r\n        if (hasParentInjector(parentLoc)) {\r\n            var parentData = parentLView[TVIEW].data;\r\n            // Creates a cumulative bloom filter that merges the parent's bloom filter\r\n            // and its own cumulative bloom (which contains tokens for all ancestors)\r\n            for (var i = 0; i < 8; i++) {\r\n                hostView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];\r\n            }\r\n        }\r\n        hostView[injectorIndex + PARENT_INJECTOR] = parentLoc;\r\n        return injectorIndex;\r\n    }\r\n    function insertBloom(arr, footer) {\r\n        arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);\r\n    }\r\n    function getInjectorIndex(tNode, hostView) {\r\n        if (tNode.injectorIndex === -1 ||\r\n            // If the injector index is the same as its parent's injector index, then the index has been\r\n            // copied down from the parent node. No injector has been created yet on this node.\r\n            (tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex) ||\r\n            // After the first template pass, the injector index might exist but the parent values\r\n            // might not have been calculated yet for this instance\r\n            hostView[tNode.injectorIndex + PARENT_INJECTOR] == null) {\r\n            return -1;\r\n        }\r\n        else {\r\n            return tNode.injectorIndex;\r\n        }\r\n    }\r\n    /**\r\n     * Finds the index of the parent injector, with a view offset if applicable. Used to set the\r\n     * parent injector initially.\r\n     *\r\n     * Returns a combination of number of `ViewData` we have to go up and index in that `Viewdata`\r\n     */\r\n    function getParentInjectorLocation(tNode, view) {\r\n        if (tNode.parent && tNode.parent.injectorIndex !== -1) {\r\n            return tNode.parent.injectorIndex; // ViewOffset is 0\r\n        }\r\n        // For most cases, the parent injector index can be found on the host node (e.g. for component\r\n        // or container), so this loop will be skipped, but we must keep the loop here to support\r\n        // the rarer case of deeply nested <ng-template> tags or inline views.\r\n        var hostTNode = view[T_HOST];\r\n        var viewOffset = 1;\r\n        while (hostTNode && hostTNode.injectorIndex === -1) {\r\n            view = view[DECLARATION_VIEW];\r\n            hostTNode = view ? view[T_HOST] : null;\r\n            viewOffset++;\r\n        }\r\n        return hostTNode ?\r\n            hostTNode.injectorIndex | (viewOffset << 16 /* ViewOffsetShift */) :\r\n            -1;\r\n    }\r\n    /**\r\n     * Makes a type or an injection token public to the DI system by adding it to an\r\n     * injector's bloom filter.\r\n     *\r\n     * @param di The node injector in which a directive will be added\r\n     * @param token The type or the injection token to be made public\r\n     */\r\n    function diPublicInInjector(injectorIndex, tView, token) {\r\n        bloomAdd(injectorIndex, tView, token);\r\n    }\r\n    /**\r\n     * Inject static attribute value into directive constructor.\r\n     *\r\n     * This method is used with `factory` functions which are generated as part of\r\n     * `defineDirective` or `defineComponent`. The method retrieves the static value\r\n     * of an attribute. (Dynamic attributes are not supported since they are not resolved\r\n     *  at the time of injection and can change over time.)\r\n     *\r\n     * # Example\r\n     * Given:\r\n     * ```\r\n     * @Component(...)\r\n     * class MyComponent {\r\n     *   constructor(@Attribute('title') title: string) { ... }\r\n     * }\r\n     * ```\r\n     * When instantiated with\r\n     * ```\r\n     * <my-component title=\"Hello\"></my-component>\r\n     * ```\r\n     *\r\n     * Then factory method generated is:\r\n     * ```\r\n     * MyComponent.ngComponentDef = defineComponent({\r\n     *   factory: () => new MyComponent(injectAttribute('title'))\r\n     *   ...\r\n     * })\r\n     * ```\r\n     *\r\n     * @publicApi\r\n     */\r\n    function injectAttributeImpl(tNode, attrNameToInject) {\r\n        ngDevMode && assertNodeOfPossibleTypes(tNode, 0 /* Container */, 3 /* Element */, 4 /* ElementContainer */);\r\n        ngDevMode && assertDefined(tNode, 'expecting tNode');\r\n        if (attrNameToInject === 'class') {\r\n            return getInitialStylingValue(tNode.classes);\r\n        }\r\n        if (attrNameToInject === 'style') {\r\n            return getInitialStylingValue(tNode.styles);\r\n        }\r\n        var attrs = tNode.attrs;\r\n        if (attrs) {\r\n            var attrsLength = attrs.length;\r\n            var i = 0;\r\n            while (i < attrsLength) {\r\n                var value = attrs[i];\r\n                // If we hit a `Bindings` or `Template` marker then we are done.\r\n                if (isNameOnlyAttributeMarker(value))\r\n                    break;\r\n                // Skip namespaced attributes\r\n                if (value === 0 /* NamespaceURI */) {\r\n                    // we skip the next two values\r\n                    // as namespaced attributes looks like\r\n                    // [..., AttributeMarker.NamespaceURI, 'http://someuri.com/test', 'test:exist',\r\n                    // 'existValue', ...]\r\n                    i = i + 2;\r\n                }\r\n                else if (typeof value === 'number') {\r\n                    // Skip to the first value of the marked attribute.\r\n                    i++;\r\n                    while (i < attrsLength && typeof attrs[i] === 'string') {\r\n                        i++;\r\n                    }\r\n                }\r\n                else if (value === attrNameToInject) {\r\n                    return attrs[i + 1];\r\n                }\r\n                else {\r\n                    i = i + 2;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.\r\n     *\r\n     * Look for the injector providing the token by walking up the node injector tree and then\r\n     * the module injector tree.\r\n     *\r\n     * This function patches `token` with `__NG_ELEMENT_ID__` which contains the id for the bloom\r\n     * filter. Negative values are reserved for special objects.\r\n     *   - `-1` is reserved for injecting `Injector` (implemented by `NodeInjector`)\r\n     *\r\n     * @param tNode The Node where the search for the injector should start\r\n     * @param lView The `LView` that contains the `tNode`\r\n     * @param token The token to look for\r\n     * @param flags Injection flags\r\n     * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\r\n     * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\r\n     */\r\n    function getOrCreateInjectable(tNode, lView, token, flags, notFoundValue) {\r\n        if (flags === void 0) { flags = exports.InjectFlags.Default; }\r\n        if (tNode) {\r\n            var bloomHash = bloomHashBitOrFactory(token);\r\n            // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef\r\n            // so just call the factory function to create it.\r\n            if (typeof bloomHash === 'function') {\r\n                var savePreviousOrParentTNode = getPreviousOrParentTNode();\r\n                var saveLView = getLView();\r\n                setTNodeAndViewData(tNode, lView);\r\n                try {\r\n                    var value = bloomHash();\r\n                    if (value == null && !(flags & exports.InjectFlags.Optional)) {\r\n                        throw new Error(\"No provider for \" + stringifyForError(token) + \"!\");\r\n                    }\r\n                    else {\r\n                        return value;\r\n                    }\r\n                }\r\n                finally {\r\n                    setTNodeAndViewData(savePreviousOrParentTNode, saveLView);\r\n                }\r\n            }\r\n            else if (typeof bloomHash == 'number') {\r\n                if (bloomHash === -1) {\r\n                    // `-1` is a special value used to identify `Injector` types.\r\n                    return new NodeInjector(tNode, lView);\r\n                }\r\n                // If the token has a bloom hash, then it is a token which could be in NodeInjector.\r\n                // A reference to the previous injector TView that was found while climbing the element\r\n                // injector tree. This is used to know if viewProviders can be accessed on the current\r\n                // injector.\r\n                var previousTView = null;\r\n                var injectorIndex = getInjectorIndex(tNode, lView);\r\n                var parentLocation = NO_PARENT_INJECTOR;\r\n                var hostTElementNode = flags & exports.InjectFlags.Host ? findComponentView(lView)[T_HOST] : null;\r\n                // If we should skip this injector, or if there is no injector on this node, start by\r\n                // searching\r\n                // the parent injector.\r\n                if (injectorIndex === -1 || flags & exports.InjectFlags.SkipSelf) {\r\n                    parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) :\r\n                        lView[injectorIndex + PARENT_INJECTOR];\r\n                    if (!shouldSearchParent(flags, false)) {\r\n                        injectorIndex = -1;\r\n                    }\r\n                    else {\r\n                        previousTView = lView[TVIEW];\r\n                        injectorIndex = getParentInjectorIndex(parentLocation);\r\n                        lView = getParentInjectorView(parentLocation, lView);\r\n                    }\r\n                }\r\n                // Traverse up the injector tree until we find a potential match or until we know there\r\n                // *isn't* a match.\r\n                while (injectorIndex !== -1) {\r\n                    parentLocation = lView[injectorIndex + PARENT_INJECTOR];\r\n                    // Check the current injector. If it matches, see if it contains token.\r\n                    var tView = lView[TVIEW];\r\n                    if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {\r\n                        // At this point, we have an injector which *may* contain the token, so we step through\r\n                        // the providers and directives associated with the injector's corresponding node to get\r\n                        // the instance.\r\n                        var instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);\r\n                        if (instance !== NOT_FOUND) {\r\n                            return instance;\r\n                        }\r\n                    }\r\n                    if (shouldSearchParent(flags, lView[TVIEW].data[injectorIndex + TNODE] === hostTElementNode) &&\r\n                        bloomHasToken(bloomHash, injectorIndex, lView)) {\r\n                        // The def wasn't found anywhere on this node, so it was a false positive.\r\n                        // Traverse up the tree and continue searching.\r\n                        previousTView = tView;\r\n                        injectorIndex = getParentInjectorIndex(parentLocation);\r\n                        lView = getParentInjectorView(parentLocation, lView);\r\n                    }\r\n                    else {\r\n                        // If we should not search parent OR If the ancestor bloom filter value does not have the\r\n                        // bit corresponding to the directive we can give up on traversing up to find the specific\r\n                        // injector.\r\n                        injectorIndex = -1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (flags & exports.InjectFlags.Optional && notFoundValue === undefined) {\r\n            // This must be set or the NullInjector will throw for optional deps\r\n            notFoundValue = null;\r\n        }\r\n        if ((flags & (exports.InjectFlags.Self | exports.InjectFlags.Host)) === 0) {\r\n            var moduleInjector = lView[INJECTOR$1];\r\n            // switch to `injectInjectorOnly` implementation for module injector, since module injector\r\n            // should not have access to Component/Directive DI scope (that may happen through\r\n            // `directiveInject` implementation)\r\n            var previousInjectImplementation = setInjectImplementation(undefined);\r\n            try {\r\n                if (moduleInjector) {\r\n                    return moduleInjector.get(token, notFoundValue, flags & exports.InjectFlags.Optional);\r\n                }\r\n                else {\r\n                    return injectRootLimpMode(token, notFoundValue, flags & exports.InjectFlags.Optional);\r\n                }\r\n            }\r\n            finally {\r\n                setInjectImplementation(previousInjectImplementation);\r\n            }\r\n        }\r\n        if (flags & exports.InjectFlags.Optional) {\r\n            return notFoundValue;\r\n        }\r\n        else {\r\n            throw new Error(\"NodeInjector: NOT_FOUND [\" + stringifyForError(token) + \"]\");\r\n        }\r\n    }\r\n    var NOT_FOUND = {};\r\n    function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {\r\n        var currentTView = lView[TVIEW];\r\n        var tNode = currentTView.data[injectorIndex + TNODE];\r\n        // First, we need to determine if view providers can be accessed by the starting element.\r\n        // There are two possibities\r\n        var canAccessViewProviders = previousTView == null ?\r\n            // 1) This is the first invocation `previousTView == null` which means that we are at the\r\n            // `TNode` of where injector is starting to look. In such a case the only time we are allowed\r\n            // to look into the ViewProviders is if:\r\n            // - we are on a component\r\n            // - AND the injector set `includeViewProviders` to true (implying that the token can see\r\n            // ViewProviders because it is the Component or a Service which itself was declared in\r\n            // ViewProviders)\r\n            (isComponent(tNode) && includeViewProviders) :\r\n            // 2) `previousTView != null` which means that we are now walking across the parent nodes.\r\n            // In such a case we are only allowed to look into the ViewProviders if:\r\n            // - We just crossed from child View to Parent View `previousTView != currentTView`\r\n            // - AND the parent TNode is an Element.\r\n            // This means that we just came from the Component's View and therefore are allowed to see\r\n            // into the ViewProviders.\r\n            (previousTView != currentTView && (tNode.type === 3 /* Element */));\r\n        // This special case happens when there is a @host on the inject and when we are searching\r\n        // on the host element node.\r\n        var isHostSpecialCase = (flags & exports.InjectFlags.Host) && hostTElementNode === tNode;\r\n        var injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);\r\n        if (injectableIdx !== null) {\r\n            return getNodeInjectable(currentTView.data, lView, injectableIdx, tNode);\r\n        }\r\n        else {\r\n            return NOT_FOUND;\r\n        }\r\n    }\r\n    /**\r\n     * Searches for the given token among the node's directives and providers.\r\n     *\r\n     * @param tNode TNode on which directives are present.\r\n     * @param tView The tView we are currently processing\r\n     * @param token Provider token or type of a directive to look for.\r\n     * @param canAccessViewProviders Whether view providers should be considered.\r\n     * @param isHostSpecialCase Whether the host special case applies.\r\n     * @returns Index of a found directive or provider, or null when none found.\r\n     */\r\n    function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {\r\n        var nodeProviderIndexes = tNode.providerIndexes;\r\n        var tInjectables = tView.data;\r\n        var injectablesStart = nodeProviderIndexes & 65535 /* ProvidersStartIndexMask */;\r\n        var directivesStart = tNode.directiveStart;\r\n        var directiveEnd = tNode.directiveEnd;\r\n        var cptViewProvidersCount = nodeProviderIndexes >> 16 /* CptViewProvidersCountShift */;\r\n        var startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;\r\n        // When the host special case applies, only the viewProviders and the component are visible\r\n        var endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;\r\n        for (var i = startingIndex; i < endIndex; i++) {\r\n            var providerTokenOrDef = tInjectables[i];\r\n            if (i < directivesStart && token === providerTokenOrDef ||\r\n                i >= directivesStart && providerTokenOrDef.type === token) {\r\n                return i;\r\n            }\r\n        }\r\n        if (isHostSpecialCase) {\r\n            var dirDef = tInjectables[directivesStart];\r\n            if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {\r\n                return directivesStart;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n    * Retrieve or instantiate the injectable from the `lData` at particular `index`.\r\n    *\r\n    * This function checks to see if the value has already been instantiated and if so returns the\r\n    * cached `injectable`. Otherwise if it detects that the value is still a factory it\r\n    * instantiates the `injectable` and caches the value.\r\n    */\r\n    function getNodeInjectable(tData, lData, index, tNode) {\r\n        var value = lData[index];\r\n        if (isFactory(value)) {\r\n            var factory = value;\r\n            if (factory.resolving) {\r\n                throw new Error(\"Circular dep for \" + stringifyForError(tData[index]));\r\n            }\r\n            var previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);\r\n            factory.resolving = true;\r\n            var previousInjectImplementation = void 0;\r\n            if (factory.injectImpl) {\r\n                previousInjectImplementation = setInjectImplementation(factory.injectImpl);\r\n            }\r\n            var savePreviousOrParentTNode = getPreviousOrParentTNode();\r\n            var saveLView = getLView();\r\n            setTNodeAndViewData(tNode, lData);\r\n            try {\r\n                value = lData[index] = factory.factory(undefined, tData, lData, tNode);\r\n            }\r\n            finally {\r\n                if (factory.injectImpl)\r\n                    setInjectImplementation(previousInjectImplementation);\r\n                setIncludeViewProviders(previousIncludeViewProviders);\r\n                factory.resolving = false;\r\n                setTNodeAndViewData(savePreviousOrParentTNode, saveLView);\r\n            }\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n     * Returns the bit in an injector's bloom filter that should be used to determine whether or not\r\n     * the directive might be provided by the injector.\r\n     *\r\n     * When a directive is public, it is added to the bloom filter and given a unique ID that can be\r\n     * retrieved on the Type. When the directive isn't public or the token is not a directive `null`\r\n     * is returned as the node injector can not possibly provide that token.\r\n     *\r\n     * @param token the injection token\r\n     * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\r\n     *   When the returned value is negative then it represents special values such as `Injector`.\r\n     */\r\n    function bloomHashBitOrFactory(token) {\r\n        ngDevMode && assertDefined(token, 'token must be defined');\r\n        if (typeof token === 'string') {\r\n            return token.charCodeAt(0) || 0;\r\n        }\r\n        var tokenId = token[NG_ELEMENT_ID];\r\n        // Negative token IDs are used for special objects such as `Injector`\r\n        return (typeof tokenId === 'number' && tokenId > 0) ? tokenId & BLOOM_MASK : tokenId;\r\n    }\r\n    function bloomHasToken(bloomHash, injectorIndex, injectorView) {\r\n        // Create a mask that targets the specific bit associated with the directive we're looking for.\r\n        // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\r\n        // to bit positions 0 - 31 in a 32 bit integer.\r\n        var mask = 1 << bloomHash;\r\n        var b7 = bloomHash & 0x80;\r\n        var b6 = bloomHash & 0x40;\r\n        var b5 = bloomHash & 0x20;\r\n        // Our bloom filter size is 256 bits, which is eight 32-bit bloom filter buckets:\r\n        // bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc.\r\n        // Get the bloom filter value from the appropriate bucket based on the directive's bloomBit.\r\n        var value;\r\n        if (b7) {\r\n            value = b6 ? (b5 ? injectorView[injectorIndex + 7] : injectorView[injectorIndex + 6]) :\r\n                (b5 ? injectorView[injectorIndex + 5] : injectorView[injectorIndex + 4]);\r\n        }\r\n        else {\r\n            value = b6 ? (b5 ? injectorView[injectorIndex + 3] : injectorView[injectorIndex + 2]) :\r\n                (b5 ? injectorView[injectorIndex + 1] : injectorView[injectorIndex]);\r\n        }\r\n        // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\r\n        // this injector is a potential match.\r\n        return !!(value & mask);\r\n    }\r\n    /** Returns true if flags prevent parent injector from being searched for tokens */\r\n    function shouldSearchParent(flags, isFirstHostTNode) {\r\n        return !(flags & exports.InjectFlags.Self) && !(flags & exports.InjectFlags.Host && isFirstHostTNode);\r\n    }\r\n    var NodeInjector = /** @class */ (function () {\r\n        function NodeInjector(_tNode, _lView) {\r\n            this._tNode = _tNode;\r\n            this._lView = _lView;\r\n        }\r\n        NodeInjector.prototype.get = function (token, notFoundValue) {\r\n            return getOrCreateInjectable(this._tNode, this._lView, token, undefined, notFoundValue);\r\n        };\r\n        return NodeInjector;\r\n    }());\r\n    /**\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵgetFactoryOf(type) {\r\n        var typeAny = type;\r\n        var def = getComponentDef(typeAny) || getDirectiveDef(typeAny) ||\r\n            getPipeDef(typeAny) || getInjectableDef(typeAny) || getInjectorDef(typeAny);\r\n        if (!def || def.factory === undefined) {\r\n            return null;\r\n        }\r\n        return def.factory;\r\n    }\r\n    /**\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵgetInheritedFactory(type) {\r\n        var proto = Object.getPrototypeOf(type.prototype).constructor;\r\n        var factory = ɵɵgetFactoryOf(proto);\r\n        if (factory !== null) {\r\n            return factory;\r\n        }\r\n        else {\r\n            // There is no factory defined. Either this was improper usage of inheritance\r\n            // (no Angular decorator on the superclass) or there is no constructor at all\r\n            // in the inheritance chain. Since the two cases cannot be distinguished, the\r\n            // latter has to be assumed.\r\n            return function (t) { return new t(); };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var ERROR_TYPE = 'ngType';\r\n    var ERROR_DEBUG_CONTEXT = 'ngDebugContext';\r\n    var ERROR_ORIGINAL_ERROR = 'ngOriginalError';\r\n    var ERROR_LOGGER = 'ngErrorLogger';\r\n    function wrappedError(message, originalError) {\r\n        var msg = message + \" caused by: \" + (originalError instanceof Error ? originalError.message : originalError);\r\n        var error = Error(msg);\r\n        error[ERROR_ORIGINAL_ERROR] = originalError;\r\n        return error;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function getType(error) {\r\n        return error[ERROR_TYPE];\r\n    }\r\n    function getDebugContext(error) {\r\n        return error[ERROR_DEBUG_CONTEXT];\r\n    }\r\n    function getOriginalError(error) {\r\n        return error[ERROR_ORIGINAL_ERROR];\r\n    }\r\n    function getErrorLogger(error) {\r\n        return error[ERROR_LOGGER] || defaultErrorLogger;\r\n    }\r\n    function defaultErrorLogger(console) {\r\n        var values = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            values[_i - 1] = arguments[_i];\r\n        }\r\n        console.error.apply(console, __spread(values));\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Provides a hook for centralized exception handling.\r\n     *\r\n     * The default implementation of `ErrorHandler` prints error messages to the `console`. To\r\n     * intercept error handling, write a custom exception handler that replaces this default as\r\n     * appropriate for your app.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```\r\n     * class MyErrorHandler implements ErrorHandler {\r\n     *   handleError(error) {\r\n     *     // do something with the exception\r\n     *   }\r\n     * }\r\n     *\r\n     * @NgModule({\r\n     *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\r\n     * })\r\n     * class MyModule {}\r\n     * ```\r\n     *\r\n     * @publicApi\r\n     */\r\n    var ErrorHandler = /** @class */ (function () {\r\n        function ErrorHandler() {\r\n            /**\r\n             * @internal\r\n             */\r\n            this._console = console;\r\n        }\r\n        ErrorHandler.prototype.handleError = function (error) {\r\n            var originalError = this._findOriginalError(error);\r\n            var context = this._findContext(error);\r\n            // Note: Browser consoles show the place from where console.error was called.\r\n            // We can use this to give users additional information about the error.\r\n            var errorLogger = getErrorLogger(error);\r\n            errorLogger(this._console, \"ERROR\", error);\r\n            if (originalError) {\r\n                errorLogger(this._console, \"ORIGINAL ERROR\", originalError);\r\n            }\r\n            if (context) {\r\n                errorLogger(this._console, 'ERROR CONTEXT', context);\r\n            }\r\n        };\r\n        /** @internal */\r\n        ErrorHandler.prototype._findContext = function (error) {\r\n            if (error) {\r\n                return getDebugContext(error) ? getDebugContext(error) :\r\n                    this._findContext(getOriginalError(error));\r\n            }\r\n            return null;\r\n        };\r\n        /** @internal */\r\n        ErrorHandler.prototype._findOriginalError = function (error) {\r\n            var e = getOriginalError(error);\r\n            while (e && getOriginalError(e)) {\r\n                e = getOriginalError(e);\r\n            }\r\n            return e;\r\n        };\r\n        return ErrorHandler;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Defines a schema that allows an NgModule to contain the following:\r\n     * - Non-Angular elements named with dash case (`-`).\r\n     * - Element properties named with dash case (`-`).\r\n     * Dash case is the naming convention for custom elements.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var CUSTOM_ELEMENTS_SCHEMA = {\r\n        name: 'custom-elements'\r\n    };\r\n    /**\r\n     * Defines a schema that allows any property on any element.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var NO_ERRORS_SCHEMA = {\r\n        name: 'no-errors-schema'\r\n    };\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var BRAND = '__SANITIZER_TRUSTED_BRAND__';\r\n    function allowSanitizationBypass(value, type) {\r\n        return (value instanceof String && value[BRAND] === type);\r\n    }\r\n    /**\r\n     * Mark `html` string as trusted.\r\n     *\r\n     * This function wraps the trusted string in `String` and brands it in a way which makes it\r\n     * recognizable to {@link htmlSanitizer} to be trusted implicitly.\r\n     *\r\n     * @param trustedHtml `html` string which needs to be implicitly trusted.\r\n     * @returns a `html` `String` which has been branded to be implicitly trusted.\r\n     */\r\n    function bypassSanitizationTrustHtml(trustedHtml) {\r\n        return bypassSanitizationTrustString(trustedHtml, \"Html\" /* Html */);\r\n    }\r\n    /**\r\n     * Mark `style` string as trusted.\r\n     *\r\n     * This function wraps the trusted string in `String` and brands it in a way which makes it\r\n     * recognizable to {@link styleSanitizer} to be trusted implicitly.\r\n     *\r\n     * @param trustedStyle `style` string which needs to be implicitly trusted.\r\n     * @returns a `style` `String` which has been branded to be implicitly trusted.\r\n     */\r\n    function bypassSanitizationTrustStyle(trustedStyle) {\r\n        return bypassSanitizationTrustString(trustedStyle, \"Style\" /* Style */);\r\n    }\r\n    /**\r\n     * Mark `script` string as trusted.\r\n     *\r\n     * This function wraps the trusted string in `String` and brands it in a way which makes it\r\n     * recognizable to {@link scriptSanitizer} to be trusted implicitly.\r\n     *\r\n     * @param trustedScript `script` string which needs to be implicitly trusted.\r\n     * @returns a `script` `String` which has been branded to be implicitly trusted.\r\n     */\r\n    function bypassSanitizationTrustScript(trustedScript) {\r\n        return bypassSanitizationTrustString(trustedScript, \"Script\" /* Script */);\r\n    }\r\n    /**\r\n     * Mark `url` string as trusted.\r\n     *\r\n     * This function wraps the trusted string in `String` and brands it in a way which makes it\r\n     * recognizable to {@link urlSanitizer} to be trusted implicitly.\r\n     *\r\n     * @param trustedUrl `url` string which needs to be implicitly trusted.\r\n     * @returns a `url` `String` which has been branded to be implicitly trusted.\r\n     */\r\n    function bypassSanitizationTrustUrl(trustedUrl) {\r\n        return bypassSanitizationTrustString(trustedUrl, \"Url\" /* Url */);\r\n    }\r\n    /**\r\n     * Mark `url` string as trusted.\r\n     *\r\n     * This function wraps the trusted string in `String` and brands it in a way which makes it\r\n     * recognizable to {@link resourceUrlSanitizer} to be trusted implicitly.\r\n     *\r\n     * @param trustedResourceUrl `url` string which needs to be implicitly trusted.\r\n     * @returns a `url` `String` which has been branded to be implicitly trusted.\r\n     */\r\n    function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {\r\n        return bypassSanitizationTrustString(trustedResourceUrl, \"ResourceUrl\" /* ResourceUrl */);\r\n    }\r\n    function bypassSanitizationTrustString(trustedString, mode) {\r\n        // tslint:disable-next-line\r\n        var trusted = new String(trustedString);\r\n        trusted[BRAND] = mode;\r\n        return trusted;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * This file is used to control if the default rendering pipeline should be `ViewEngine` or `Ivy`.\r\n     *\r\n     * For more information on how to run and debug tests with either Ivy or View Engine (legacy),\r\n     * please see [BAZEL.md](./docs/BAZEL.md).\r\n     */\r\n    var _devMode = true;\r\n    var _runModeLocked = false;\r\n    /**\r\n     * Returns whether Angular is in development mode. After called once,\r\n     * the value is locked and won't change any more.\r\n     *\r\n     * By default, this is true, unless a user calls `enableProdMode` before calling this.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function isDevMode() {\r\n        _runModeLocked = true;\r\n        return _devMode;\r\n    }\r\n    /**\r\n     * Disable Angular's development mode, which turns off assertions and other\r\n     * checks within the framework.\r\n     *\r\n     * One important assertion this disables verifies that a change detection pass\r\n     * does not result in additional changes to any bindings (also known as\r\n     * unidirectional data flow).\r\n     *\r\n     * @publicApi\r\n     */\r\n    function enableProdMode() {\r\n        if (_runModeLocked) {\r\n            throw new Error('Cannot enable prod mode after platform setup.');\r\n        }\r\n        _devMode = false;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * This helper class is used to get hold of an inert tree of DOM elements containing dirty HTML\r\n     * that needs sanitizing.\r\n     * Depending upon browser support we must use one of three strategies for doing this.\r\n     * Support: Safari 10.x -> XHR strategy\r\n     * Support: Firefox -> DomParser strategy\r\n     * Default: InertDocument strategy\r\n     */\r\n    var InertBodyHelper = /** @class */ (function () {\r\n        function InertBodyHelper(defaultDoc) {\r\n            this.defaultDoc = defaultDoc;\r\n            this.inertDocument = this.defaultDoc.implementation.createHTMLDocument('sanitization-inert');\r\n            this.inertBodyElement = this.inertDocument.body;\r\n            if (this.inertBodyElement == null) {\r\n                // usually there should be only one body element in the document, but IE doesn't have any, so\r\n                // we need to create one.\r\n                var inertHtml = this.inertDocument.createElement('html');\r\n                this.inertDocument.appendChild(inertHtml);\r\n                this.inertBodyElement = this.inertDocument.createElement('body');\r\n                inertHtml.appendChild(this.inertBodyElement);\r\n            }\r\n            this.inertBodyElement.innerHTML = '<svg><g onload=\"this.parentNode.remove()\"></g></svg>';\r\n            if (this.inertBodyElement.querySelector && !this.inertBodyElement.querySelector('svg')) {\r\n                // We just hit the Safari 10.1 bug - which allows JS to run inside the SVG G element\r\n                // so use the XHR strategy.\r\n                this.getInertBodyElement = this.getInertBodyElement_XHR;\r\n                return;\r\n            }\r\n            this.inertBodyElement.innerHTML =\r\n                '<svg><p><style><img src=\"</style><img src=x onerror=alert(1)//\">';\r\n            if (this.inertBodyElement.querySelector && this.inertBodyElement.querySelector('svg img')) {\r\n                // We just hit the Firefox bug - which prevents the inner img JS from being sanitized\r\n                // so use the DOMParser strategy, if it is available.\r\n                // If the DOMParser is not available then we are not in Firefox (Server/WebWorker?) so we\r\n                // fall through to the default strategy below.\r\n                if (isDOMParserAvailable()) {\r\n                    this.getInertBodyElement = this.getInertBodyElement_DOMParser;\r\n                    return;\r\n                }\r\n            }\r\n            // None of the bugs were hit so it is safe for us to use the default InertDocument strategy\r\n            this.getInertBodyElement = this.getInertBodyElement_InertDocument;\r\n        }\r\n        /**\r\n         * Use XHR to create and fill an inert body element (on Safari 10.1)\r\n         * See\r\n         * https://github.com/cure53/DOMPurify/blob/a992d3a75031cb8bb032e5ea8399ba972bdf9a65/src/purify.js#L439-L449\r\n         */\r\n        InertBodyHelper.prototype.getInertBodyElement_XHR = function (html) {\r\n            // We add these extra elements to ensure that the rest of the content is parsed as expected\r\n            // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\r\n            // `<head>` tag.\r\n            html = '<body><remove></remove>' + html + '</body>';\r\n            try {\r\n                html = encodeURI(html);\r\n            }\r\n            catch (_a) {\r\n                return null;\r\n            }\r\n            var xhr = new XMLHttpRequest();\r\n            xhr.responseType = 'document';\r\n            xhr.open('GET', 'data:text/html;charset=utf-8,' + html, false);\r\n            xhr.send(undefined);\r\n            var body = xhr.response.body;\r\n            body.removeChild(body.firstChild);\r\n            return body;\r\n        };\r\n        /**\r\n         * Use DOMParser to create and fill an inert body element (on Firefox)\r\n         * See https://github.com/cure53/DOMPurify/releases/tag/0.6.7\r\n         *\r\n         */\r\n        InertBodyHelper.prototype.getInertBodyElement_DOMParser = function (html) {\r\n            // We add these extra elements to ensure that the rest of the content is parsed as expected\r\n            // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\r\n            // `<head>` tag.\r\n            html = '<body><remove></remove>' + html + '</body>';\r\n            try {\r\n                var body = new window\r\n                    .DOMParser()\r\n                    .parseFromString(html, 'text/html')\r\n                    .body;\r\n                body.removeChild(body.firstChild);\r\n                return body;\r\n            }\r\n            catch (_a) {\r\n                return null;\r\n            }\r\n        };\r\n        /**\r\n         * Use an HTML5 `template` element, if supported, or an inert body element created via\r\n         * `createHtmlDocument` to create and fill an inert DOM element.\r\n         * This is the default sane strategy to use if the browser does not require one of the specialised\r\n         * strategies above.\r\n         */\r\n        InertBodyHelper.prototype.getInertBodyElement_InertDocument = function (html) {\r\n            // Prefer using <template> element if supported.\r\n            var templateEl = this.inertDocument.createElement('template');\r\n            if ('content' in templateEl) {\r\n                templateEl.innerHTML = html;\r\n                return templateEl;\r\n            }\r\n            this.inertBodyElement.innerHTML = html;\r\n            // Support: IE 9-11 only\r\n            // strip custom-namespaced attributes on IE<=11\r\n            if (this.defaultDoc.documentMode) {\r\n                this.stripCustomNsAttrs(this.inertBodyElement);\r\n            }\r\n            return this.inertBodyElement;\r\n        };\r\n        /**\r\n         * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'\r\n         * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g.\r\n         * 'ns1:xlink:foo').\r\n         *\r\n         * This is undesirable since we don't want to allow any of these custom attributes. This method\r\n         * strips them all.\r\n         */\r\n        InertBodyHelper.prototype.stripCustomNsAttrs = function (el) {\r\n            var elAttrs = el.attributes;\r\n            // loop backwards so that we can support removals.\r\n            for (var i = elAttrs.length - 1; 0 < i; i--) {\r\n                var attrib = elAttrs.item(i);\r\n                var attrName = attrib.name;\r\n                if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {\r\n                    el.removeAttribute(attrName);\r\n                }\r\n            }\r\n            var childNode = el.firstChild;\r\n            while (childNode) {\r\n                if (childNode.nodeType === Node.ELEMENT_NODE)\r\n                    this.stripCustomNsAttrs(childNode);\r\n                childNode = childNode.nextSibling;\r\n            }\r\n        };\r\n        return InertBodyHelper;\r\n    }());\r\n    /**\r\n     * We need to determine whether the DOMParser exists in the global context.\r\n     * The try-catch is because, on some browsers, trying to access this property\r\n     * on window can actually throw an error.\r\n     *\r\n     * @suppress {uselessCode}\r\n     */\r\n    function isDOMParserAvailable() {\r\n        try {\r\n            return !!window.DOMParser;\r\n        }\r\n        catch (_a) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * A pattern that recognizes a commonly useful subset of URLs that are safe.\r\n     *\r\n     * This regular expression matches a subset of URLs that will not cause script\r\n     * execution if used in URL context within a HTML document. Specifically, this\r\n     * regular expression matches if (comment from here on and regex copied from\r\n     * Soy's EscapingConventions):\r\n     * (1) Either an allowed protocol (http, https, mailto or ftp).\r\n     * (2) or no protocol.  A protocol must be followed by a colon. The below\r\n     *     allows that by allowing colons only after one of the characters [/?#].\r\n     *     A colon after a hash (#) must be in the fragment.\r\n     *     Otherwise, a colon after a (?) must be in a query.\r\n     *     Otherwise, a colon after a single solidus (/) must be in a path.\r\n     *     Otherwise, a colon after a double solidus (//) must be in the authority\r\n     *     (before port).\r\n     *\r\n     * The pattern disallows &, used in HTML entity declarations before\r\n     * one of the characters in [/?#]. This disallows HTML entities used in the\r\n     * protocol name, which should never happen, e.g. \"h&#116;tp\" for \"http\".\r\n     * It also disallows HTML entities in the first path part of a relative path,\r\n     * e.g. \"foo&lt;bar/baz\".  Our existing escaping functions should not produce\r\n     * that. More importantly, it disallows masking of a colon,\r\n     * e.g. \"javascript&#58;...\".\r\n     *\r\n     * This regular expression was taken from the Closure sanitization library.\r\n     */\r\n    var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;\r\n    /* A pattern that matches safe srcset values */\r\n    var SAFE_SRCSET_PATTERN = /^(?:(?:https?|file):|[^&:/?#]*(?:[/?#]|$))/gi;\r\n    /** A pattern that matches safe data URLs. Only matches image, video and audio types. */\r\n    var DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\\/]+=*$/i;\r\n    function _sanitizeUrl(url) {\r\n        url = String(url);\r\n        if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))\r\n            return url;\r\n        if (isDevMode()) {\r\n            console.warn(\"WARNING: sanitizing unsafe URL value \" + url + \" (see http://g.co/ng/security#xss)\");\r\n        }\r\n        return 'unsafe:' + url;\r\n    }\r\n    function sanitizeSrcset(srcset) {\r\n        srcset = String(srcset);\r\n        return srcset.split(',').map(function (srcset) { return _sanitizeUrl(srcset.trim()); }).join(', ');\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function tagSet(tags) {\r\n        var e_1, _a;\r\n        var res = {};\r\n        try {\r\n            for (var _b = __values(tags.split(',')), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var t = _c.value;\r\n                res[t] = true;\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return res;\r\n    }\r\n    function merge() {\r\n        var e_2, _a;\r\n        var sets = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            sets[_i] = arguments[_i];\r\n        }\r\n        var res = {};\r\n        try {\r\n            for (var sets_1 = __values(sets), sets_1_1 = sets_1.next(); !sets_1_1.done; sets_1_1 = sets_1.next()) {\r\n                var s = sets_1_1.value;\r\n                for (var v in s) {\r\n                    if (s.hasOwnProperty(v))\r\n                        res[v] = true;\r\n                }\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (sets_1_1 && !sets_1_1.done && (_a = sets_1.return)) _a.call(sets_1);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        return res;\r\n    }\r\n    // Good source of info about elements and attributes\r\n    // http://dev.w3.org/html5/spec/Overview.html#semantics\r\n    // http://simon.html5.org/html-elements\r\n    // Safe Void Elements - HTML5\r\n    // http://dev.w3.org/html5/spec/Overview.html#void-elements\r\n    var VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');\r\n    // Elements that you can, intentionally, leave open (and which close themselves)\r\n    // http://dev.w3.org/html5/spec/Overview.html#optional-tags\r\n    var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');\r\n    var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');\r\n    var OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);\r\n    // Safe Block Elements - HTML5\r\n    var BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' +\r\n        'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +\r\n        'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));\r\n    // Inline Elements - HTML5\r\n    var INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' +\r\n        'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +\r\n        'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));\r\n    var VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);\r\n    // Attributes that have href and hence need to be sanitized\r\n    var URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');\r\n    // Attributes that have special href set hence need to be sanitized\r\n    var SRCSET_ATTRS = tagSet('srcset');\r\n    var HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +\r\n        'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +\r\n        'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +\r\n        'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' +\r\n        'valign,value,vspace,width');\r\n    // Accessibility attributes as per WAI-ARIA 1.1 (W3C Working Draft 14 December 2018)\r\n    var ARIA_ATTRS = tagSet('aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,' +\r\n        'aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,' +\r\n        'aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,' +\r\n        'aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,' +\r\n        'aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,' +\r\n        'aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,' +\r\n        'aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext');\r\n    // NB: This currently consciously doesn't support SVG. SVG sanitization has had several security\r\n    // issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via\r\n    // innerHTML is required, SVG attributes should be added here.\r\n    // NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those\r\n    // can be sanitized, but they increase security surface area without a legitimate use case, so they\r\n    // are left out here.\r\n    var VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS, ARIA_ATTRS);\r\n    // Elements whose content should not be traversed/preserved, if the elements themselves are invalid.\r\n    //\r\n    // Typically, `<invalid>Some content</invalid>` would traverse (and in this case preserve)\r\n    // `Some content`, but strip `invalid-element` opening/closing tags. For some elements, though, we\r\n    // don't want to preserve the content, if the elements themselves are going to be removed.\r\n    var SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet('script,style,template');\r\n    /**\r\n     * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe\r\n     * attributes.\r\n     */\r\n    var SanitizingHtmlSerializer = /** @class */ (function () {\r\n        function SanitizingHtmlSerializer() {\r\n            // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just\r\n            // because characters were re-encoded.\r\n            this.sanitizedSomething = false;\r\n            this.buf = [];\r\n        }\r\n        SanitizingHtmlSerializer.prototype.sanitizeChildren = function (el) {\r\n            // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.\r\n            // However this code never accesses properties off of `document` before deleting its contents\r\n            // again, so it shouldn't be vulnerable to DOM clobbering.\r\n            var current = el.firstChild;\r\n            var traverseContent = true;\r\n            while (current) {\r\n                if (current.nodeType === Node.ELEMENT_NODE) {\r\n                    traverseContent = this.startElement(current);\r\n                }\r\n                else if (current.nodeType === Node.TEXT_NODE) {\r\n                    this.chars(current.nodeValue);\r\n                }\r\n                else {\r\n                    // Strip non-element, non-text nodes.\r\n                    this.sanitizedSomething = true;\r\n                }\r\n                if (traverseContent && current.firstChild) {\r\n                    current = current.firstChild;\r\n                    continue;\r\n                }\r\n                while (current) {\r\n                    // Leaving the element. Walk up and to the right, closing tags as we go.\r\n                    if (current.nodeType === Node.ELEMENT_NODE) {\r\n                        this.endElement(current);\r\n                    }\r\n                    var next = this.checkClobberedElement(current, current.nextSibling);\r\n                    if (next) {\r\n                        current = next;\r\n                        break;\r\n                    }\r\n                    current = this.checkClobberedElement(current, current.parentNode);\r\n                }\r\n            }\r\n            return this.buf.join('');\r\n        };\r\n        /**\r\n         * Sanitizes an opening element tag (if valid) and returns whether the element's contents should\r\n         * be traversed. Element content must always be traversed (even if the element itself is not\r\n         * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.\r\n         *\r\n         * @param element The element to sanitize.\r\n         * @return True if the element's contents should be traversed.\r\n         */\r\n        SanitizingHtmlSerializer.prototype.startElement = function (element) {\r\n            var tagName = element.nodeName.toLowerCase();\r\n            if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\r\n                this.sanitizedSomething = true;\r\n                return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);\r\n            }\r\n            this.buf.push('<');\r\n            this.buf.push(tagName);\r\n            var elAttrs = element.attributes;\r\n            for (var i = 0; i < elAttrs.length; i++) {\r\n                var elAttr = elAttrs.item(i);\r\n                var attrName = elAttr.name;\r\n                var lower = attrName.toLowerCase();\r\n                if (!VALID_ATTRS.hasOwnProperty(lower)) {\r\n                    this.sanitizedSomething = true;\r\n                    continue;\r\n                }\r\n                var value = elAttr.value;\r\n                // TODO(martinprobst): Special case image URIs for data:image/...\r\n                if (URI_ATTRS[lower])\r\n                    value = _sanitizeUrl(value);\r\n                if (SRCSET_ATTRS[lower])\r\n                    value = sanitizeSrcset(value);\r\n                this.buf.push(' ', attrName, '=\"', encodeEntities(value), '\"');\r\n            }\r\n            this.buf.push('>');\r\n            return true;\r\n        };\r\n        SanitizingHtmlSerializer.prototype.endElement = function (current) {\r\n            var tagName = current.nodeName.toLowerCase();\r\n            if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {\r\n                this.buf.push('</');\r\n                this.buf.push(tagName);\r\n                this.buf.push('>');\r\n            }\r\n        };\r\n        SanitizingHtmlSerializer.prototype.chars = function (chars) { this.buf.push(encodeEntities(chars)); };\r\n        SanitizingHtmlSerializer.prototype.checkClobberedElement = function (node, nextNode) {\r\n            if (nextNode &&\r\n                (node.compareDocumentPosition(nextNode) &\r\n                    Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) {\r\n                throw new Error(\"Failed to sanitize html because the element is clobbered: \" + node.outerHTML);\r\n            }\r\n            return nextNode;\r\n        };\r\n        return SanitizingHtmlSerializer;\r\n    }());\r\n    // Regular Expressions for parsing tags and attributes\r\n    var SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\r\n    // ! to ~ is the ASCII range.\r\n    var NON_ALPHANUMERIC_REGEXP = /([^\\#-~ |!])/g;\r\n    /**\r\n     * Escapes all potentially dangerous characters, so that the\r\n     * resulting string can be safely inserted into attribute or\r\n     * element text.\r\n     * @param value\r\n     */\r\n    function encodeEntities(value) {\r\n        return value.replace(/&/g, '&amp;')\r\n            .replace(SURROGATE_PAIR_REGEXP, function (match) {\r\n            var hi = match.charCodeAt(0);\r\n            var low = match.charCodeAt(1);\r\n            return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\r\n        })\r\n            .replace(NON_ALPHANUMERIC_REGEXP, function (match) { return '&#' + match.charCodeAt(0) + ';'; })\r\n            .replace(/</g, '&lt;')\r\n            .replace(/>/g, '&gt;');\r\n    }\r\n    var inertBodyHelper;\r\n    /**\r\n     * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to\r\n     * the DOM in a browser environment.\r\n     */\r\n    function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {\r\n        var inertBodyElement = null;\r\n        try {\r\n            inertBodyHelper = inertBodyHelper || new InertBodyHelper(defaultDoc);\r\n            // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).\r\n            var unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';\r\n            inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\r\n            // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser\r\n            // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.\r\n            var mXSSAttempts = 5;\r\n            var parsedHtml = unsafeHtml;\r\n            do {\r\n                if (mXSSAttempts === 0) {\r\n                    throw new Error('Failed to sanitize html because the input is unstable');\r\n                }\r\n                mXSSAttempts--;\r\n                unsafeHtml = parsedHtml;\r\n                parsedHtml = inertBodyElement.innerHTML;\r\n                inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\r\n            } while (unsafeHtml !== parsedHtml);\r\n            var sanitizer = new SanitizingHtmlSerializer();\r\n            var safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);\r\n            if (isDevMode() && sanitizer.sanitizedSomething) {\r\n                console.warn('WARNING: sanitizing HTML stripped some content, see http://g.co/ng/security#xss');\r\n            }\r\n            return safeHtml;\r\n        }\r\n        finally {\r\n            // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.\r\n            if (inertBodyElement) {\r\n                var parent_1 = getTemplateContent(inertBodyElement) || inertBodyElement;\r\n                while (parent_1.firstChild) {\r\n                    parent_1.removeChild(parent_1.firstChild);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function getTemplateContent(el) {\r\n        return 'content' in el /** Microsoft/TypeScript#21517 */ && isTemplateElement(el) ?\r\n            el.content :\r\n            null;\r\n    }\r\n    function isTemplateElement(el) {\r\n        return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'TEMPLATE';\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    (function (SecurityContext) {\r\n        SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\r\n        SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\r\n        SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\r\n        SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\r\n        SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\r\n        SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\r\n    })(exports.SecurityContext || (exports.SecurityContext = {}));\r\n    /**\r\n     * Sanitizer is used by the views to sanitize potentially dangerous values.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var Sanitizer = /** @class */ (function () {\r\n        function Sanitizer() {\r\n        }\r\n        return Sanitizer;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Regular expression for safe style values.\r\n     *\r\n     * Quotes (\" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.\r\n     *\r\n     * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or\r\n     * font-family) and hence could allow multiple values to get injected, but that should pose no risk\r\n     * of XSS.\r\n     *\r\n     * The function expression checks only for XSS safety, not for CSS validity.\r\n     *\r\n     * This regular expression was taken from the Closure sanitization library, and augmented for\r\n     * transformation values.\r\n     */\r\n    var VALUES = '[-,.\"\\'%_!# a-zA-Z0-9]+';\r\n    var TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|Z|3d)?';\r\n    var COLOR_FNS = '(?:rgb|hsl)a?';\r\n    var GRADIENTS = '(?:repeating-)?(?:linear|radial)-gradient';\r\n    var CSS3_FNS = '(?:calc|attr)';\r\n    var FN_ARGS = '\\\\([-0-9.%, #a-zA-Z]+\\\\)';\r\n    var SAFE_STYLE_VALUE = new RegExp(\"^(\" + VALUES + \"|\" +\r\n        (\"(?:\" + TRANSFORMATION_FNS + \"|\" + COLOR_FNS + \"|\" + GRADIENTS + \"|\" + CSS3_FNS + \")\") +\r\n        (FN_ARGS + \")$\"), 'g');\r\n    /**\r\n     * Matches a `url(...)` value with an arbitrary argument as long as it does\r\n     * not contain parentheses.\r\n     *\r\n     * The URL value still needs to be sanitized separately.\r\n     *\r\n     * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted\r\n     * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.\r\n     * by observing whether scroll bars are displayed, or character ranges used by a font face\r\n     * definition.\r\n     *\r\n     * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that\r\n     * binding a URL value without further cooperation from the page will cause an information leak, and\r\n     * if so, it is just a leak, not a full blown XSS vulnerability.\r\n     *\r\n     * Given the common use case, low likelihood of attack vector, and low impact of an attack, this\r\n     * code is permissive and allows URLs that sanitize otherwise.\r\n     */\r\n    var URL_RE = /^url\\(([^)]+)\\)$/;\r\n    /**\r\n     * Checks that quotes (\" and ') are properly balanced inside a string. Assumes\r\n     * that neither escape (\\) nor any other character that could result in\r\n     * breaking out of a string parsing context are allowed;\r\n     * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.\r\n     *\r\n     * This code was taken from the Closure sanitization library.\r\n     */\r\n    function hasBalancedQuotes(value) {\r\n        var outsideSingle = true;\r\n        var outsideDouble = true;\r\n        for (var i = 0; i < value.length; i++) {\r\n            var c = value.charAt(i);\r\n            if (c === '\\'' && outsideDouble) {\r\n                outsideSingle = !outsideSingle;\r\n            }\r\n            else if (c === '\"' && outsideSingle) {\r\n                outsideDouble = !outsideDouble;\r\n            }\r\n        }\r\n        return outsideSingle && outsideDouble;\r\n    }\r\n    /**\r\n     * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single\r\n     * value) and returns a value that is safe to use in a browser environment.\r\n     */\r\n    function _sanitizeStyle(value) {\r\n        value = String(value).trim(); // Make sure it's actually a string.\r\n        if (!value)\r\n            return '';\r\n        // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for\r\n        // reasoning behind this.\r\n        var urlMatch = value.match(URL_RE);\r\n        if ((urlMatch && _sanitizeUrl(urlMatch[1]) === urlMatch[1]) ||\r\n            value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {\r\n            return value; // Safe style values.\r\n        }\r\n        if (isDevMode()) {\r\n            console.warn(\"WARNING: sanitizing unsafe style value \" + value + \" (see http://g.co/ng/security#xss).\");\r\n        }\r\n        return 'unsafe';\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * An `html` sanitizer which converts untrusted `html` **string** into trusted string by removing\r\n     * dangerous content.\r\n     *\r\n     * This method parses the `html` and locates potentially dangerous content (such as urls and\r\n     * javascript) and removes it.\r\n     *\r\n     * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustHtml}.\r\n     *\r\n     * @param unsafeHtml untrusted `html`, typically from the user.\r\n     * @returns `html` string which is safe to display to user, because all of the dangerous javascript\r\n     * and urls have been removed.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function ɵɵsanitizeHtml(unsafeHtml) {\r\n        var sanitizer = getSanitizer();\r\n        if (sanitizer) {\r\n            return sanitizer.sanitize(exports.SecurityContext.HTML, unsafeHtml) || '';\r\n        }\r\n        if (allowSanitizationBypass(unsafeHtml, \"Html\" /* Html */)) {\r\n            return unsafeHtml.toString();\r\n        }\r\n        return _sanitizeHtml(document, renderStringify(unsafeHtml));\r\n    }\r\n    /**\r\n     * A `style` sanitizer which converts untrusted `style` **string** into trusted string by removing\r\n     * dangerous content.\r\n     *\r\n     * This method parses the `style` and locates potentially dangerous content (such as urls and\r\n     * javascript) and removes it.\r\n     *\r\n     * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustStyle}.\r\n     *\r\n     * @param unsafeStyle untrusted `style`, typically from the user.\r\n     * @returns `style` string which is safe to bind to the `style` properties, because all of the\r\n     * dangerous javascript and urls have been removed.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function ɵɵsanitizeStyle(unsafeStyle) {\r\n        var sanitizer = getSanitizer();\r\n        if (sanitizer) {\r\n            return sanitizer.sanitize(exports.SecurityContext.STYLE, unsafeStyle) || '';\r\n        }\r\n        if (allowSanitizationBypass(unsafeStyle, \"Style\" /* Style */)) {\r\n            return unsafeStyle.toString();\r\n        }\r\n        return _sanitizeStyle(renderStringify(unsafeStyle));\r\n    }\r\n    /**\r\n     * A `url` sanitizer which converts untrusted `url` **string** into trusted string by removing\r\n     * dangerous\r\n     * content.\r\n     *\r\n     * This method parses the `url` and locates potentially dangerous content (such as javascript) and\r\n     * removes it.\r\n     *\r\n     * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustUrl}.\r\n     *\r\n     * @param unsafeUrl untrusted `url`, typically from the user.\r\n     * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\r\n     * all of the dangerous javascript has been removed.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function ɵɵsanitizeUrl(unsafeUrl) {\r\n        var sanitizer = getSanitizer();\r\n        if (sanitizer) {\r\n            return sanitizer.sanitize(exports.SecurityContext.URL, unsafeUrl) || '';\r\n        }\r\n        if (allowSanitizationBypass(unsafeUrl, \"Url\" /* Url */)) {\r\n            return unsafeUrl.toString();\r\n        }\r\n        return _sanitizeUrl(renderStringify(unsafeUrl));\r\n    }\r\n    /**\r\n     * A `url` sanitizer which only lets trusted `url`s through.\r\n     *\r\n     * This passes only `url`s marked trusted by calling {@link bypassSanitizationTrustResourceUrl}.\r\n     *\r\n     * @param unsafeResourceUrl untrusted `url`, typically from the user.\r\n     * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\r\n     * only trusted `url`s have been allowed to pass.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function ɵɵsanitizeResourceUrl(unsafeResourceUrl) {\r\n        var sanitizer = getSanitizer();\r\n        if (sanitizer) {\r\n            return sanitizer.sanitize(exports.SecurityContext.RESOURCE_URL, unsafeResourceUrl) || '';\r\n        }\r\n        if (allowSanitizationBypass(unsafeResourceUrl, \"ResourceUrl\" /* ResourceUrl */)) {\r\n            return unsafeResourceUrl.toString();\r\n        }\r\n        throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');\r\n    }\r\n    /**\r\n     * A `script` sanitizer which only lets trusted javascript through.\r\n     *\r\n     * This passes only `script`s marked trusted by calling {@link\r\n     * bypassSanitizationTrustScript}.\r\n     *\r\n     * @param unsafeScript untrusted `script`, typically from the user.\r\n     * @returns `url` string which is safe to bind to the `<script>` element such as `<img src>`,\r\n     * because only trusted `scripts` have been allowed to pass.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function ɵɵsanitizeScript(unsafeScript) {\r\n        var sanitizer = getSanitizer();\r\n        if (sanitizer) {\r\n            return sanitizer.sanitize(exports.SecurityContext.SCRIPT, unsafeScript) || '';\r\n        }\r\n        if (allowSanitizationBypass(unsafeScript, \"Script\" /* Script */)) {\r\n            return unsafeScript.toString();\r\n        }\r\n        throw new Error('unsafe value used in a script context');\r\n    }\r\n    /**\r\n     * Detects which sanitizer to use for URL property, based on tag name and prop name.\r\n     *\r\n     * The rules are based on the RESOURCE_URL context config from\r\n     * `packages/compiler/src/schema/dom_security_schema.ts`.\r\n     * If tag and prop names don't match Resource URL schema, use URL sanitizer.\r\n     */\r\n    function getUrlSanitizer(tag, prop) {\r\n        if ((prop === 'src' && (tag === 'embed' || tag === 'frame' || tag === 'iframe' ||\r\n            tag === 'media' || tag === 'script')) ||\r\n            (prop === 'href' && (tag === 'base' || tag === 'link'))) {\r\n            return ɵɵsanitizeResourceUrl;\r\n        }\r\n        return ɵɵsanitizeUrl;\r\n    }\r\n    /**\r\n     * Sanitizes URL, selecting sanitizer function based on tag and property names.\r\n     *\r\n     * This function is used in case we can't define security context at compile time, when only prop\r\n     * name is available. This happens when we generate host bindings for Directives/Components. The\r\n     * host element is unknown at compile time, so we defer calculation of specific sanitizer to\r\n     * runtime.\r\n     *\r\n     * @param unsafeUrl untrusted `url`, typically from the user.\r\n     * @param tag target element tag name.\r\n     * @param prop name of the property that contains the value.\r\n     * @returns `url` string which is safe to bind.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function ɵɵsanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {\r\n        return getUrlSanitizer(tag, prop)(unsafeUrl);\r\n    }\r\n    /**\r\n     * The default style sanitizer will handle sanitization for style properties by\r\n     * sanitizing any CSS property that can include a `url` value (usually image-based properties)\r\n     *\r\n     * @publicApi\r\n     */\r\n    var ɵɵdefaultStyleSanitizer = function (prop, value, mode) {\r\n        mode = mode || 3 /* ValidateAndSanitize */;\r\n        var doSanitizeValue = true;\r\n        if (mode & 1 /* ValidateProperty */) {\r\n            doSanitizeValue = prop === 'background-image' || prop === 'background' ||\r\n                prop === 'border-image' || prop === 'filter' || prop === 'list-style' ||\r\n                prop === 'list-style-image' || prop === 'clip-path';\r\n        }\r\n        if (mode & 2 /* SanitizeOnly */) {\r\n            return doSanitizeValue ? ɵɵsanitizeStyle(value) : value;\r\n        }\r\n        else {\r\n            return doSanitizeValue;\r\n        }\r\n    };\r\n    function validateAgainstEventProperties(name) {\r\n        if (name.toLowerCase().startsWith('on')) {\r\n            var msg = \"Binding to event property '\" + name + \"' is disallowed for security reasons, \" +\r\n                (\"please use (\" + name.slice(2) + \")=...\") +\r\n                (\"\\nIf '\" + name + \"' is a directive input, make sure the directive is imported by the\") +\r\n                \" current module.\";\r\n            throw new Error(msg);\r\n        }\r\n    }\r\n    function validateAgainstEventAttributes(name) {\r\n        if (name.toLowerCase().startsWith('on')) {\r\n            var msg = \"Binding to event attribute '\" + name + \"' is disallowed for security reasons, \" +\r\n                (\"please use (\" + name.slice(2) + \")=...\");\r\n            throw new Error(msg);\r\n        }\r\n    }\r\n    function getSanitizer() {\r\n        var lView = getLView();\r\n        return lView && lView[SANITIZER];\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * THIS FILE CONTAINS CODE WHICH SHOULD BE TREE SHAKEN AND NEVER CALLED FROM PRODUCTION CODE!!!\r\n     */\r\n    /**\r\n     * Creates an `Array` construction with a given name. This is useful when\r\n     * looking for memory consumption to see what time of array it is.\r\n     *\r\n     *\r\n     * @param name Name to give to the constructor\r\n     * @returns A subclass of `Array` if possible. This can only be done in\r\n     *          environments which support `class` construct.\r\n     */\r\n    function createNamedArrayType(name) {\r\n        // This should never be called in prod mode, so let's verify that is the case.\r\n        if (ngDevMode) {\r\n            try {\r\n                // We need to do it this way so that TypeScript does not down-level the below code.\r\n                var FunctionConstructor = createNamedArrayType.constructor;\r\n                return (new FunctionConstructor('Array', \"return class ABC extends Array{}\"))(Array);\r\n            }\r\n            catch (e) {\r\n                // If it does not work just give up and fall back to regular Array.\r\n                return Array;\r\n            }\r\n        }\r\n        else {\r\n            throw new Error('Looks like we are in \\'prod mode\\', but we are creating a named Array type, which is wrong! Check your code');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function normalizeDebugBindingName(name) {\r\n        // Attribute names with `$` (eg `x-y$`) are valid per spec, but unsupported by some browsers\r\n        name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));\r\n        return \"ng-reflect-\" + name;\r\n    }\r\n    var CAMEL_CASE_REGEXP = /([A-Z])/g;\r\n    function camelCaseToDashCase(input) {\r\n        return input.replace(CAMEL_CASE_REGEXP, function () {\r\n            var m = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                m[_i] = arguments[_i];\r\n            }\r\n            return '-' + m[1].toLowerCase();\r\n        });\r\n    }\r\n    function normalizeDebugBindingValue(value) {\r\n        try {\r\n            // Limit the size of the value as otherwise the DOM just gets polluted.\r\n            return value != null ? value.toString().slice(0, 30) : value;\r\n        }\r\n        catch (e) {\r\n            return '[ERROR] Exception while trying to serialize the value';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /** Returns the matching `LContext` data for a given DOM node, directive or component instance.\r\n     *\r\n     * This function will examine the provided DOM element, component, or directive instance\\'s\r\n     * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched\r\n     * value will be that of the newly created `LContext`.\r\n     *\r\n     * If the monkey-patched value is the `LView` instance then the context value for that\r\n     * target will be created and the monkey-patch reference will be updated. Therefore when this\r\n     * function is called it may mutate the provided element\\'s, component\\'s or any of the associated\r\n     * directive\\'s monkey-patch values.\r\n     *\r\n     * If the monkey-patch value is not detected then the code will walk up the DOM until an element\r\n     * is found which contains a monkey-patch reference. When that occurs then the provided element\r\n     * will be updated with a new context (which is then returned). If the monkey-patch value is not\r\n     * detected for a component/directive instance then it will throw an error (all components and\r\n     * directives should be automatically monkey-patched by ivy).\r\n     *\r\n     * @param target Component, Directive or DOM Node.\r\n     */\r\n    function getLContext(target) {\r\n        var mpValue = readPatchedData(target);\r\n        if (mpValue) {\r\n            // only when it's an array is it considered an LView instance\r\n            // ... otherwise it's an already constructed LContext instance\r\n            if (Array.isArray(mpValue)) {\r\n                var lView = mpValue;\r\n                var nodeIndex = void 0;\r\n                var component = undefined;\r\n                var directives = undefined;\r\n                if (isComponentInstance(target)) {\r\n                    nodeIndex = findViaComponent(lView, target);\r\n                    if (nodeIndex == -1) {\r\n                        throw new Error('The provided component was not found in the application');\r\n                    }\r\n                    component = target;\r\n                }\r\n                else if (isDirectiveInstance(target)) {\r\n                    nodeIndex = findViaDirective(lView, target);\r\n                    if (nodeIndex == -1) {\r\n                        throw new Error('The provided directive was not found in the application');\r\n                    }\r\n                    directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);\r\n                }\r\n                else {\r\n                    nodeIndex = findViaNativeElement(lView, target);\r\n                    if (nodeIndex == -1) {\r\n                        return null;\r\n                    }\r\n                }\r\n                // the goal is not to fill the entire context full of data because the lookups\r\n                // are expensive. Instead, only the target data (the element, component, container, ICU\r\n                // expression or directive details) are filled into the context. If called multiple times\r\n                // with different target values then the missing target data will be filled in.\r\n                var native = unwrapRNode(lView[nodeIndex]);\r\n                var existingCtx = readPatchedData(native);\r\n                var context = (existingCtx && !Array.isArray(existingCtx)) ?\r\n                    existingCtx :\r\n                    createLContext(lView, nodeIndex, native);\r\n                // only when the component has been discovered then update the monkey-patch\r\n                if (component && context.component === undefined) {\r\n                    context.component = component;\r\n                    attachPatchData(context.component, context);\r\n                }\r\n                // only when the directives have been discovered then update the monkey-patch\r\n                if (directives && context.directives === undefined) {\r\n                    context.directives = directives;\r\n                    for (var i = 0; i < directives.length; i++) {\r\n                        attachPatchData(directives[i], context);\r\n                    }\r\n                }\r\n                attachPatchData(context.native, context);\r\n                mpValue = context;\r\n            }\r\n        }\r\n        else {\r\n            var rElement = target;\r\n            ngDevMode && assertDomNode(rElement);\r\n            // if the context is not found then we need to traverse upwards up the DOM\r\n            // to find the nearest element that has already been monkey patched with data\r\n            var parent_1 = rElement;\r\n            while (parent_1 = parent_1.parentNode) {\r\n                var parentContext = readPatchedData(parent_1);\r\n                if (parentContext) {\r\n                    var lView = void 0;\r\n                    if (Array.isArray(parentContext)) {\r\n                        lView = parentContext;\r\n                    }\r\n                    else {\r\n                        lView = parentContext.lView;\r\n                    }\r\n                    // the edge of the app was also reached here through another means\r\n                    // (maybe because the DOM was changed manually).\r\n                    if (!lView) {\r\n                        return null;\r\n                    }\r\n                    var index = findViaNativeElement(lView, rElement);\r\n                    if (index >= 0) {\r\n                        var native = unwrapRNode(lView[index]);\r\n                        var context = createLContext(lView, index, native);\r\n                        attachPatchData(native, context);\r\n                        mpValue = context;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return mpValue || null;\r\n    }\r\n    /**\r\n     * Creates an empty instance of a `LContext` context\r\n     */\r\n    function createLContext(lView, nodeIndex, native) {\r\n        return {\r\n            lView: lView,\r\n            nodeIndex: nodeIndex,\r\n            native: native,\r\n            component: undefined,\r\n            directives: undefined,\r\n            localRefs: undefined,\r\n        };\r\n    }\r\n    /**\r\n     * Takes a component instance and returns the view for that component.\r\n     *\r\n     * @param componentInstance\r\n     * @returns The component's view\r\n     */\r\n    function getComponentViewByInstance(componentInstance) {\r\n        var lView = readPatchedData(componentInstance);\r\n        var view;\r\n        if (Array.isArray(lView)) {\r\n            var nodeIndex = findViaComponent(lView, componentInstance);\r\n            view = getComponentViewByIndex(nodeIndex, lView);\r\n            var context = createLContext(lView, nodeIndex, view[HOST]);\r\n            context.component = componentInstance;\r\n            attachPatchData(componentInstance, context);\r\n            attachPatchData(context.native, context);\r\n        }\r\n        else {\r\n            var context = lView;\r\n            view = getComponentViewByIndex(context.nodeIndex, context.lView);\r\n        }\r\n        return view;\r\n    }\r\n    /**\r\n     * Assigns the given data to the given target (which could be a component,\r\n     * directive or DOM node instance) using monkey-patching.\r\n     */\r\n    function attachPatchData(target, data) {\r\n        target[MONKEY_PATCH_KEY_NAME] = data;\r\n    }\r\n    function isComponentInstance(instance) {\r\n        return instance && instance.constructor && instance.constructor.ngComponentDef;\r\n    }\r\n    function isDirectiveInstance(instance) {\r\n        return instance && instance.constructor && instance.constructor.ngDirectiveDef;\r\n    }\r\n    /**\r\n     * Locates the element within the given LView and returns the matching index\r\n     */\r\n    function findViaNativeElement(lView, target) {\r\n        var tNode = lView[TVIEW].firstChild;\r\n        while (tNode) {\r\n            var native = getNativeByTNodeOrNull(tNode, lView);\r\n            if (native === target) {\r\n                return tNode.index;\r\n            }\r\n            tNode = traverseNextElement(tNode);\r\n        }\r\n        return -1;\r\n    }\r\n    /**\r\n     * Locates the next tNode (child, sibling or parent).\r\n     */\r\n    function traverseNextElement(tNode) {\r\n        if (tNode.child) {\r\n            return tNode.child;\r\n        }\r\n        else if (tNode.next) {\r\n            return tNode.next;\r\n        }\r\n        else {\r\n            // Let's take the following template: <div><span>text</span></div><component/>\r\n            // After checking the text node, we need to find the next parent that has a \"next\" TNode,\r\n            // in this case the parent `div`, so that we can find the component.\r\n            while (tNode.parent && !tNode.parent.next) {\r\n                tNode = tNode.parent;\r\n            }\r\n            return tNode.parent && tNode.parent.next;\r\n        }\r\n    }\r\n    /**\r\n     * Locates the component within the given LView and returns the matching index\r\n     */\r\n    function findViaComponent(lView, componentInstance) {\r\n        var componentIndices = lView[TVIEW].components;\r\n        if (componentIndices) {\r\n            for (var i = 0; i < componentIndices.length; i++) {\r\n                var elementComponentIndex = componentIndices[i];\r\n                var componentView = getComponentViewByIndex(elementComponentIndex, lView);\r\n                if (componentView[CONTEXT] === componentInstance) {\r\n                    return elementComponentIndex;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var rootComponentView = getComponentViewByIndex(HEADER_OFFSET, lView);\r\n            var rootComponent = rootComponentView[CONTEXT];\r\n            if (rootComponent === componentInstance) {\r\n                // we are dealing with the root element here therefore we know that the\r\n                // element is the very first element after the HEADER data in the lView\r\n                return HEADER_OFFSET;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    /**\r\n     * Locates the directive within the given LView and returns the matching index\r\n     */\r\n    function findViaDirective(lView, directiveInstance) {\r\n        // if a directive is monkey patched then it will (by default)\r\n        // have a reference to the LView of the current view. The\r\n        // element bound to the directive being search lives somewhere\r\n        // in the view data. We loop through the nodes and check their\r\n        // list of directives for the instance.\r\n        var tNode = lView[TVIEW].firstChild;\r\n        while (tNode) {\r\n            var directiveIndexStart = tNode.directiveStart;\r\n            var directiveIndexEnd = tNode.directiveEnd;\r\n            for (var i = directiveIndexStart; i < directiveIndexEnd; i++) {\r\n                if (lView[i] === directiveInstance) {\r\n                    return tNode.index;\r\n                }\r\n            }\r\n            tNode = traverseNextElement(tNode);\r\n        }\r\n        return -1;\r\n    }\r\n    /**\r\n     * Returns a list of directives extracted from the given view based on the\r\n     * provided list of directive index values.\r\n     *\r\n     * @param nodeIndex The node index\r\n     * @param lView The target view data\r\n     * @param includeComponents Whether or not to include components in returned directives\r\n     */\r\n    function getDirectivesAtNodeIndex(nodeIndex, lView, includeComponents) {\r\n        var tNode = lView[TVIEW].data[nodeIndex];\r\n        var directiveStartIndex = tNode.directiveStart;\r\n        if (directiveStartIndex == 0)\r\n            return EMPTY_ARRAY;\r\n        var directiveEndIndex = tNode.directiveEnd;\r\n        if (!includeComponents && tNode.flags & 1 /* isComponent */)\r\n            directiveStartIndex++;\r\n        return lView.slice(directiveStartIndex, directiveEndIndex);\r\n    }\r\n    function getComponentAtNodeIndex(nodeIndex, lView) {\r\n        var tNode = lView[TVIEW].data[nodeIndex];\r\n        var directiveStartIndex = tNode.directiveStart;\r\n        return tNode.flags & 1 /* isComponent */ ? lView[directiveStartIndex] : null;\r\n    }\r\n    /**\r\n     * Returns a map of local references (local reference name => element or directive instance) that\r\n     * exist on a given element.\r\n     */\r\n    function discoverLocalRefs(lView, nodeIndex) {\r\n        var tNode = lView[TVIEW].data[nodeIndex];\r\n        if (tNode && tNode.localNames) {\r\n            var result = {};\r\n            var localIndex = tNode.index + 1;\r\n            for (var i = 0; i < tNode.localNames.length; i += 2) {\r\n                result[tNode.localNames[i]] = lView[localIndex];\r\n                localIndex++;\r\n            }\r\n            return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** Called when directives inject each other (creating a circular dependency) */\r\n    function throwCyclicDependencyError(token) {\r\n        throw new Error(\"Cannot instantiate cyclic dependency! \" + token);\r\n    }\r\n    /** Called when there are multiple component selectors that match a given node */\r\n    function throwMultipleComponentError(tNode) {\r\n        throw new Error(\"Multiple components match node with tagname \" + tNode.tagName);\r\n    }\r\n    /** Throws an ExpressionChangedAfterChecked error if checkNoChanges mode is on. */\r\n    function throwErrorIfNoChangesMode(creationMode, oldValue, currValue) {\r\n        var msg = \"ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: '\" + oldValue + \"'. Current value: '\" + currValue + \"'.\";\r\n        if (creationMode) {\r\n            msg +=\r\n                \" It seems like the view has been created after its parent and its children have been dirty checked.\" +\r\n                    \" Has it been created in a change detection hook ?\";\r\n        }\r\n        // TODO: include debug context\r\n        throw new Error(msg);\r\n    }\r\n    function throwMixedMultiProviderError() {\r\n        throw new Error(\"Cannot mix multi providers and regular providers\");\r\n    }\r\n    function throwInvalidProviderError(ngModuleType, providers, provider) {\r\n        var ngModuleDetail = '';\r\n        if (ngModuleType && providers) {\r\n            var providerDetail = providers.map(function (v) { return v == provider ? '?' + provider + '?' : '...'; });\r\n            ngModuleDetail =\r\n                \" - only instances of Provider and Type are allowed, got: [\" + providerDetail.join(', ') + \"]\";\r\n        }\r\n        throw new Error(\"Invalid provider for the NgModule '\" + stringify(ngModuleType) + \"'\" + ngModuleDetail);\r\n    }\r\n\r\n    // Note: This hack is necessary so we don't erroneously get a circular dependency\r\n    // failure based on types.\r\n    var unusedValueExportToPlacateAjd$4 = 1;\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    // Note: This hack is necessary so we don't erroneously get a circular dependency\r\n    // failure based on types.\r\n    var unusedValueExportToPlacateAjd$5 = 1;\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var unusedValueToPlacateAjd = unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd$5;\r\n    var NG_TEMPLATE_SELECTOR = 'ng-template';\r\n    function isCssClassMatching(nodeClassAttrVal, cssClassToMatch) {\r\n        var nodeClassesLen = nodeClassAttrVal.length;\r\n        var matchIndex = nodeClassAttrVal.indexOf(cssClassToMatch);\r\n        var matchEndIdx = matchIndex + cssClassToMatch.length;\r\n        if (matchIndex === -1 // no match\r\n            || (matchIndex > 0 && nodeClassAttrVal[matchIndex - 1] !== ' ') // no space before\r\n            ||\r\n                (matchEndIdx < nodeClassesLen && nodeClassAttrVal[matchEndIdx] !== ' ')) // no space after\r\n         {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Function that checks whether a given tNode matches tag-based selector and has a valid type.\r\n     *\r\n     * Matching can be performed in 2 modes: projection mode (when we project nodes) and regular\r\n     * directive matching mode:\r\n     * - in the \"directive matching\" mode we do _not_ take TContainer's tagName into account if it is\r\n     * different from NG_TEMPLATE_SELECTOR (value different from NG_TEMPLATE_SELECTOR indicates that a\r\n     * tag name was extracted from * syntax so we would match the same directive twice);\r\n     * - in the \"projection\" mode, we use a tag name potentially extracted from the * syntax processing\r\n     * (applicable to TNodeType.Container only).\r\n     */\r\n    function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {\r\n        var tagNameToCompare = tNode.type === 0 /* Container */ && !isProjectionMode ?\r\n            NG_TEMPLATE_SELECTOR :\r\n            tNode.tagName;\r\n        return currentSelector === tagNameToCompare;\r\n    }\r\n    /**\r\n     * A utility function to match an Ivy node static data against a simple CSS selector\r\n     *\r\n     * @param node static data of the node to match\r\n     * @param selector The selector to try matching against the node.\r\n     * @param isProjectionMode if `true` we are matching for content projection, otherwise we are doing\r\n     * directive matching.\r\n     * @returns true if node matches the selector.\r\n     */\r\n    function isNodeMatchingSelector(tNode, selector, isProjectionMode) {\r\n        ngDevMode && assertDefined(selector[0], 'Selector should have a tag name');\r\n        var mode = 4 /* ELEMENT */;\r\n        var nodeAttrs = tNode.attrs || [];\r\n        // Find the index of first attribute that has no value, only a name.\r\n        var nameOnlyMarkerIdx = getNameOnlyMarkerIndex(nodeAttrs);\r\n        // When processing \":not\" selectors, we skip to the next \":not\" if the\r\n        // current one doesn't match\r\n        var skipToNextSelector = false;\r\n        for (var i = 0; i < selector.length; i++) {\r\n            var current = selector[i];\r\n            if (typeof current === 'number') {\r\n                // If we finish processing a :not selector and it hasn't failed, return false\r\n                if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {\r\n                    return false;\r\n                }\r\n                // If we are skipping to the next :not() and this mode flag is positive,\r\n                // it's a part of the current :not() selector, and we should keep skipping\r\n                if (skipToNextSelector && isPositive(current))\r\n                    continue;\r\n                skipToNextSelector = false;\r\n                mode = current | (mode & 1 /* NOT */);\r\n                continue;\r\n            }\r\n            if (skipToNextSelector)\r\n                continue;\r\n            if (mode & 4 /* ELEMENT */) {\r\n                mode = 2 /* ATTRIBUTE */ | mode & 1 /* NOT */;\r\n                if (current !== '' && !hasTagAndTypeMatch(tNode, current, isProjectionMode) ||\r\n                    current === '' && selector.length === 1) {\r\n                    if (isPositive(mode))\r\n                        return false;\r\n                    skipToNextSelector = true;\r\n                }\r\n            }\r\n            else {\r\n                var selectorAttrValue = mode & 8 /* CLASS */ ? current : selector[++i];\r\n                // special case for matching against classes when a tNode has been instantiated with\r\n                // class and style values as separate attribute values (e.g. ['title', CLASS, 'foo'])\r\n                if ((mode & 8 /* CLASS */) && tNode.classes) {\r\n                    if (!isCssClassMatching(getInitialStylingValue(tNode.classes), selectorAttrValue)) {\r\n                        if (isPositive(mode))\r\n                            return false;\r\n                        skipToNextSelector = true;\r\n                    }\r\n                    continue;\r\n                }\r\n                var isInlineTemplate = tNode.type == 0 /* Container */ && tNode.tagName !== NG_TEMPLATE_SELECTOR;\r\n                var attrName = (mode & 8 /* CLASS */) ? 'class' : current;\r\n                var attrIndexInNode = findAttrIndexInNode(attrName, nodeAttrs, isInlineTemplate, isProjectionMode);\r\n                if (attrIndexInNode === -1) {\r\n                    if (isPositive(mode))\r\n                        return false;\r\n                    skipToNextSelector = true;\r\n                    continue;\r\n                }\r\n                if (selectorAttrValue !== '') {\r\n                    var nodeAttrValue = void 0;\r\n                    if (attrIndexInNode > nameOnlyMarkerIdx) {\r\n                        nodeAttrValue = '';\r\n                    }\r\n                    else {\r\n                        ngDevMode && assertNotEqual(nodeAttrs[attrIndexInNode], 0 /* NamespaceURI */, 'We do not match directives on namespaced attributes');\r\n                        nodeAttrValue = nodeAttrs[attrIndexInNode + 1];\r\n                    }\r\n                    var compareAgainstClassName = mode & 8 /* CLASS */ ? nodeAttrValue : null;\r\n                    if (compareAgainstClassName &&\r\n                        !isCssClassMatching(compareAgainstClassName, selectorAttrValue) ||\r\n                        mode & 2 /* ATTRIBUTE */ && selectorAttrValue !== nodeAttrValue) {\r\n                        if (isPositive(mode))\r\n                            return false;\r\n                        skipToNextSelector = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return isPositive(mode) || skipToNextSelector;\r\n    }\r\n    function isPositive(mode) {\r\n        return (mode & 1 /* NOT */) === 0;\r\n    }\r\n    /**\r\n     * Examines the attribute's definition array for a node to find the index of the\r\n     * attribute that matches the given `name`.\r\n     *\r\n     * NOTE: This will not match namespaced attributes.\r\n     *\r\n     * Attribute matching depends upon `isInlineTemplate` and `isProjectionMode`.\r\n     * The following table summarizes which types of attributes we attempt to match:\r\n     *\r\n     * ===========================================================================================================\r\n     * Modes                   | Normal Attributes | Bindings Attributes | Template Attributes | I18n\r\n     * Attributes\r\n     * ===========================================================================================================\r\n     * Inline + Projection     | YES               | YES                 | NO                  | YES\r\n     * -----------------------------------------------------------------------------------------------------------\r\n     * Inline + Directive      | NO                | NO                  | YES                 | NO\r\n     * -----------------------------------------------------------------------------------------------------------\r\n     * Non-inline + Projection | YES               | YES                 | NO                  | YES\r\n     * -----------------------------------------------------------------------------------------------------------\r\n     * Non-inline + Directive  | YES               | YES                 | NO                  | YES\r\n     * ===========================================================================================================\r\n     *\r\n     * @param name the name of the attribute to find\r\n     * @param attrs the attribute array to examine\r\n     * @param isInlineTemplate true if the node being matched is an inline template (e.g. `*ngFor`)\r\n     * rather than a manually expanded template node (e.g `<ng-template>`).\r\n     * @param isProjectionMode true if we are matching against content projection otherwise we are\r\n     * matching against directives.\r\n     */\r\n    function findAttrIndexInNode(name, attrs, isInlineTemplate, isProjectionMode) {\r\n        if (attrs === null)\r\n            return -1;\r\n        var i = 0;\r\n        if (isProjectionMode || !isInlineTemplate) {\r\n            var bindingsMode = false;\r\n            while (i < attrs.length) {\r\n                var maybeAttrName = attrs[i];\r\n                if (maybeAttrName === name) {\r\n                    return i;\r\n                }\r\n                else if (maybeAttrName === 3 /* Bindings */ || maybeAttrName === 6 /* I18n */) {\r\n                    bindingsMode = true;\r\n                }\r\n                else if (maybeAttrName === 1 /* Classes */) {\r\n                    var value = attrs[++i];\r\n                    // We should skip classes here because we have a separate mechanism for\r\n                    // matching classes in projection mode.\r\n                    while (typeof value === 'string') {\r\n                        value = attrs[++i];\r\n                    }\r\n                    continue;\r\n                }\r\n                else if (maybeAttrName === 4 /* Template */) {\r\n                    // We do not care about Template attributes in this scenario.\r\n                    break;\r\n                }\r\n                else if (maybeAttrName === 0 /* NamespaceURI */) {\r\n                    // Skip the whole namespaced attribute and value. This is by design.\r\n                    i += 4;\r\n                    continue;\r\n                }\r\n                // In binding mode there are only names, rather than name-value pairs.\r\n                i += bindingsMode ? 1 : 2;\r\n            }\r\n            // We did not match the attribute\r\n            return -1;\r\n        }\r\n        else {\r\n            return matchTemplateAttribute(attrs, name);\r\n        }\r\n    }\r\n    function isNodeMatchingSelectorList(tNode, selector, isProjectionMode) {\r\n        if (isProjectionMode === void 0) { isProjectionMode = false; }\r\n        for (var i = 0; i < selector.length; i++) {\r\n            if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    function getProjectAsAttrValue(tNode) {\r\n        var nodeAttrs = tNode.attrs;\r\n        if (nodeAttrs != null) {\r\n            var ngProjectAsAttrIdx = nodeAttrs.indexOf(5 /* ProjectAs */);\r\n            // only check for ngProjectAs in attribute names, don't accidentally match attribute's value\r\n            // (attribute names are stored at even indexes)\r\n            if ((ngProjectAsAttrIdx & 1) === 0) {\r\n                return nodeAttrs[ngProjectAsAttrIdx + 1];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    function getNameOnlyMarkerIndex(nodeAttrs) {\r\n        for (var i = 0; i < nodeAttrs.length; i++) {\r\n            var nodeAttr = nodeAttrs[i];\r\n            if (isNameOnlyAttributeMarker(nodeAttr)) {\r\n                return i;\r\n            }\r\n        }\r\n        return nodeAttrs.length;\r\n    }\r\n    function matchTemplateAttribute(attrs, name) {\r\n        var i = attrs.indexOf(4 /* Template */);\r\n        if (i > -1) {\r\n            i++;\r\n            while (i < attrs.length) {\r\n                if (attrs[i] === name)\r\n                    return i;\r\n                i++;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    /**\r\n     * Checks whether a selector is inside a CssSelectorList\r\n     * @param selector Selector to be checked.\r\n     * @param list List in which to look for the selector.\r\n     */\r\n    function isSelectorInSelectorList(selector, list) {\r\n        selectorListLoop: for (var i = 0; i < list.length; i++) {\r\n            var currentSelectorInList = list[i];\r\n            if (selector.length !== currentSelectorInList.length) {\r\n                continue;\r\n            }\r\n            for (var j = 0; j < selector.length; j++) {\r\n                if (selector[j] !== currentSelectorInList[j]) {\r\n                    continue selectorListLoop;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * --------\r\n     *\r\n     * This file contains the core logic for styling in Angular.\r\n     *\r\n     * All styling bindings (i.e. `[style]`, `[style.prop]`, `[class]` and `[class.name]`)\r\n     * will have their values be applied through the logic in this file.\r\n     *\r\n     * When a binding is encountered (e.g. `<div [style.width]=\"w\">`) then\r\n     * the binding data will be populated into a `TStylingContext` data-structure.\r\n     * There is only one `TStylingContext` per `TNode` and each element instance\r\n     * will update its style/class binding values in concert with the styling\r\n     * context.\r\n     *\r\n     * To learn more about the algorithm see `TStylingContext`.\r\n     *\r\n     * --------\r\n     */\r\n    // The first bit value reflects a map-based binding value's bit.\r\n    // The reason why it's always activated for every entry in the map\r\n    // is so that if any map-binding values update then all other prop\r\n    // based bindings will pass the guard check automatically without\r\n    // any extra code or flags.\r\n    var DEFAULT_GUARD_MASK_VALUE = 1;\r\n    /**\r\n     * The guard/update mask bit index location for map-based bindings.\r\n     *\r\n     * All map-based bindings (i.e. `[style]` and `[class]` )\r\n     */\r\n    var STYLING_INDEX_FOR_MAP_BINDING = 0;\r\n    /**\r\n     * Default fallback value for a styling binding.\r\n     *\r\n     * A value of `null` is used here which signals to the styling algorithm that\r\n     * the styling value is not present. This way if there are no other values\r\n     * detected then it will be removed once the style/class property is dirty and\r\n     * diffed within the styling algorithm present in `flushStyling`.\r\n     */\r\n    var DEFAULT_BINDING_VALUE = null;\r\n    /**\r\n     * Default size count value for a new entry in a context.\r\n     *\r\n     * A value of `1` is used here because each entry in the context has a default\r\n     * property.\r\n     */\r\n    var DEFAULT_SIZE_VALUE = 1;\r\n    var deferredBindingQueue = [];\r\n    /**\r\n     * Visits a class-based binding and updates the new value (if changed).\r\n     *\r\n     * This function is called each time a class-based styling instruction\r\n     * is executed. It's important that it's always called (even if the value\r\n     * has not changed) so that the inner counter index value is incremented.\r\n     * This way, each instruction is always guaranteed to get the same counter\r\n     * state each time it's called (which then allows the `TStylingContext`\r\n     * and the bit mask values to be in sync).\r\n     */\r\n    function updateClassBinding(context, data, element, prop, bindingIndex, value, deferRegistration, forceUpdate) {\r\n        var isMapBased = !prop;\r\n        var state = getStylingState(element, stateIsPersisted(context));\r\n        var index = isMapBased ? STYLING_INDEX_FOR_MAP_BINDING : state.classesIndex++;\r\n        var updated = updateBindingData(context, data, index, prop, bindingIndex, value, deferRegistration, forceUpdate, false);\r\n        if (updated || forceUpdate) {\r\n            // We flip the bit in the bitMask to reflect that the binding\r\n            // at the `index` slot has changed. This identifies to the flushing\r\n            // phase that the bindings for this particular CSS class need to be\r\n            // applied again because on or more of the bindings for the CSS\r\n            // class have changed.\r\n            state.classesBitMask |= 1 << index;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Visits a style-based binding and updates the new value (if changed).\r\n     *\r\n     * This function is called each time a style-based styling instruction\r\n     * is executed. It's important that it's always called (even if the value\r\n     * has not changed) so that the inner counter index value is incremented.\r\n     * This way, each instruction is always guaranteed to get the same counter\r\n     * state each time it's called (which then allows the `TStylingContext`\r\n     * and the bit mask values to be in sync).\r\n     */\r\n    function updateStyleBinding(context, data, element, prop, bindingIndex, value, sanitizer, deferRegistration, forceUpdate) {\r\n        var isMapBased = !prop;\r\n        var state = getStylingState(element, stateIsPersisted(context));\r\n        var index = isMapBased ? STYLING_INDEX_FOR_MAP_BINDING : state.stylesIndex++;\r\n        var sanitizationRequired = isMapBased ?\r\n            true :\r\n            (sanitizer ? sanitizer(prop, null, 1 /* ValidateProperty */) : false);\r\n        var updated = updateBindingData(context, data, index, prop, bindingIndex, value, deferRegistration, forceUpdate, sanitizationRequired);\r\n        if (updated || forceUpdate) {\r\n            // We flip the bit in the bitMask to reflect that the binding\r\n            // at the `index` slot has changed. This identifies to the flushing\r\n            // phase that the bindings for this particular property need to be\r\n            // applied again because on or more of the bindings for the CSS\r\n            // property have changed.\r\n            state.stylesBitMask |= 1 << index;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Called each time a binding value has changed within the provided `TStylingContext`.\r\n     *\r\n     * This function is designed to be called from `updateStyleBinding` and `updateClassBinding`.\r\n     * If called during the first update pass, the binding will be registered in the context.\r\n     * If the binding does get registered and the `deferRegistration` flag is true then the\r\n     * binding data will be queued up until the context is later flushed in `applyStyling`.\r\n     *\r\n     * This function will also update binding slot in the provided `LStylingData` with the\r\n     * new binding entry (if it has changed).\r\n     *\r\n     * @returns whether or not the binding value was updated in the `LStylingData`.\r\n     */\r\n    function updateBindingData(context, data, counterIndex, prop, bindingIndex, value, deferRegistration, forceUpdate, sanitizationRequired) {\r\n        if (!isContextLocked(context)) {\r\n            if (deferRegistration) {\r\n                deferBindingRegistration(context, counterIndex, prop, bindingIndex, sanitizationRequired);\r\n            }\r\n            else {\r\n                deferredBindingQueue.length && flushDeferredBindings();\r\n                // this will only happen during the first update pass of the\r\n                // context. The reason why we can't use `tNode.firstTemplatePass`\r\n                // here is because its not guaranteed to be true when the first\r\n                // update pass is executed (remember that all styling instructions\r\n                // are run in the update phase, and, as a result, are no more\r\n                // styling instructions that are run in the creation phase).\r\n                registerBinding(context, counterIndex, prop, bindingIndex, sanitizationRequired);\r\n            }\r\n        }\r\n        var changed = forceUpdate || hasValueChanged(data[bindingIndex], value);\r\n        if (changed) {\r\n            data[bindingIndex] = value;\r\n        }\r\n        return changed;\r\n    }\r\n    /**\r\n     * Schedules a binding registration to be run at a later point.\r\n     *\r\n     * The reasoning for this feature is to ensure that styling\r\n     * bindings are registered in the correct order for when\r\n     * directives/components have a super/sub class inheritance\r\n     * chains. Each directive's styling bindings must be\r\n     * registered into the context in reverse order. Therefore all\r\n     * bindings will be buffered in reverse order and then applied\r\n     * after the inheritance chain exits.\r\n     */\r\n    function deferBindingRegistration(context, counterIndex, prop, bindingIndex, sanitizationRequired) {\r\n        deferredBindingQueue.unshift(context, counterIndex, prop, bindingIndex, sanitizationRequired);\r\n    }\r\n    /**\r\n     * Flushes the collection of deferred bindings and causes each entry\r\n     * to be registered into the context.\r\n     */\r\n    function flushDeferredBindings() {\r\n        var i = 0;\r\n        while (i < deferredBindingQueue.length) {\r\n            var context = deferredBindingQueue[i++];\r\n            var count = deferredBindingQueue[i++];\r\n            var prop = deferredBindingQueue[i++];\r\n            var bindingIndex = deferredBindingQueue[i++];\r\n            var sanitizationRequired = deferredBindingQueue[i++];\r\n            registerBinding(context, count, prop, bindingIndex, sanitizationRequired);\r\n        }\r\n        deferredBindingQueue.length = 0;\r\n    }\r\n    /**\r\n     * Registers the provided binding (prop + bindingIndex) into the context.\r\n     *\r\n     * This function is shared between bindings that are assigned immediately\r\n     * (via `updateBindingData`) and at a deferred stage. When called, it will\r\n     * figure out exactly where to place the binding data in the context.\r\n     *\r\n     * It is needed because it will either update or insert a styling property\r\n     * into the context at the correct spot.\r\n     *\r\n     * When called, one of two things will happen:\r\n     *\r\n     * 1) If the property already exists in the context then it will just add\r\n     *    the provided `bindingValue` to the end of the binding sources region\r\n     *    for that particular property.\r\n     *\r\n     *    - If the binding value is a number then it will be added as a new\r\n     *      binding index source next to the other binding sources for the property.\r\n     *\r\n     *    - Otherwise, if the binding value is a string/boolean/null type then it will\r\n     *      replace the default value for the property if the default value is `null`.\r\n     *\r\n     * 2) If the property does not exist then it will be inserted into the context.\r\n     *    The styling context relies on all properties being stored in alphabetical\r\n     *    order, so it knows exactly where to store it.\r\n     *\r\n     *    When inserted, a default `null` value is created for the property which exists\r\n     *    as the default value for the binding. If the bindingValue property is inserted\r\n     *    and it is either a string, number or null value then that will replace the default\r\n     *    value.\r\n     *\r\n     * Note that this function is also used for map-based styling bindings. They are treated\r\n     * much the same as prop-based bindings, but, because they do not have a property value\r\n     * (since it's a map), all map-based entries are stored in an already populated area of\r\n     * the context at the top (which is reserved for map-based entries).\r\n     */\r\n    function registerBinding(context, countId, prop, bindingValue, sanitizationRequired) {\r\n        var registered = false;\r\n        if (prop) {\r\n            // prop-based bindings (e.g `<div [style.width]=\"w\" [class.foo]=\"f\">`)\r\n            var found = false;\r\n            var i = getPropValuesStartPosition(context);\r\n            while (i < context.length) {\r\n                var valuesCount = getValuesCount(context, i);\r\n                var p = getProp(context, i);\r\n                found = prop <= p;\r\n                if (found) {\r\n                    // all style/class bindings are sorted by property name\r\n                    if (prop < p) {\r\n                        allocateNewContextEntry(context, i, prop, sanitizationRequired);\r\n                    }\r\n                    addBindingIntoContext(context, false, i, bindingValue, countId);\r\n                    break;\r\n                }\r\n                i += 3 /* BindingsStartOffset */ + valuesCount;\r\n            }\r\n            if (!found) {\r\n                allocateNewContextEntry(context, context.length, prop, sanitizationRequired);\r\n                addBindingIntoContext(context, false, i, bindingValue, countId);\r\n                registered = true;\r\n            }\r\n        }\r\n        else {\r\n            // map-based bindings (e.g `<div [style]=\"s\" [class]=\"{className:true}\">`)\r\n            // there is no need to allocate the map-based binding region into the context\r\n            // since it is already there when the context is first created.\r\n            addBindingIntoContext(context, true, 3 /* MapBindingsPosition */, bindingValue, countId);\r\n            registered = true;\r\n        }\r\n        return registered;\r\n    }\r\n    function allocateNewContextEntry(context, index, prop, sanitizationRequired) {\r\n        // 1,2: splice index locations\r\n        // 3: each entry gets a config value (guard mask + flags)\r\n        // 4. each entry gets a size value (which is always one because there is always a default binding\r\n        // value)\r\n        // 5. the property that is getting allocated into the context\r\n        // 6. the default binding value (usually `null`)\r\n        var config = sanitizationRequired ? 1 /* SanitizationRequired */ :\r\n            0 /* Default */;\r\n        context.splice(index, 0, config, DEFAULT_SIZE_VALUE, prop, DEFAULT_BINDING_VALUE);\r\n        setGuardMask(context, index, DEFAULT_GUARD_MASK_VALUE);\r\n    }\r\n    /**\r\n     * Inserts a new binding value into a styling property tuple in the `TStylingContext`.\r\n     *\r\n     * A bindingValue is inserted into a context during the first update pass\r\n     * of a template or host bindings function. When this occurs, two things\r\n     * happen:\r\n     *\r\n     * - If the bindingValue value is a number then it is treated as a bindingIndex\r\n     *   value (a index in the `LView`) and it will be inserted next to the other\r\n     *   binding index entries.\r\n     *\r\n     * - Otherwise the binding value will update the default value for the property\r\n     *   and this will only happen if the default value is `null`.\r\n     *\r\n     * Note that this function also handles map-based bindings and will insert them\r\n     * at the top of the context.\r\n     */\r\n    function addBindingIntoContext(context, isMapBased, index, bindingValue, countId) {\r\n        var valuesCount = getValuesCount(context, index);\r\n        var firstValueIndex = index + 3 /* BindingsStartOffset */;\r\n        var lastValueIndex = firstValueIndex + valuesCount;\r\n        if (!isMapBased) {\r\n            // prop-based values all have default values, but map-based entries do not.\r\n            // we want to access the index for the default value in this case and not just\r\n            // the bindings...\r\n            lastValueIndex--;\r\n        }\r\n        if (typeof bindingValue === 'number') {\r\n            // the loop here will check to see if the binding already exists\r\n            // for the property in the context. Why? The reason for this is\r\n            // because the styling context is not \"locked\" until the first\r\n            // flush has occurred. This means that if a repeated element\r\n            // registers its styling bindings then it will register each\r\n            // binding more than once (since its duplicated). This check\r\n            // will prevent that from happening. Note that this only happens\r\n            // when a binding is first encountered and not each time it is\r\n            // updated.\r\n            for (var i = firstValueIndex; i <= lastValueIndex; i++) {\r\n                var indexAtPosition = context[i];\r\n                if (indexAtPosition === bindingValue)\r\n                    return;\r\n            }\r\n            context.splice(lastValueIndex, 0, bindingValue);\r\n            context[index + 1 /* ValuesCountOffset */]++;\r\n            // now that a new binding index has been added to the property\r\n            // the guard mask bit value (at the `countId` position) needs\r\n            // to be included into the existing mask value.\r\n            var guardMask = getGuardMask(context, index) | (1 << countId);\r\n            setGuardMask(context, index, guardMask);\r\n        }\r\n        else if (bindingValue !== null && context[lastValueIndex] == null) {\r\n            context[lastValueIndex] = bindingValue;\r\n        }\r\n    }\r\n    /**\r\n     * Applies all pending style and class bindings to the provided element.\r\n     *\r\n     * This function will attempt to flush styling via the provided `classesContext`\r\n     * and `stylesContext` context values. This function is designed to be run from\r\n     * the `stylingApply()` instruction (which is run at the very end of styling\r\n     * change detection) and will rely on any state values that are set from when\r\n     * any styling bindings update.\r\n     *\r\n     * This function may be called multiple times on the same element because it can\r\n     * be called from the template code as well as from host bindings. In order for\r\n     * styling to be successfully flushed to the element (which will only happen once\r\n     * despite this being called multiple times), the following criteria must be met:\r\n     *\r\n     * - `flushStyling` is called from the very last directive that has styling for\r\n     *    the element (see `allowStylingFlush()`).\r\n     * - one or more bindings for classes or styles has updated (this is checked by\r\n     *   examining the classes or styles bit mask).\r\n     *\r\n     * If the style and class values are successfully applied to the element then\r\n     * the temporary state values for the element will be cleared. Otherwise, if\r\n     * this did not occur then the styling state is persisted (see `state.ts` for\r\n     * more information on how this works).\r\n     */\r\n    function flushStyling(renderer, data, classesContext, stylesContext, element, directiveIndex, styleSanitizer) {\r\n        ngDevMode && ngDevMode.flushStyling++;\r\n        var persistState = classesContext ? stateIsPersisted(classesContext) :\r\n            (stylesContext ? stateIsPersisted(stylesContext) : false);\r\n        var allowFlushClasses = allowStylingFlush(classesContext, directiveIndex);\r\n        var allowFlushStyles = allowStylingFlush(stylesContext, directiveIndex);\r\n        // deferred bindings are bindings which are scheduled to register with\r\n        // the context at a later point. These bindings can only registered when\r\n        // the context will be 100% flushed to the element.\r\n        if (deferredBindingQueue.length && (allowFlushClasses || allowFlushStyles)) {\r\n            flushDeferredBindings();\r\n        }\r\n        var state = getStylingState(element, persistState);\r\n        var classesFlushed = maybeApplyStyling(renderer, element, data, classesContext, allowFlushClasses, state.classesBitMask, setClass, null);\r\n        var stylesFlushed = maybeApplyStyling(renderer, element, data, stylesContext, allowFlushStyles, state.stylesBitMask, setStyle, styleSanitizer);\r\n        if (classesFlushed && stylesFlushed) {\r\n            resetStylingState();\r\n            if (persistState) {\r\n                deleteStylingStateFromStorage(element);\r\n            }\r\n        }\r\n        else if (persistState) {\r\n            storeStylingState(element, state);\r\n        }\r\n    }\r\n    function maybeApplyStyling(renderer, element, data, context, allowFlush, bitMask, styleSetter, styleSanitizer) {\r\n        if (allowFlush && context) {\r\n            lockAndFinalizeContext(context);\r\n            if (contextHasUpdates(context, bitMask)) {\r\n                ngDevMode && (styleSanitizer ? ngDevMode.stylesApplied++ : ngDevMode.classesApplied++);\r\n                applyStyling(context, renderer, element, data, bitMask, styleSetter, styleSanitizer);\r\n                return true;\r\n            }\r\n        }\r\n        return allowFlush;\r\n    }\r\n    function contextHasUpdates(context, bitMask) {\r\n        return context && bitMask > BIT_MASK_START_VALUE;\r\n    }\r\n    /**\r\n     * Locks the context (so no more bindings can be added) and also copies over initial class/style\r\n     * values into their binding areas.\r\n     *\r\n     * There are two main actions that take place in this function:\r\n     *\r\n     * - Locking the context:\r\n     *   Locking the context is required so that the style/class instructions know NOT to\r\n     *   register a binding again after the first update pass has run. If a locking bit was\r\n     *   not used then it would need to scan over the context each time an instruction is run\r\n     *   (which is expensive).\r\n     *\r\n     * - Patching initial values:\r\n     *   Directives and component host bindings may include static class/style values which are\r\n     *   bound to the host element. When this happens, the styling context will need to be informed\r\n     *   so it can use these static styling values as defaults when a matching binding is falsy.\r\n     *   These initial styling values are read from the initial styling values slot within the\r\n     *   provided `TStylingContext` (which is an instance of a `StylingMapArray`). This inner map will\r\n     *   be updated each time a host binding applies its static styling values (via `elementHostAttrs`)\r\n     *   so these values are only read at this point because this is the very last point before the\r\n     *   first style/class values are flushed to the element.\r\n     */\r\n    function lockAndFinalizeContext(context) {\r\n        if (!isContextLocked(context)) {\r\n            var initialValues = getStylingMapArray(context);\r\n            if (initialValues) {\r\n                updateInitialStylingOnContext(context, initialValues);\r\n            }\r\n            lockContext(context);\r\n        }\r\n    }\r\n    /**\r\n     * Runs through the provided styling context and applies each value to\r\n     * the provided element (via the renderer) if one or more values are present.\r\n     *\r\n     * This function will iterate over all entries present in the provided\r\n     * `TStylingContext` array (both prop-based and map-based bindings).-\r\n     *\r\n     * Each entry, within the `TStylingContext` array, is stored alphabetically\r\n     * and this means that each prop/value entry will be applied in order\r\n     * (so long as it is marked dirty in the provided `bitMask` value).\r\n     *\r\n     * If there are any map-based entries present (which are applied to the\r\n     * element via the `[style]` and `[class]` bindings) then those entries\r\n     * will be applied as well. However, the code for that is not a part of\r\n     * this function. Instead, each time a property is visited, then the\r\n     * code below will call an external function called `stylingMapsSyncFn`\r\n     * and, if present, it will keep the application of styling values in\r\n     * map-based bindings up to sync with the application of prop-based\r\n     * bindings.\r\n     *\r\n     * Visit `styling_next/map_based_bindings.ts` to learn more about how the\r\n     * algorithm works for map-based styling bindings.\r\n     *\r\n     * Note that this function is not designed to be called in isolation (use\r\n     * `applyClasses` and `applyStyles` to actually apply styling values).\r\n     */\r\n    function applyStyling(context, renderer, element, bindingData, bitMaskValue, applyStylingFn, sanitizer) {\r\n        var bitMask = normalizeBitMaskValue(bitMaskValue);\r\n        var stylingMapsSyncFn = getStylingMapsSyncFn();\r\n        var mapsGuardMask = getGuardMask(context, 3 /* MapBindingsPosition */);\r\n        var applyAllValues = (bitMask & mapsGuardMask) > 0;\r\n        var mapsMode = applyAllValues ? 1 /* ApplyAllValues */ : 0 /* TraverseValues */;\r\n        var i = getPropValuesStartPosition(context);\r\n        while (i < context.length) {\r\n            var valuesCount = getValuesCount(context, i);\r\n            var guardMask = getGuardMask(context, i);\r\n            if (bitMask & guardMask) {\r\n                var valueApplied = false;\r\n                var prop = getProp(context, i);\r\n                var valuesCountUpToDefault = valuesCount - 1;\r\n                var defaultValue = getBindingValue(context, i, valuesCountUpToDefault);\r\n                // case 1: apply prop-based values\r\n                // try to apply the binding values and see if a non-null\r\n                // value gets set for the styling binding\r\n                for (var j = 0; j < valuesCountUpToDefault; j++) {\r\n                    var bindingIndex = getBindingValue(context, i, j);\r\n                    var value = bindingData[bindingIndex];\r\n                    if (isStylingValueDefined(value)) {\r\n                        var finalValue = sanitizer && isSanitizationRequired(context, i) ?\r\n                            sanitizer(prop, value, 2 /* SanitizeOnly */) :\r\n                            value;\r\n                        applyStylingFn(renderer, element, prop, finalValue, bindingIndex);\r\n                        valueApplied = true;\r\n                        break;\r\n                    }\r\n                }\r\n                // case 2: apply map-based values\r\n                // traverse through each map-based styling binding and update all values up to\r\n                // the provided `prop` value. If the property was not applied in the loop above\r\n                // then it will be attempted to be applied in the maps sync code below.\r\n                if (stylingMapsSyncFn) {\r\n                    // determine whether or not to apply the target property or to skip it\r\n                    var mode = mapsMode | (valueApplied ? 4 /* SkipTargetProp */ :\r\n                        2 /* ApplyTargetProp */);\r\n                    var valueAppliedWithinMap = stylingMapsSyncFn(context, renderer, element, bindingData, applyStylingFn, sanitizer, mode, prop, defaultValue);\r\n                    valueApplied = valueApplied || valueAppliedWithinMap;\r\n                }\r\n                // case 3: apply the default value\r\n                // if the value has not yet been applied then a truthy value does not exist in the\r\n                // prop-based or map-based bindings code. If and when this happens, just apply the\r\n                // default value (even if the default value is `null`).\r\n                if (!valueApplied) {\r\n                    applyStylingFn(renderer, element, prop, defaultValue);\r\n                }\r\n            }\r\n            i += 3 /* BindingsStartOffset */ + valuesCount;\r\n        }\r\n        // the map-based styling entries may have not applied all their\r\n        // values. For this reason, one more call to the sync function\r\n        // needs to be issued at the end.\r\n        if (stylingMapsSyncFn) {\r\n            stylingMapsSyncFn(context, renderer, element, bindingData, applyStylingFn, sanitizer, mapsMode);\r\n        }\r\n    }\r\n    function normalizeBitMaskValue(value) {\r\n        // if pass => apply all values (-1 implies that all bits are flipped to true)\r\n        if (value === true)\r\n            return -1;\r\n        // if pass => skip all values\r\n        if (value === false)\r\n            return 0;\r\n        // return the bit mask value as is\r\n        return value;\r\n    }\r\n    var _activeStylingMapApplyFn = null;\r\n    function getStylingMapsSyncFn() {\r\n        return _activeStylingMapApplyFn;\r\n    }\r\n    function setStylingMapsSyncFn(fn) {\r\n        _activeStylingMapApplyFn = fn;\r\n    }\r\n    /**\r\n     * Assigns a style value to a style property for the given element.\r\n     */\r\n    var setStyle = function (renderer, native, prop, value) {\r\n        // the reason why this may be `null` is either because\r\n        // it's a container element or it's a part of a test\r\n        // environment that doesn't have styling. In either\r\n        // case it's safe not to apply styling to the element.\r\n        var nativeStyle = native.style;\r\n        if (value) {\r\n            // opacity, z-index and flexbox all have number values\r\n            // and these need to be converted into strings so that\r\n            // they can be assigned properly.\r\n            value = value.toString();\r\n            ngDevMode && ngDevMode.rendererSetStyle++;\r\n            renderer && isProceduralRenderer(renderer) ?\r\n                renderer.setStyle(native, prop, value, RendererStyleFlags3.DashCase) :\r\n                (nativeStyle && nativeStyle.setProperty(prop, value));\r\n        }\r\n        else {\r\n            ngDevMode && ngDevMode.rendererRemoveStyle++;\r\n            renderer && isProceduralRenderer(renderer) ?\r\n                renderer.removeStyle(native, prop, RendererStyleFlags3.DashCase) :\r\n                (nativeStyle && nativeStyle.removeProperty(prop));\r\n        }\r\n    };\r\n    var ɵ0$4 = setStyle;\r\n    /**\r\n     * Adds/removes the provided className value to the provided element.\r\n     */\r\n    var setClass = function (renderer, native, className, value) {\r\n        if (className !== '') {\r\n            // the reason why this may be `null` is either because\r\n            // it's a container element or it's a part of a test\r\n            // environment that doesn't have styling. In either\r\n            // case it's safe not to apply styling to the element.\r\n            var classList = native.classList;\r\n            if (value) {\r\n                ngDevMode && ngDevMode.rendererAddClass++;\r\n                renderer && isProceduralRenderer(renderer) ? renderer.addClass(native, className) :\r\n                    (classList && classList.add(className));\r\n            }\r\n            else {\r\n                ngDevMode && ngDevMode.rendererRemoveClass++;\r\n                renderer && isProceduralRenderer(renderer) ? renderer.removeClass(native, className) :\r\n                    (classList && classList.remove(className));\r\n            }\r\n        }\r\n    };\r\n    var ɵ1$1 = setClass;\r\n    /**\r\n     * Iterates over all provided styling entries and renders them on the element.\r\n     *\r\n     * This function is used alongside a `StylingMapArray` entry. This entry is not\r\n     * the same as the `TStylingContext` and is only really used when an element contains\r\n     * initial styling values (e.g. `<div style=\"width:200px\">`), but no style/class bindings\r\n     * are present. If and when that happens then this function will be called to render all\r\n     * initial styling values on an element.\r\n     */\r\n    function renderStylingMap(renderer, element, stylingValues, isClassBased) {\r\n        var stylingMapArr = getStylingMapArray(stylingValues);\r\n        if (stylingMapArr) {\r\n            for (var i = 1 /* ValuesStartPosition */; i < stylingMapArr.length; i += 2 /* TupleSize */) {\r\n                var prop = getMapProp(stylingMapArr, i);\r\n                var value = getMapValue(stylingMapArr, i);\r\n                if (isClassBased) {\r\n                    setClass(renderer, element, prop, value, null);\r\n                }\r\n                else {\r\n                    setStyle(renderer, element, prop, value, null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Registers all initial styling entries into the provided context.\r\n     *\r\n     * This function will iterate over all entries in the provided `initialStyling` ar}ray and register\r\n     * them as default (initial) values in the provided context. Initial styling values in a context are\r\n     * the default values that are to be applied unless overwritten by a binding.\r\n     *\r\n     * The reason why this function exists and isn't a part of the context construction is because\r\n     * host binding is evaluated at a later stage after the element is created. This means that\r\n     * if a directive or component contains any initial styling code (i.e. `<div class=\"foo\">`)\r\n     * then that initial styling data can only be applied once the styling for that element\r\n     * is first applied (at the end of the update phase). Once that happens then the context will\r\n     * update itself with the complete initial styling for the element.\r\n     */\r\n    function updateInitialStylingOnContext(context, initialStyling) {\r\n        // `-1` is used here because all initial styling data is not a spart\r\n        // of a binding (since it's static)\r\n        var INITIAL_STYLING_COUNT_ID = -1;\r\n        for (var i = 1 /* ValuesStartPosition */; i < initialStyling.length; i += 2 /* TupleSize */) {\r\n            var value = getMapValue(initialStyling, i);\r\n            if (value) {\r\n                var prop = getMapProp(initialStyling, i);\r\n                registerBinding(context, INITIAL_STYLING_COUNT_ID, prop, value, false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /** A special value which designates that a value has not changed. */\r\n    var NO_CHANGE = {};\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Marks that the next string is for element.\r\n     *\r\n     * See `I18nMutateOpCodes` documentation.\r\n     */\r\n    var ELEMENT_MARKER = {\r\n        marker: 'element'\r\n    };\r\n    /**\r\n     * Marks that the next string is for comment.\r\n     *\r\n     * See `I18nMutateOpCodes` documentation.\r\n     */\r\n    var COMMENT_MARKER = {\r\n        marker: 'comment'\r\n    };\r\n    // Note: This hack is necessary so we don't erroneously get a circular dependency\r\n    // failure based on types.\r\n    var unusedValueExportToPlacateAjd$6 = 1;\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function attachDebugObject(obj, debug) {\r\n        Object.defineProperty(obj, 'debug', { value: debug, enumerable: false });\r\n    }\r\n\r\n    /**\r\n     * --------\r\n     *\r\n     * This file contains the algorithm logic for applying map-based bindings\r\n     * such as `[style]` and `[class]`.\r\n     *\r\n     * --------\r\n     */\r\n    /**\r\n     * Used to apply styling values presently within any map-based bindings on an element.\r\n     *\r\n     * Angular supports map-based styling bindings which can be applied via the\r\n     * `[style]` and `[class]` bindings which can be placed on any HTML element.\r\n     * These bindings can work independently, together or alongside prop-based\r\n     * styling bindings (e.g. `<div [style]=\"x\" [style.width]=\"w\">`).\r\n     *\r\n     * If a map-based styling binding is detected by the compiler, the following\r\n     * AOT code is produced:\r\n     *\r\n     * ```typescript\r\n     * styleMap(ctx.styles); // styles = {key:value}\r\n     * classMap(ctx.classes); // classes = {key:value}|string\r\n     * ```\r\n     *\r\n     * If and when either of the instructions above are evaluated, then the code\r\n     * present in this file is included into the bundle. The mechanism used, to\r\n     * activate support for map-based bindings at runtime is possible via the\r\n     * `activeStylingMapFeature` function (which is also present in this file).\r\n     *\r\n     * # The Algorithm\r\n     * Whenever a map-based binding updates (which is when the identity of the\r\n     * map-value changes) then the map is iterated over and a `StylingMapArray` array\r\n     * is produced. The `StylingMapArray` instance is stored in the binding location\r\n     * where the `BINDING_INDEX` is situated when the `styleMap()` or `classMap()`\r\n     * instruction were called. Once the binding changes, then the internal `bitMask`\r\n     * value is marked as dirty.\r\n     *\r\n     * Styling values are applied once CD exits the element (which happens when\r\n     * the `select(n)` instruction is called or the template function exits). When\r\n     * this occurs, all prop-based bindings are applied. If a map-based binding is\r\n     * present then a special flushing function (called a sync function) is made\r\n     * available and it will be called each time a styling property is flushed.\r\n     *\r\n     * The flushing algorithm is designed to apply styling for a property (which is\r\n     * a CSS property or a className value) one by one. If map-based bindings\r\n     * are present, then the flushing algorithm will keep calling the maps styling\r\n     * sync function each time a property is visited. This way, the flushing\r\n     * behavior of map-based bindings will always be at the same property level\r\n     * as the current prop-based property being iterated over (because everything\r\n     * is alphabetically sorted).\r\n     *\r\n     * Let's imagine we have the following HTML template code:\r\n     *\r\n     * ```html\r\n     * <div [style]=\"{width:'100px', height:'200px', 'z-index':'10'}\"\r\n     *      [style.width.px]=\"200\">...</div>\r\n     * ```\r\n     *\r\n     * When CD occurs, both the `[style]` and `[style.width]` bindings\r\n     * are evaluated. Then when the styles are flushed on screen, the\r\n     * following operations happen:\r\n     *\r\n     * 1. `[style.width]` is attempted to be written to the element.\r\n     *\r\n     * 2.  Once that happens, the algorithm instructs the map-based\r\n     *     entries (`[style]` in this case) to \"catch up\" and apply\r\n     *     all values up to the `width` value. When this happens the\r\n     *     `height` value is applied to the element (since it is\r\n     *     alphabetically situated before the `width` property).\r\n     *\r\n     * 3. Since there are no more prop-based entries anymore, the\r\n     *    loop exits and then, just before the flushing ends, it\r\n     *    instructs all map-based bindings to \"finish up\" applying\r\n     *    their values.\r\n     *\r\n     * 4. The only remaining value within the map-based entries is\r\n     *    the `z-index` value (`width` got skipped because it was\r\n     *    successfully applied via the prop-based `[style.width]`\r\n     *    binding). Since all map-based entries are told to \"finish up\",\r\n     *    the `z-index` value is iterated over and it is then applied\r\n     *    to the element.\r\n     *\r\n     * The most important thing to take note of here is that prop-based\r\n     * bindings are evaluated in order alongside map-based bindings.\r\n     * This allows all styling across an element to be applied in O(n)\r\n     * time (a similar algorithm is that of the array merge algorithm\r\n     * in merge sort).\r\n     */\r\n    var syncStylingMap = function (context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp, defaultValue) {\r\n        var targetPropValueWasApplied = false;\r\n        // once the map-based styling code is activate it is never deactivated. For this reason a\r\n        // check to see if the current styling context has any map based bindings is required.\r\n        var totalMaps = getValuesCount(context, 3 /* MapBindingsPosition */);\r\n        if (totalMaps) {\r\n            var runTheSyncAlgorithm = true;\r\n            var loopUntilEnd = !targetProp;\r\n            // If the code is told to finish up (run until the end), but the mode\r\n            // hasn't been flagged to apply values (it only traverses values) then\r\n            // there is no point in iterating over the array because nothing will\r\n            // be applied to the element.\r\n            if (loopUntilEnd && (mode & ~1 /* ApplyAllValues */)) {\r\n                runTheSyncAlgorithm = false;\r\n                targetPropValueWasApplied = true;\r\n            }\r\n            if (runTheSyncAlgorithm) {\r\n                targetPropValueWasApplied = innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp || null, 0, defaultValue || null);\r\n            }\r\n            if (loopUntilEnd) {\r\n                resetSyncCursors();\r\n            }\r\n        }\r\n        return targetPropValueWasApplied;\r\n    };\r\n    /**\r\n     * Recursive function designed to apply map-based styling to an element one map at a time.\r\n     *\r\n     * This function is designed to be called from the `syncStylingMap` function and will\r\n     * apply map-based styling data one map at a time to the provided `element`.\r\n     *\r\n     * This function is recursive and it will call itself if a follow-up map value is to be\r\n     * processed. To learn more about how the algorithm works, see `syncStylingMap`.\r\n     */\r\n    function innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp, currentMapIndex, defaultValue) {\r\n        var targetPropValueWasApplied = false;\r\n        var totalMaps = getValuesCount(context, 3 /* MapBindingsPosition */);\r\n        if (currentMapIndex < totalMaps) {\r\n            var bindingIndex = getBindingValue(context, 3 /* MapBindingsPosition */, currentMapIndex);\r\n            var stylingMapArr = data[bindingIndex];\r\n            var cursor = getCurrentSyncCursor(currentMapIndex);\r\n            while (cursor < stylingMapArr.length) {\r\n                var prop = getMapProp(stylingMapArr, cursor);\r\n                var iteratedTooFar = targetProp && prop > targetProp;\r\n                var isTargetPropMatched = !iteratedTooFar && prop === targetProp;\r\n                var value = getMapValue(stylingMapArr, cursor);\r\n                var valueIsDefined = isStylingValueDefined(value);\r\n                // the recursive code is designed to keep applying until\r\n                // it reaches or goes past the target prop. If and when\r\n                // this happens then it will stop processing values, but\r\n                // all other map values must also catch up to the same\r\n                // point. This is why a recursive call is still issued\r\n                // even if the code has iterated too far.\r\n                var innerMode = iteratedTooFar ? mode : resolveInnerMapMode(mode, valueIsDefined, isTargetPropMatched);\r\n                var innerProp = iteratedTooFar ? targetProp : prop;\r\n                var valueApplied = innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, innerMode, innerProp, currentMapIndex + 1, defaultValue);\r\n                if (iteratedTooFar) {\r\n                    if (!targetPropValueWasApplied) {\r\n                        targetPropValueWasApplied = valueApplied;\r\n                    }\r\n                    break;\r\n                }\r\n                if (!valueApplied && isValueAllowedToBeApplied(mode, isTargetPropMatched)) {\r\n                    var useDefault = isTargetPropMatched && !valueIsDefined;\r\n                    var valueToApply = useDefault ? defaultValue : value;\r\n                    var bindingIndexToApply = useDefault ? bindingIndex : null;\r\n                    var finalValue = sanitizer ?\r\n                        sanitizer(prop, valueToApply, 3 /* ValidateAndSanitize */) :\r\n                        valueToApply;\r\n                    applyStylingFn(renderer, element, prop, finalValue, bindingIndexToApply);\r\n                    valueApplied = true;\r\n                }\r\n                targetPropValueWasApplied = valueApplied && isTargetPropMatched;\r\n                cursor += 2 /* TupleSize */;\r\n            }\r\n            setCurrentSyncCursor(currentMapIndex, cursor);\r\n            // this is a fallback case in the event that the styling map is `null` for this\r\n            // binding but there are other map-based bindings that need to be evaluated\r\n            // afterwards. If the `prop` value is falsy then the intention is to cycle\r\n            // through all of the properties in the remaining maps as well. If the current\r\n            // styling map is too short then there are no values to iterate over. In either\r\n            // case the follow-up maps need to be iterated over.\r\n            if (stylingMapArr.length === 1 /* ValuesStartPosition */ || !targetProp) {\r\n                return innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp, currentMapIndex + 1, defaultValue);\r\n            }\r\n        }\r\n        return targetPropValueWasApplied;\r\n    }\r\n    /**\r\n     * Enables support for map-based styling bindings (e.g. `[style]` and `[class]` bindings).\r\n     */\r\n    function activateStylingMapFeature() {\r\n        setStylingMapsSyncFn(syncStylingMap);\r\n    }\r\n    /**\r\n     * Used to determine the mode for the inner recursive call.\r\n     *\r\n     * If an inner map is iterated on then this is done so for one\r\n     * of two reasons:\r\n     *\r\n     * - value is being applied:\r\n     *   if the value is being applied from this current styling\r\n     *   map then there is no need to apply it in a deeper map.\r\n     *\r\n     * - value is being not applied:\r\n     *   apply the value if it is found in a deeper map.\r\n     *\r\n     * When these reasons are encountered the flags will for the\r\n     * inner map mode will be configured.\r\n     */\r\n    function resolveInnerMapMode(currentMode, valueIsDefined, isExactMatch) {\r\n        var innerMode = currentMode;\r\n        if (!valueIsDefined && !(currentMode & 4 /* SkipTargetProp */) &&\r\n            (isExactMatch || (currentMode & 1 /* ApplyAllValues */))) {\r\n            // case 1: set the mode to apply the targeted prop value if it\r\n            // ends up being encountered in another map value\r\n            innerMode |= 2 /* ApplyTargetProp */;\r\n            innerMode &= ~4 /* SkipTargetProp */;\r\n        }\r\n        else {\r\n            // case 2: set the mode to skip the targeted prop value if it\r\n            // ends up being encountered in another map value\r\n            innerMode |= 4 /* SkipTargetProp */;\r\n            innerMode &= ~2 /* ApplyTargetProp */;\r\n        }\r\n        return innerMode;\r\n    }\r\n    /**\r\n     * Decides whether or not a prop/value entry will be applied to an element.\r\n     *\r\n     * To determine whether or not a value is to be applied,\r\n     * the following procedure is evaluated:\r\n     *\r\n     * First check to see the current `mode` status:\r\n     *  1. If the mode value permits all props to be applied then allow.\r\n     *    - But do not allow if the current prop is set to be skipped.\r\n     *  2. Otherwise if the current prop is permitted then allow.\r\n     */\r\n    function isValueAllowedToBeApplied(mode, isTargetPropMatched) {\r\n        var doApplyValue = (mode & 1 /* ApplyAllValues */) > 0;\r\n        if (!doApplyValue) {\r\n            if (mode & 2 /* ApplyTargetProp */) {\r\n                doApplyValue = isTargetPropMatched;\r\n            }\r\n        }\r\n        else if ((mode & 4 /* SkipTargetProp */) && isTargetPropMatched) {\r\n            doApplyValue = false;\r\n        }\r\n        return doApplyValue;\r\n    }\r\n    /**\r\n     * Used to keep track of concurrent cursor values for multiple map-based styling bindings present on\r\n     * an element.\r\n     */\r\n    var MAP_CURSORS = [];\r\n    /**\r\n     * Used to reset the state of each cursor value being used to iterate over map-based styling\r\n     * bindings.\r\n     */\r\n    function resetSyncCursors() {\r\n        for (var i = 0; i < MAP_CURSORS.length; i++) {\r\n            MAP_CURSORS[i] = 1 /* ValuesStartPosition */;\r\n        }\r\n    }\r\n    /**\r\n     * Returns an active cursor value at a given mapIndex location.\r\n     */\r\n    function getCurrentSyncCursor(mapIndex) {\r\n        if (mapIndex >= MAP_CURSORS.length) {\r\n            MAP_CURSORS.push(1 /* ValuesStartPosition */);\r\n        }\r\n        return MAP_CURSORS[mapIndex];\r\n    }\r\n    /**\r\n     * Sets a cursor value at a given mapIndex location.\r\n     */\r\n    function setCurrentSyncCursor(mapIndex, indexValue) {\r\n        MAP_CURSORS[mapIndex] = indexValue;\r\n    }\r\n    /**\r\n     * Used to convert a {key:value} map into a `StylingMapArray` array.\r\n     *\r\n     * This function will either generate a new `StylingMapArray` instance\r\n     * or it will patch the provided `newValues` map value into an\r\n     * existing `StylingMapArray` value (this only happens if `bindingValue`\r\n     * is an instance of `StylingMapArray`).\r\n     *\r\n     * If a new key/value map is provided with an old `StylingMapArray`\r\n     * value then all properties will be overwritten with their new\r\n     * values or with `null`. This means that the array will never\r\n     * shrink in size (but it will also not be created and thrown\r\n     * away whenever the {key:value} map entries change).\r\n     */\r\n    function normalizeIntoStylingMap(bindingValue, newValues, normalizeProps) {\r\n        var stylingMapArr = Array.isArray(bindingValue) ? bindingValue : [null];\r\n        stylingMapArr[0 /* RawValuePosition */] = newValues || null;\r\n        // because the new values may not include all the properties\r\n        // that the old ones had, all values are set to `null` before\r\n        // the new values are applied. This way, when flushed, the\r\n        // styling algorithm knows exactly what style/class values\r\n        // to remove from the element (since they are `null`).\r\n        for (var j = 1 /* ValuesStartPosition */; j < stylingMapArr.length; j += 2 /* TupleSize */) {\r\n            setMapValue(stylingMapArr, j, null);\r\n        }\r\n        var props = null;\r\n        var map;\r\n        var allValuesTrue = false;\r\n        if (typeof newValues === 'string') { // [class] bindings allow string values\r\n            if (newValues.length) {\r\n                props = newValues.split(/\\s+/);\r\n                allValuesTrue = true;\r\n            }\r\n        }\r\n        else {\r\n            props = newValues ? Object.keys(newValues) : null;\r\n            map = newValues;\r\n        }\r\n        if (props) {\r\n            for (var i = 0; i < props.length; i++) {\r\n                var prop = props[i];\r\n                var newProp = normalizeProps ? hyphenate(prop) : prop;\r\n                var value = allValuesTrue ? true : map[prop];\r\n                addItemToStylingMap(stylingMapArr, newProp, value, true);\r\n            }\r\n        }\r\n        return stylingMapArr;\r\n    }\r\n    /**\r\n     * Inserts the provided item into the provided styling array at the right spot.\r\n     *\r\n     * The `StylingMapArray` type is a sorted key/value array of entries. This means\r\n     * that when a new entry is inserted it must be placed at the right spot in the\r\n     * array. This function figures out exactly where to place it.\r\n     */\r\n    function addItemToStylingMap(stylingMapArr, prop, value, allowOverwrite) {\r\n        for (var j = 1 /* ValuesStartPosition */; j < stylingMapArr.length; j += 2 /* TupleSize */) {\r\n            var propAtIndex = getMapProp(stylingMapArr, j);\r\n            if (prop <= propAtIndex) {\r\n                var applied = false;\r\n                if (propAtIndex === prop) {\r\n                    var valueAtIndex = stylingMapArr[j];\r\n                    if (allowOverwrite || !isStylingValueDefined(valueAtIndex)) {\r\n                        applied = true;\r\n                        setMapValue(stylingMapArr, j, value);\r\n                    }\r\n                }\r\n                else {\r\n                    applied = true;\r\n                    stylingMapArr.splice(j, 0, prop, value);\r\n                }\r\n                return applied;\r\n            }\r\n        }\r\n        stylingMapArr.push(prop, value);\r\n        return true;\r\n    }\r\n    /**\r\n     * Converts the provided styling map array into a string.\r\n     *\r\n     * Classes => `one two three`\r\n     * Styles => `prop:value; prop2:value2`\r\n     */\r\n    function stylingMapToString(map, isClassBased) {\r\n        var str = '';\r\n        for (var i = 1 /* ValuesStartPosition */; i < map.length; i += 2 /* TupleSize */) {\r\n            var prop = getMapProp(map, i);\r\n            var value = getMapValue(map, i);\r\n            var attrValue = concatString(prop, isClassBased ? '' : value, ':');\r\n            str = concatString(str, attrValue, isClassBased ? ' ' : '; ');\r\n        }\r\n        return str;\r\n    }\r\n    /**\r\n     * Converts the provided styling map array into a key value map.\r\n     */\r\n    function stylingMapToStringMap(map) {\r\n        var stringMap = {};\r\n        if (map) {\r\n            for (var i = 1 /* ValuesStartPosition */; i < map.length; i += 2 /* TupleSize */) {\r\n                var prop = getMapProp(map, i);\r\n                var value = getMapValue(map, i);\r\n                stringMap[prop] = value;\r\n            }\r\n        }\r\n        return stringMap;\r\n    }\r\n\r\n    /**\r\n     * Instantiates and attaches an instance of `TStylingContextDebug` to the provided context.\r\n     */\r\n    function attachStylingDebugObject(context) {\r\n        var debug = new TStylingContextDebug(context);\r\n        attachDebugObject(context, debug);\r\n        return debug;\r\n    }\r\n    /**\r\n     * A human-readable debug summary of the styling data present within `TStylingContext`.\r\n     *\r\n     * This class is designed to be used within testing code or when an\r\n     * application has `ngDevMode` activated.\r\n     */\r\n    var TStylingContextDebug = /** @class */ (function () {\r\n        function TStylingContextDebug(context) {\r\n            this.context = context;\r\n        }\r\n        Object.defineProperty(TStylingContextDebug.prototype, \"isLocked\", {\r\n            get: function () { return isContextLocked(this.context); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(TStylingContextDebug.prototype, \"entries\", {\r\n            /**\r\n             * Returns a detailed summary of each styling entry in the context.\r\n             *\r\n             * See `TStylingTupleSummary`.\r\n             */\r\n            get: function () {\r\n                var context = this.context;\r\n                var entries = {};\r\n                var start = 3 /* MapBindingsPosition */;\r\n                var i = start;\r\n                while (i < context.length) {\r\n                    var valuesCount = getValuesCount(context, i);\r\n                    // the context may contain placeholder values which are populated ahead of time,\r\n                    // but contain no actual binding values. In this situation there is no point in\r\n                    // classifying this as an \"entry\" since no real data is stored here yet.\r\n                    if (valuesCount) {\r\n                        var prop = getProp(context, i);\r\n                        var guardMask = getGuardMask(context, i);\r\n                        var defaultValue = getDefaultValue(context, i);\r\n                        var sanitizationRequired = isSanitizationRequired(context, i);\r\n                        var bindingsStartPosition = i + 3 /* BindingsStartOffset */;\r\n                        var sources = [];\r\n                        for (var j = 0; j < valuesCount; j++) {\r\n                            sources.push(context[bindingsStartPosition + j]);\r\n                        }\r\n                        entries[prop] = { prop: prop, guardMask: guardMask, sanitizationRequired: sanitizationRequired, valuesCount: valuesCount, defaultValue: defaultValue, sources: sources };\r\n                    }\r\n                    i += 3 /* BindingsStartOffset */ + valuesCount;\r\n                }\r\n                return entries;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return TStylingContextDebug;\r\n    }());\r\n    /**\r\n     * A human-readable debug summary of the styling data present for a `DebugNode` instance.\r\n     *\r\n     * This class is designed to be used within testing code or when an\r\n     * application has `ngDevMode` activated.\r\n     */\r\n    var NodeStylingDebug = /** @class */ (function () {\r\n        function NodeStylingDebug(context, _data, _isClassBased) {\r\n            this.context = context;\r\n            this._data = _data;\r\n            this._isClassBased = _isClassBased;\r\n            this._sanitizer = null;\r\n        }\r\n        /**\r\n         * Overrides the sanitizer used to process styles.\r\n         */\r\n        NodeStylingDebug.prototype.overrideSanitizer = function (sanitizer) { this._sanitizer = sanitizer; };\r\n        Object.defineProperty(NodeStylingDebug.prototype, \"summary\", {\r\n            /**\r\n             * Returns a detailed summary of each styling entry in the context and\r\n             * what their runtime representation is.\r\n             *\r\n             * See `LStylingSummary`.\r\n             */\r\n            get: function () {\r\n                var entries = {};\r\n                this._mapValues(function (prop, value, bindingIndex) {\r\n                    entries[prop] = { prop: prop, value: value, bindingIndex: bindingIndex };\r\n                });\r\n                return entries;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(NodeStylingDebug.prototype, \"values\", {\r\n            /**\r\n             * Returns a key/value map of all the styles/classes that were last applied to the element.\r\n             */\r\n            get: function () {\r\n                var entries = {};\r\n                this._mapValues(function (prop, value) { entries[prop] = value; });\r\n                return entries;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        NodeStylingDebug.prototype._mapValues = function (fn) {\r\n            // there is no need to store/track an element instance. The\r\n            // element is only used when the styling algorithm attempts to\r\n            // style the value (and we mock out the stylingApplyFn anyway).\r\n            var mockElement = {};\r\n            var hasMaps = getValuesCount(this.context, 3 /* MapBindingsPosition */) > 0;\r\n            if (hasMaps) {\r\n                activateStylingMapFeature();\r\n            }\r\n            var mapFn = function (renderer, element, prop, value, bindingIndex) { fn(prop, value, bindingIndex || null); };\r\n            var sanitizer = this._isClassBased ? null : (this._sanitizer || getCurrentStyleSanitizer());\r\n            applyStyling(this.context, null, mockElement, this._data, true, mapFn, sanitizer);\r\n        };\r\n        return NodeStylingDebug;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /*\r\n     * This file contains conditionally attached classes which provide human readable (debug) level\r\n     * information for `LView`, `LContainer` and other internal data structures. These data structures\r\n     * are stored internally as array which makes it very difficult during debugging to reason about the\r\n     * current state of the system.\r\n     *\r\n     * Patching the array with extra property does change the array's hidden class' but it does not\r\n     * change the cost of access, therefore this patching should not have significant if any impact in\r\n     * `ngDevMode` mode. (see: https://jsperf.com/array-vs-monkey-patch-array)\r\n     *\r\n     * So instead of seeing:\r\n     * ```\r\n     * Array(30) [Object, 659, null, …]\r\n     * ```\r\n     *\r\n     * You get to see:\r\n     * ```\r\n     * LViewDebug {\r\n     *   views: [...],\r\n     *   flags: {attached: true, ...}\r\n     *   nodes: [\r\n     *     {html: '<div id=\"123\">', ..., nodes: [\r\n     *       {html: '<span>', ..., nodes: null}\r\n     *     ]}\r\n     *   ]\r\n     * }\r\n     * ```\r\n     */\r\n    var LViewArray = ngDevMode && createNamedArrayType('LView');\r\n    var LVIEW_EMPTY; // can't initialize here or it will not be tree shaken, because `LView`\r\n    // constructor could have side-effects.\r\n    /**\r\n     * This function clones a blueprint and creates LView.\r\n     *\r\n     * Simple slice will keep the same type, and we need it to be LView\r\n     */\r\n    function cloneToLView(list) {\r\n        if (LVIEW_EMPTY === undefined)\r\n            LVIEW_EMPTY = new LViewArray();\r\n        return LVIEW_EMPTY.concat(list);\r\n    }\r\n    /**\r\n     * This class is a debug version of Object literal so that we can have constructor name show up in\r\n     * debug tools in ngDevMode.\r\n     */\r\n    var TViewConstructor = /** @class */ (function () {\r\n        function TView(id, //\r\n        blueprint, //\r\n        template, //\r\n        queries, //\r\n        viewQuery, //\r\n        node, //\r\n        data, //\r\n        bindingStartIndex, //\r\n        expandoStartIndex, //\r\n        expandoInstructions, //\r\n        firstTemplatePass, //\r\n        staticViewQueries, //\r\n        staticContentQueries, //\r\n        preOrderHooks, //\r\n        preOrderCheckHooks, //\r\n        contentHooks, //\r\n        contentCheckHooks, //\r\n        viewHooks, //\r\n        viewCheckHooks, //\r\n        destroyHooks, //\r\n        cleanup, //\r\n        contentQueries, //\r\n        components, //\r\n        directiveRegistry, //\r\n        pipeRegistry, //\r\n        firstChild, //\r\n        schemas) {\r\n            this.id = id;\r\n            this.blueprint = blueprint;\r\n            this.template = template;\r\n            this.queries = queries;\r\n            this.viewQuery = viewQuery;\r\n            this.node = node;\r\n            this.data = data;\r\n            this.bindingStartIndex = bindingStartIndex;\r\n            this.expandoStartIndex = expandoStartIndex;\r\n            this.expandoInstructions = expandoInstructions;\r\n            this.firstTemplatePass = firstTemplatePass;\r\n            this.staticViewQueries = staticViewQueries;\r\n            this.staticContentQueries = staticContentQueries;\r\n            this.preOrderHooks = preOrderHooks;\r\n            this.preOrderCheckHooks = preOrderCheckHooks;\r\n            this.contentHooks = contentHooks;\r\n            this.contentCheckHooks = contentCheckHooks;\r\n            this.viewHooks = viewHooks;\r\n            this.viewCheckHooks = viewCheckHooks;\r\n            this.destroyHooks = destroyHooks;\r\n            this.cleanup = cleanup;\r\n            this.contentQueries = contentQueries;\r\n            this.components = components;\r\n            this.directiveRegistry = directiveRegistry;\r\n            this.pipeRegistry = pipeRegistry;\r\n            this.firstChild = firstChild;\r\n            this.schemas = schemas;\r\n        }\r\n        return TView;\r\n    }());\r\n    var TNodeConstructor = /** @class */ (function () {\r\n        function TNode(tView_, //\r\n        type, //\r\n        index, //\r\n        injectorIndex, //\r\n        directiveStart, //\r\n        directiveEnd, //\r\n        propertyMetadataStartIndex, //\r\n        propertyMetadataEndIndex, //\r\n        flags, //\r\n        providerIndexes, //\r\n        tagName, //\r\n        attrs, //\r\n        localNames, //\r\n        initialInputs, //\r\n        inputs, //\r\n        outputs, //\r\n        tViews, //\r\n        next, //\r\n        projectionNext, //\r\n        child, //\r\n        parent, //\r\n        projection, //\r\n        styles, //\r\n        classes) {\r\n            this.tView_ = tView_;\r\n            this.type = type;\r\n            this.index = index;\r\n            this.injectorIndex = injectorIndex;\r\n            this.directiveStart = directiveStart;\r\n            this.directiveEnd = directiveEnd;\r\n            this.propertyMetadataStartIndex = propertyMetadataStartIndex;\r\n            this.propertyMetadataEndIndex = propertyMetadataEndIndex;\r\n            this.flags = flags;\r\n            this.providerIndexes = providerIndexes;\r\n            this.tagName = tagName;\r\n            this.attrs = attrs;\r\n            this.localNames = localNames;\r\n            this.initialInputs = initialInputs;\r\n            this.inputs = inputs;\r\n            this.outputs = outputs;\r\n            this.tViews = tViews;\r\n            this.next = next;\r\n            this.projectionNext = projectionNext;\r\n            this.child = child;\r\n            this.parent = parent;\r\n            this.projection = projection;\r\n            this.styles = styles;\r\n            this.classes = classes;\r\n        }\r\n        Object.defineProperty(TNode.prototype, \"type_\", {\r\n            get: function () {\r\n                switch (this.type) {\r\n                    case 0 /* Container */:\r\n                        return 'TNodeType.Container';\r\n                    case 3 /* Element */:\r\n                        return 'TNodeType.Element';\r\n                    case 4 /* ElementContainer */:\r\n                        return 'TNodeType.ElementContainer';\r\n                    case 5 /* IcuContainer */:\r\n                        return 'TNodeType.IcuContainer';\r\n                    case 1 /* Projection */:\r\n                        return 'TNodeType.Projection';\r\n                    case 2 /* View */:\r\n                        return 'TNodeType.View';\r\n                    default:\r\n                        return 'TNodeType.???';\r\n                }\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(TNode.prototype, \"flags_\", {\r\n            get: function () {\r\n                var flags = [];\r\n                if (this.flags & 8 /* hasClassInput */)\r\n                    flags.push('TNodeFlags.hasClassInput');\r\n                if (this.flags & 4 /* hasContentQuery */)\r\n                    flags.push('TNodeFlags.hasContentQuery');\r\n                if (this.flags & 16 /* hasStyleInput */)\r\n                    flags.push('TNodeFlags.hasStyleInput');\r\n                if (this.flags & 1 /* isComponent */)\r\n                    flags.push('TNodeFlags.isComponent');\r\n                if (this.flags & 32 /* isDetached */)\r\n                    flags.push('TNodeFlags.isDetached');\r\n                if (this.flags & 2 /* isProjected */)\r\n                    flags.push('TNodeFlags.isProjected');\r\n                return flags.join('|');\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return TNode;\r\n    }());\r\n    var TViewData = ngDevMode && createNamedArrayType('TViewData');\r\n    var TVIEWDATA_EMPTY; // can't initialize here or it will not be tree shaken, because `LView`\r\n    // constructor could have side-effects.\r\n    /**\r\n     * This function clones a blueprint and creates TData.\r\n     *\r\n     * Simple slice will keep the same type, and we need it to be TData\r\n     */\r\n    function cloneToTViewData(list) {\r\n        if (TVIEWDATA_EMPTY === undefined)\r\n            TVIEWDATA_EMPTY = new TViewData();\r\n        return TVIEWDATA_EMPTY.concat(list);\r\n    }\r\n    var LViewBlueprint = ngDevMode && createNamedArrayType('LViewBlueprint');\r\n    var MatchesArray = ngDevMode && createNamedArrayType('MatchesArray');\r\n    var TViewComponents = ngDevMode && createNamedArrayType('TViewComponents');\r\n    var TNodeLocalNames = ngDevMode && createNamedArrayType('TNodeLocalNames');\r\n    var TNodeInitialInputs = ngDevMode && createNamedArrayType('TNodeInitialInputs');\r\n    var TNodeInitialData = ngDevMode && createNamedArrayType('TNodeInitialData');\r\n    var LCleanup = ngDevMode && createNamedArrayType('LCleanup');\r\n    var TCleanup = ngDevMode && createNamedArrayType('TCleanup');\r\n    function attachLViewDebug(lView) {\r\n        attachDebugObject(lView, new LViewDebug(lView));\r\n    }\r\n    function attachLContainerDebug(lContainer) {\r\n        attachDebugObject(lContainer, new LContainerDebug(lContainer));\r\n    }\r\n    function toDebug(obj) {\r\n        if (obj) {\r\n            var debug = obj.debug;\r\n            assertDefined(debug, 'Object does not have a debug representation.');\r\n            return debug;\r\n        }\r\n        else {\r\n            return obj;\r\n        }\r\n    }\r\n    /**\r\n     * Use this method to unwrap a native element in `LView` and convert it into HTML for easier\r\n     * reading.\r\n     *\r\n     * @param value possibly wrapped native DOM node.\r\n     * @param includeChildren If `true` then the serialized HTML form will include child elements (same\r\n     * as `outerHTML`). If `false` then the serialized HTML form will only contain the element itself\r\n     * (will not serialize child elements).\r\n     */\r\n    function toHtml(value, includeChildren) {\r\n        if (includeChildren === void 0) { includeChildren = false; }\r\n        var node = unwrapRNode(value);\r\n        if (node) {\r\n            var isTextNode = node.nodeType === Node.TEXT_NODE;\r\n            var outerHTML = (isTextNode ? node.textContent : node.outerHTML) || '';\r\n            if (includeChildren || isTextNode) {\r\n                return outerHTML;\r\n            }\r\n            else {\r\n                var innerHTML = node.innerHTML;\r\n                return outerHTML.split(innerHTML)[0] || null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    var LViewDebug = /** @class */ (function () {\r\n        function LViewDebug(_raw_lView) {\r\n            this._raw_lView = _raw_lView;\r\n        }\r\n        Object.defineProperty(LViewDebug.prototype, \"flags\", {\r\n            /**\r\n             * Flags associated with the `LView` unpacked into a more readable state.\r\n             */\r\n            get: function () {\r\n                var flags = this._raw_lView[FLAGS];\r\n                return {\r\n                    __raw__flags__: flags,\r\n                    initPhaseState: flags & 3 /* InitPhaseStateMask */,\r\n                    creationMode: !!(flags & 4 /* CreationMode */),\r\n                    firstViewPass: !!(flags & 8 /* FirstLViewPass */),\r\n                    checkAlways: !!(flags & 16 /* CheckAlways */),\r\n                    dirty: !!(flags & 64 /* Dirty */),\r\n                    attached: !!(flags & 128 /* Attached */),\r\n                    destroyed: !!(flags & 256 /* Destroyed */),\r\n                    isRoot: !!(flags & 512 /* IsRoot */),\r\n                    indexWithinInitPhase: flags >> 10 /* IndexWithinInitPhaseShift */,\r\n                };\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(LViewDebug.prototype, \"parent\", {\r\n            get: function () { return toDebug(this._raw_lView[PARENT]); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(LViewDebug.prototype, \"host\", {\r\n            get: function () { return toHtml(this._raw_lView[HOST], true); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(LViewDebug.prototype, \"context\", {\r\n            get: function () { return this._raw_lView[CONTEXT]; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(LViewDebug.prototype, \"nodes\", {\r\n            /**\r\n             * The tree of nodes associated with the current `LView`. The nodes have been normalized into a\r\n             * tree structure with relevant details pulled out for readability.\r\n             */\r\n            get: function () {\r\n                var lView = this._raw_lView;\r\n                var tNode = lView[TVIEW].firstChild;\r\n                return toDebugNodes(tNode, lView);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(LViewDebug.prototype, \"__other__\", {\r\n            /**\r\n             * Additional information which is hidden behind a property. The extra level of indirection is\r\n             * done so that the debug view would not be cluttered with properties which are only rarely\r\n             * relevant to the developer.\r\n             */\r\n            get: function () {\r\n                return {\r\n                    tView: this._raw_lView[TVIEW],\r\n                    cleanup: this._raw_lView[CLEANUP],\r\n                    injector: this._raw_lView[INJECTOR$1],\r\n                    rendererFactory: this._raw_lView[RENDERER_FACTORY],\r\n                    renderer: this._raw_lView[RENDERER],\r\n                    sanitizer: this._raw_lView[SANITIZER],\r\n                    childHead: toDebug(this._raw_lView[CHILD_HEAD]),\r\n                    next: toDebug(this._raw_lView[NEXT]),\r\n                    childTail: toDebug(this._raw_lView[CHILD_TAIL]),\r\n                    declarationView: toDebug(this._raw_lView[DECLARATION_VIEW]),\r\n                    queries: null,\r\n                    tHost: this._raw_lView[T_HOST],\r\n                    bindingIndex: this._raw_lView[BINDING_INDEX],\r\n                };\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(LViewDebug.prototype, \"childViews\", {\r\n            /**\r\n             * Normalized view of child views (and containers) attached at this location.\r\n             */\r\n            get: function () {\r\n                var childViews = [];\r\n                var child = this.__other__.childHead;\r\n                while (child) {\r\n                    childViews.push(child);\r\n                    child = child.__other__.next;\r\n                }\r\n                return childViews;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return LViewDebug;\r\n    }());\r\n    /**\r\n     * Turns a flat list of nodes into a tree by walking the associated `TNode` tree.\r\n     *\r\n     * @param tNode\r\n     * @param lView\r\n     */\r\n    function toDebugNodes(tNode, lView) {\r\n        if (tNode) {\r\n            var debugNodes = [];\r\n            var tNodeCursor = tNode;\r\n            while (tNodeCursor) {\r\n                var rawValue = lView[tNode.index];\r\n                var native = unwrapRNode(rawValue);\r\n                var componentLViewDebug = toDebug(readLViewValue(rawValue));\r\n                var styles = isStylingContext(tNode.styles) ?\r\n                    new NodeStylingDebug(tNode.styles, lView) :\r\n                    null;\r\n                var classes = isStylingContext(tNode.classes) ?\r\n                    new NodeStylingDebug(tNode.classes, lView, true) :\r\n                    null;\r\n                debugNodes.push({\r\n                    html: toHtml(native),\r\n                    native: native, styles: styles, classes: classes,\r\n                    nodes: toDebugNodes(tNode.child, lView),\r\n                    component: componentLViewDebug,\r\n                });\r\n                tNodeCursor = tNodeCursor.next;\r\n            }\r\n            return debugNodes;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    var LContainerDebug = /** @class */ (function () {\r\n        function LContainerDebug(_raw_lContainer) {\r\n            this._raw_lContainer = _raw_lContainer;\r\n        }\r\n        Object.defineProperty(LContainerDebug.prototype, \"activeIndex\", {\r\n            get: function () { return this._raw_lContainer[ACTIVE_INDEX]; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(LContainerDebug.prototype, \"views\", {\r\n            get: function () {\r\n                return this._raw_lContainer.slice(CONTAINER_HEADER_OFFSET)\r\n                    .map(toDebug);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(LContainerDebug.prototype, \"parent\", {\r\n            get: function () { return toDebug(this._raw_lContainer[PARENT]); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(LContainerDebug.prototype, \"movedViews\", {\r\n            get: function () { return this._raw_lContainer[MOVED_VIEWS]; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(LContainerDebug.prototype, \"host\", {\r\n            get: function () { return this._raw_lContainer[HOST]; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(LContainerDebug.prototype, \"native\", {\r\n            get: function () { return this._raw_lContainer[NATIVE]; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(LContainerDebug.prototype, \"__other__\", {\r\n            get: function () {\r\n                return {\r\n                    next: toDebug(this._raw_lContainer[NEXT]),\r\n                };\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return LContainerDebug;\r\n    }());\r\n    /**\r\n     * Return an `LView` value if found.\r\n     *\r\n     * @param value `LView` if any\r\n     */\r\n    function readLViewValue(value) {\r\n        while (Array.isArray(value)) {\r\n            // This check is not quite right, as it does not take into account `StylingContext`\r\n            // This is why it is in debug, not in util.ts\r\n            if (value.length >= HEADER_OFFSET - 1)\r\n                return value;\r\n            value = value[HOST];\r\n        }\r\n        return null;\r\n    }\r\n    var I18NDebugItem = /** @class */ (function () {\r\n        function I18NDebugItem(__raw_opCode, _lView, nodeIndex, type) {\r\n            this.__raw_opCode = __raw_opCode;\r\n            this._lView = _lView;\r\n            this.nodeIndex = nodeIndex;\r\n            this.type = type;\r\n        }\r\n        Object.defineProperty(I18NDebugItem.prototype, \"tNode\", {\r\n            get: function () { return getTNode(this.nodeIndex, this._lView); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return I18NDebugItem;\r\n    }());\r\n    /**\r\n     * Turns a list of \"Create\" & \"Update\" OpCodes into a human-readable list of operations for\r\n     * debugging purposes.\r\n     * @param mutateOpCodes mutation opCodes to read\r\n     * @param updateOpCodes update opCodes to read\r\n     * @param icus list of ICU expressions\r\n     * @param lView The view the opCodes are acting on\r\n     */\r\n    function attachI18nOpCodesDebug(mutateOpCodes, updateOpCodes, icus, lView) {\r\n        attachDebugObject(mutateOpCodes, new I18nMutateOpCodesDebug(mutateOpCodes, lView));\r\n        attachDebugObject(updateOpCodes, new I18nUpdateOpCodesDebug(updateOpCodes, icus, lView));\r\n        if (icus) {\r\n            icus.forEach(function (icu) {\r\n                icu.create.forEach(function (icuCase) { attachDebugObject(icuCase, new I18nMutateOpCodesDebug(icuCase, lView)); });\r\n                icu.update.forEach(function (icuCase) {\r\n                    attachDebugObject(icuCase, new I18nUpdateOpCodesDebug(icuCase, icus, lView));\r\n                });\r\n            });\r\n        }\r\n    }\r\n    var I18nMutateOpCodesDebug = /** @class */ (function () {\r\n        function I18nMutateOpCodesDebug(__raw_opCodes, __lView) {\r\n            this.__raw_opCodes = __raw_opCodes;\r\n            this.__lView = __lView;\r\n        }\r\n        Object.defineProperty(I18nMutateOpCodesDebug.prototype, \"operations\", {\r\n            /**\r\n             * A list of operation information about how the OpCodes will act on the view.\r\n             */\r\n            get: function () {\r\n                var _a = this, __lView = _a.__lView, __raw_opCodes = _a.__raw_opCodes;\r\n                var results = [];\r\n                for (var i = 0; i < __raw_opCodes.length; i++) {\r\n                    var opCode = __raw_opCodes[i];\r\n                    var result = void 0;\r\n                    if (typeof opCode === 'string') {\r\n                        result = {\r\n                            __raw_opCode: opCode,\r\n                            type: 'Create Text Node',\r\n                            nodeIndex: __raw_opCodes[++i],\r\n                            text: opCode,\r\n                        };\r\n                    }\r\n                    if (typeof opCode === 'number') {\r\n                        switch (opCode & 7 /* MASK_OPCODE */) {\r\n                            case 1 /* AppendChild */:\r\n                                var destinationNodeIndex = opCode >>> 17 /* SHIFT_PARENT */;\r\n                                result = new I18NDebugItem(opCode, __lView, destinationNodeIndex, 'AppendChild');\r\n                                break;\r\n                            case 0 /* Select */:\r\n                                var nodeIndex = opCode >>> 3 /* SHIFT_REF */;\r\n                                result = new I18NDebugItem(opCode, __lView, nodeIndex, 'Select');\r\n                                break;\r\n                            case 5 /* ElementEnd */:\r\n                                var elementIndex = opCode >>> 3 /* SHIFT_REF */;\r\n                                result = new I18NDebugItem(opCode, __lView, elementIndex, 'ElementEnd');\r\n                                break;\r\n                            case 4 /* Attr */:\r\n                                elementIndex = opCode >>> 3 /* SHIFT_REF */;\r\n                                result = new I18NDebugItem(opCode, __lView, elementIndex, 'Attr');\r\n                                result['attrName'] = __raw_opCodes[++i];\r\n                                result['attrValue'] = __raw_opCodes[++i];\r\n                                break;\r\n                        }\r\n                    }\r\n                    if (!result) {\r\n                        switch (opCode) {\r\n                            case COMMENT_MARKER:\r\n                                result = {\r\n                                    __raw_opCode: opCode,\r\n                                    type: 'COMMENT_MARKER',\r\n                                    commentValue: __raw_opCodes[++i],\r\n                                    nodeIndex: __raw_opCodes[++i],\r\n                                };\r\n                                break;\r\n                            case ELEMENT_MARKER:\r\n                                result = {\r\n                                    __raw_opCode: opCode,\r\n                                    type: 'ELEMENT_MARKER',\r\n                                };\r\n                                break;\r\n                        }\r\n                    }\r\n                    if (!result) {\r\n                        result = {\r\n                            __raw_opCode: opCode,\r\n                            type: 'Unknown Op Code',\r\n                            code: opCode,\r\n                        };\r\n                    }\r\n                    results.push(result);\r\n                }\r\n                return results;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return I18nMutateOpCodesDebug;\r\n    }());\r\n    var I18nUpdateOpCodesDebug = /** @class */ (function () {\r\n        function I18nUpdateOpCodesDebug(__raw_opCodes, icus, __lView) {\r\n            this.__raw_opCodes = __raw_opCodes;\r\n            this.icus = icus;\r\n            this.__lView = __lView;\r\n        }\r\n        Object.defineProperty(I18nUpdateOpCodesDebug.prototype, \"operations\", {\r\n            /**\r\n             * A list of operation information about how the OpCodes will act on the view.\r\n             */\r\n            get: function () {\r\n                var _a = this, __lView = _a.__lView, __raw_opCodes = _a.__raw_opCodes, icus = _a.icus;\r\n                var results = [];\r\n                for (var i = 0; i < __raw_opCodes.length; i++) {\r\n                    // bit code to check if we should apply the next update\r\n                    var checkBit = __raw_opCodes[i];\r\n                    // Number of opCodes to skip until next set of update codes\r\n                    var skipCodes = __raw_opCodes[++i];\r\n                    var value = '';\r\n                    for (var j = i + 1; j <= (i + skipCodes); j++) {\r\n                        var opCode = __raw_opCodes[j];\r\n                        if (typeof opCode === 'string') {\r\n                            value += opCode;\r\n                        }\r\n                        else if (typeof opCode == 'number') {\r\n                            if (opCode < 0) {\r\n                                // It's a binding index whose value is negative\r\n                                // We cannot know the value of the binding so we only show the index\r\n                                value += \"\\uFFFD\" + (-opCode - 1) + \"\\uFFFD\";\r\n                            }\r\n                            else {\r\n                                var nodeIndex = opCode >>> 2 /* SHIFT_REF */;\r\n                                var tIcuIndex = void 0;\r\n                                var tIcu = void 0;\r\n                                switch (opCode & 3 /* MASK_OPCODE */) {\r\n                                    case 1 /* Attr */:\r\n                                        var attrName = __raw_opCodes[++j];\r\n                                        var sanitizeFn = __raw_opCodes[++j];\r\n                                        results.push({\r\n                                            __raw_opCode: opCode,\r\n                                            checkBit: checkBit,\r\n                                            type: 'Attr',\r\n                                            attrValue: value, attrName: attrName, sanitizeFn: sanitizeFn,\r\n                                        });\r\n                                        break;\r\n                                    case 0 /* Text */:\r\n                                        results.push({\r\n                                            __raw_opCode: opCode,\r\n                                            checkBit: checkBit,\r\n                                            type: 'Text', nodeIndex: nodeIndex,\r\n                                            text: value,\r\n                                        });\r\n                                        break;\r\n                                    case 2 /* IcuSwitch */:\r\n                                        tIcuIndex = __raw_opCodes[++j];\r\n                                        tIcu = icus[tIcuIndex];\r\n                                        var result = new I18NDebugItem(opCode, __lView, nodeIndex, 'IcuSwitch');\r\n                                        result['tIcuIndex'] = tIcuIndex;\r\n                                        result['checkBit'] = checkBit;\r\n                                        result['mainBinding'] = value;\r\n                                        result['tIcu'] = tIcu;\r\n                                        results.push(result);\r\n                                        break;\r\n                                    case 3 /* IcuUpdate */:\r\n                                        tIcuIndex = __raw_opCodes[++j];\r\n                                        tIcu = icus[tIcuIndex];\r\n                                        result = new I18NDebugItem(opCode, __lView, nodeIndex, 'IcuUpdate');\r\n                                        result['tIcuIndex'] = tIcuIndex;\r\n                                        result['checkBit'] = checkBit;\r\n                                        result['tIcu'] = tIcu;\r\n                                        results.push(result);\r\n                                        break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    i += skipCodes;\r\n                }\r\n                return results;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return I18nUpdateOpCodesDebug;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Selects an element for later binding instructions.\r\n     *\r\n     * Used in conjunction with instructions like {@link property} to act on elements with specified\r\n     * indices, for example those created with {@link element} or {@link elementStart}.\r\n     *\r\n     * ```ts\r\n     * (rf: RenderFlags, ctx: any) => {\r\n     *   if (rf & 1) {\r\n     *     element(0, 'div');\r\n     *   }\r\n     *   if (rf & 2) {\r\n     *     select(0); // Select the <div/> created above.\r\n     *     property('title', 'test');\r\n     *   }\r\n     *  }\r\n     * ```\r\n     * @param index the index of the item to act on with the following instructions\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵselect(index) {\r\n        ngDevMode && assertGreaterThan(index, -1, 'Invalid index');\r\n        ngDevMode &&\r\n            assertLessThan(index, getLView().length - HEADER_OFFSET, 'Should be within range for the view data');\r\n        var lView = getLView();\r\n        selectInternal(lView, index);\r\n    }\r\n    function selectInternal(lView, index) {\r\n        // Flush the initial hooks for elements in the view that have been added up to this point.\r\n        executePreOrderHooks(lView, lView[TVIEW], getCheckNoChangesMode(), index);\r\n        // We must set the selected index *after* running the hooks, because hooks may have side-effects\r\n        // that cause other template functions to run, thus updating the selected index, which is global\r\n        // state. If we run `setSelectedIndex` *before* we run the hooks, in some cases the selected index\r\n        // will be altered by the time we leave the `ɵɵselect` instruction.\r\n        setSelectedIndex(index);\r\n    }\r\n\r\n    var ɵ0$5 = function () { return Promise.resolve(null); };\r\n    /**\r\n     * A permanent marker promise which signifies that the current CD tree is\r\n     * clean.\r\n     */\r\n    var _CLEAN_PROMISE = (ɵ0$5)();\r\n    /**\r\n     * Refreshes the view, executing the following steps in that order:\r\n     * triggers init hooks, refreshes dynamic embedded views, triggers content hooks, sets host\r\n     * bindings, refreshes child components.\r\n     * Note: view hooks are triggered later when leaving the view.\r\n     */\r\n    function refreshDescendantViews(lView) {\r\n        var tView = lView[TVIEW];\r\n        var creationMode = isCreationMode(lView);\r\n        // This needs to be set before children are processed to support recursive components\r\n        tView.firstTemplatePass = false;\r\n        // Resetting the bindingIndex of the current LView as the next steps may trigger change detection.\r\n        lView[BINDING_INDEX] = tView.bindingStartIndex;\r\n        // If this is a creation pass, we should not call lifecycle hooks or evaluate bindings.\r\n        // This will be done in the update pass.\r\n        if (!creationMode) {\r\n            var checkNoChangesMode = getCheckNoChangesMode();\r\n            executePreOrderHooks(lView, tView, checkNoChangesMode, undefined);\r\n            refreshDynamicEmbeddedViews(lView);\r\n            // Content query results must be refreshed before content hooks are called.\r\n            refreshContentQueries(tView, lView);\r\n            resetPreOrderHookFlags(lView);\r\n            executeHooks(lView, tView.contentHooks, tView.contentCheckHooks, checkNoChangesMode, 1 /* AfterContentInitHooksToBeRun */, undefined);\r\n            setHostBindings(tView, lView);\r\n        }\r\n        // We resolve content queries specifically marked as `static` in creation mode. Dynamic\r\n        // content queries are resolved during change detection (i.e. update mode), after embedded\r\n        // views are refreshed (see block above).\r\n        if (creationMode && tView.staticContentQueries) {\r\n            refreshContentQueries(tView, lView);\r\n        }\r\n        // We must materialize query results before child components are processed\r\n        // in case a child component has projected a container. The LContainer needs\r\n        // to exist so the embedded views are properly attached by the container.\r\n        if (!creationMode || tView.staticViewQueries) {\r\n            executeViewQueryFn(2 /* Update */, tView, lView[CONTEXT]);\r\n        }\r\n        refreshChildComponents(lView, tView.components);\r\n    }\r\n    /** Sets the host bindings for the current view. */\r\n    function setHostBindings(tView, viewData) {\r\n        var selectedIndex = getSelectedIndex();\r\n        try {\r\n            if (tView.expandoInstructions) {\r\n                var bindingRootIndex = viewData[BINDING_INDEX] = tView.expandoStartIndex;\r\n                setBindingRoot(bindingRootIndex);\r\n                var currentDirectiveIndex = -1;\r\n                var currentElementIndex = -1;\r\n                for (var i = 0; i < tView.expandoInstructions.length; i++) {\r\n                    var instruction = tView.expandoInstructions[i];\r\n                    if (typeof instruction === 'number') {\r\n                        if (instruction <= 0) {\r\n                            // Negative numbers mean that we are starting new EXPANDO block and need to update\r\n                            // the current element and directive index.\r\n                            currentElementIndex = -instruction;\r\n                            setActiveHostElement(currentElementIndex);\r\n                            // Injector block and providers are taken into account.\r\n                            var providerCount = tView.expandoInstructions[++i];\r\n                            bindingRootIndex += INJECTOR_BLOOM_PARENT_SIZE + providerCount;\r\n                            currentDirectiveIndex = bindingRootIndex;\r\n                        }\r\n                        else {\r\n                            // This is either the injector size (so the binding root can skip over directives\r\n                            // and get to the first set of host bindings on this node) or the host var count\r\n                            // (to get to the next set of host bindings on this node).\r\n                            bindingRootIndex += instruction;\r\n                        }\r\n                        setBindingRoot(bindingRootIndex);\r\n                    }\r\n                    else {\r\n                        // If it's not a number, it's a host binding function that needs to be executed.\r\n                        if (instruction !== null) {\r\n                            viewData[BINDING_INDEX] = bindingRootIndex;\r\n                            var hostCtx = unwrapRNode(viewData[currentDirectiveIndex]);\r\n                            instruction(2 /* Update */, hostCtx, currentElementIndex);\r\n                            // Each directive gets a uniqueId value that is the same for both\r\n                            // create and update calls when the hostBindings function is called. The\r\n                            // directive uniqueId is not set anywhere--it is just incremented between\r\n                            // each hostBindings call and is useful for helping instruction code\r\n                            // uniquely determine which directive is currently active when executed.\r\n                            incrementActiveDirectiveId();\r\n                        }\r\n                        currentDirectiveIndex++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        finally {\r\n            setActiveHostElement(selectedIndex);\r\n        }\r\n    }\r\n    /** Refreshes all content queries declared by directives in a given view */\r\n    function refreshContentQueries(tView, lView) {\r\n        var contentQueries = tView.contentQueries;\r\n        if (contentQueries !== null) {\r\n            for (var i = 0; i < contentQueries.length; i += 2) {\r\n                var queryStartIdx = contentQueries[i];\r\n                var directiveDefIdx = contentQueries[i + 1];\r\n                if (directiveDefIdx !== -1) {\r\n                    var directiveDef = tView.data[directiveDefIdx];\r\n                    ngDevMode &&\r\n                        assertDefined(directiveDef.contentQueries, 'contentQueries function should be defined');\r\n                    setCurrentQueryIndex(queryStartIdx);\r\n                    directiveDef.contentQueries(2 /* Update */, lView[directiveDefIdx], directiveDefIdx);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /** Refreshes child components in the current view. */\r\n    function refreshChildComponents(hostLView, components) {\r\n        if (components != null) {\r\n            for (var i = 0; i < components.length; i++) {\r\n                componentRefresh(hostLView, components[i]);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Creates a native element from a tag name, using a renderer.\r\n     * @param name the tag name\r\n     * @param overriddenRenderer Optional A renderer to override the default one\r\n     * @returns the element created\r\n     */\r\n    function elementCreate(name, overriddenRenderer) {\r\n        var native;\r\n        var rendererToUse = overriddenRenderer || getLView()[RENDERER];\r\n        var namespace = getNamespace();\r\n        if (isProceduralRenderer(rendererToUse)) {\r\n            native = rendererToUse.createElement(name, namespace);\r\n        }\r\n        else {\r\n            if (namespace === null) {\r\n                native = rendererToUse.createElement(name);\r\n            }\r\n            else {\r\n                native = rendererToUse.createElementNS(namespace, name);\r\n            }\r\n        }\r\n        return native;\r\n    }\r\n    function createLView(parentLView, tView, context, flags, host, tHostNode, rendererFactory, renderer, sanitizer, injector) {\r\n        var lView = ngDevMode ? cloneToLView(tView.blueprint) : tView.blueprint.slice();\r\n        lView[HOST] = host;\r\n        lView[FLAGS] = flags | 4 /* CreationMode */ | 128 /* Attached */ | 8 /* FirstLViewPass */;\r\n        resetPreOrderHookFlags(lView);\r\n        lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;\r\n        lView[CONTEXT] = context;\r\n        lView[RENDERER_FACTORY] = (rendererFactory || parentLView && parentLView[RENDERER_FACTORY]);\r\n        ngDevMode && assertDefined(lView[RENDERER_FACTORY], 'RendererFactory is required');\r\n        lView[RENDERER] = (renderer || parentLView && parentLView[RENDERER]);\r\n        ngDevMode && assertDefined(lView[RENDERER], 'Renderer is required');\r\n        lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || null;\r\n        lView[INJECTOR$1] = injector || parentLView && parentLView[INJECTOR$1] || null;\r\n        lView[T_HOST] = tHostNode;\r\n        ngDevMode && attachLViewDebug(lView);\r\n        return lView;\r\n    }\r\n    function getOrCreateTNode(tView, tHostNode, index, type, name, attrs) {\r\n        // Keep this function short, so that the VM will inline it.\r\n        var adjustedIndex = index + HEADER_OFFSET;\r\n        var tNode = tView.data[adjustedIndex] ||\r\n            createTNodeAtIndex(tView, tHostNode, adjustedIndex, type, name, attrs, index);\r\n        setPreviousOrParentTNode(tNode, true);\r\n        return tNode;\r\n    }\r\n    function createTNodeAtIndex(tView, tHostNode, adjustedIndex, type, name, attrs, index) {\r\n        var previousOrParentTNode = getPreviousOrParentTNode();\r\n        var isParent = getIsParent();\r\n        var parent = isParent ? previousOrParentTNode : previousOrParentTNode && previousOrParentTNode.parent;\r\n        // Parents cannot cross component boundaries because components will be used in multiple places,\r\n        // so it's only set if the view is the same.\r\n        var parentInSameView = parent && parent !== tHostNode;\r\n        var tParentNode = parentInSameView ? parent : null;\r\n        var tNode = tView.data[adjustedIndex] =\r\n            createTNode(tView, tParentNode, type, adjustedIndex, name, attrs);\r\n        // The first node is not always the one at index 0, in case of i18n, index 0 can be the\r\n        // instruction `i18nStart` and the first node has the index 1 or more\r\n        if (index === 0 || !tView.firstChild) {\r\n            tView.firstChild = tNode;\r\n        }\r\n        // Now link ourselves into the tree.\r\n        if (previousOrParentTNode) {\r\n            if (isParent && previousOrParentTNode.child == null &&\r\n                (tNode.parent !== null || previousOrParentTNode.type === 2 /* View */)) {\r\n                // We are in the same view, which means we are adding content node to the parent view.\r\n                previousOrParentTNode.child = tNode;\r\n            }\r\n            else if (!isParent) {\r\n                previousOrParentTNode.next = tNode;\r\n            }\r\n        }\r\n        return tNode;\r\n    }\r\n    function assignTViewNodeToLView(tView, tParentNode, index, lView) {\r\n        // View nodes are not stored in data because they can be added / removed at runtime (which\r\n        // would cause indices to change). Their TNodes are instead stored in tView.node.\r\n        var tNode = tView.node;\r\n        if (tNode == null) {\r\n            ngDevMode && tParentNode &&\r\n                assertNodeOfPossibleTypes(tParentNode, 3 /* Element */, 0 /* Container */);\r\n            tView.node = tNode = createTNode(tView, tParentNode, //\r\n            2 /* View */, index, null, null);\r\n        }\r\n        return lView[T_HOST] = tNode;\r\n    }\r\n    /**\r\n     * When elements are created dynamically after a view blueprint is created (e.g. through\r\n     * i18nApply() or ComponentFactory.create), we need to adjust the blueprint for future\r\n     * template passes.\r\n     *\r\n     * @param view The LView containing the blueprint to adjust\r\n     * @param numSlotsToAlloc The number of slots to alloc in the LView, should be >0\r\n     */\r\n    function allocExpando(view, numSlotsToAlloc) {\r\n        ngDevMode && assertGreaterThan(numSlotsToAlloc, 0, 'The number of slots to alloc should be greater than 0');\r\n        if (numSlotsToAlloc > 0) {\r\n            var tView = view[TVIEW];\r\n            if (tView.firstTemplatePass) {\r\n                for (var i = 0; i < numSlotsToAlloc; i++) {\r\n                    tView.blueprint.push(null);\r\n                    tView.data.push(null);\r\n                    view.push(null);\r\n                }\r\n                // We should only increment the expando start index if there aren't already directives\r\n                // and injectors saved in the \"expando\" section\r\n                if (!tView.expandoInstructions) {\r\n                    tView.expandoStartIndex += numSlotsToAlloc;\r\n                }\r\n                else {\r\n                    // Since we're adding the dynamic nodes into the expando section, we need to let the host\r\n                    // bindings know that they should skip x slots\r\n                    tView.expandoInstructions.push(numSlotsToAlloc);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    //////////////////////////\r\n    //// Render\r\n    //////////////////////////\r\n    /**\r\n     * Used for creating the LViewNode of a dynamic embedded view,\r\n     * either through ViewContainerRef.createEmbeddedView() or TemplateRef.createEmbeddedView().\r\n     * Such lViewNode will then be renderer with renderEmbeddedTemplate() (see below).\r\n     */\r\n    function createEmbeddedViewAndNode(tView, context, declarationView, injectorIndex) {\r\n        var _isParent = getIsParent();\r\n        var _previousOrParentTNode = getPreviousOrParentTNode();\r\n        setPreviousOrParentTNode(null, true);\r\n        var lView = createLView(declarationView, tView, context, 16 /* CheckAlways */, null, null);\r\n        lView[DECLARATION_VIEW] = declarationView;\r\n        assignTViewNodeToLView(tView, null, -1, lView);\r\n        if (tView.firstTemplatePass) {\r\n            tView.node.injectorIndex = injectorIndex;\r\n        }\r\n        setPreviousOrParentTNode(_previousOrParentTNode, _isParent);\r\n        return lView;\r\n    }\r\n    /**\r\n     * Used for rendering embedded views (e.g. dynamically created views)\r\n     *\r\n     * Dynamically created views must store/retrieve their TViews differently from component views\r\n     * because their template functions are nested in the template functions of their hosts, creating\r\n     * closures. If their host template happens to be an embedded template in a loop (e.g. ngFor\r\n     * inside\r\n     * an ngFor), the nesting would mean we'd have multiple instances of the template function, so we\r\n     * can't store TViews in the template function itself (as we do for comps). Instead, we store the\r\n     * TView for dynamically created views on their host TNode, which only has one instance.\r\n     */\r\n    function renderEmbeddedTemplate(viewToRender, tView, context) {\r\n        var _isParent = getIsParent();\r\n        var _previousOrParentTNode = getPreviousOrParentTNode();\r\n        var oldView;\r\n        if (viewToRender[FLAGS] & 512 /* IsRoot */) {\r\n            // This is a root view inside the view tree\r\n            tickRootContext(getRootContext(viewToRender));\r\n        }\r\n        else {\r\n            // Will become true if the `try` block executes with no errors.\r\n            var safeToRunHooks = false;\r\n            try {\r\n                setPreviousOrParentTNode(null, true);\r\n                oldView = enterView(viewToRender, viewToRender[T_HOST]);\r\n                resetPreOrderHookFlags(viewToRender);\r\n                executeTemplate(viewToRender, tView.template, getRenderFlags(viewToRender), context);\r\n                // This must be set to false immediately after the first creation run because in an\r\n                // ngFor loop, all the views will be created together before update mode runs and turns\r\n                // off firstTemplatePass. If we don't set it here, instances will perform directive\r\n                // matching, etc again and again.\r\n                tView.firstTemplatePass = false;\r\n                refreshDescendantViews(viewToRender);\r\n                safeToRunHooks = true;\r\n            }\r\n            finally {\r\n                leaveView(oldView, safeToRunHooks);\r\n                setPreviousOrParentTNode(_previousOrParentTNode, _isParent);\r\n            }\r\n        }\r\n    }\r\n    function renderComponentOrTemplate(hostView, context, templateFn) {\r\n        var rendererFactory = hostView[RENDERER_FACTORY];\r\n        var oldView = enterView(hostView, hostView[T_HOST]);\r\n        var normalExecutionPath = !getCheckNoChangesMode();\r\n        var creationModeIsActive = isCreationMode(hostView);\r\n        // Will become true if the `try` block executes with no errors.\r\n        var safeToRunHooks = false;\r\n        try {\r\n            if (normalExecutionPath && !creationModeIsActive && rendererFactory.begin) {\r\n                rendererFactory.begin();\r\n            }\r\n            if (creationModeIsActive) {\r\n                // creation mode pass\r\n                templateFn && executeTemplate(hostView, templateFn, 1 /* Create */, context);\r\n                refreshDescendantViews(hostView);\r\n                hostView[FLAGS] &= ~4 /* CreationMode */;\r\n            }\r\n            // update mode pass\r\n            resetPreOrderHookFlags(hostView);\r\n            templateFn && executeTemplate(hostView, templateFn, 2 /* Update */, context);\r\n            refreshDescendantViews(hostView);\r\n            safeToRunHooks = true;\r\n        }\r\n        finally {\r\n            if (normalExecutionPath && !creationModeIsActive && rendererFactory.end) {\r\n                rendererFactory.end();\r\n            }\r\n            leaveView(oldView, safeToRunHooks);\r\n        }\r\n    }\r\n    function executeTemplate(lView, templateFn, rf, context) {\r\n        namespaceHTMLInternal();\r\n        var prevSelectedIndex = getSelectedIndex();\r\n        try {\r\n            setActiveHostElement(null);\r\n            if (rf & 2 /* Update */) {\r\n                // When we're updating, have an inherent ɵɵselect(0) so we don't have to generate that\r\n                // instruction for most update blocks\r\n                selectInternal(lView, 0);\r\n            }\r\n            templateFn(rf, context);\r\n        }\r\n        finally {\r\n            setSelectedIndex(prevSelectedIndex);\r\n        }\r\n    }\r\n    /**\r\n     * This function returns the default configuration of rendering flags depending on when the\r\n     * template is in creation mode or update mode. Update block and create block are\r\n     * always run separately.\r\n     */\r\n    function getRenderFlags(view) {\r\n        return isCreationMode(view) ? 1 /* Create */ : 2 /* Update */;\r\n    }\r\n    //////////////////////////\r\n    //// Element\r\n    //////////////////////////\r\n    function executeContentQueries(tView, tNode, lView) {\r\n        if (isContentQueryHost(tNode)) {\r\n            var start = tNode.directiveStart;\r\n            var end = tNode.directiveEnd;\r\n            for (var directiveIndex = start; directiveIndex < end; directiveIndex++) {\r\n                var def = tView.data[directiveIndex];\r\n                if (def.contentQueries) {\r\n                    def.contentQueries(1 /* Create */, lView[directiveIndex], directiveIndex);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Creates directive instances and populates local refs.\r\n     *\r\n     * @param localRefs Local refs of the node in question\r\n     * @param localRefExtractor mapping function that extracts local ref value from TNode\r\n     */\r\n    function createDirectivesAndLocals(tView, lView, tNode, localRefExtractor) {\r\n        if (localRefExtractor === void 0) { localRefExtractor = getNativeByTNode; }\r\n        if (!getBindingsEnabled())\r\n            return;\r\n        instantiateAllDirectives(tView, lView, tNode);\r\n        invokeDirectivesHostBindings(tView, lView, tNode);\r\n        saveResolvedLocalsInData(lView, tNode, localRefExtractor);\r\n        setActiveHostElement(null);\r\n    }\r\n    /**\r\n     * Takes a list of local names and indices and pushes the resolved local variable values\r\n     * to LView in the same order as they are loaded in the template with load().\r\n     */\r\n    function saveResolvedLocalsInData(viewData, tNode, localRefExtractor) {\r\n        var localNames = tNode.localNames;\r\n        if (localNames) {\r\n            var localIndex = tNode.index + 1;\r\n            for (var i = 0; i < localNames.length; i += 2) {\r\n                var index = localNames[i + 1];\r\n                var value = index === -1 ?\r\n                    localRefExtractor(tNode, viewData) :\r\n                    viewData[index];\r\n                viewData[localIndex++] = value;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Gets TView from a template function or creates a new TView\r\n     * if it doesn't already exist.\r\n     *\r\n     * @param def ComponentDef\r\n     * @returns TView\r\n     */\r\n    function getOrCreateTView(def) {\r\n        return def.tView || (def.tView = createTView(-1, def.template, def.consts, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas));\r\n    }\r\n    /**\r\n     * Creates a TView instance\r\n     *\r\n     * @param viewIndex The viewBlockId for inline views, or -1 if it's a component/dynamic\r\n     * @param templateFn Template function\r\n     * @param consts The number of nodes, local refs, and pipes in this template\r\n     * @param directives Registry of directives for this view\r\n     * @param pipes Registry of pipes for this view\r\n     * @param viewQuery View queries for this view\r\n     * @param schemas Schemas for this view\r\n     */\r\n    function createTView(viewIndex, templateFn, consts, vars, directives, pipes, viewQuery, schemas) {\r\n        ngDevMode && ngDevMode.tView++;\r\n        var bindingStartIndex = HEADER_OFFSET + consts;\r\n        // This length does not yet contain host bindings from child directives because at this point,\r\n        // we don't know which directives are active on this template. As soon as a directive is matched\r\n        // that has a host binding, we will update the blueprint with that def's hostVars count.\r\n        var initialViewLength = bindingStartIndex + vars;\r\n        var blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);\r\n        return blueprint[TVIEW] = ngDevMode ?\r\n            new TViewConstructor(viewIndex, // id: number,\r\n            blueprint, // blueprint: LView,\r\n            templateFn, // template: ComponentTemplate<{}>|null,\r\n            null, // queries: TQueries|null\r\n            viewQuery, // viewQuery: ViewQueriesFunction<{}>|null,\r\n            null, // node: TViewNode|TElementNode|null,\r\n            cloneToTViewData(blueprint).fill(null, bindingStartIndex), // data: TData,\r\n            bindingStartIndex, // bindingStartIndex: number,\r\n            initialViewLength, // expandoStartIndex: number,\r\n            null, // expandoInstructions: ExpandoInstructions|null,\r\n            true, // firstTemplatePass: boolean,\r\n            false, // staticViewQueries: boolean,\r\n            false, // staticContentQueries: boolean,\r\n            null, // preOrderHooks: HookData|null,\r\n            null, // preOrderCheckHooks: HookData|null,\r\n            null, // contentHooks: HookData|null,\r\n            null, // contentCheckHooks: HookData|null,\r\n            null, // viewHooks: HookData|null,\r\n            null, // viewCheckHooks: HookData|null,\r\n            null, // destroyHooks: HookData|null,\r\n            null, // cleanup: any[]|null,\r\n            null, // contentQueries: number[]|null,\r\n            null, // components: number[]|null,\r\n            typeof directives === 'function' ?\r\n                directives() :\r\n                directives, // directiveRegistry: DirectiveDefList|null,\r\n            typeof pipes === 'function' ? pipes() : pipes, // pipeRegistry: PipeDefList|null,\r\n            null, // firstChild: TNode|null,\r\n            schemas) :\r\n            {\r\n                id: viewIndex,\r\n                blueprint: blueprint,\r\n                template: templateFn,\r\n                queries: null,\r\n                viewQuery: viewQuery,\r\n                node: null,\r\n                data: blueprint.slice().fill(null, bindingStartIndex),\r\n                bindingStartIndex: bindingStartIndex,\r\n                expandoStartIndex: initialViewLength,\r\n                expandoInstructions: null,\r\n                firstTemplatePass: true,\r\n                staticViewQueries: false,\r\n                staticContentQueries: false,\r\n                preOrderHooks: null,\r\n                preOrderCheckHooks: null,\r\n                contentHooks: null,\r\n                contentCheckHooks: null,\r\n                viewHooks: null,\r\n                viewCheckHooks: null,\r\n                destroyHooks: null,\r\n                cleanup: null,\r\n                contentQueries: null,\r\n                components: null,\r\n                directiveRegistry: typeof directives === 'function' ? directives() : directives,\r\n                pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,\r\n                firstChild: null,\r\n                schemas: schemas,\r\n            };\r\n    }\r\n    function createViewBlueprint(bindingStartIndex, initialViewLength) {\r\n        var blueprint = new (ngDevMode ? LViewBlueprint : Array)(initialViewLength)\r\n            .fill(null, 0, bindingStartIndex)\r\n            .fill(NO_CHANGE, bindingStartIndex);\r\n        blueprint[BINDING_INDEX] = bindingStartIndex;\r\n        return blueprint;\r\n    }\r\n    function createError(text, token) {\r\n        return new Error(\"Renderer: \" + text + \" [\" + stringifyForError(token) + \"]\");\r\n    }\r\n    /**\r\n     * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\r\n     *\r\n     * @param elementOrSelector Render element or CSS selector to locate the element.\r\n     */\r\n    function locateHostElement(factory, elementOrSelector) {\r\n        var defaultRenderer = factory.createRenderer(null, null);\r\n        var rNode = typeof elementOrSelector === 'string' ?\r\n            (isProceduralRenderer(defaultRenderer) ?\r\n                defaultRenderer.selectRootElement(elementOrSelector) :\r\n                defaultRenderer.querySelector(elementOrSelector)) :\r\n            elementOrSelector;\r\n        if (ngDevMode && !rNode) {\r\n            if (typeof elementOrSelector === 'string') {\r\n                throw createError('Host node with selector not found:', elementOrSelector);\r\n            }\r\n            else {\r\n                throw createError('Host node is required:', elementOrSelector);\r\n            }\r\n        }\r\n        return rNode;\r\n    }\r\n    /**\r\n     * Saves context for this cleanup function in LView.cleanupInstances.\r\n     *\r\n     * On the first template pass, saves in TView:\r\n     * - Cleanup function\r\n     * - Index of context we just saved in LView.cleanupInstances\r\n     */\r\n    function storeCleanupWithContext(lView, context, cleanupFn) {\r\n        var lCleanup = getCleanup(lView);\r\n        lCleanup.push(context);\r\n        if (lView[TVIEW].firstTemplatePass) {\r\n            getTViewCleanup(lView).push(cleanupFn, lCleanup.length - 1);\r\n        }\r\n    }\r\n    /**\r\n     * Saves the cleanup function itself in LView.cleanupInstances.\r\n     *\r\n     * This is necessary for functions that are wrapped with their contexts, like in renderer2\r\n     * listeners.\r\n     *\r\n     * On the first template pass, the index of the cleanup function is saved in TView.\r\n     */\r\n    function storeCleanupFn(view, cleanupFn) {\r\n        getCleanup(view).push(cleanupFn);\r\n        if (view[TVIEW].firstTemplatePass) {\r\n            getTViewCleanup(view).push(view[CLEANUP].length - 1, null);\r\n        }\r\n    }\r\n    /**\r\n     * Constructs a TNode object from the arguments.\r\n     *\r\n     * @param tView `TView` to which this `TNode` belongs (used only in `ngDevMode`)\r\n     * @param type The type of the node\r\n     * @param adjustedIndex The index of the TNode in TView.data, adjusted for HEADER_OFFSET\r\n     * @param tagName The tag name of the node\r\n     * @param attrs The attributes defined on this node\r\n     * @param tViews Any TViews attached to this node\r\n     * @returns the TNode object\r\n     */\r\n    function createTNode(tView, tParent, type, adjustedIndex, tagName, attrs) {\r\n        ngDevMode && ngDevMode.tNode++;\r\n        var injectorIndex = tParent ? tParent.injectorIndex : -1;\r\n        return ngDevMode ? new TNodeConstructor(tView, // tView_: TView\r\n        type, // type: TNodeType\r\n        adjustedIndex, // index: number\r\n        injectorIndex, // injectorIndex: number\r\n        -1, // directiveStart: number\r\n        -1, // directiveEnd: number\r\n        -1, // propertyMetadataStartIndex: number\r\n        -1, // propertyMetadataEndIndex: number\r\n        0, // flags: TNodeFlags\r\n        0, // providerIndexes: TNodeProviderIndexes\r\n        tagName, // tagName: string|null\r\n        attrs, // attrs: (string|AttributeMarker|(string|SelectorFlags)[])[]|null\r\n        null, // localNames: (string|number)[]|null\r\n        undefined, // initialInputs: (string[]|null)[]|null|undefined\r\n        undefined, // inputs: PropertyAliases|null|undefined\r\n        undefined, // outputs: PropertyAliases|null|undefined\r\n        null, // tViews: ITView|ITView[]|null\r\n        null, // next: ITNode|null\r\n        null, // projectionNext: ITNode|null\r\n        null, // child: ITNode|null\r\n        tParent, // parent: TElementNode|TContainerNode|null\r\n        null, // projection: number|(ITNode|RNode[])[]|null\r\n        null, // styles: TStylingContext|null\r\n        null) :\r\n            {\r\n                type: type,\r\n                index: adjustedIndex,\r\n                injectorIndex: injectorIndex,\r\n                directiveStart: -1,\r\n                directiveEnd: -1,\r\n                propertyMetadataStartIndex: -1,\r\n                propertyMetadataEndIndex: -1,\r\n                flags: 0,\r\n                providerIndexes: 0,\r\n                tagName: tagName,\r\n                attrs: attrs,\r\n                localNames: null,\r\n                initialInputs: undefined,\r\n                inputs: undefined,\r\n                outputs: undefined,\r\n                tViews: null,\r\n                next: null,\r\n                projectionNext: null,\r\n                child: null,\r\n                parent: tParent,\r\n                projection: null,\r\n                styles: null,\r\n                classes: null,\r\n            };\r\n    }\r\n    /**\r\n     * Consolidates all inputs or outputs of all directives on this logical node.\r\n     *\r\n     * @param tNode\r\n     * @param direction whether to consider inputs or outputs\r\n     * @returns PropertyAliases|null aggregate of all properties if any, `null` otherwise\r\n     */\r\n    function generatePropertyAliases(tNode, direction) {\r\n        var tView = getLView()[TVIEW];\r\n        var propStore = null;\r\n        var start = tNode.directiveStart;\r\n        var end = tNode.directiveEnd;\r\n        if (end > start) {\r\n            var isInput = direction === 0 /* Input */;\r\n            var defs = tView.data;\r\n            for (var i = start; i < end; i++) {\r\n                var directiveDef = defs[i];\r\n                var propertyAliasMap = isInput ? directiveDef.inputs : directiveDef.outputs;\r\n                for (var publicName in propertyAliasMap) {\r\n                    if (propertyAliasMap.hasOwnProperty(publicName)) {\r\n                        propStore = propStore || {};\r\n                        var internalName = propertyAliasMap[publicName];\r\n                        var hasProperty = propStore.hasOwnProperty(publicName);\r\n                        hasProperty ? propStore[publicName].push(i, publicName, internalName) :\r\n                            (propStore[publicName] = [i, publicName, internalName]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return propStore;\r\n    }\r\n    /**\r\n     * Mapping between attributes names that don't correspond to their element property names.\r\n     * Note: this mapping has to be kept in sync with the equally named mapping in the template\r\n     * type-checking machinery of ngtsc.\r\n     */\r\n    var ATTR_TO_PROP = {\r\n        'class': 'className',\r\n        'for': 'htmlFor',\r\n        'formaction': 'formAction',\r\n        'innerHtml': 'innerHTML',\r\n        'readonly': 'readOnly',\r\n        'tabindex': 'tabIndex',\r\n    };\r\n    function elementPropertyInternal(index, propName, value, sanitizer, nativeOnly, loadRendererFn) {\r\n        ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\r\n        var lView = getLView();\r\n        var element = getNativeByIndex(index, lView);\r\n        var tNode = getTNode(index, lView);\r\n        var inputData;\r\n        var dataValue;\r\n        if (!nativeOnly && (inputData = initializeTNodeInputs(tNode)) &&\r\n            (dataValue = inputData[propName])) {\r\n            setInputsForProperty(lView, dataValue, value);\r\n            if (isComponent(tNode))\r\n                markDirtyIfOnPush(lView, index + HEADER_OFFSET);\r\n            if (ngDevMode) {\r\n                if (tNode.type === 3 /* Element */ || tNode.type === 0 /* Container */) {\r\n                    /**\r\n                     * dataValue is an array containing runtime input or output names for the directives:\r\n                     * i+0: directive instance index\r\n                     * i+1: publicName\r\n                     * i+2: privateName\r\n                     *\r\n                     * e.g. [0, 'change', 'change-minified']\r\n                     * we want to set the reflected property with the privateName: dataValue[i+2]\r\n                     */\r\n                    for (var i = 0; i < dataValue.length; i += 3) {\r\n                        setNgReflectProperty(lView, element, tNode.type, dataValue[i + 2], value);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (tNode.type === 3 /* Element */) {\r\n            propName = ATTR_TO_PROP[propName] || propName;\r\n            if (ngDevMode) {\r\n                validateAgainstEventProperties(propName);\r\n                validateAgainstUnknownProperties(lView, element, propName, tNode);\r\n                ngDevMode.rendererSetProperty++;\r\n            }\r\n            savePropertyDebugData(tNode, lView, propName, lView[TVIEW].data, nativeOnly);\r\n            var renderer = loadRendererFn ? loadRendererFn(tNode, lView) : lView[RENDERER];\r\n            // It is assumed that the sanitizer is only added when the compiler determines that the\r\n            // property\r\n            // is risky, so sanitization can be done without further checks.\r\n            value = sanitizer != null ? sanitizer(value, tNode.tagName || '', propName) : value;\r\n            if (isProceduralRenderer(renderer)) {\r\n                renderer.setProperty(element, propName, value);\r\n            }\r\n            else if (!isAnimationProp(propName)) {\r\n                element.setProperty ? element.setProperty(propName, value) :\r\n                    element[propName] = value;\r\n            }\r\n        }\r\n        else if (tNode.type === 0 /* Container */) {\r\n            // If the node is a container and the property didn't\r\n            // match any of the inputs or schemas we should throw.\r\n            if (ngDevMode && !matchingSchemas(lView, tNode.tagName)) {\r\n                throw createUnknownPropertyError(propName, tNode);\r\n            }\r\n        }\r\n    }\r\n    /** If node is an OnPush component, marks its LView dirty. */\r\n    function markDirtyIfOnPush(lView, viewIndex) {\r\n        ngDevMode && assertLView(lView);\r\n        var childComponentLView = getComponentViewByIndex(viewIndex, lView);\r\n        if (!(childComponentLView[FLAGS] & 16 /* CheckAlways */)) {\r\n            childComponentLView[FLAGS] |= 64 /* Dirty */;\r\n        }\r\n    }\r\n    function setNgReflectProperty(lView, element, type, attrName, value) {\r\n        var _a;\r\n        var renderer = lView[RENDERER];\r\n        attrName = normalizeDebugBindingName(attrName);\r\n        var debugValue = normalizeDebugBindingValue(value);\r\n        if (type === 3 /* Element */) {\r\n            if (value == null) {\r\n                isProceduralRenderer(renderer) ? renderer.removeAttribute(element, attrName) :\r\n                    element.removeAttribute(attrName);\r\n            }\r\n            else {\r\n                isProceduralRenderer(renderer) ?\r\n                    renderer.setAttribute(element, attrName, debugValue) :\r\n                    element.setAttribute(attrName, debugValue);\r\n            }\r\n        }\r\n        else {\r\n            var textContent = \"bindings=\" + JSON.stringify((_a = {}, _a[attrName] = debugValue, _a), null, 2);\r\n            if (isProceduralRenderer(renderer)) {\r\n                renderer.setValue(element, textContent);\r\n            }\r\n            else {\r\n                element.textContent = textContent;\r\n            }\r\n        }\r\n    }\r\n    function validateAgainstUnknownProperties(hostView, element, propName, tNode) {\r\n        // If the tag matches any of the schemas we shouldn't throw.\r\n        if (matchingSchemas(hostView, tNode.tagName)) {\r\n            return;\r\n        }\r\n        // If prop is not a known property of the HTML element...\r\n        if (!(propName in element) &&\r\n            // and we are in a browser context... (web worker nodes should be skipped)\r\n            typeof Node === 'function' && element instanceof Node &&\r\n            // and isn't a synthetic animation property...\r\n            propName[0] !== ANIMATION_PROP_PREFIX) {\r\n            // ... it is probably a user error and we should throw.\r\n            throw createUnknownPropertyError(propName, tNode);\r\n        }\r\n    }\r\n    function matchingSchemas(hostView, tagName) {\r\n        var schemas = hostView[TVIEW].schemas;\r\n        if (schemas !== null) {\r\n            for (var i = 0; i < schemas.length; i++) {\r\n                var schema = schemas[i];\r\n                if (schema === NO_ERRORS_SCHEMA ||\r\n                    schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf('-') > -1) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n    * Stores debugging data for this property binding on first template pass.\r\n    * This enables features like DebugElement.properties.\r\n    */\r\n    function savePropertyDebugData(tNode, lView, propName, tData, nativeOnly) {\r\n        var lastBindingIndex = lView[BINDING_INDEX] - 1;\r\n        // Bind/interpolation functions save binding metadata in the last binding index,\r\n        // but leave the property name blank. If the interpolation delimiter is at the 0\r\n        // index, we know that this is our first pass and the property name still needs to\r\n        // be set.\r\n        var bindingMetadata = tData[lastBindingIndex];\r\n        if (bindingMetadata[0] == INTERPOLATION_DELIMITER) {\r\n            tData[lastBindingIndex] = propName + bindingMetadata;\r\n            // We don't want to store indices for host bindings because they are stored in a\r\n            // different part of LView (the expando section).\r\n            if (!nativeOnly) {\r\n                if (tNode.propertyMetadataStartIndex == -1) {\r\n                    tNode.propertyMetadataStartIndex = lastBindingIndex;\r\n                }\r\n                tNode.propertyMetadataEndIndex = lastBindingIndex + 1;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n    * Creates an error that should be thrown when encountering an unknown property on an element.\r\n    * @param propName Name of the invalid property.\r\n    * @param tNode Node on which we encountered the error.\r\n    */\r\n    function createUnknownPropertyError(propName, tNode) {\r\n        return new Error(\"Template error: Can't bind to '\" + propName + \"' since it isn't a known property of '\" + tNode.tagName + \"'.\");\r\n    }\r\n    /**\r\n     * Instantiate a root component.\r\n     */\r\n    function instantiateRootComponent(tView, viewData, def) {\r\n        var rootTNode = getPreviousOrParentTNode();\r\n        if (tView.firstTemplatePass) {\r\n            if (def.providersResolver)\r\n                def.providersResolver(def);\r\n            generateExpandoInstructionBlock(tView, rootTNode, 1);\r\n            baseResolveDirective(tView, viewData, def, def.factory);\r\n        }\r\n        var directive = getNodeInjectable(tView.data, viewData, viewData.length - 1, rootTNode);\r\n        postProcessBaseDirective(viewData, rootTNode, directive);\r\n        return directive;\r\n    }\r\n    /**\r\n     * Resolve the matched directives on a node.\r\n     */\r\n    function resolveDirectives(tView, lView, tNode, localRefs) {\r\n        // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in\r\n        // tsickle.\r\n        ngDevMode && assertEqual(tView.firstTemplatePass, true, 'should run on first template pass only');\r\n        if (!getBindingsEnabled())\r\n            return;\r\n        var directives = findDirectiveMatches(tView, lView, tNode);\r\n        var exportsMap = localRefs ? { '': -1 } : null;\r\n        if (directives) {\r\n            initNodeFlags(tNode, tView.data.length, directives.length);\r\n            // When the same token is provided by several directives on the same node, some rules apply in\r\n            // the viewEngine:\r\n            // - viewProviders have priority over providers\r\n            // - the last directive in NgModule.declarations has priority over the previous one\r\n            // So to match these rules, the order in which providers are added in the arrays is very\r\n            // important.\r\n            for (var i = 0; i < directives.length; i++) {\r\n                var def = directives[i];\r\n                if (def.providersResolver)\r\n                    def.providersResolver(def);\r\n            }\r\n            generateExpandoInstructionBlock(tView, tNode, directives.length);\r\n            var initialPreOrderHooksLength = (tView.preOrderHooks && tView.preOrderHooks.length) || 0;\r\n            var initialPreOrderCheckHooksLength = (tView.preOrderCheckHooks && tView.preOrderCheckHooks.length) || 0;\r\n            var nodeIndex = tNode.index - HEADER_OFFSET;\r\n            for (var i = 0; i < directives.length; i++) {\r\n                var def = directives[i];\r\n                var directiveDefIdx = tView.data.length;\r\n                baseResolveDirective(tView, lView, def, def.factory);\r\n                saveNameToExportMap(tView.data.length - 1, def, exportsMap);\r\n                // Init hooks are queued now so ngOnInit is called in host components before\r\n                // any projected components.\r\n                registerPreOrderHooks(directiveDefIdx, def, tView, nodeIndex, initialPreOrderHooksLength, initialPreOrderCheckHooksLength);\r\n            }\r\n        }\r\n        if (exportsMap)\r\n            cacheMatchingLocalNames(tNode, localRefs, exportsMap);\r\n    }\r\n    /**\r\n     * Instantiate all the directives that were previously resolved on the current node.\r\n     */\r\n    function instantiateAllDirectives(tView, lView, tNode) {\r\n        var start = tNode.directiveStart;\r\n        var end = tNode.directiveEnd;\r\n        if (!tView.firstTemplatePass && start < end) {\r\n            getOrCreateNodeInjectorForNode(tNode, lView);\r\n        }\r\n        for (var i = start; i < end; i++) {\r\n            var def = tView.data[i];\r\n            if (isComponentDef(def)) {\r\n                addComponentLogic(lView, tNode, def);\r\n            }\r\n            var directive = getNodeInjectable(tView.data, lView, i, tNode);\r\n            postProcessDirective(lView, directive, def, i);\r\n        }\r\n    }\r\n    function invokeDirectivesHostBindings(tView, viewData, tNode) {\r\n        var start = tNode.directiveStart;\r\n        var end = tNode.directiveEnd;\r\n        var expando = tView.expandoInstructions;\r\n        var firstTemplatePass = tView.firstTemplatePass;\r\n        var elementIndex = tNode.index - HEADER_OFFSET;\r\n        var selectedIndex = getSelectedIndex();\r\n        try {\r\n            setActiveHostElement(elementIndex);\r\n            for (var i = start; i < end; i++) {\r\n                var def = tView.data[i];\r\n                var directive = viewData[i];\r\n                if (def.hostBindings) {\r\n                    invokeHostBindingsInCreationMode(def, expando, directive, tNode, firstTemplatePass);\r\n                    // Each directive gets a uniqueId value that is the same for both\r\n                    // create and update calls when the hostBindings function is called. The\r\n                    // directive uniqueId is not set anywhere--it is just incremented between\r\n                    // each hostBindings call and is useful for helping instruction code\r\n                    // uniquely determine which directive is currently active when executed.\r\n                    incrementActiveDirectiveId();\r\n                }\r\n                else if (firstTemplatePass) {\r\n                    expando.push(null);\r\n                }\r\n            }\r\n        }\r\n        finally {\r\n            setActiveHostElement(selectedIndex);\r\n        }\r\n    }\r\n    function invokeHostBindingsInCreationMode(def, expando, directive, tNode, firstTemplatePass) {\r\n        var previousExpandoLength = expando.length;\r\n        setCurrentDirectiveDef(def);\r\n        var elementIndex = tNode.index - HEADER_OFFSET;\r\n        def.hostBindings(1 /* Create */, directive, elementIndex);\r\n        setCurrentDirectiveDef(null);\r\n        // `hostBindings` function may or may not contain `allocHostVars` call\r\n        // (e.g. it may not if it only contains host listeners), so we need to check whether\r\n        // `expandoInstructions` has changed and if not - we still push `hostBindings` to\r\n        // expando block, to make sure we execute it for DI cycle\r\n        if (previousExpandoLength === expando.length && firstTemplatePass) {\r\n            expando.push(def.hostBindings);\r\n        }\r\n    }\r\n    /**\r\n    * Generates a new block in TView.expandoInstructions for this node.\r\n    *\r\n    * Each expando block starts with the element index (turned negative so we can distinguish\r\n    * it from the hostVar count) and the directive count. See more in VIEW_DATA.md.\r\n    */\r\n    function generateExpandoInstructionBlock(tView, tNode, directiveCount) {\r\n        ngDevMode && assertEqual(tView.firstTemplatePass, true, 'Expando block should only be generated on first template pass.');\r\n        var elementIndex = -(tNode.index - HEADER_OFFSET);\r\n        var providerStartIndex = tNode.providerIndexes & 65535 /* ProvidersStartIndexMask */;\r\n        var providerCount = tView.data.length - providerStartIndex;\r\n        (tView.expandoInstructions || (tView.expandoInstructions = [])).push(elementIndex, providerCount, directiveCount);\r\n    }\r\n    /**\r\n     * Process a directive on the current node after its creation.\r\n     */\r\n    function postProcessDirective(viewData, directive, def, directiveDefIdx) {\r\n        var previousOrParentTNode = getPreviousOrParentTNode();\r\n        postProcessBaseDirective(viewData, previousOrParentTNode, directive);\r\n        ngDevMode && assertDefined(previousOrParentTNode, 'previousOrParentTNode');\r\n        if (previousOrParentTNode && previousOrParentTNode.attrs) {\r\n            setInputsFromAttrs(directiveDefIdx, directive, def, previousOrParentTNode);\r\n        }\r\n        if (viewData[TVIEW].firstTemplatePass && def.contentQueries) {\r\n            previousOrParentTNode.flags |= 4 /* hasContentQuery */;\r\n        }\r\n        if (isComponentDef(def)) {\r\n            var componentView = getComponentViewByIndex(previousOrParentTNode.index, viewData);\r\n            componentView[CONTEXT] = directive;\r\n        }\r\n    }\r\n    /**\r\n     * A lighter version of postProcessDirective() that is used for the root component.\r\n     */\r\n    function postProcessBaseDirective(lView, previousOrParentTNode, directive) {\r\n        var native = getNativeByTNode(previousOrParentTNode, lView);\r\n        ngDevMode && assertEqual(lView[BINDING_INDEX], lView[TVIEW].bindingStartIndex, 'directives should be created before any bindings');\r\n        ngDevMode && assertPreviousIsParent(getIsParent());\r\n        attachPatchData(directive, lView);\r\n        if (native) {\r\n            attachPatchData(native, lView);\r\n        }\r\n    }\r\n    /**\r\n    * Matches the current node against all available selectors.\r\n    * If a component is matched (at most one), it is returned in first position in the array.\r\n    */\r\n    function findDirectiveMatches(tView, viewData, tNode) {\r\n        ngDevMode && assertEqual(tView.firstTemplatePass, true, 'should run on first template pass only');\r\n        var registry = tView.directiveRegistry;\r\n        var matches = null;\r\n        if (registry) {\r\n            for (var i = 0; i < registry.length; i++) {\r\n                var def = registry[i];\r\n                if (isNodeMatchingSelectorList(tNode, def.selectors, /* isProjectionMode */ false)) {\r\n                    matches || (matches = ngDevMode ? new MatchesArray() : []);\r\n                    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, viewData), tView, def.type);\r\n                    if (isComponentDef(def)) {\r\n                        if (tNode.flags & 1 /* isComponent */)\r\n                            throwMultipleComponentError(tNode);\r\n                        tNode.flags = 1 /* isComponent */;\r\n                        // The component is always stored first with directives after.\r\n                        matches.unshift(def);\r\n                    }\r\n                    else {\r\n                        matches.push(def);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return matches;\r\n    }\r\n    /** Stores index of component's host element so it will be queued for view refresh during CD. */\r\n    function queueComponentIndexForCheck(previousOrParentTNode) {\r\n        var tView = getLView()[TVIEW];\r\n        ngDevMode &&\r\n            assertEqual(tView.firstTemplatePass, true, 'Should only be called in first template pass.');\r\n        (tView.components || (tView.components = ngDevMode ? new TViewComponents() : [])).push(previousOrParentTNode.index);\r\n    }\r\n    /** Caches local names and their matching directive indices for query and template lookups. */\r\n    function cacheMatchingLocalNames(tNode, localRefs, exportsMap) {\r\n        if (localRefs) {\r\n            var localNames = tNode.localNames =\r\n                ngDevMode ? new TNodeLocalNames() : [];\r\n            // Local names must be stored in tNode in the same order that localRefs are defined\r\n            // in the template to ensure the data is loaded in the same slots as their refs\r\n            // in the template (for template queries).\r\n            for (var i = 0; i < localRefs.length; i += 2) {\r\n                var index = exportsMap[localRefs[i + 1]];\r\n                if (index == null)\r\n                    throw new Error(\"Export of name '\" + localRefs[i + 1] + \"' not found!\");\r\n                localNames.push(localRefs[i], index);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n    * Builds up an export map as directives are created, so local refs can be quickly mapped\r\n    * to their directive instances.\r\n    */\r\n    function saveNameToExportMap(index, def, exportsMap) {\r\n        if (exportsMap) {\r\n            if (def.exportAs) {\r\n                for (var i = 0; i < def.exportAs.length; i++) {\r\n                    exportsMap[def.exportAs[i]] = index;\r\n                }\r\n            }\r\n            if (def.template)\r\n                exportsMap[''] = index;\r\n        }\r\n    }\r\n    /**\r\n     * Initializes the flags on the current node, setting all indices to the initial index,\r\n     * the directive count to 0, and adding the isComponent flag.\r\n     * @param index the initial index\r\n     */\r\n    function initNodeFlags(tNode, index, numberOfDirectives) {\r\n        var flags = tNode.flags;\r\n        ngDevMode && assertEqual(flags === 0 || flags === 1 /* isComponent */, true, 'expected node flags to not be initialized');\r\n        ngDevMode && assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, 'Reached the max number of directives');\r\n        // When the first directive is created on a node, save the index\r\n        tNode.flags = flags & 1 /* isComponent */;\r\n        tNode.directiveStart = index;\r\n        tNode.directiveEnd = index + numberOfDirectives;\r\n        tNode.providerIndexes = index;\r\n    }\r\n    function baseResolveDirective(tView, viewData, def, directiveFactory) {\r\n        tView.data.push(def);\r\n        var nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), null);\r\n        tView.blueprint.push(nodeInjectorFactory);\r\n        viewData.push(nodeInjectorFactory);\r\n    }\r\n    function addComponentLogic(lView, previousOrParentTNode, def) {\r\n        var native = getNativeByTNode(previousOrParentTNode, lView);\r\n        var tView = getOrCreateTView(def);\r\n        // Only component views should be added to the view tree directly. Embedded views are\r\n        // accessed through their containers because they may be removed / re-added later.\r\n        var rendererFactory = lView[RENDERER_FACTORY];\r\n        var componentView = addToViewTree(lView, createLView(lView, tView, null, def.onPush ? 64 /* Dirty */ : 16 /* CheckAlways */, lView[previousOrParentTNode.index], previousOrParentTNode, rendererFactory, rendererFactory.createRenderer(native, def)));\r\n        componentView[T_HOST] = previousOrParentTNode;\r\n        // Component view will always be created before any injected LContainers,\r\n        // so this is a regular element, wrap it with the component view\r\n        lView[previousOrParentTNode.index] = componentView;\r\n        if (lView[TVIEW].firstTemplatePass) {\r\n            queueComponentIndexForCheck(previousOrParentTNode);\r\n        }\r\n    }\r\n    function elementAttributeInternal(index, name, value, lView, sanitizer, namespace) {\r\n        ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\r\n        ngDevMode && validateAgainstEventAttributes(name);\r\n        var element = getNativeByIndex(index, lView);\r\n        var renderer = lView[RENDERER];\r\n        if (value == null) {\r\n            ngDevMode && ngDevMode.rendererRemoveAttribute++;\r\n            isProceduralRenderer(renderer) ? renderer.removeAttribute(element, name, namespace) :\r\n                element.removeAttribute(name);\r\n        }\r\n        else {\r\n            ngDevMode && ngDevMode.rendererSetAttribute++;\r\n            var tNode = getTNode(index, lView);\r\n            var strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tNode.tagName || '', name);\r\n            if (isProceduralRenderer(renderer)) {\r\n                renderer.setAttribute(element, name, strValue, namespace);\r\n            }\r\n            else {\r\n                namespace ? element.setAttributeNS(namespace, name, strValue) :\r\n                    element.setAttribute(name, strValue);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Sets initial input properties on directive instances from attribute data\r\n     *\r\n     * @param directiveIndex Index of the directive in directives array\r\n     * @param instance Instance of the directive on which to set the initial inputs\r\n     * @param def The directive def that contains the list of inputs\r\n     * @param tNode The static data for this node\r\n     */\r\n    function setInputsFromAttrs(directiveIndex, instance, def, tNode) {\r\n        var initialInputData = tNode.initialInputs;\r\n        if (initialInputData === undefined || directiveIndex >= initialInputData.length) {\r\n            initialInputData = generateInitialInputs(directiveIndex, def.inputs, tNode);\r\n        }\r\n        var initialInputs = initialInputData[directiveIndex];\r\n        if (initialInputs) {\r\n            var setInput = def.setInput;\r\n            for (var i = 0; i < initialInputs.length;) {\r\n                var publicName = initialInputs[i++];\r\n                var privateName = initialInputs[i++];\r\n                var value = initialInputs[i++];\r\n                if (setInput) {\r\n                    def.setInput(instance, value, publicName, privateName);\r\n                }\r\n                else {\r\n                    instance[privateName] = value;\r\n                }\r\n                if (ngDevMode) {\r\n                    var lView = getLView();\r\n                    var nativeElement = getNativeByTNode(tNode, lView);\r\n                    setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Generates initialInputData for a node and stores it in the template's static storage\r\n     * so subsequent template invocations don't have to recalculate it.\r\n     *\r\n     * initialInputData is an array containing values that need to be set as input properties\r\n     * for directives on this node, but only once on creation. We need this array to support\r\n     * the case where you set an @Input property of a directive using attribute-like syntax.\r\n     * e.g. if you have a `name` @Input, you can set it once like this:\r\n     *\r\n     * <my-component name=\"Bess\"></my-component>\r\n     *\r\n     * @param directiveIndex Index to store the initial input data\r\n     * @param inputs The list of inputs from the directive def\r\n     * @param tNode The static data on this node\r\n     */\r\n    function generateInitialInputs(directiveIndex, inputs, tNode) {\r\n        var initialInputData = tNode.initialInputs || (tNode.initialInputs = ngDevMode ? new TNodeInitialInputs() : []);\r\n        // Ensure that we don't create sparse arrays\r\n        for (var i_1 = initialInputData.length; i_1 <= directiveIndex; i_1++) {\r\n            initialInputData.push(null);\r\n        }\r\n        var attrs = tNode.attrs;\r\n        var i = 0;\r\n        while (i < attrs.length) {\r\n            var attrName = attrs[i];\r\n            if (attrName === 0 /* NamespaceURI */) {\r\n                // We do not allow inputs on namespaced attributes.\r\n                i += 4;\r\n                continue;\r\n            }\r\n            else if (attrName === 5 /* ProjectAs */) {\r\n                // Skip over the `ngProjectAs` value.\r\n                i += 2;\r\n                continue;\r\n            }\r\n            // If we hit any other attribute markers, we're done anyway. None of those are valid inputs.\r\n            if (typeof attrName === 'number')\r\n                break;\r\n            var minifiedInputName = inputs[attrName];\r\n            var attrValue = attrs[i + 1];\r\n            if (minifiedInputName !== undefined) {\r\n                var inputsToStore = initialInputData[directiveIndex] ||\r\n                    (initialInputData[directiveIndex] = ngDevMode ? new TNodeInitialData() : []);\r\n                inputsToStore.push(attrName, minifiedInputName, attrValue);\r\n            }\r\n            i += 2;\r\n        }\r\n        return initialInputData;\r\n    }\r\n    //////////////////////////\r\n    //// ViewContainer & View\r\n    //////////////////////////\r\n    // Not sure why I need to do `any` here but TS complains later.\r\n    var LContainerArray = ngDevMode && createNamedArrayType('LContainer');\r\n    /**\r\n     * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\r\n     *\r\n     * @param hostNative The host element for the LContainer\r\n     * @param hostTNode The host TNode for the LContainer\r\n     * @param currentView The parent view of the LContainer\r\n     * @param native The native comment element\r\n     * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\r\n     * @returns LContainer\r\n     */\r\n    function createLContainer(hostNative, currentView, native, tNode, isForViewContainerRef) {\r\n        ngDevMode && assertDomNode(native);\r\n        ngDevMode && assertLView(currentView);\r\n        // https://jsperf.com/array-literal-vs-new-array-really\r\n        var lContainer = new (ngDevMode ? LContainerArray : Array)(hostNative, // host native\r\n        true, // Boolean `true` in this position signifies that this is an `LContainer`\r\n        isForViewContainerRef ? -1 : 0, // active index\r\n        currentView, // parent\r\n        null, // next\r\n        null, // queries\r\n        tNode, // t_host\r\n        native, // native,\r\n        null);\r\n        ngDevMode && attachLContainerDebug(lContainer);\r\n        return lContainer;\r\n    }\r\n    /**\r\n     * Goes over dynamic embedded views (ones created through ViewContainerRef APIs) and refreshes\r\n     * them\r\n     * by executing an associated template function.\r\n     */\r\n    function refreshDynamicEmbeddedViews(lView) {\r\n        for (var current = lView[CHILD_HEAD]; current !== null; current = current[NEXT]) {\r\n            // Note: current can be an LView or an LContainer instance, but here we are only interested\r\n            // in LContainer. We can tell it's an LContainer because its length is less than the LView\r\n            // header.\r\n            if (current[ACTIVE_INDEX] === -1 && isLContainer(current)) {\r\n                for (var i = CONTAINER_HEADER_OFFSET; i < current.length; i++) {\r\n                    var dynamicViewData = current[i];\r\n                    // The directives and pipes are not needed here as an existing view is only being\r\n                    // refreshed.\r\n                    ngDevMode && assertDefined(dynamicViewData[TVIEW], 'TView must be allocated');\r\n                    renderEmbeddedTemplate(dynamicViewData, dynamicViewData[TVIEW], dynamicViewData[CONTEXT]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /////////////\r\n    /**\r\n     * Refreshes components by entering the component view and processing its bindings, queries, etc.\r\n     *\r\n     * @param adjustedElementIndex  Element index in LView[] (adjusted for HEADER_OFFSET)\r\n     */\r\n    function componentRefresh(hostLView, adjustedElementIndex) {\r\n        ngDevMode && assertDataInRange(hostLView, adjustedElementIndex);\r\n        var componentView = getComponentViewByIndex(adjustedElementIndex, hostLView);\r\n        ngDevMode &&\r\n            assertNodeType(hostLView[TVIEW].data[adjustedElementIndex], 3 /* Element */);\r\n        // Only components in creation mode, attached CheckAlways\r\n        // components or attached, dirty OnPush components should be checked\r\n        if ((viewAttachedToChangeDetector(componentView) || isCreationMode(hostLView)) &&\r\n            componentView[FLAGS] & (16 /* CheckAlways */ | 64 /* Dirty */)) {\r\n            syncViewWithBlueprint(componentView);\r\n            checkView(componentView, componentView[CONTEXT]);\r\n        }\r\n    }\r\n    /**\r\n     * Syncs an LView instance with its blueprint if they have gotten out of sync.\r\n     *\r\n     * Typically, blueprints and their view instances should always be in sync, so the loop here\r\n     * will be skipped. However, consider this case of two components side-by-side:\r\n     *\r\n     * App template:\r\n     * ```\r\n     * <comp></comp>\r\n     * <comp></comp>\r\n     * ```\r\n     *\r\n     * The following will happen:\r\n     * 1. App template begins processing.\r\n     * 2. First <comp> is matched as a component and its LView is created.\r\n     * 3. Second <comp> is matched as a component and its LView is created.\r\n     * 4. App template completes processing, so it's time to check child templates.\r\n     * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.\r\n     * 6. Second <comp> template is checked. Its blueprint has been updated by the first\r\n     * <comp> template, but its LView was created before this update, so it is out of sync.\r\n     *\r\n     * Note that embedded views inside ngFor loops will never be out of sync because these views\r\n     * are processed as soon as they are created.\r\n     *\r\n     * @param componentView The view to sync\r\n     */\r\n    function syncViewWithBlueprint(componentView) {\r\n        var componentTView = componentView[TVIEW];\r\n        for (var i = componentView.length; i < componentTView.blueprint.length; i++) {\r\n            componentView[i] = componentTView.blueprint[i];\r\n        }\r\n    }\r\n    /**\r\n     * Adds LView or LContainer to the end of the current view tree.\r\n     *\r\n     * This structure will be used to traverse through nested views to remove listeners\r\n     * and call onDestroy callbacks.\r\n     *\r\n     * @param lView The view where LView or LContainer should be added\r\n     * @param adjustedHostIndex Index of the view's host node in LView[], adjusted for header\r\n     * @param lViewOrLContainer The LView or LContainer to add to the view tree\r\n     * @returns The state passed in\r\n     */\r\n    function addToViewTree(lView, lViewOrLContainer) {\r\n        // TODO(benlesh/misko): This implementation is incorrect, because it always adds the LContainer\r\n        // to\r\n        // the end of the queue, which means if the developer retrieves the LContainers from RNodes out\r\n        // of\r\n        // order, the change detection will run out of order, as the act of retrieving the the\r\n        // LContainer\r\n        // from the RNode is what adds it to the queue.\r\n        if (lView[CHILD_HEAD]) {\r\n            lView[CHILD_TAIL][NEXT] = lViewOrLContainer;\r\n        }\r\n        else {\r\n            lView[CHILD_HEAD] = lViewOrLContainer;\r\n        }\r\n        lView[CHILD_TAIL] = lViewOrLContainer;\r\n        return lViewOrLContainer;\r\n    }\r\n    ///////////////////////////////\r\n    //// Change detection\r\n    ///////////////////////////////\r\n    /**\r\n     * Marks current view and all ancestors dirty.\r\n     *\r\n     * Returns the root view because it is found as a byproduct of marking the view tree\r\n     * dirty, and can be used by methods that consume markViewDirty() to easily schedule\r\n     * change detection. Otherwise, such methods would need to traverse up the view tree\r\n     * an additional time to get the root view and schedule a tick on it.\r\n     *\r\n     * @param lView The starting LView to mark dirty\r\n     * @returns the root LView\r\n     */\r\n    function markViewDirty(lView) {\r\n        while (lView) {\r\n            lView[FLAGS] |= 64 /* Dirty */;\r\n            var parent_1 = getLViewParent(lView);\r\n            // Stop traversing up as soon as you find a root view that wasn't attached to any container\r\n            if (isRootView(lView) && !parent_1) {\r\n                return lView;\r\n            }\r\n            // continue otherwise\r\n            lView = parent_1;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Used to schedule change detection on the whole application.\r\n     *\r\n     * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.\r\n     * It is usually called indirectly by calling `markDirty` when the view needs to be\r\n     * re-rendered.\r\n     *\r\n     * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple\r\n     * `scheduleTick` requests. The scheduling function can be overridden in\r\n     * `renderComponent`'s `scheduler` option.\r\n     */\r\n    function scheduleTick(rootContext, flags) {\r\n        var nothingScheduled = rootContext.flags === 0 /* Empty */;\r\n        rootContext.flags |= flags;\r\n        if (nothingScheduled && rootContext.clean == _CLEAN_PROMISE) {\r\n            var res_1;\r\n            rootContext.clean = new Promise(function (r) { return res_1 = r; });\r\n            rootContext.scheduler(function () {\r\n                if (rootContext.flags & 1 /* DetectChanges */) {\r\n                    rootContext.flags &= ~1 /* DetectChanges */;\r\n                    tickRootContext(rootContext);\r\n                }\r\n                if (rootContext.flags & 2 /* FlushPlayers */) {\r\n                    rootContext.flags &= ~2 /* FlushPlayers */;\r\n                    var playerHandler = rootContext.playerHandler;\r\n                    if (playerHandler) {\r\n                        playerHandler.flushPlayers();\r\n                    }\r\n                }\r\n                rootContext.clean = _CLEAN_PROMISE;\r\n                res_1(null);\r\n            });\r\n        }\r\n    }\r\n    function tickRootContext(rootContext) {\r\n        for (var i = 0; i < rootContext.components.length; i++) {\r\n            var rootComponent = rootContext.components[i];\r\n            renderComponentOrTemplate(readPatchedLView(rootComponent), rootComponent);\r\n        }\r\n    }\r\n    function detectChangesInternal(view, context) {\r\n        var rendererFactory = view[RENDERER_FACTORY];\r\n        if (rendererFactory.begin)\r\n            rendererFactory.begin();\r\n        try {\r\n            if (isCreationMode(view)) {\r\n                checkView(view, context); // creation mode pass\r\n            }\r\n            checkView(view, context); // update mode pass\r\n        }\r\n        catch (error) {\r\n            handleError(view, error);\r\n            throw error;\r\n        }\r\n        finally {\r\n            if (rendererFactory.end)\r\n                rendererFactory.end();\r\n        }\r\n    }\r\n    /**\r\n     * Synchronously perform change detection on a root view and its components.\r\n     *\r\n     * @param lView The view which the change detection should be performed on.\r\n     */\r\n    function detectChangesInRootView(lView) {\r\n        tickRootContext(lView[CONTEXT]);\r\n    }\r\n    /**\r\n     * Checks the change detector and its children, and throws if any changes are detected.\r\n     *\r\n     * This is used in development mode to verify that running change detection doesn't\r\n     * introduce other changes.\r\n     */\r\n    function checkNoChanges(component) {\r\n        var view = getComponentViewByInstance(component);\r\n        checkNoChangesInternal(view, component);\r\n    }\r\n    function checkNoChangesInternal(view, context) {\r\n        setCheckNoChangesMode(true);\r\n        try {\r\n            detectChangesInternal(view, context);\r\n        }\r\n        finally {\r\n            setCheckNoChangesMode(false);\r\n        }\r\n    }\r\n    /**\r\n     * Checks the change detector on a root view and its components, and throws if any changes are\r\n     * detected.\r\n     *\r\n     * This is used in development mode to verify that running change detection doesn't\r\n     * introduce other changes.\r\n     *\r\n     * @param lView The view which the change detection should be checked on.\r\n     */\r\n    function checkNoChangesInRootView(lView) {\r\n        setCheckNoChangesMode(true);\r\n        try {\r\n            detectChangesInRootView(lView);\r\n        }\r\n        finally {\r\n            setCheckNoChangesMode(false);\r\n        }\r\n    }\r\n    /** Checks the view of the component provided. Does not gate on dirty checks or execute doCheck.\r\n     */\r\n    function checkView(hostView, component) {\r\n        var hostTView = hostView[TVIEW];\r\n        var oldView = enterView(hostView, hostView[T_HOST]);\r\n        var templateFn = hostTView.template;\r\n        var creationMode = isCreationMode(hostView);\r\n        // Will become true if the `try` block executes with no errors.\r\n        var safeToRunHooks = false;\r\n        try {\r\n            resetPreOrderHookFlags(hostView);\r\n            creationMode && executeViewQueryFn(1 /* Create */, hostTView, component);\r\n            executeTemplate(hostView, templateFn, getRenderFlags(hostView), component);\r\n            refreshDescendantViews(hostView);\r\n            safeToRunHooks = true;\r\n        }\r\n        finally {\r\n            leaveView(oldView, safeToRunHooks);\r\n        }\r\n    }\r\n    function executeViewQueryFn(flags, tView, component) {\r\n        var viewQuery = tView.viewQuery;\r\n        if (viewQuery !== null) {\r\n            setCurrentQueryIndex(0);\r\n            viewQuery(flags, component);\r\n        }\r\n    }\r\n    ///////////////////////////////\r\n    //// Bindings & interpolations\r\n    ///////////////////////////////\r\n    /**\r\n     * Creates binding metadata for a particular binding and stores it in\r\n     * TView.data. These are generated in order to support DebugElement.properties.\r\n     *\r\n     * Each binding / interpolation will have one (including attribute bindings)\r\n     * because at the time of binding, we don't know to which instruction the binding\r\n     * belongs. It is always stored in TView.data at the index of the last binding\r\n     * value in LView (e.g. for interpolation8, it would be stored at the index of\r\n     * the 8th value).\r\n     *\r\n     * @param lView The LView that contains the current binding index.\r\n     * @param prefix The static prefix string\r\n     * @param suffix The static suffix string\r\n     *\r\n     * @returns Newly created binding metadata string for this binding or null\r\n     */\r\n    function storeBindingMetadata(lView, prefix, suffix) {\r\n        if (prefix === void 0) { prefix = ''; }\r\n        if (suffix === void 0) { suffix = ''; }\r\n        var tData = lView[TVIEW].data;\r\n        var lastBindingIndex = lView[BINDING_INDEX] - 1;\r\n        var value = INTERPOLATION_DELIMITER + prefix + INTERPOLATION_DELIMITER + suffix;\r\n        return tData[lastBindingIndex] == null ? (tData[lastBindingIndex] = value) : null;\r\n    }\r\n    var CLEAN_PROMISE = _CLEAN_PROMISE;\r\n    function initializeTNodeInputs(tNode) {\r\n        // If tNode.inputs is undefined, a listener has created outputs, but inputs haven't\r\n        // yet been checked.\r\n        if (tNode.inputs === undefined) {\r\n            // mark inputs as checked\r\n            tNode.inputs = generatePropertyAliases(tNode, 0 /* Input */);\r\n        }\r\n        return tNode.inputs;\r\n    }\r\n    function getCleanup(view) {\r\n        // top level variables should not be exported for performance reasons (PERF_NOTES.md)\r\n        return view[CLEANUP] || (view[CLEANUP] = ngDevMode ? new LCleanup() : []);\r\n    }\r\n    function getTViewCleanup(view) {\r\n        return view[TVIEW].cleanup || (view[TVIEW].cleanup = ngDevMode ? new TCleanup() : []);\r\n    }\r\n    /**\r\n     * There are cases where the sub component's renderer needs to be included\r\n     * instead of the current renderer (see the componentSyntheticHost* instructions).\r\n     */\r\n    function loadComponentRenderer(tNode, lView) {\r\n        var componentLView = lView[tNode.index];\r\n        return componentLView[RENDERER];\r\n    }\r\n    /** Handles an error thrown in an LView. */\r\n    function handleError(lView, error) {\r\n        var injector = lView[INJECTOR$1];\r\n        var errorHandler = injector ? injector.get(ErrorHandler, null) : null;\r\n        errorHandler && errorHandler.handleError(error);\r\n    }\r\n    /**\r\n     * Set the inputs of directives at the current node to corresponding value.\r\n     *\r\n     * @param lView the `LView` which contains the directives.\r\n     * @param inputs mapping between the public \"input\" name and privately-known,\r\n     * possibly minified, property names to write to.\r\n     * @param value Value to set.\r\n     */\r\n    function setInputsForProperty(lView, inputs, value) {\r\n        var tView = lView[TVIEW];\r\n        for (var i = 0; i < inputs.length;) {\r\n            var index = inputs[i++];\r\n            var publicName = inputs[i++];\r\n            var privateName = inputs[i++];\r\n            var instance = lView[index];\r\n            ngDevMode && assertDataInRange(lView, index);\r\n            var def = tView.data[index];\r\n            var setInput = def.setInput;\r\n            if (setInput) {\r\n                def.setInput(instance, value, publicName, privateName);\r\n            }\r\n            else {\r\n                instance[privateName] = value;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Updates a text binding at a given index in a given LView.\r\n     */\r\n    function textBindingInternal(lView, index, value) {\r\n        ngDevMode && assertNotSame(value, NO_CHANGE, 'value should not be NO_CHANGE');\r\n        ngDevMode && assertDataInRange(lView, index + HEADER_OFFSET);\r\n        var element = getNativeByIndex(index, lView);\r\n        ngDevMode && assertDefined(element, 'native element should exist');\r\n        ngDevMode && ngDevMode.rendererSetText++;\r\n        var renderer = lView[RENDERER];\r\n        isProceduralRenderer(renderer) ? renderer.setValue(element, value) : element.textContent = value;\r\n    }\r\n    /**\r\n     * Renders all initial styling (class and style values) on to the element from the tNode.\r\n     *\r\n     * All initial styling data (i.e. any values extracted from the `style` or `class` attributes\r\n     * on an element) are collected into the `tNode.styles` and `tNode.classes` data structures.\r\n     * These values are populated during the creation phase of an element and are then later\r\n     * applied once the element is instantiated. This function applies each of the static\r\n     * style and class entries to the element.\r\n     */\r\n    function renderInitialStyling(renderer, native, tNode) {\r\n        renderStylingMap(renderer, native, tNode.classes, true);\r\n        renderStylingMap(renderer, native, tNode.styles, false);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var unusedValueToPlacateAjd$1 = unusedValueExportToPlacateAjd$1 + unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd$5 + unusedValueExportToPlacateAjd$3 + unusedValueExportToPlacateAjd;\r\n    function getLContainer(tNode, embeddedView) {\r\n        ngDevMode && assertLView(embeddedView);\r\n        var container = embeddedView[PARENT];\r\n        if (tNode.index === -1) {\r\n            // This is a dynamically created view inside a dynamic container.\r\n            // The parent isn't an LContainer if the embedded view hasn't been attached yet.\r\n            return isLContainer(container) ? container : null;\r\n        }\r\n        else {\r\n            ngDevMode && assertLContainer(container);\r\n            // This is a inline view node (e.g. embeddedViewStart)\r\n            return container;\r\n        }\r\n    }\r\n    /**\r\n     * Retrieves render parent for a given view.\r\n     * Might be null if a view is not yet attached to any container.\r\n     */\r\n    function getContainerRenderParent(tViewNode, view) {\r\n        var container = getLContainer(tViewNode, view);\r\n        return container ? nativeParentNode(view[RENDERER], container[NATIVE]) : null;\r\n    }\r\n    /**\r\n     * NOTE: for performance reasons, the possible actions are inlined within the function instead of\r\n     * being passed as an argument.\r\n     */\r\n    function executeActionOnElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {\r\n        // If this slot was allocated for a text node dynamically created by i18n, the text node itself\r\n        // won't be created until i18nApply() in the update block, so this node should be skipped.\r\n        // For more info, see \"ICU expressions should work inside an ngTemplateOutlet inside an ngFor\"\r\n        // in `i18n_spec.ts`.\r\n        if (lNodeToHandle != null) {\r\n            var lContainer = void 0;\r\n            var isComponent = false;\r\n            // We are expecting an RNode, but in the case of a component or LContainer the `RNode` is\r\n            // wrapped\r\n            // in an array which needs to be unwrapped. We need to know if it is a component and if\r\n            // it has LContainer so that we can process all of those cases appropriately.\r\n            if (isLContainer(lNodeToHandle)) {\r\n                lContainer = lNodeToHandle;\r\n            }\r\n            else if (isLView(lNodeToHandle)) {\r\n                isComponent = true;\r\n                ngDevMode && assertDefined(lNodeToHandle[HOST], 'HOST must be defined for a component LView');\r\n                lNodeToHandle = lNodeToHandle[HOST];\r\n            }\r\n            var rNode = unwrapRNode(lNodeToHandle);\r\n            ngDevMode && assertDomNode(rNode);\r\n            if (action === 0 /* Insert */) {\r\n                nativeInsertBefore(renderer, parent, rNode, beforeNode || null);\r\n            }\r\n            else if (action === 1 /* Detach */) {\r\n                nativeRemoveNode(renderer, rNode, isComponent);\r\n            }\r\n            else if (action === 2 /* Destroy */) {\r\n                ngDevMode && ngDevMode.rendererDestroyNode++;\r\n                renderer.destroyNode(rNode);\r\n            }\r\n            if (lContainer != null) {\r\n                executeActionOnContainer(renderer, action, lContainer, parent, beforeNode);\r\n            }\r\n        }\r\n    }\r\n    function createTextNode(value, renderer) {\r\n        return isProceduralRenderer(renderer) ? renderer.createText(renderStringify(value)) :\r\n            renderer.createTextNode(renderStringify(value));\r\n    }\r\n    function addRemoveViewFromContainer(lView, insertMode, beforeNode) {\r\n        var renderParent = getContainerRenderParent(lView[TVIEW].node, lView);\r\n        ngDevMode && assertNodeType(lView[TVIEW].node, 2 /* View */);\r\n        if (renderParent) {\r\n            var renderer = lView[RENDERER];\r\n            var action = insertMode ? 0 /* Insert */ : 1 /* Detach */;\r\n            executeActionOnView(renderer, action, lView, renderParent, beforeNode);\r\n        }\r\n    }\r\n    /**\r\n     * Detach a `LView` from the DOM by detaching its nodes.\r\n     *\r\n     * @param lView the `LView` to be detached.\r\n     */\r\n    function renderDetachView(lView) {\r\n        executeActionOnView(lView[RENDERER], 1 /* Detach */, lView, null, null);\r\n    }\r\n    /**\r\n     * Traverses down and up the tree of views and containers to remove listeners and\r\n     * call onDestroy callbacks.\r\n     *\r\n     * Notes:\r\n     *  - Because it's used for onDestroy calls, it needs to be bottom-up.\r\n     *  - Must process containers instead of their views to avoid splicing\r\n     *  when views are destroyed and re-added.\r\n     *  - Using a while loop because it's faster than recursion\r\n     *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\r\n     *\r\n     *  @param rootView The view to destroy\r\n     */\r\n    function destroyViewTree(rootView) {\r\n        // If the view has no children, we can clean it up and return early.\r\n        var lViewOrLContainer = rootView[CHILD_HEAD];\r\n        if (!lViewOrLContainer) {\r\n            return cleanUpView(rootView);\r\n        }\r\n        while (lViewOrLContainer) {\r\n            var next = null;\r\n            if (isLView(lViewOrLContainer)) {\r\n                // If LView, traverse down to child.\r\n                next = lViewOrLContainer[CHILD_HEAD];\r\n            }\r\n            else {\r\n                ngDevMode && assertLContainer(lViewOrLContainer);\r\n                // If container, traverse down to its first LView.\r\n                var firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];\r\n                if (firstView)\r\n                    next = firstView;\r\n            }\r\n            if (!next) {\r\n                // Only clean up view when moving to the side or up, as destroy hooks\r\n                // should be called in order from the bottom up.\r\n                while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {\r\n                    cleanUpView(lViewOrLContainer);\r\n                    lViewOrLContainer = getParentState(lViewOrLContainer, rootView);\r\n                }\r\n                cleanUpView(lViewOrLContainer || rootView);\r\n                next = lViewOrLContainer && lViewOrLContainer[NEXT];\r\n            }\r\n            lViewOrLContainer = next;\r\n        }\r\n    }\r\n    /**\r\n     * Inserts a view into a container.\r\n     *\r\n     * This adds the view to the container's array of active views in the correct\r\n     * position. It also adds the view's elements to the DOM if the container isn't a\r\n     * root node of another view (in that case, the view's elements will be added when\r\n     * the container's parent view is added later).\r\n     *\r\n     * @param lView The view to insert\r\n     * @param lContainer The container into which the view should be inserted\r\n     * @param index Which index in the container to insert the child view into\r\n     */\r\n    function insertView(lView, lContainer, index) {\r\n        ngDevMode && assertLView(lView);\r\n        ngDevMode && assertLContainer(lContainer);\r\n        var indexInContainer = CONTAINER_HEADER_OFFSET + index;\r\n        var containerLength = lContainer.length;\r\n        if (index > 0) {\r\n            // This is a new view, we need to add it to the children.\r\n            lContainer[indexInContainer - 1][NEXT] = lView;\r\n        }\r\n        if (index < containerLength - CONTAINER_HEADER_OFFSET) {\r\n            lView[NEXT] = lContainer[indexInContainer];\r\n            addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);\r\n        }\r\n        else {\r\n            lContainer.push(lView);\r\n            lView[NEXT] = null;\r\n        }\r\n        lView[PARENT] = lContainer;\r\n        // track views where declaration and insertion points are different\r\n        var declarationLContainer = lView[DECLARATION_LCONTAINER];\r\n        if (declarationLContainer !== null && lContainer !== declarationLContainer) {\r\n            trackMovedView(declarationLContainer, lView);\r\n        }\r\n        // notify query that a new view has been added\r\n        var lQueries = lView[QUERIES];\r\n        if (lQueries !== null) {\r\n            lQueries.insertView(lView[TVIEW]);\r\n        }\r\n        // Sets the attached flag\r\n        lView[FLAGS] |= 128 /* Attached */;\r\n    }\r\n    /**\r\n     * Track views created from the declaration container (TemplateRef) and inserted into a\r\n     * different LContainer.\r\n     */\r\n    function trackMovedView(declarationContainer, lView) {\r\n        ngDevMode && assertLContainer(declarationContainer);\r\n        var declaredViews = declarationContainer[MOVED_VIEWS];\r\n        if (declaredViews === null) {\r\n            declarationContainer[MOVED_VIEWS] = [lView];\r\n        }\r\n        else {\r\n            declaredViews.push(lView);\r\n        }\r\n    }\r\n    function detachMovedView(declarationContainer, lView) {\r\n        ngDevMode && assertLContainer(declarationContainer);\r\n        ngDevMode && assertDefined(declarationContainer[MOVED_VIEWS], 'A projected view should belong to a non-empty projected views collection');\r\n        var projectedViews = declarationContainer[MOVED_VIEWS];\r\n        var declaredViewIndex = projectedViews.indexOf(lView);\r\n        projectedViews.splice(declaredViewIndex, 1);\r\n    }\r\n    /**\r\n     * Detaches a view from a container.\r\n     *\r\n     * This method removes the view from the container's array of active views. It also\r\n     * removes the view's elements from the DOM.\r\n     *\r\n     * @param lContainer The container from which to detach a view\r\n     * @param removeIndex The index of the view to detach\r\n     * @returns Detached LView instance.\r\n     */\r\n    function detachView(lContainer, removeIndex) {\r\n        if (lContainer.length <= CONTAINER_HEADER_OFFSET)\r\n            return;\r\n        var indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;\r\n        var viewToDetach = lContainer[indexInContainer];\r\n        if (viewToDetach) {\r\n            var declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];\r\n            if (declarationLContainer !== null && declarationLContainer !== lContainer) {\r\n                detachMovedView(declarationLContainer, viewToDetach);\r\n            }\r\n            if (removeIndex > 0) {\r\n                lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];\r\n            }\r\n            var removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);\r\n            addRemoveViewFromContainer(viewToDetach, false);\r\n            // notify query that a view has been removed\r\n            var lQueries = removedLView[QUERIES];\r\n            if (lQueries !== null) {\r\n                lQueries.detachView(removedLView[TVIEW]);\r\n            }\r\n            viewToDetach[PARENT] = null;\r\n            viewToDetach[NEXT] = null;\r\n            // Unsets the attached flag\r\n            viewToDetach[FLAGS] &= ~128 /* Attached */;\r\n        }\r\n        return viewToDetach;\r\n    }\r\n    /**\r\n     * Removes a view from a container, i.e. detaches it and then destroys the underlying LView.\r\n     *\r\n     * @param lContainer The container from which to remove a view\r\n     * @param removeIndex The index of the view to remove\r\n     */\r\n    function removeView(lContainer, removeIndex) {\r\n        var detachedView = detachView(lContainer, removeIndex);\r\n        detachedView && destroyLView(detachedView);\r\n    }\r\n    /**\r\n     * A standalone function which destroys an LView,\r\n     * conducting cleanup (e.g. removing listeners, calling onDestroys).\r\n     *\r\n     * @param lView The view to be destroyed.\r\n     */\r\n    function destroyLView(lView) {\r\n        if (!(lView[FLAGS] & 256 /* Destroyed */)) {\r\n            var renderer = lView[RENDERER];\r\n            if (isProceduralRenderer(renderer) && renderer.destroyNode) {\r\n                executeActionOnView(renderer, 2 /* Destroy */, lView, null, null);\r\n            }\r\n            destroyViewTree(lView);\r\n        }\r\n    }\r\n    /**\r\n     * Determines which LViewOrLContainer to jump to when traversing back up the\r\n     * tree in destroyViewTree.\r\n     *\r\n     * Normally, the view's parent LView should be checked, but in the case of\r\n     * embedded views, the container (which is the view node's parent, but not the\r\n     * LView's parent) needs to be checked for a possible next property.\r\n     *\r\n     * @param lViewOrLContainer The LViewOrLContainer for which we need a parent state\r\n     * @param rootView The rootView, so we don't propagate too far up the view tree\r\n     * @returns The correct parent LViewOrLContainer\r\n     */\r\n    function getParentState(lViewOrLContainer, rootView) {\r\n        var tNode;\r\n        if (isLView(lViewOrLContainer) && (tNode = lViewOrLContainer[T_HOST]) &&\r\n            tNode.type === 2 /* View */) {\r\n            // if it's an embedded view, the state needs to go up to the container, in case the\r\n            // container has a next\r\n            return getLContainer(tNode, lViewOrLContainer);\r\n        }\r\n        else {\r\n            // otherwise, use parent view for containers or component views\r\n            return lViewOrLContainer[PARENT] === rootView ? null : lViewOrLContainer[PARENT];\r\n        }\r\n    }\r\n    /**\r\n     * Calls onDestroys hooks for all directives and pipes in a given view and then removes all\r\n     * listeners. Listeners are removed as the last step so events delivered in the onDestroys hooks\r\n     * can be propagated to @Output listeners.\r\n     *\r\n     * @param view The LView to clean up\r\n     */\r\n    function cleanUpView(view) {\r\n        if (isLView(view) && !(view[FLAGS] & 256 /* Destroyed */)) {\r\n            // Usually the Attached flag is removed when the view is detached from its parent, however\r\n            // if it's a root view, the flag won't be unset hence why we're also removing on destroy.\r\n            view[FLAGS] &= ~128 /* Attached */;\r\n            // Mark the LView as destroyed *before* executing the onDestroy hooks. An onDestroy hook\r\n            // runs arbitrary user code, which could include its own `viewRef.destroy()` (or similar). If\r\n            // We don't flag the view as destroyed before the hooks, this could lead to an infinite loop.\r\n            // This also aligns with the ViewEngine behavior. It also means that the onDestroy hook is\r\n            // really more of an \"afterDestroy\" hook if you think about it.\r\n            view[FLAGS] |= 256 /* Destroyed */;\r\n            executeOnDestroys(view);\r\n            removeListeners(view);\r\n            var hostTNode = view[T_HOST];\r\n            // For component views only, the local renderer is destroyed as clean up time.\r\n            if (hostTNode && hostTNode.type === 3 /* Element */ && isProceduralRenderer(view[RENDERER])) {\r\n                ngDevMode && ngDevMode.rendererDestroy++;\r\n                view[RENDERER].destroy();\r\n            }\r\n            var declarationContainer = view[DECLARATION_LCONTAINER];\r\n            // we are dealing with an embedded view that is still inserted into a container\r\n            if (declarationContainer !== null && isLContainer(view[PARENT])) {\r\n                // and this is a projected view\r\n                if (declarationContainer !== view[PARENT]) {\r\n                    detachMovedView(declarationContainer, view);\r\n                }\r\n                // For embedded views still attached to a container: remove query result from this view.\r\n                var lQueries = view[QUERIES];\r\n                if (lQueries !== null) {\r\n                    lQueries.detachView(view[TVIEW]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /** Removes listeners and unsubscribes from output subscriptions */\r\n    function removeListeners(lView) {\r\n        var tCleanup = lView[TVIEW].cleanup;\r\n        if (tCleanup !== null) {\r\n            var lCleanup = lView[CLEANUP];\r\n            for (var i = 0; i < tCleanup.length - 1; i += 2) {\r\n                if (typeof tCleanup[i] === 'string') {\r\n                    // This is a native DOM listener\r\n                    var idxOrTargetGetter = tCleanup[i + 1];\r\n                    var target = typeof idxOrTargetGetter === 'function' ?\r\n                        idxOrTargetGetter(lView) :\r\n                        unwrapRNode(lView[idxOrTargetGetter]);\r\n                    var listener = lCleanup[tCleanup[i + 2]];\r\n                    var useCaptureOrSubIdx = tCleanup[i + 3];\r\n                    if (typeof useCaptureOrSubIdx === 'boolean') {\r\n                        // native DOM listener registered with Renderer3\r\n                        target.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx);\r\n                    }\r\n                    else {\r\n                        if (useCaptureOrSubIdx >= 0) {\r\n                            // unregister\r\n                            lCleanup[useCaptureOrSubIdx]();\r\n                        }\r\n                        else {\r\n                            // Subscription\r\n                            lCleanup[-useCaptureOrSubIdx].unsubscribe();\r\n                        }\r\n                    }\r\n                    i += 2;\r\n                }\r\n                else {\r\n                    // This is a cleanup function that is grouped with the index of its context\r\n                    var context = lCleanup[tCleanup[i + 1]];\r\n                    tCleanup[i].call(context);\r\n                }\r\n            }\r\n            lView[CLEANUP] = null;\r\n        }\r\n    }\r\n    /** Calls onDestroy hooks for this view */\r\n    function executeOnDestroys(view) {\r\n        var tView = view[TVIEW];\r\n        var destroyHooks;\r\n        if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\r\n            for (var i = 0; i < destroyHooks.length; i += 2) {\r\n                var context = view[destroyHooks[i]];\r\n                // Only call the destroy hook if the context has been requested.\r\n                if (!(context instanceof NodeInjectorFactory)) {\r\n                    destroyHooks[i + 1].call(context);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns a native element if a node can be inserted into the given parent.\r\n     *\r\n     * There are two reasons why we may not be able to insert a element immediately.\r\n     * - Projection: When creating a child content element of a component, we have to skip the\r\n     *   insertion because the content of a component will be projected.\r\n     *   `<component><content>delayed due to projection</content></component>`\r\n     * - Parent container is disconnected: This can happen when we are inserting a view into\r\n     *   parent container, which itself is disconnected. For example the parent container is part\r\n     *   of a View which has not be inserted or is made for projection but has not been inserted\r\n     *   into destination.\r\n     */\r\n    function getRenderParent(tNode, currentView) {\r\n        // Nodes of the top-most view can be inserted eagerly.\r\n        if (isRootView(currentView)) {\r\n            return nativeParentNode(currentView[RENDERER], getNativeByTNode(tNode, currentView));\r\n        }\r\n        // Skip over element and ICU containers as those are represented by a comment node and\r\n        // can't be used as a render parent.\r\n        var parent = getHighestElementOrICUContainer(tNode);\r\n        var renderParent = parent.parent;\r\n        // If the parent is null, then we are inserting across views: either into an embedded view or a\r\n        // component view.\r\n        if (renderParent == null) {\r\n            var hostTNode = currentView[T_HOST];\r\n            if (hostTNode.type === 2 /* View */) {\r\n                // We are inserting a root element of an embedded view We might delay insertion of children\r\n                // for a given view if it is disconnected. This might happen for 2 main reasons:\r\n                // - view is not inserted into any container(view was created but not inserted yet)\r\n                // - view is inserted into a container but the container itself is not inserted into the DOM\r\n                // (container might be part of projection or child of a view that is not inserted yet).\r\n                // In other words we can insert children of a given view if this view was inserted into a\r\n                // container and the container itself has its render parent determined.\r\n                return getContainerRenderParent(hostTNode, currentView);\r\n            }\r\n            else {\r\n                // We are inserting a root element of the component view into the component host element and\r\n                // it should always be eager.\r\n                return getHostNative(currentView);\r\n            }\r\n        }\r\n        else {\r\n            var isIcuCase = parent && parent.type === 5 /* IcuContainer */;\r\n            // If the parent of this node is an ICU container, then it is represented by comment node and we\r\n            // need to use it as an anchor. If it is projected then its direct parent node is the renderer.\r\n            if (isIcuCase && parent.flags & 2 /* isProjected */) {\r\n                return getNativeByTNode(parent, currentView).parentNode;\r\n            }\r\n            ngDevMode && assertNodeType(renderParent, 3 /* Element */);\r\n            if (renderParent.flags & 1 /* isComponent */ && !isIcuCase) {\r\n                var tData = currentView[TVIEW].data;\r\n                var tNode_1 = tData[renderParent.index];\r\n                var encapsulation = tData[tNode_1.directiveStart].encapsulation;\r\n                // We've got a parent which is an element in the current view. We just need to verify if the\r\n                // parent element is not a component. Component's content nodes are not inserted immediately\r\n                // because they will be projected, and so doing insert at this point would be wasteful.\r\n                // Since the projection would then move it to its final destination. Note that we can't\r\n                // make this assumption when using the Shadow DOM, because the native projection placeholders\r\n                // (<content> or <slot>) have to be in place as elements are being inserted.\r\n                if (encapsulation !== exports.ViewEncapsulation.ShadowDom &&\r\n                    encapsulation !== exports.ViewEncapsulation.Native) {\r\n                    return null;\r\n                }\r\n            }\r\n            return getNativeByTNode(renderParent, currentView);\r\n        }\r\n    }\r\n    /**\r\n     * Gets the native host element for a given view. Will return null if the current view does not have\r\n     * a host element.\r\n     */\r\n    function getHostNative(currentView) {\r\n        ngDevMode && assertLView(currentView);\r\n        var hostTNode = currentView[T_HOST];\r\n        return hostTNode && hostTNode.type === 3 /* Element */ ?\r\n            getNativeByTNode(hostTNode, getLViewParent(currentView)) :\r\n            null;\r\n    }\r\n    /**\r\n     * Inserts a native node before another native node for a given parent using {@link Renderer3}.\r\n     * This is a utility function that can be used when native nodes were determined - it abstracts an\r\n     * actual renderer being used.\r\n     */\r\n    function nativeInsertBefore(renderer, parent, child, beforeNode) {\r\n        ngDevMode && ngDevMode.rendererInsertBefore++;\r\n        if (isProceduralRenderer(renderer)) {\r\n            renderer.insertBefore(parent, child, beforeNode);\r\n        }\r\n        else {\r\n            parent.insertBefore(child, beforeNode, true);\r\n        }\r\n    }\r\n    function nativeAppendChild(renderer, parent, child) {\r\n        ngDevMode && ngDevMode.rendererAppendChild++;\r\n        if (isProceduralRenderer(renderer)) {\r\n            renderer.appendChild(parent, child);\r\n        }\r\n        else {\r\n            parent.appendChild(child);\r\n        }\r\n    }\r\n    function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode) {\r\n        if (beforeNode !== null) {\r\n            nativeInsertBefore(renderer, parent, child, beforeNode);\r\n        }\r\n        else {\r\n            nativeAppendChild(renderer, parent, child);\r\n        }\r\n    }\r\n    /** Removes a node from the DOM given its native parent. */\r\n    function nativeRemoveChild(renderer, parent, child, isHostElement) {\r\n        if (isProceduralRenderer(renderer)) {\r\n            renderer.removeChild(parent, child, isHostElement);\r\n        }\r\n        else {\r\n            parent.removeChild(child);\r\n        }\r\n    }\r\n    /**\r\n     * Returns a native parent of a given native node.\r\n     */\r\n    function nativeParentNode(renderer, node) {\r\n        return (isProceduralRenderer(renderer) ? renderer.parentNode(node) : node.parentNode);\r\n    }\r\n    /**\r\n     * Returns a native sibling of a given native node.\r\n     */\r\n    function nativeNextSibling(renderer, node) {\r\n        return isProceduralRenderer(renderer) ? renderer.nextSibling(node) : node.nextSibling;\r\n    }\r\n    /**\r\n     * Finds a native \"anchor\" node for cases where we can't append a native child directly\r\n     * (`appendChild`) and need to use a reference (anchor) node for the `insertBefore` operation.\r\n     * @param parentTNode\r\n     * @param lView\r\n     */\r\n    function getNativeAnchorNode(parentTNode, lView) {\r\n        if (parentTNode.type === 2 /* View */) {\r\n            var lContainer = getLContainer(parentTNode, lView);\r\n            var index = lContainer.indexOf(lView, CONTAINER_HEADER_OFFSET) - CONTAINER_HEADER_OFFSET;\r\n            return getBeforeNodeForView(index, lContainer);\r\n        }\r\n        else if (parentTNode.type === 4 /* ElementContainer */ ||\r\n            parentTNode.type === 5 /* IcuContainer */) {\r\n            return getNativeByTNode(parentTNode, lView);\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Appends the `child` native node (or a collection of nodes) to the `parent`.\r\n     *\r\n     * The element insertion might be delayed {@link canInsertNativeNode}.\r\n     *\r\n     * @param childEl The native child (or children) that should be appended\r\n     * @param childTNode The TNode of the child element\r\n     * @param currentView The current LView\r\n     * @returns Whether or not the child was appended\r\n     */\r\n    function appendChild(childEl, childTNode, currentView) {\r\n        var e_1, _a;\r\n        var renderParent = getRenderParent(childTNode, currentView);\r\n        if (renderParent != null) {\r\n            var renderer = currentView[RENDERER];\r\n            var parentTNode = childTNode.parent || currentView[T_HOST];\r\n            var anchorNode = getNativeAnchorNode(parentTNode, currentView);\r\n            if (Array.isArray(childEl)) {\r\n                try {\r\n                    for (var childEl_1 = __values(childEl), childEl_1_1 = childEl_1.next(); !childEl_1_1.done; childEl_1_1 = childEl_1.next()) {\r\n                        var nativeNode = childEl_1_1.value;\r\n                        nativeAppendOrInsertBefore(renderer, renderParent, nativeNode, anchorNode);\r\n                    }\r\n                }\r\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (childEl_1_1 && !childEl_1_1.done && (_a = childEl_1.return)) _a.call(childEl_1);\r\n                    }\r\n                    finally { if (e_1) throw e_1.error; }\r\n                }\r\n            }\r\n            else {\r\n                nativeAppendOrInsertBefore(renderer, renderParent, childEl, anchorNode);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Gets the top-level element or an ICU container if those containers are nested.\r\n     *\r\n     * @param tNode The starting TNode for which we should skip element and ICU containers\r\n     * @returns The TNode of the highest level ICU container or element container\r\n     */\r\n    function getHighestElementOrICUContainer(tNode) {\r\n        while (tNode.parent != null && (tNode.parent.type === 4 /* ElementContainer */ ||\r\n            tNode.parent.type === 5 /* IcuContainer */)) {\r\n            tNode = tNode.parent;\r\n        }\r\n        return tNode;\r\n    }\r\n    function getBeforeNodeForView(viewIndexInContainer, lContainer) {\r\n        var nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;\r\n        if (nextViewIndex < lContainer.length) {\r\n            var lView = lContainer[nextViewIndex];\r\n            ngDevMode && assertDefined(lView[T_HOST], 'Missing Host TNode');\r\n            var tViewNodeChild = lView[T_HOST].child;\r\n            return tViewNodeChild !== null ? getNativeByTNodeOrNull(tViewNodeChild, lView) :\r\n                lContainer[NATIVE];\r\n        }\r\n        else {\r\n            return lContainer[NATIVE];\r\n        }\r\n    }\r\n    /**\r\n     * Removes a native node itself using a given renderer. To remove the node we are looking up its\r\n     * parent from the native tree as not all platforms / browsers support the equivalent of\r\n     * node.remove().\r\n     *\r\n     * @param renderer A renderer to be used\r\n     * @param rNode The native node that should be removed\r\n     * @param isHostElement A flag indicating if a node to be removed is a host of a component.\r\n     */\r\n    function nativeRemoveNode(renderer, rNode, isHostElement) {\r\n        var nativeParent = nativeParentNode(renderer, rNode);\r\n        if (nativeParent) {\r\n            nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);\r\n        }\r\n    }\r\n    /**\r\n     * Appends nodes to a target projection place. Nodes to insert were previously re-distribution and\r\n     * stored on a component host level.\r\n     * @param lView A LView where nodes are inserted (target LView)\r\n     * @param tProjectionNode A projection node where previously re-distribution should be appended\r\n     * (target insertion place)\r\n     * @param selectorIndex A bucket from where nodes to project should be taken\r\n     * @param componentView A where projectable nodes were initially created (source view)\r\n     */\r\n    function appendProjectedNodes(lView, tProjectionNode, selectorIndex, componentView) {\r\n        var projectedView = componentView[PARENT];\r\n        var componentNode = componentView[T_HOST];\r\n        var nodeToProject = componentNode.projection[selectorIndex];\r\n        if (Array.isArray(nodeToProject)) {\r\n            appendChild(nodeToProject, tProjectionNode, lView);\r\n        }\r\n        else {\r\n            while (nodeToProject) {\r\n                if (!(nodeToProject.flags & 32 /* isDetached */)) {\r\n                    if (nodeToProject.type === 1 /* Projection */) {\r\n                        appendProjectedNodes(lView, tProjectionNode, nodeToProject.projection, findComponentView(projectedView));\r\n                    }\r\n                    else {\r\n                        // This flag must be set now or we won't know that this node is projected\r\n                        // if the nodes are inserted into a container later.\r\n                        nodeToProject.flags |= 2 /* isProjected */;\r\n                        appendProjectedNode(nodeToProject, tProjectionNode, lView, projectedView);\r\n                    }\r\n                }\r\n                nodeToProject = nodeToProject.projectionNext;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Loops over all children of a TNode container and appends them to the DOM\r\n     *\r\n     * @param ngContainerChildTNode The first child of the TNode container\r\n     * @param tProjectionNode The projection (ng-content) TNode\r\n     * @param currentView Current LView\r\n     * @param projectionView Projection view (view above current)\r\n     */\r\n    function appendProjectedChildren(ngContainerChildTNode, tProjectionNode, currentView, projectionView) {\r\n        while (ngContainerChildTNode) {\r\n            appendProjectedNode(ngContainerChildTNode, tProjectionNode, currentView, projectionView);\r\n            ngContainerChildTNode = ngContainerChildTNode.next;\r\n        }\r\n    }\r\n    /**\r\n     * Appends a projected node to the DOM, or in the case of a projected container,\r\n     * appends the nodes from all of the container's active views to the DOM.\r\n     *\r\n     * @param projectedTNode The TNode to be projected\r\n     * @param tProjectionNode The projection (ng-content) TNode\r\n     * @param currentView Current LView\r\n     * @param projectionView Projection view (view above current)\r\n     */\r\n    function appendProjectedNode(projectedTNode, tProjectionNode, currentView, projectionView) {\r\n        var native = getNativeByTNode(projectedTNode, projectionView);\r\n        appendChild(native, tProjectionNode, currentView);\r\n        // the projected contents are processed while in the shadow view (which is the currentView)\r\n        // therefore we need to extract the view where the host element lives since it's the\r\n        // logical container of the content projected views\r\n        attachPatchData(native, projectionView);\r\n        var nodeOrContainer = projectionView[projectedTNode.index];\r\n        if (projectedTNode.type === 0 /* Container */) {\r\n            // The node we are adding is a container and we are adding it to an element which\r\n            // is not a component (no more re-projection).\r\n            // Alternatively a container is projected at the root of a component's template\r\n            // and can't be re-projected (as not content of any component).\r\n            // Assign the final projection location in those cases.\r\n            for (var i = CONTAINER_HEADER_OFFSET; i < nodeOrContainer.length; i++) {\r\n                addRemoveViewFromContainer(nodeOrContainer[i], true, nodeOrContainer[NATIVE]);\r\n            }\r\n        }\r\n        else if (projectedTNode.type === 5 /* IcuContainer */) {\r\n            // The node we are adding is an ICU container which is why we also need to project all the\r\n            // children nodes that might have been created previously and are linked to this anchor\r\n            var ngContainerChildTNode = projectedTNode.child;\r\n            appendProjectedChildren(ngContainerChildTNode, ngContainerChildTNode, projectionView, projectionView);\r\n        }\r\n        else {\r\n            if (projectedTNode.type === 4 /* ElementContainer */) {\r\n                appendProjectedChildren(projectedTNode.child, tProjectionNode, currentView, projectionView);\r\n            }\r\n            if (isLContainer(nodeOrContainer)) {\r\n                appendChild(nodeOrContainer[NATIVE], tProjectionNode, currentView);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * `executeActionOnView` performs an operation on the view as specified in `action` (insert, detach,\r\n     * destroy)\r\n     *\r\n     * Inserting a view without projection or containers at top level is simple. Just iterate over the\r\n     * root nodes of the View, and for each node perform the `action`.\r\n     *\r\n     * Things get more complicated with containers and projections. That is because coming across:\r\n     * - Container: implies that we have to insert/remove/destroy the views of that container as well\r\n     *              which in turn can have their own Containers at the View roots.\r\n     * - Projection: implies that we have to insert/remove/destroy the nodes of the projection. The\r\n     *               complication is that the nodes we are projecting can themselves have Containers\r\n     *               or other Projections.\r\n     *\r\n     * As you can see this is a very recursive problem. While the recursive implementation is not the\r\n     * most efficient one, trying to unroll the nodes non-recursively results in very complex code that\r\n     * is very hard (to maintain). We are sacrificing a bit of performance for readability using a\r\n     * recursive implementation.\r\n     *\r\n     * @param renderer Renderer to use\r\n     * @param action action to perform (insert, detach, destroy)\r\n     * @param lView The LView which needs to be inserted, detached, destroyed.\r\n     * @param renderParent parent DOM element for insertion/removal.\r\n     * @param beforeNode Before which node the insertions should happen.\r\n     */\r\n    function executeActionOnView(renderer, action, lView, renderParent, beforeNode) {\r\n        var tView = lView[TVIEW];\r\n        ngDevMode && assertNodeType(tView.node, 2 /* View */);\r\n        var viewRootTNode = tView.node.child;\r\n        while (viewRootTNode !== null) {\r\n            executeActionOnNode(renderer, action, lView, viewRootTNode, renderParent, beforeNode);\r\n            viewRootTNode = viewRootTNode.next;\r\n        }\r\n    }\r\n    /**\r\n     * `executeActionOnProjection` performs an operation on the projection specified by `action`\r\n     * (insert, detach, destroy).\r\n     *\r\n     * Inserting a projection requires us to locate the projected nodes from the parent component. The\r\n     * complication is that those nodes themselves could be re-projected from their parent component.\r\n     *\r\n     * @param renderer Renderer to use\r\n     * @param action action to perform (insert, detach, destroy)\r\n     * @param lView The LView which needs to be inserted, detached, destroyed.\r\n     * @param tProjectionNode projection TNode to process\r\n     * @param renderParent parent DOM element for insertion/removal.\r\n     * @param beforeNode Before which node the insertions should happen.\r\n     */\r\n    function executeActionOnProjection(renderer, action, lView, tProjectionNode, renderParent, beforeNode) {\r\n        var componentLView = findComponentView(lView);\r\n        var componentNode = componentLView[T_HOST];\r\n        ngDevMode && assertDefined(componentNode.projection, 'Element nodes for which projection is processed must have projection defined.');\r\n        var nodeToProject = componentNode.projection[tProjectionNode.projection];\r\n        if (nodeToProject !== undefined) {\r\n            if (Array.isArray(nodeToProject)) {\r\n                for (var i = 0; i < nodeToProject.length; i++) {\r\n                    var rNode = nodeToProject[i];\r\n                    ngDevMode && assertDomNode(rNode);\r\n                    executeActionOnElementOrContainer(action, renderer, renderParent, rNode, beforeNode);\r\n                }\r\n            }\r\n            else {\r\n                var projectionTNode = nodeToProject;\r\n                var projectedComponentLView = componentLView[PARENT];\r\n                while (projectionTNode !== null) {\r\n                    executeActionOnNode(renderer, action, projectedComponentLView, projectionTNode, renderParent, beforeNode);\r\n                    projectionTNode = projectionTNode.projectionNext;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * `executeActionOnContainer` performs an operation on the container and its views as specified by\r\n     * `action` (insert, detach, destroy)\r\n     *\r\n     * Inserting a Container is complicated by the fact that the container may have Views which\r\n     * themselves have containers or projections.\r\n     *\r\n     * @param renderer Renderer to use\r\n     * @param action action to perform (insert, detach, destroy)\r\n     * @param lContainer The LContainer which needs to be inserted, detached, destroyed.\r\n     * @param renderParent parent DOM element for insertion/removal.\r\n     * @param beforeNode Before which node the insertions should happen.\r\n     */\r\n    function executeActionOnContainer(renderer, action, lContainer, renderParent, beforeNode) {\r\n        ngDevMode && assertLContainer(lContainer);\r\n        var anchor = lContainer[NATIVE]; // LContainer has its own before node.\r\n        var native = unwrapRNode(lContainer);\r\n        // An LContainer can be created dynamically on any node by injecting ViewContainerRef.\r\n        // Asking for a ViewContainerRef on an element will result in a creation of a separate anchor node\r\n        // (comment in the DOM) that will be different from the LContainer's host node. In this particular\r\n        // case we need to execute action on 2 nodes:\r\n        // - container's host node (this is done in the executeNodeAction)\r\n        // - container's host node (this is done here)\r\n        if (anchor !== native) {\r\n            executeActionOnElementOrContainer(action, renderer, renderParent, anchor, beforeNode);\r\n        }\r\n        for (var i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\r\n            var lView = lContainer[i];\r\n            executeActionOnView(renderer, action, lView, renderParent, anchor);\r\n        }\r\n    }\r\n    /**\r\n     * `executeActionOnElementContainerOrIcuContainer` performs an operation on the ng-container node\r\n     * and its child nodes as specified by the `action` (insert, detach, destroy).\r\n     *\r\n     * @param renderer Renderer to use\r\n     * @param action action to perform (insert, detach, destroy)\r\n     * @param lView The LView which needs to be inserted, detached, destroyed.\r\n     * @param tNode The TNode associated with the `ElementContainer` or `IcuContainer`.\r\n     * @param renderParent parent DOM element for insertion/removal.\r\n     * @param beforeNode Before which node the insertions should happen.\r\n     */\r\n    function executeActionOnElementContainerOrIcuContainer(renderer, action, lView, tNode, renderParent, beforeNode) {\r\n        var node = lView[tNode.index];\r\n        executeActionOnElementOrContainer(action, renderer, renderParent, node, beforeNode);\r\n        var childTNode = tNode.child;\r\n        while (childTNode) {\r\n            executeActionOnNode(renderer, action, lView, childTNode, renderParent, beforeNode);\r\n            childTNode = childTNode.next;\r\n        }\r\n    }\r\n    function executeActionOnNode(renderer, action, lView, tNode, renderParent, beforeNode) {\r\n        var nodeType = tNode.type;\r\n        if (!(tNode.flags & 32 /* isDetached */)) {\r\n            if (nodeType === 4 /* ElementContainer */ || nodeType === 5 /* IcuContainer */) {\r\n                executeActionOnElementContainerOrIcuContainer(renderer, action, lView, tNode, renderParent, beforeNode);\r\n            }\r\n            else if (nodeType === 1 /* Projection */) {\r\n                executeActionOnProjection(renderer, action, lView, tNode, renderParent, beforeNode);\r\n            }\r\n            else {\r\n                ngDevMode && assertNodeOfPossibleTypes(tNode, 3 /* Element */, 0 /* Container */);\r\n                executeActionOnElementOrContainer(action, renderer, renderParent, lView[tNode.index], beforeNode);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Unwraps a parent injector location number to find the view offset from the current injector,\r\n     * then walks up the declaration view tree until the TNode of the parent injector is found.\r\n     *\r\n     * @param location The location of the parent injector, which contains the view offset\r\n     * @param startView The LView instance from which to start walking up the view tree\r\n     * @param startTNode The TNode instance of the starting element\r\n     * @returns The TNode of the parent injector\r\n     */\r\n    function getParentInjectorTNode(location, startView, startTNode) {\r\n        if (startTNode.parent && startTNode.parent.injectorIndex !== -1) {\r\n            // view offset is 0\r\n            var injectorIndex = startTNode.parent.injectorIndex;\r\n            var parentTNode_1 = startTNode.parent;\r\n            while (parentTNode_1.parent != null && injectorIndex == parentTNode_1.injectorIndex) {\r\n                parentTNode_1 = parentTNode_1.parent;\r\n            }\r\n            return parentTNode_1;\r\n        }\r\n        var viewOffset = getParentInjectorViewOffset(location);\r\n        // view offset is 1\r\n        var parentView = startView;\r\n        var parentTNode = startView[T_HOST];\r\n        // view offset is superior to 1\r\n        while (viewOffset > 1) {\r\n            parentView = parentView[DECLARATION_VIEW];\r\n            parentTNode = parentView[T_HOST];\r\n            viewOffset--;\r\n        }\r\n        return parentTNode;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var ViewRef = /** @class */ (function () {\r\n        function ViewRef(_lView, _context, _componentIndex) {\r\n            this._context = _context;\r\n            this._componentIndex = _componentIndex;\r\n            this._appRef = null;\r\n            this._viewContainerRef = null;\r\n            /**\r\n             * @internal\r\n             */\r\n            this._tViewNode = null;\r\n            this._lView = _lView;\r\n        }\r\n        Object.defineProperty(ViewRef.prototype, \"rootNodes\", {\r\n            get: function () {\r\n                if (this._lView[HOST] == null) {\r\n                    var tView = this._lView[T_HOST];\r\n                    return collectNativeNodes(this._lView, tView, []);\r\n                }\r\n                return [];\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(ViewRef.prototype, \"context\", {\r\n            get: function () { return this._context ? this._context : this._lookUpContext(); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(ViewRef.prototype, \"destroyed\", {\r\n            get: function () {\r\n                return (this._lView[FLAGS] & 256 /* Destroyed */) === 256 /* Destroyed */;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        ViewRef.prototype.destroy = function () {\r\n            if (this._appRef) {\r\n                this._appRef.detachView(this);\r\n            }\r\n            else if (this._viewContainerRef) {\r\n                var index = this._viewContainerRef.indexOf(this);\r\n                if (index > -1) {\r\n                    this._viewContainerRef.detach(index);\r\n                }\r\n                this._viewContainerRef = null;\r\n            }\r\n            destroyLView(this._lView);\r\n        };\r\n        ViewRef.prototype.onDestroy = function (callback) { storeCleanupFn(this._lView, callback); };\r\n        /**\r\n         * Marks a view and all of its ancestors dirty.\r\n         *\r\n         * It also triggers change detection by calling `scheduleTick` internally, which coalesces\r\n         * multiple `markForCheck` calls to into one change detection run.\r\n         *\r\n         * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush} component is\r\n         * checked when it needs to be re-rendered but the two normal triggers haven't marked it\r\n         * dirty (i.e. inputs haven't changed and events haven't fired in the view).\r\n         *\r\n         * <!-- TODO: Add a link to a chapter on OnPush components -->\r\n         *\r\n         * @usageNotes\r\n         * ### Example\r\n         *\r\n         * ```typescript\r\n         * @Component({\r\n         *   selector: 'my-app',\r\n         *   template: `Number of ticks: {{numberOfTicks}}`\r\n         *   changeDetection: ChangeDetectionStrategy.OnPush,\r\n         * })\r\n         * class AppComponent {\r\n         *   numberOfTicks = 0;\r\n         *\r\n         *   constructor(private ref: ChangeDetectorRef) {\r\n         *     setInterval(() => {\r\n         *       this.numberOfTicks++;\r\n         *       // the following is required, otherwise the view will not be updated\r\n         *       this.ref.markForCheck();\r\n         *     }, 1000);\r\n         *   }\r\n         * }\r\n         * ```\r\n         */\r\n        ViewRef.prototype.markForCheck = function () { markViewDirty(this._lView); };\r\n        /**\r\n         * Detaches the view from the change detection tree.\r\n         *\r\n         * Detached views will not be checked during change detection runs until they are\r\n         * re-attached, even if they are dirty. `detach` can be used in combination with\r\n         * {@link ChangeDetectorRef#detectChanges detectChanges} to implement local change\r\n         * detection checks.\r\n         *\r\n         * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\r\n         * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\r\n         *\r\n         * @usageNotes\r\n         * ### Example\r\n         *\r\n         * The following example defines a component with a large list of readonly data.\r\n         * Imagine the data changes constantly, many times per second. For performance reasons,\r\n         * we want to check and update the list every five seconds. We can do that by detaching\r\n         * the component's change detector and doing a local check every five seconds.\r\n         *\r\n         * ```typescript\r\n         * class DataProvider {\r\n         *   // in a real application the returned data will be different every time\r\n         *   get data() {\r\n         *     return [1,2,3,4,5];\r\n         *   }\r\n         * }\r\n         *\r\n         * @Component({\r\n         *   selector: 'giant-list',\r\n         *   template: `\r\n         *     <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</li>\r\n         *   `,\r\n         * })\r\n         * class GiantList {\r\n         *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\r\n         *     ref.detach();\r\n         *     setInterval(() => {\r\n         *       this.ref.detectChanges();\r\n         *     }, 5000);\r\n         *   }\r\n         * }\r\n         *\r\n         * @Component({\r\n         *   selector: 'app',\r\n         *   providers: [DataProvider],\r\n         *   template: `\r\n         *     <giant-list><giant-list>\r\n         *   `,\r\n         * })\r\n         * class App {\r\n         * }\r\n         * ```\r\n         */\r\n        ViewRef.prototype.detach = function () { this._lView[FLAGS] &= ~128 /* Attached */; };\r\n        /**\r\n         * Re-attaches a view to the change detection tree.\r\n         *\r\n         * This can be used to re-attach views that were previously detached from the tree\r\n         * using {@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.\r\n         *\r\n         * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\r\n         *\r\n         * @usageNotes\r\n         * ### Example\r\n         *\r\n         * The following example creates a component displaying `live` data. The component will detach\r\n         * its change detector from the main change detector tree when the component's live property\r\n         * is set to false.\r\n         *\r\n         * ```typescript\r\n         * class DataProvider {\r\n         *   data = 1;\r\n         *\r\n         *   constructor() {\r\n         *     setInterval(() => {\r\n         *       this.data = this.data * 2;\r\n         *     }, 500);\r\n         *   }\r\n         * }\r\n         *\r\n         * @Component({\r\n         *   selector: 'live-data',\r\n         *   inputs: ['live'],\r\n         *   template: 'Data: {{dataProvider.data}}'\r\n         * })\r\n         * class LiveData {\r\n         *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\r\n         *\r\n         *   set live(value) {\r\n         *     if (value) {\r\n         *       this.ref.reattach();\r\n         *     } else {\r\n         *       this.ref.detach();\r\n         *     }\r\n         *   }\r\n         * }\r\n         *\r\n         * @Component({\r\n         *   selector: 'my-app',\r\n         *   providers: [DataProvider],\r\n         *   template: `\r\n         *     Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\r\n         *     <live-data [live]=\"live\"><live-data>\r\n         *   `,\r\n         * })\r\n         * class AppComponent {\r\n         *   live = true;\r\n         * }\r\n         * ```\r\n         */\r\n        ViewRef.prototype.reattach = function () { this._lView[FLAGS] |= 128 /* Attached */; };\r\n        /**\r\n         * Checks the view and its children.\r\n         *\r\n         * This can also be used in combination with {@link ChangeDetectorRef#detach detach} to implement\r\n         * local change detection checks.\r\n         *\r\n         * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\r\n         * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\r\n         *\r\n         * @usageNotes\r\n         * ### Example\r\n         *\r\n         * The following example defines a component with a large list of readonly data.\r\n         * Imagine, the data changes constantly, many times per second. For performance reasons,\r\n         * we want to check and update the list every five seconds.\r\n         *\r\n         * We can do that by detaching the component's change detector and doing a local change detection\r\n         * check every five seconds.\r\n         *\r\n         * See {@link ChangeDetectorRef#detach detach} for more information.\r\n         */\r\n        ViewRef.prototype.detectChanges = function () { detectChangesInternal(this._lView, this.context); };\r\n        /**\r\n         * Checks the change detector and its children, and throws if any changes are detected.\r\n         *\r\n         * This is used in development mode to verify that running change detection doesn't\r\n         * introduce other changes.\r\n         */\r\n        ViewRef.prototype.checkNoChanges = function () { checkNoChangesInternal(this._lView, this.context); };\r\n        ViewRef.prototype.attachToViewContainerRef = function (vcRef) {\r\n            if (this._appRef) {\r\n                throw new Error('This view is already attached directly to the ApplicationRef!');\r\n            }\r\n            this._viewContainerRef = vcRef;\r\n        };\r\n        ViewRef.prototype.detachFromAppRef = function () {\r\n            this._appRef = null;\r\n            renderDetachView(this._lView);\r\n        };\r\n        ViewRef.prototype.attachToAppRef = function (appRef) {\r\n            if (this._viewContainerRef) {\r\n                throw new Error('This view is already attached to a ViewContainer!');\r\n            }\r\n            this._appRef = appRef;\r\n        };\r\n        ViewRef.prototype._lookUpContext = function () {\r\n            return this._context = getLViewParent(this._lView)[this._componentIndex];\r\n        };\r\n        return ViewRef;\r\n    }());\r\n    /** @internal */\r\n    var RootViewRef = /** @class */ (function (_super) {\r\n        __extends(RootViewRef, _super);\r\n        function RootViewRef(_view) {\r\n            var _this = _super.call(this, _view, null, -1) || this;\r\n            _this._view = _view;\r\n            return _this;\r\n        }\r\n        RootViewRef.prototype.detectChanges = function () { detectChangesInRootView(this._view); };\r\n        RootViewRef.prototype.checkNoChanges = function () { checkNoChangesInRootView(this._view); };\r\n        Object.defineProperty(RootViewRef.prototype, \"context\", {\r\n            get: function () { return null; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return RootViewRef;\r\n    }(ViewRef));\r\n    function collectNativeNodes(lView, parentTNode, result) {\r\n        var tNodeChild = parentTNode.child;\r\n        while (tNodeChild) {\r\n            var nativeNode = getNativeByTNodeOrNull(tNodeChild, lView);\r\n            nativeNode && result.push(nativeNode);\r\n            if (tNodeChild.type === 4 /* ElementContainer */) {\r\n                collectNativeNodes(lView, tNodeChild, result);\r\n            }\r\n            else if (tNodeChild.type === 1 /* Projection */) {\r\n                var componentView = findComponentView(lView);\r\n                var componentHost = componentView[T_HOST];\r\n                var parentView = getLViewParent(componentView);\r\n                var currentProjectedNode = componentHost.projection[tNodeChild.projection];\r\n                while (currentProjectedNode && parentView) {\r\n                    result.push(getNativeByTNode(currentProjectedNode, parentView));\r\n                    currentProjectedNode = currentProjectedNode.next;\r\n                }\r\n            }\r\n            tNodeChild = tNodeChild.next;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Creates an ElementRef from the most recent node.\r\n     *\r\n     * @returns The ElementRef instance to use\r\n     */\r\n    function injectElementRef(ElementRefToken) {\r\n        return createElementRef(ElementRefToken, getPreviousOrParentTNode(), getLView());\r\n    }\r\n    var R3ElementRef;\r\n    /**\r\n     * Creates an ElementRef given a node.\r\n     *\r\n     * @param ElementRefToken The ElementRef type\r\n     * @param tNode The node for which you'd like an ElementRef\r\n     * @param view The view to which the node belongs\r\n     * @returns The ElementRef instance to use\r\n     */\r\n    function createElementRef(ElementRefToken, tNode, view) {\r\n        if (!R3ElementRef) {\r\n            // TODO: Fix class name, should be ElementRef, but there appears to be a rollup bug\r\n            R3ElementRef = /** @class */ (function (_super) {\r\n                __extends(ElementRef_, _super);\r\n                function ElementRef_() {\r\n                    return _super !== null && _super.apply(this, arguments) || this;\r\n                }\r\n                return ElementRef_;\r\n            }(ElementRefToken));\r\n        }\r\n        return new R3ElementRef(getNativeByTNode(tNode, view));\r\n    }\r\n    var R3TemplateRef;\r\n    /**\r\n     * Creates a TemplateRef given a node.\r\n     *\r\n     * @returns The TemplateRef instance to use\r\n     */\r\n    function injectTemplateRef(TemplateRefToken, ElementRefToken) {\r\n        return createTemplateRef(TemplateRefToken, ElementRefToken, getPreviousOrParentTNode(), getLView());\r\n    }\r\n    /**\r\n     * Creates a TemplateRef and stores it on the injector.\r\n     *\r\n     * @param TemplateRefToken The TemplateRef type\r\n     * @param ElementRefToken The ElementRef type\r\n     * @param hostTNode The node on which a TemplateRef is requested\r\n     * @param hostView The view to which the node belongs\r\n     * @returns The TemplateRef instance or null if we can't create a TemplateRef on a given node type\r\n     */\r\n    function createTemplateRef(TemplateRefToken, ElementRefToken, hostTNode, hostView) {\r\n        if (!R3TemplateRef) {\r\n            // TODO: Fix class name, should be TemplateRef, but there appears to be a rollup bug\r\n            R3TemplateRef = /** @class */ (function (_super) {\r\n                __extends(TemplateRef_, _super);\r\n                function TemplateRef_(_declarationView, _declarationTContainer, elementRef) {\r\n                    var _this = _super.call(this) || this;\r\n                    _this._declarationView = _declarationView;\r\n                    _this._declarationTContainer = _declarationTContainer;\r\n                    _this.elementRef = elementRef;\r\n                    return _this;\r\n                }\r\n                TemplateRef_.prototype.createEmbeddedView = function (context) {\r\n                    var embeddedTView = this._declarationTContainer.tViews;\r\n                    var lView = createEmbeddedViewAndNode(embeddedTView, context, this._declarationView, this._declarationTContainer.injectorIndex);\r\n                    var declarationLContainer = this._declarationView[this._declarationTContainer.index];\r\n                    ngDevMode && assertLContainer(declarationLContainer);\r\n                    lView[DECLARATION_LCONTAINER] = declarationLContainer;\r\n                    var declarationViewLQueries = this._declarationView[QUERIES];\r\n                    if (declarationViewLQueries !== null) {\r\n                        lView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);\r\n                    }\r\n                    renderEmbeddedTemplate(lView, embeddedTView, context);\r\n                    var viewRef = new ViewRef(lView, context, -1);\r\n                    viewRef._tViewNode = lView[T_HOST];\r\n                    return viewRef;\r\n                };\r\n                return TemplateRef_;\r\n            }(TemplateRefToken));\r\n        }\r\n        if (hostTNode.type === 0 /* Container */) {\r\n            ngDevMode && assertDefined(hostTNode.tViews, 'TView must be allocated');\r\n            return new R3TemplateRef(hostView, hostTNode, createElementRef(ElementRefToken, hostTNode, hostView));\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    var R3ViewContainerRef;\r\n    /**\r\n     * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\r\n     * already exists, retrieves the existing ViewContainerRef.\r\n     *\r\n     * @returns The ViewContainerRef instance to use\r\n     */\r\n    function injectViewContainerRef(ViewContainerRefToken, ElementRefToken) {\r\n        var previousTNode = getPreviousOrParentTNode();\r\n        return createContainerRef(ViewContainerRefToken, ElementRefToken, previousTNode, getLView());\r\n    }\r\n    /**\r\n     * Creates a ViewContainerRef and stores it on the injector.\r\n     *\r\n     * @param ViewContainerRefToken The ViewContainerRef type\r\n     * @param ElementRefToken The ElementRef type\r\n     * @param hostTNode The node that is requesting a ViewContainerRef\r\n     * @param hostView The view to which the node belongs\r\n     * @returns The ViewContainerRef instance to use\r\n     */\r\n    function createContainerRef(ViewContainerRefToken, ElementRefToken, hostTNode, hostView) {\r\n        if (!R3ViewContainerRef) {\r\n            // TODO: Fix class name, should be ViewContainerRef, but there appears to be a rollup bug\r\n            R3ViewContainerRef = /** @class */ (function (_super) {\r\n                __extends(ViewContainerRef_, _super);\r\n                function ViewContainerRef_(_lContainer, _hostTNode, _hostView) {\r\n                    var _this = _super.call(this) || this;\r\n                    _this._lContainer = _lContainer;\r\n                    _this._hostTNode = _hostTNode;\r\n                    _this._hostView = _hostView;\r\n                    return _this;\r\n                }\r\n                Object.defineProperty(ViewContainerRef_.prototype, \"element\", {\r\n                    get: function () {\r\n                        return createElementRef(ElementRefToken, this._hostTNode, this._hostView);\r\n                    },\r\n                    enumerable: true,\r\n                    configurable: true\r\n                });\r\n                Object.defineProperty(ViewContainerRef_.prototype, \"injector\", {\r\n                    get: function () { return new NodeInjector(this._hostTNode, this._hostView); },\r\n                    enumerable: true,\r\n                    configurable: true\r\n                });\r\n                Object.defineProperty(ViewContainerRef_.prototype, \"parentInjector\", {\r\n                    /** @deprecated No replacement */\r\n                    get: function () {\r\n                        var parentLocation = getParentInjectorLocation(this._hostTNode, this._hostView);\r\n                        var parentView = getParentInjectorView(parentLocation, this._hostView);\r\n                        var parentTNode = getParentInjectorTNode(parentLocation, this._hostView, this._hostTNode);\r\n                        return !hasParentInjector(parentLocation) || parentTNode == null ?\r\n                            new NodeInjector(null, this._hostView) :\r\n                            new NodeInjector(parentTNode, parentView);\r\n                    },\r\n                    enumerable: true,\r\n                    configurable: true\r\n                });\r\n                ViewContainerRef_.prototype.clear = function () {\r\n                    while (this.length > 0) {\r\n                        this.remove(this.length - 1);\r\n                    }\r\n                };\r\n                ViewContainerRef_.prototype.get = function (index) {\r\n                    return this._lContainer[VIEW_REFS] !== null && this._lContainer[VIEW_REFS][index] || null;\r\n                };\r\n                Object.defineProperty(ViewContainerRef_.prototype, \"length\", {\r\n                    get: function () { return this._lContainer.length - CONTAINER_HEADER_OFFSET; },\r\n                    enumerable: true,\r\n                    configurable: true\r\n                });\r\n                ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, context, index) {\r\n                    var viewRef = templateRef.createEmbeddedView(context || {});\r\n                    this.insert(viewRef, index);\r\n                    return viewRef;\r\n                };\r\n                ViewContainerRef_.prototype.createComponent = function (componentFactory, index, injector, projectableNodes, ngModuleRef) {\r\n                    var contextInjector = injector || this.parentInjector;\r\n                    if (!ngModuleRef && componentFactory.ngModule == null && contextInjector) {\r\n                        ngModuleRef = contextInjector.get(NgModuleRef, null);\r\n                    }\r\n                    var componentRef = componentFactory.create(contextInjector, projectableNodes, undefined, ngModuleRef);\r\n                    this.insert(componentRef.hostView, index);\r\n                    return componentRef;\r\n                };\r\n                ViewContainerRef_.prototype.insert = function (viewRef, index) {\r\n                    if (viewRef.destroyed) {\r\n                        throw new Error('Cannot insert a destroyed View in a ViewContainer!');\r\n                    }\r\n                    this.allocateContainerIfNeeded();\r\n                    var lView = viewRef._lView;\r\n                    var adjustedIdx = this._adjustIndex(index);\r\n                    if (viewAttachedToContainer(lView)) {\r\n                        // If view is already attached, fall back to move() so we clean up\r\n                        // references appropriately.\r\n                        return this.move(viewRef, adjustedIdx);\r\n                    }\r\n                    insertView(lView, this._lContainer, adjustedIdx);\r\n                    var beforeNode = getBeforeNodeForView(adjustedIdx, this._lContainer);\r\n                    addRemoveViewFromContainer(lView, true, beforeNode);\r\n                    viewRef.attachToViewContainerRef(this);\r\n                    addToArray(this._lContainer[VIEW_REFS], adjustedIdx, viewRef);\r\n                    return viewRef;\r\n                };\r\n                ViewContainerRef_.prototype.move = function (viewRef, newIndex) {\r\n                    if (viewRef.destroyed) {\r\n                        throw new Error('Cannot move a destroyed View in a ViewContainer!');\r\n                    }\r\n                    var index = this.indexOf(viewRef);\r\n                    if (index !== -1)\r\n                        this.detach(index);\r\n                    this.insert(viewRef, newIndex);\r\n                    return viewRef;\r\n                };\r\n                ViewContainerRef_.prototype.indexOf = function (viewRef) {\r\n                    return this._lContainer[VIEW_REFS] !== null ?\r\n                        this._lContainer[VIEW_REFS].indexOf(viewRef) :\r\n                        0;\r\n                };\r\n                ViewContainerRef_.prototype.remove = function (index) {\r\n                    this.allocateContainerIfNeeded();\r\n                    var adjustedIdx = this._adjustIndex(index, -1);\r\n                    removeView(this._lContainer, adjustedIdx);\r\n                    removeFromArray(this._lContainer[VIEW_REFS], adjustedIdx);\r\n                };\r\n                ViewContainerRef_.prototype.detach = function (index) {\r\n                    this.allocateContainerIfNeeded();\r\n                    var adjustedIdx = this._adjustIndex(index, -1);\r\n                    var view = detachView(this._lContainer, adjustedIdx);\r\n                    var wasDetached = view && removeFromArray(this._lContainer[VIEW_REFS], adjustedIdx) != null;\r\n                    return wasDetached ? new ViewRef(view, view[CONTEXT], -1) : null;\r\n                };\r\n                ViewContainerRef_.prototype._adjustIndex = function (index, shift) {\r\n                    if (shift === void 0) { shift = 0; }\r\n                    if (index == null) {\r\n                        return this.length + shift;\r\n                    }\r\n                    if (ngDevMode) {\r\n                        assertGreaterThan(index, -1, 'index must be positive');\r\n                        // +1 because it's legal to insert at the end.\r\n                        assertLessThan(index, this.length + 1 + shift, 'index');\r\n                    }\r\n                    return index;\r\n                };\r\n                ViewContainerRef_.prototype.allocateContainerIfNeeded = function () {\r\n                    if (this._lContainer[VIEW_REFS] === null) {\r\n                        this._lContainer[VIEW_REFS] = [];\r\n                    }\r\n                };\r\n                return ViewContainerRef_;\r\n            }(ViewContainerRefToken));\r\n        }\r\n        ngDevMode && assertNodeOfPossibleTypes(hostTNode, 0 /* Container */, 3 /* Element */, 4 /* ElementContainer */);\r\n        var lContainer;\r\n        var slotValue = hostView[hostTNode.index];\r\n        if (isLContainer(slotValue)) {\r\n            // If the host is a container, we don't need to create a new LContainer\r\n            lContainer = slotValue;\r\n            lContainer[ACTIVE_INDEX] = -1;\r\n        }\r\n        else {\r\n            var commentNode = void 0;\r\n            // If the host is an element container, the native host element is guaranteed to be a\r\n            // comment and we can reuse that comment as anchor element for the new LContainer.\r\n            if (hostTNode.type === 4 /* ElementContainer */) {\r\n                commentNode = unwrapRNode(slotValue);\r\n            }\r\n            else {\r\n                ngDevMode && ngDevMode.rendererCreateComment++;\r\n                commentNode = hostView[RENDERER].createComment(ngDevMode ? 'container' : '');\r\n            }\r\n            // A container can be created on the root (topmost / bootstrapped) component and in this case we\r\n            // can't use LTree to insert container's marker node (both parent of a comment node and the\r\n            // commend node itself is located outside of elements hold by LTree). In this specific case we\r\n            // use low-level DOM manipulation to insert container's marker (comment) node.\r\n            if (isRootView(hostView)) {\r\n                var renderer = hostView[RENDERER];\r\n                var hostNative = getNativeByTNode(hostTNode, hostView);\r\n                var parentOfHostNative = nativeParentNode(renderer, hostNative);\r\n                nativeInsertBefore(renderer, parentOfHostNative, commentNode, nativeNextSibling(renderer, hostNative));\r\n            }\r\n            else {\r\n                appendChild(commentNode, hostTNode, hostView);\r\n            }\r\n            hostView[hostTNode.index] = lContainer =\r\n                createLContainer(slotValue, hostView, commentNode, hostTNode, true);\r\n            addToViewTree(hostView, lContainer);\r\n        }\r\n        return new R3ViewContainerRef(lContainer, hostTNode, hostView);\r\n    }\r\n    /** Returns a ChangeDetectorRef (a.k.a. a ViewRef) */\r\n    function injectChangeDetectorRef(isPipe) {\r\n        if (isPipe === void 0) { isPipe = false; }\r\n        return createViewRef(getPreviousOrParentTNode(), getLView(), isPipe);\r\n    }\r\n    /**\r\n     * Creates a ViewRef and stores it on the injector as ChangeDetectorRef (public alias).\r\n     *\r\n     * @param hostTNode The node that is requesting a ChangeDetectorRef\r\n     * @param hostView The view to which the node belongs\r\n     * @param isPipe Whether the view is being injected into a pipe.\r\n     * @returns The ChangeDetectorRef to use\r\n     */\r\n    function createViewRef(hostTNode, hostView, isPipe) {\r\n        if (isComponent(hostTNode) && !isPipe) {\r\n            var componentIndex = hostTNode.directiveStart;\r\n            var componentView = getComponentViewByIndex(hostTNode.index, hostView);\r\n            return new ViewRef(componentView, null, componentIndex);\r\n        }\r\n        else if (hostTNode.type === 3 /* Element */ || hostTNode.type === 0 /* Container */ ||\r\n            hostTNode.type === 4 /* ElementContainer */) {\r\n            var hostComponentView = findComponentView(hostView);\r\n            return new ViewRef(hostComponentView, hostComponentView[CONTEXT], -1);\r\n        }\r\n        return null;\r\n    }\r\n    /** Returns a Renderer2 (or throws when application was bootstrapped with Renderer3) */\r\n    function getOrCreateRenderer2(view) {\r\n        var renderer = view[RENDERER];\r\n        if (isProceduralRenderer(renderer)) {\r\n            return renderer;\r\n        }\r\n        else {\r\n            throw new Error('Cannot inject Renderer2 when the application uses Renderer3!');\r\n        }\r\n    }\r\n    /** Injects a Renderer2 for the current component. */\r\n    function injectRenderer2() {\r\n        // We need the Renderer to be based on the component that it's being injected into, however since\r\n        // DI happens before we've entered its view, `getLView` will return the parent view instead.\r\n        var lView = getLView();\r\n        var tNode = getPreviousOrParentTNode();\r\n        var nodeAtIndex = getComponentViewByIndex(tNode.index, lView);\r\n        return getOrCreateRenderer2(isLView(nodeAtIndex) ? nodeAtIndex : lView);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Base class for Angular Views, provides change detection functionality.\r\n     * A change-detection tree collects all views that are to be checked for changes.\r\n     * Use the methods to add and remove views from the tree, initiate change-detection,\r\n     * and explicitly mark views as _dirty_, meaning that they have changed and need to be rerendered.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * The following examples demonstrate how to modify default change-detection behavior\r\n     * to perform explicit detection when needed.\r\n     *\r\n     * ### Use `markForCheck()` with `CheckOnce` strategy\r\n     *\r\n     * The following example sets the `OnPush` change-detection strategy for a component\r\n     * (`CheckOnce`, rather than the default `CheckAlways`), then forces a second check\r\n     * after an interval. See [live demo](http://plnkr.co/edit/GC512b?p=preview).\r\n     *\r\n     * <code-example path=\"core/ts/change_detect/change-detection.ts\"\r\n     * region=\"mark-for-check\"></code-example>\r\n     *\r\n     * ### Detach change detector to limit how often check occurs\r\n     *\r\n     * The following example defines a component with a large list of read-only data\r\n     * that is expected to change constantly, many times per second.\r\n     * To improve performance, we want to check and update the list\r\n     * less often than the changes actually occur. To do that, we detach\r\n     * the component's change detector and perform an explicit local check every five seconds.\r\n     *\r\n     * <code-example path=\"core/ts/change_detect/change-detection.ts\" region=\"detach\"></code-example>\r\n     *\r\n     *\r\n     * ### Reattaching a detached component\r\n     *\r\n     * The following example creates a component displaying live data.\r\n     * The component detaches its change detector from the main change detector tree\r\n     * when the `live` property is set to false, and reattaches it when the property\r\n     * becomes true.\r\n     *\r\n     * <code-example path=\"core/ts/change_detect/change-detection.ts\" region=\"reattach\"></code-example>\r\n     *\r\n     * @publicApi\r\n     */\r\n    var ChangeDetectorRef = /** @class */ (function () {\r\n        function ChangeDetectorRef() {\r\n        }\r\n        /**\r\n         * @internal\r\n         * @nocollapse\r\n         */\r\n        ChangeDetectorRef.__NG_ELEMENT_ID__ = function () { return SWITCH_CHANGE_DETECTOR_REF_FACTORY(); };\r\n        return ChangeDetectorRef;\r\n    }());\r\n    var SWITCH_CHANGE_DETECTOR_REF_FACTORY__POST_R3__ = injectChangeDetectorRef;\r\n    var SWITCH_CHANGE_DETECTOR_REF_FACTORY__PRE_R3__ = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n    };\r\n    var ɵ0$6 = SWITCH_CHANGE_DETECTOR_REF_FACTORY__PRE_R3__;\r\n    var SWITCH_CHANGE_DETECTOR_REF_FACTORY = SWITCH_CHANGE_DETECTOR_REF_FACTORY__PRE_R3__;\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * @description\r\n     *\r\n     * Represents a type that a Component or other object is instances of.\r\n     *\r\n     * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by\r\n     * the `MyCustomComponent` constructor function.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var Type = Function;\r\n    function isType(v) {\r\n        return typeof v === 'function';\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Attention: These regex has to hold even if the code is minified!\r\n     */\r\n    var DELEGATE_CTOR = /^function\\s+\\S+\\(\\)\\s*{[\\s\\S]+\\.apply\\(this,\\s*arguments\\)/;\r\n    var INHERITED_CLASS = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{/;\r\n    var INHERITED_CLASS_WITH_CTOR = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(/;\r\n    var INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(\\)\\s*{\\s+super\\(\\.\\.\\.arguments\\)/;\r\n    /**\r\n     * Determine whether a stringified type is a class which delegates its constructor\r\n     * to its parent.\r\n     *\r\n     * This is not trivial since compiled code can actually contain a constructor function\r\n     * even if the original source code did not. For instance, when the child class contains\r\n     * an initialized instance property.\r\n     */\r\n    function isDelegateCtor(typeStr) {\r\n        return DELEGATE_CTOR.test(typeStr) || INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) ||\r\n            (INHERITED_CLASS.test(typeStr) && !INHERITED_CLASS_WITH_CTOR.test(typeStr));\r\n    }\r\n    var ReflectionCapabilities = /** @class */ (function () {\r\n        function ReflectionCapabilities(reflect) {\r\n            this._reflect = reflect || _global['Reflect'];\r\n        }\r\n        ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };\r\n        ReflectionCapabilities.prototype.factory = function (t) { return function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            return new (t.bind.apply(t, __spread([void 0], args)))();\r\n        }; };\r\n        /** @internal */\r\n        ReflectionCapabilities.prototype._zipTypesAndAnnotations = function (paramTypes, paramAnnotations) {\r\n            var result;\r\n            if (typeof paramTypes === 'undefined') {\r\n                result = new Array(paramAnnotations.length);\r\n            }\r\n            else {\r\n                result = new Array(paramTypes.length);\r\n            }\r\n            for (var i = 0; i < result.length; i++) {\r\n                // TS outputs Object for parameters without types, while Traceur omits\r\n                // the annotations. For now we preserve the Traceur behavior to aid\r\n                // migration, but this can be revisited.\r\n                if (typeof paramTypes === 'undefined') {\r\n                    result[i] = [];\r\n                }\r\n                else if (paramTypes[i] && paramTypes[i] != Object) {\r\n                    result[i] = [paramTypes[i]];\r\n                }\r\n                else {\r\n                    result[i] = [];\r\n                }\r\n                if (paramAnnotations && paramAnnotations[i] != null) {\r\n                    result[i] = result[i].concat(paramAnnotations[i]);\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        ReflectionCapabilities.prototype._ownParameters = function (type, parentCtor) {\r\n            var typeStr = type.toString();\r\n            // If we have no decorators, we only have function.length as metadata.\r\n            // In that case, to detect whether a child class declared an own constructor or not,\r\n            // we need to look inside of that constructor to check whether it is\r\n            // just calling the parent.\r\n            // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\r\n            // that sets 'design:paramtypes' to []\r\n            // if a class inherits from another class but has no ctor declared itself.\r\n            if (isDelegateCtor(typeStr)) {\r\n                return null;\r\n            }\r\n            // Prefer the direct API.\r\n            if (type.parameters && type.parameters !== parentCtor.parameters) {\r\n                return type.parameters;\r\n            }\r\n            // API of tsickle for lowering decorators to properties on the class.\r\n            var tsickleCtorParams = type.ctorParameters;\r\n            if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\r\n                // Newer tsickle uses a function closure\r\n                // Retain the non-function case for compatibility with older tsickle\r\n                var ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\r\n                var paramTypes_1 = ctorParameters.map(function (ctorParam) { return ctorParam && ctorParam.type; });\r\n                var paramAnnotations_1 = ctorParameters.map(function (ctorParam) {\r\n                    return ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators);\r\n                });\r\n                return this._zipTypesAndAnnotations(paramTypes_1, paramAnnotations_1);\r\n            }\r\n            // API for metadata created by invoking the decorators.\r\n            var paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];\r\n            var paramTypes = this._reflect && this._reflect.getOwnMetadata &&\r\n                this._reflect.getOwnMetadata('design:paramtypes', type);\r\n            if (paramTypes || paramAnnotations) {\r\n                return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\r\n            }\r\n            // If a class has no decorators, at least create metadata\r\n            // based on function.length.\r\n            // Note: We know that this is a real constructor as we checked\r\n            // the content of the constructor above.\r\n            return new Array(type.length).fill(undefined);\r\n        };\r\n        ReflectionCapabilities.prototype.parameters = function (type) {\r\n            // Note: only report metadata if we have at least one class decorator\r\n            // to stay in sync with the static reflector.\r\n            if (!isType(type)) {\r\n                return [];\r\n            }\r\n            var parentCtor = getParentCtor(type);\r\n            var parameters = this._ownParameters(type, parentCtor);\r\n            if (!parameters && parentCtor !== Object) {\r\n                parameters = this.parameters(parentCtor);\r\n            }\r\n            return parameters || [];\r\n        };\r\n        ReflectionCapabilities.prototype._ownAnnotations = function (typeOrFunc, parentCtor) {\r\n            // Prefer the direct API.\r\n            if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {\r\n                var annotations = typeOrFunc.annotations;\r\n                if (typeof annotations === 'function' && annotations.annotations) {\r\n                    annotations = annotations.annotations;\r\n                }\r\n                return annotations;\r\n            }\r\n            // API of tsickle for lowering decorators to properties on the class.\r\n            if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {\r\n                return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);\r\n            }\r\n            // API for metadata created by invoking the decorators.\r\n            if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {\r\n                return typeOrFunc[ANNOTATIONS];\r\n            }\r\n            return null;\r\n        };\r\n        ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {\r\n            if (!isType(typeOrFunc)) {\r\n                return [];\r\n            }\r\n            var parentCtor = getParentCtor(typeOrFunc);\r\n            var ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\r\n            var parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\r\n            return parentAnnotations.concat(ownAnnotations);\r\n        };\r\n        ReflectionCapabilities.prototype._ownPropMetadata = function (typeOrFunc, parentCtor) {\r\n            // Prefer the direct API.\r\n            if (typeOrFunc.propMetadata &&\r\n                typeOrFunc.propMetadata !== parentCtor.propMetadata) {\r\n                var propMetadata = typeOrFunc.propMetadata;\r\n                if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\r\n                    propMetadata = propMetadata.propMetadata;\r\n                }\r\n                return propMetadata;\r\n            }\r\n            // API of tsickle for lowering decorators to properties on the class.\r\n            if (typeOrFunc.propDecorators &&\r\n                typeOrFunc.propDecorators !== parentCtor.propDecorators) {\r\n                var propDecorators_1 = typeOrFunc.propDecorators;\r\n                var propMetadata_1 = {};\r\n                Object.keys(propDecorators_1).forEach(function (prop) {\r\n                    propMetadata_1[prop] = convertTsickleDecoratorIntoMetadata(propDecorators_1[prop]);\r\n                });\r\n                return propMetadata_1;\r\n            }\r\n            // API for metadata created by invoking the decorators.\r\n            if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {\r\n                return typeOrFunc[PROP_METADATA];\r\n            }\r\n            return null;\r\n        };\r\n        ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {\r\n            if (!isType(typeOrFunc)) {\r\n                return {};\r\n            }\r\n            var parentCtor = getParentCtor(typeOrFunc);\r\n            var propMetadata = {};\r\n            if (parentCtor !== Object) {\r\n                var parentPropMetadata_1 = this.propMetadata(parentCtor);\r\n                Object.keys(parentPropMetadata_1).forEach(function (propName) {\r\n                    propMetadata[propName] = parentPropMetadata_1[propName];\r\n                });\r\n            }\r\n            var ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\r\n            if (ownPropMetadata) {\r\n                Object.keys(ownPropMetadata).forEach(function (propName) {\r\n                    var decorators = [];\r\n                    if (propMetadata.hasOwnProperty(propName)) {\r\n                        decorators.push.apply(decorators, __spread(propMetadata[propName]));\r\n                    }\r\n                    decorators.push.apply(decorators, __spread(ownPropMetadata[propName]));\r\n                    propMetadata[propName] = decorators;\r\n                });\r\n            }\r\n            return propMetadata;\r\n        };\r\n        ReflectionCapabilities.prototype.ownPropMetadata = function (typeOrFunc) {\r\n            if (!isType(typeOrFunc)) {\r\n                return {};\r\n            }\r\n            return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};\r\n        };\r\n        ReflectionCapabilities.prototype.hasLifecycleHook = function (type, lcProperty) {\r\n            return type instanceof Type && lcProperty in type.prototype;\r\n        };\r\n        ReflectionCapabilities.prototype.guards = function (type) { return {}; };\r\n        ReflectionCapabilities.prototype.getter = function (name) { return new Function('o', 'return o.' + name + ';'); };\r\n        ReflectionCapabilities.prototype.setter = function (name) {\r\n            return new Function('o', 'v', 'return o.' + name + ' = v;');\r\n        };\r\n        ReflectionCapabilities.prototype.method = function (name) {\r\n            var functionBody = \"if (!o.\" + name + \") throw new Error('\\\"\" + name + \"\\\" is undefined');\\n        return o.\" + name + \".apply(o, args);\";\r\n            return new Function('o', 'args', functionBody);\r\n        };\r\n        // There is not a concept of import uri in Js, but this is useful in developing Dart applications.\r\n        ReflectionCapabilities.prototype.importUri = function (type) {\r\n            // StaticSymbol\r\n            if (typeof type === 'object' && type['filePath']) {\r\n                return type['filePath'];\r\n            }\r\n            // Runtime type\r\n            return \"./\" + stringify(type);\r\n        };\r\n        ReflectionCapabilities.prototype.resourceUri = function (type) { return \"./\" + stringify(type); };\r\n        ReflectionCapabilities.prototype.resolveIdentifier = function (name, moduleUrl, members, runtime) {\r\n            return runtime;\r\n        };\r\n        ReflectionCapabilities.prototype.resolveEnum = function (enumIdentifier, name) { return enumIdentifier[name]; };\r\n        return ReflectionCapabilities;\r\n    }());\r\n    function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {\r\n        if (!decoratorInvocations) {\r\n            return [];\r\n        }\r\n        return decoratorInvocations.map(function (decoratorInvocation) {\r\n            var decoratorType = decoratorInvocation.type;\r\n            var annotationCls = decoratorType.annotationCls;\r\n            var annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\r\n            return new (annotationCls.bind.apply(annotationCls, __spread([void 0], annotationArgs)))();\r\n        });\r\n    }\r\n    function getParentCtor(ctor) {\r\n        var parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;\r\n        var parentCtor = parentProto ? parentProto.constructor : null;\r\n        // Note: We always use `Object` as the null value\r\n        // to simplify checking later on.\r\n        return parentCtor || Object;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var _reflect = null;\r\n    function getReflect() {\r\n        return (_reflect = _reflect || new ReflectionCapabilities());\r\n    }\r\n    function reflectDependencies(type) {\r\n        return convertDependencies(getReflect().parameters(type));\r\n    }\r\n    function convertDependencies(deps) {\r\n        var compiler = getCompilerFacade();\r\n        return deps.map(function (dep) { return reflectDependency(compiler, dep); });\r\n    }\r\n    function reflectDependency(compiler, dep) {\r\n        var meta = {\r\n            token: null,\r\n            host: false,\r\n            optional: false,\r\n            resolved: compiler.R3ResolvedDependencyType.Token,\r\n            self: false,\r\n            skipSelf: false,\r\n        };\r\n        function setTokenAndResolvedType(token) {\r\n            meta.resolved = compiler.R3ResolvedDependencyType.Token;\r\n            meta.token = token;\r\n        }\r\n        if (Array.isArray(dep)) {\r\n            if (dep.length === 0) {\r\n                throw new Error('Dependency array must have arguments.');\r\n            }\r\n            for (var j = 0; j < dep.length; j++) {\r\n                var param = dep[j];\r\n                if (param === undefined) {\r\n                    // param may be undefined if type of dep is not set by ngtsc\r\n                    continue;\r\n                }\r\n                else if (param instanceof Optional || param.__proto__.ngMetadataName === 'Optional') {\r\n                    meta.optional = true;\r\n                }\r\n                else if (param instanceof SkipSelf || param.__proto__.ngMetadataName === 'SkipSelf') {\r\n                    meta.skipSelf = true;\r\n                }\r\n                else if (param instanceof Self || param.__proto__.ngMetadataName === 'Self') {\r\n                    meta.self = true;\r\n                }\r\n                else if (param instanceof Host || param.__proto__.ngMetadataName === 'Host') {\r\n                    meta.host = true;\r\n                }\r\n                else if (param instanceof Inject) {\r\n                    meta.token = param.token;\r\n                }\r\n                else if (param instanceof Attribute) {\r\n                    if (param.attributeName === undefined) {\r\n                        throw new Error(\"Attribute name must be defined.\");\r\n                    }\r\n                    meta.token = param.attributeName;\r\n                    meta.resolved = compiler.R3ResolvedDependencyType.Attribute;\r\n                }\r\n                else if (param === ChangeDetectorRef) {\r\n                    meta.token = param;\r\n                    meta.resolved = compiler.R3ResolvedDependencyType.ChangeDetectorRef;\r\n                }\r\n                else {\r\n                    setTokenAndResolvedType(param);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            setTokenAndResolvedType(dep);\r\n        }\r\n        return meta;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting\r\n     * `ngInjectableDef` onto the injectable type.\r\n     */\r\n    function compileInjectable(type, srcMeta) {\r\n        var def = null;\r\n        // if NG_INJECTABLE_DEF is already defined on this class then don't overwrite it\r\n        if (type.hasOwnProperty(NG_INJECTABLE_DEF))\r\n            return;\r\n        Object.defineProperty(type, NG_INJECTABLE_DEF, {\r\n            get: function () {\r\n                if (def === null) {\r\n                    // Allow the compilation of a class with a `@Injectable()` decorator without parameters\r\n                    var meta = srcMeta || { providedIn: null };\r\n                    var hasAProvider = isUseClassProvider(meta) || isUseFactoryProvider(meta) ||\r\n                        isUseValueProvider(meta) || isUseExistingProvider(meta);\r\n                    var compilerMeta = {\r\n                        name: type.name,\r\n                        type: type,\r\n                        typeArgumentCount: 0,\r\n                        providedIn: meta.providedIn,\r\n                        ctorDeps: reflectDependencies(type),\r\n                        userDeps: undefined,\r\n                    };\r\n                    if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== undefined) {\r\n                        compilerMeta.userDeps = convertDependencies(meta.deps);\r\n                    }\r\n                    if (!hasAProvider) {\r\n                        // In the case the user specifies a type provider, treat it as {provide: X, useClass: X}.\r\n                        // The deps will have been reflected above, causing the factory to create the class by\r\n                        // calling\r\n                        // its constructor with injected deps.\r\n                        compilerMeta.useClass = type;\r\n                    }\r\n                    else if (isUseClassProvider(meta)) {\r\n                        // The user explicitly specified useClass, and may or may not have provided deps.\r\n                        compilerMeta.useClass = meta.useClass;\r\n                    }\r\n                    else if (isUseValueProvider(meta)) {\r\n                        // The user explicitly specified useValue.\r\n                        compilerMeta.useValue = meta.useValue;\r\n                    }\r\n                    else if (isUseFactoryProvider(meta)) {\r\n                        // The user explicitly specified useFactory.\r\n                        compilerMeta.useFactory = meta.useFactory;\r\n                    }\r\n                    else if (isUseExistingProvider(meta)) {\r\n                        // The user explicitly specified useExisting.\r\n                        compilerMeta.useExisting = meta.useExisting;\r\n                    }\r\n                    else {\r\n                        // Can't happen - either hasAProvider will be false, or one of the providers will be set.\r\n                        throw new Error(\"Unreachable state.\");\r\n                    }\r\n                    def = getCompilerFacade().compileInjectable(angularCoreDiEnv, \"ng:///\" + type.name + \"/ngInjectableDef.js\", compilerMeta);\r\n                }\r\n                return def;\r\n            },\r\n        });\r\n    }\r\n    var ɵ0$7 = getClosureSafeProperty;\r\n    var USE_VALUE$1 = getClosureSafeProperty({ provide: String, useValue: ɵ0$7 });\r\n    function isUseClassProvider(meta) {\r\n        return meta.useClass !== undefined;\r\n    }\r\n    function isUseValueProvider(meta) {\r\n        return USE_VALUE$1 in meta;\r\n    }\r\n    function isUseFactoryProvider(meta) {\r\n        return meta.useFactory !== undefined;\r\n    }\r\n    function isUseExistingProvider(meta) {\r\n        return meta.useExisting !== undefined;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var ɵ0$8 = getClosureSafeProperty;\r\n    var USE_VALUE$2 = getClosureSafeProperty({ provide: String, useValue: ɵ0$8 });\r\n    var EMPTY_ARRAY$1 = [];\r\n    function convertInjectableProviderToFactory(type, provider) {\r\n        if (!provider) {\r\n            var reflectionCapabilities = new ReflectionCapabilities();\r\n            var deps_1 = reflectionCapabilities.parameters(type);\r\n            // TODO - convert to flags.\r\n            return function () { return new (type.bind.apply(type, __spread([void 0], injectArgs(deps_1))))(); };\r\n        }\r\n        if (USE_VALUE$2 in provider) {\r\n            var valueProvider_1 = provider;\r\n            return function () { return valueProvider_1.useValue; };\r\n        }\r\n        else if (provider.useExisting) {\r\n            var existingProvider_1 = provider;\r\n            return function () { return ɵɵinject(existingProvider_1.useExisting); };\r\n        }\r\n        else if (provider.useFactory) {\r\n            var factoryProvider_1 = provider;\r\n            return function () { return factoryProvider_1.useFactory.apply(factoryProvider_1, __spread(injectArgs(factoryProvider_1.deps || EMPTY_ARRAY$1))); };\r\n        }\r\n        else if (provider.useClass) {\r\n            var classProvider_1 = provider;\r\n            var deps_2 = provider.deps;\r\n            if (!deps_2) {\r\n                var reflectionCapabilities = new ReflectionCapabilities();\r\n                deps_2 = reflectionCapabilities.parameters(type);\r\n            }\r\n            return function () {\r\n                var _a;\r\n                return new ((_a = classProvider_1.useClass).bind.apply(_a, __spread([void 0], injectArgs(deps_2))))();\r\n            };\r\n        }\r\n        else {\r\n            var deps_3 = provider.deps;\r\n            if (!deps_3) {\r\n                var reflectionCapabilities = new ReflectionCapabilities();\r\n                deps_3 = reflectionCapabilities.parameters(type);\r\n            }\r\n            return function () { return new (type.bind.apply(type, __spread([void 0], injectArgs(deps_3))))(); };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var ɵ0$9 = function (type, meta) { return SWITCH_COMPILE_INJECTABLE(type, meta); };\r\n    /**\r\n     * Injectable decorator and metadata.\r\n     *\r\n     * @Annotation\r\n     * @publicApi\r\n     */\r\n    var Injectable = makeDecorator('Injectable', undefined, undefined, undefined, ɵ0$9);\r\n    /**\r\n     * Supports @Injectable() in JIT mode for Render2.\r\n     */\r\n    function render2CompileInjectable(injectableType, options) {\r\n        if (options && options.providedIn !== undefined && !getInjectableDef(injectableType)) {\r\n            injectableType.ngInjectableDef = ɵɵdefineInjectable({\r\n                token: injectableType,\r\n                providedIn: options.providedIn,\r\n                factory: convertInjectableProviderToFactory(injectableType, options),\r\n            });\r\n        }\r\n    }\r\n    var SWITCH_COMPILE_INJECTABLE__POST_R3__ = compileInjectable;\r\n    var SWITCH_COMPILE_INJECTABLE__PRE_R3__ = render2CompileInjectable;\r\n    var SWITCH_COMPILE_INJECTABLE = SWITCH_COMPILE_INJECTABLE__PRE_R3__;\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * An internal token whose presence in an injector indicates that the injector should treat itself\r\n     * as a root scoped injector when processing requests for unknown tokens which may indicate\r\n     * they are provided in the root scope.\r\n     */\r\n    var APP_ROOT = new InjectionToken('The presence of this token marks an injector as being the root injector.');\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Marker which indicates that a value has not yet been created from the factory function.\r\n     */\r\n    var NOT_YET = {};\r\n    /**\r\n     * Marker which indicates that the factory function for a token is in the process of being called.\r\n     *\r\n     * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\r\n     * injection of a dependency has recursively attempted to inject the original token, and there is\r\n     * a circular dependency among the providers.\r\n     */\r\n    var CIRCULAR = {};\r\n    var EMPTY_ARRAY$2 = [];\r\n    /**\r\n     * A lazily initialized NullInjector.\r\n     */\r\n    var NULL_INJECTOR = undefined;\r\n    function getNullInjector() {\r\n        if (NULL_INJECTOR === undefined) {\r\n            NULL_INJECTOR = new NullInjector();\r\n        }\r\n        return NULL_INJECTOR;\r\n    }\r\n    /**\r\n     * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function createInjector(defType, parent, additionalProviders, name) {\r\n        if (parent === void 0) { parent = null; }\r\n        if (additionalProviders === void 0) { additionalProviders = null; }\r\n        parent = parent || getNullInjector();\r\n        return new R3Injector(defType, additionalProviders, parent, name);\r\n    }\r\n    var R3Injector = /** @class */ (function () {\r\n        function R3Injector(def, additionalProviders, parent, source) {\r\n            var _this = this;\r\n            if (source === void 0) { source = null; }\r\n            this.parent = parent;\r\n            /**\r\n             * Map of tokens to records which contain the instances of those tokens.\r\n             */\r\n            this.records = new Map();\r\n            /**\r\n             * The transitive set of `InjectorType`s which define this injector.\r\n             */\r\n            this.injectorDefTypes = new Set();\r\n            /**\r\n             * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\r\n             */\r\n            this.onDestroy = new Set();\r\n            this._destroyed = false;\r\n            // Start off by creating Records for every provider declared in every InjectorType\r\n            // included transitively in `def`.\r\n            var dedupStack = [];\r\n            deepForEach([def], function (injectorDef) { return _this.processInjectorType(injectorDef, [], dedupStack); });\r\n            additionalProviders && deepForEach(additionalProviders, function (provider) { return _this.processProvider(provider, def, additionalProviders); });\r\n            // Make sure the INJECTOR token provides this injector.\r\n            this.records.set(INJECTOR, makeRecord(undefined, this));\r\n            // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\r\n            // any injectable scoped to APP_ROOT_SCOPE.\r\n            this.isRootInjector = this.records.has(APP_ROOT);\r\n            // Eagerly instantiate the InjectorType classes themselves.\r\n            this.injectorDefTypes.forEach(function (defType) { return _this.get(defType); });\r\n            // Source name, used for debugging\r\n            this.source = source || (typeof def === 'object' ? null : stringify(def));\r\n        }\r\n        Object.defineProperty(R3Injector.prototype, \"destroyed\", {\r\n            /**\r\n             * Flag indicating that this injector was previously destroyed.\r\n             */\r\n            get: function () { return this._destroyed; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * Destroy the injector and release references to every instance or provider associated with it.\r\n         *\r\n         * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\r\n         * hook was found.\r\n         */\r\n        R3Injector.prototype.destroy = function () {\r\n            this.assertNotDestroyed();\r\n            // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\r\n            this._destroyed = true;\r\n            try {\r\n                // Call all the lifecycle hooks.\r\n                this.onDestroy.forEach(function (service) { return service.ngOnDestroy(); });\r\n            }\r\n            finally {\r\n                // Release all references.\r\n                this.records.clear();\r\n                this.onDestroy.clear();\r\n                this.injectorDefTypes.clear();\r\n            }\r\n        };\r\n        R3Injector.prototype.get = function (token, notFoundValue, flags) {\r\n            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }\r\n            if (flags === void 0) { flags = exports.InjectFlags.Default; }\r\n            this.assertNotDestroyed();\r\n            // Set the injection context.\r\n            var previousInjector = setCurrentInjector(this);\r\n            try {\r\n                // Check for the SkipSelf flag.\r\n                if (!(flags & exports.InjectFlags.SkipSelf)) {\r\n                    // SkipSelf isn't set, check if the record belongs to this injector.\r\n                    var record = this.records.get(token);\r\n                    if (record === undefined) {\r\n                        // No record, but maybe the token is scoped to this injector. Look for an ngInjectableDef\r\n                        // with a scope matching this injector.\r\n                        var def = couldBeInjectableType(token) && getInjectableDef(token);\r\n                        if (def && this.injectableDefInScope(def)) {\r\n                            // Found an ngInjectableDef and it's scoped to this injector. Pretend as if it was here\r\n                            // all along.\r\n                            record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);\r\n                            this.records.set(token, record);\r\n                        }\r\n                    }\r\n                    // If a record was found, get the instance for it and return it.\r\n                    if (record !== undefined) {\r\n                        return this.hydrate(token, record);\r\n                    }\r\n                }\r\n                // Select the next injector based on the Self flag - if self is set, the next injector is\r\n                // the NullInjector, otherwise it's the parent.\r\n                var nextInjector = !(flags & exports.InjectFlags.Self) ? this.parent : getNullInjector();\r\n                return nextInjector.get(token, flags & exports.InjectFlags.Optional ? null : notFoundValue);\r\n            }\r\n            catch (e) {\r\n                if (e.name === 'NullInjectorError') {\r\n                    var path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\r\n                    path.unshift(stringify(token));\r\n                    if (previousInjector) {\r\n                        // We still have a parent injector, keep throwing\r\n                        throw e;\r\n                    }\r\n                    else {\r\n                        // Format & throw the final error message when we don't have any previous injector\r\n                        return catchInjectorError(e, token, 'R3InjectorError', this.source);\r\n                    }\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n            finally {\r\n                // Lastly, clean up the state by restoring the previous injector.\r\n                setCurrentInjector(previousInjector);\r\n            }\r\n        };\r\n        R3Injector.prototype.toString = function () {\r\n            var tokens = [], records = this.records;\r\n            records.forEach(function (v, token) { return tokens.push(stringify(token)); });\r\n            return \"R3Injector[\" + tokens.join(', ') + \"]\";\r\n        };\r\n        R3Injector.prototype.assertNotDestroyed = function () {\r\n            if (this._destroyed) {\r\n                throw new Error('Injector has already been destroyed.');\r\n            }\r\n        };\r\n        /**\r\n         * Add an `InjectorType` or `InjectorTypeWithProviders` and all of its transitive providers\r\n         * to this injector.\r\n         *\r\n         * If an `InjectorTypeWithProviders` that declares providers besides the type is specified,\r\n         * the function will return \"true\" to indicate that the providers of the type definition need\r\n         * to be processed. This allows us to process providers of injector types after all imports of\r\n         * an injector definition are processed. (following View Engine semantics: see FW-1349)\r\n         */\r\n        R3Injector.prototype.processInjectorType = function (defOrWrappedDef, parents, dedupStack) {\r\n            var _this = this;\r\n            defOrWrappedDef = resolveForwardRef(defOrWrappedDef);\r\n            if (!defOrWrappedDef)\r\n                return false;\r\n            // Either the defOrWrappedDef is an InjectorType (with ngInjectorDef) or an\r\n            // InjectorDefTypeWithProviders (aka ModuleWithProviders). Detecting either is a megamorphic\r\n            // read, so care is taken to only do the read once.\r\n            // First attempt to read the ngInjectorDef.\r\n            var def = getInjectorDef(defOrWrappedDef);\r\n            // If that's not present, then attempt to read ngModule from the InjectorDefTypeWithProviders.\r\n            var ngModule = (def == null) && defOrWrappedDef.ngModule || undefined;\r\n            // Determine the InjectorType. In the case where `defOrWrappedDef` is an `InjectorType`,\r\n            // then this is easy. In the case of an InjectorDefTypeWithProviders, then the definition type\r\n            // is the `ngModule`.\r\n            var defType = (ngModule === undefined) ? defOrWrappedDef : ngModule;\r\n            // Check for circular dependencies.\r\n            if (ngDevMode && parents.indexOf(defType) !== -1) {\r\n                var defName = stringify(defType);\r\n                throw new Error(\"Circular dependency in DI detected for type \" + defName + \". Dependency path: \" + parents.map(function (defType) { return stringify(defType); }).join(' > ') + \" > \" + defName + \".\");\r\n            }\r\n            // Check for multiple imports of the same module\r\n            var isDuplicate = dedupStack.indexOf(defType) !== -1;\r\n            // Finally, if defOrWrappedType was an `InjectorDefTypeWithProviders`, then the actual\r\n            // `InjectorDef` is on its `ngModule`.\r\n            if (ngModule !== undefined) {\r\n                def = getInjectorDef(ngModule);\r\n            }\r\n            // If no definition was found, it might be from exports. Remove it.\r\n            if (def == null) {\r\n                return false;\r\n            }\r\n            // Track the InjectorType and add a provider for it.\r\n            this.injectorDefTypes.add(defType);\r\n            this.records.set(defType, makeRecord(def.factory, NOT_YET));\r\n            // Add providers in the same way that @NgModule resolution did:\r\n            // First, include providers from any imports.\r\n            if (def.imports != null && !isDuplicate) {\r\n                // Before processing defType's imports, add it to the set of parents. This way, if it ends\r\n                // up deeply importing itself, this can be detected.\r\n                ngDevMode && parents.push(defType);\r\n                // Add it to the set of dedups. This way we can detect multiple imports of the same module\r\n                dedupStack.push(defType);\r\n                var importTypesWithProviders_1;\r\n                try {\r\n                    deepForEach(def.imports, function (imported) {\r\n                        if (_this.processInjectorType(imported, parents, dedupStack)) {\r\n                            if (importTypesWithProviders_1 === undefined)\r\n                                importTypesWithProviders_1 = [];\r\n                            // If the processed import is an injector type with providers, we store it in the\r\n                            // list of import types with providers, so that we can process those afterwards.\r\n                            importTypesWithProviders_1.push(imported);\r\n                        }\r\n                    });\r\n                }\r\n                finally {\r\n                    // Remove it from the parents set when finished.\r\n                    ngDevMode && parents.pop();\r\n                }\r\n                // Imports which are declared with providers (TypeWithProviders) need to be processed\r\n                // after all imported modules are processed. This is similar to how View Engine\r\n                // processes/merges module imports in the metadata resolver. See: FW-1349.\r\n                if (importTypesWithProviders_1 !== undefined) {\r\n                    var _loop_1 = function (i) {\r\n                        var _a = importTypesWithProviders_1[i], ngModule_1 = _a.ngModule, providers = _a.providers;\r\n                        deepForEach(providers, function (provider) { return _this.processProvider(provider, ngModule_1, providers || EMPTY_ARRAY$2); });\r\n                    };\r\n                    for (var i = 0; i < importTypesWithProviders_1.length; i++) {\r\n                        _loop_1(i);\r\n                    }\r\n                }\r\n            }\r\n            // Next, include providers listed on the definition itself.\r\n            var defProviders = def.providers;\r\n            if (defProviders != null && !isDuplicate) {\r\n                var injectorType_1 = defOrWrappedDef;\r\n                deepForEach(defProviders, function (provider) { return _this.processProvider(provider, injectorType_1, defProviders); });\r\n            }\r\n            return (ngModule !== undefined &&\r\n                defOrWrappedDef.providers !== undefined);\r\n        };\r\n        /**\r\n         * Process a `SingleProvider` and add it.\r\n         */\r\n        R3Injector.prototype.processProvider = function (provider, ngModuleType, providers) {\r\n            // Determine the token from the provider. Either it's its own token, or has a {provide: ...}\r\n            // property.\r\n            provider = resolveForwardRef(provider);\r\n            var token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);\r\n            // Construct a `Record` for the provider.\r\n            var record = providerToRecord(provider, ngModuleType, providers);\r\n            if (!isTypeProvider(provider) && provider.multi === true) {\r\n                // If the provider indicates that it's a multi-provider, process it specially.\r\n                // First check whether it's been defined already.\r\n                var multiRecord_1 = this.records.get(token);\r\n                if (multiRecord_1) {\r\n                    // It has. Throw a nice error if\r\n                    if (multiRecord_1.multi === undefined) {\r\n                        throwMixedMultiProviderError();\r\n                    }\r\n                }\r\n                else {\r\n                    multiRecord_1 = makeRecord(undefined, NOT_YET, true);\r\n                    multiRecord_1.factory = function () { return injectArgs(multiRecord_1.multi); };\r\n                    this.records.set(token, multiRecord_1);\r\n                }\r\n                token = provider;\r\n                multiRecord_1.multi.push(provider);\r\n            }\r\n            else {\r\n                var existing = this.records.get(token);\r\n                if (existing && existing.multi !== undefined) {\r\n                    throwMixedMultiProviderError();\r\n                }\r\n            }\r\n            this.records.set(token, record);\r\n        };\r\n        R3Injector.prototype.hydrate = function (token, record) {\r\n            if (record.value === CIRCULAR) {\r\n                throwCyclicDependencyError(stringify(token));\r\n            }\r\n            else if (record.value === NOT_YET) {\r\n                record.value = CIRCULAR;\r\n                record.value = record.factory();\r\n            }\r\n            if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\r\n                this.onDestroy.add(record.value);\r\n            }\r\n            return record.value;\r\n        };\r\n        R3Injector.prototype.injectableDefInScope = function (def) {\r\n            if (!def.providedIn) {\r\n                return false;\r\n            }\r\n            else if (typeof def.providedIn === 'string') {\r\n                return def.providedIn === 'any' || (def.providedIn === 'root' && this.isRootInjector);\r\n            }\r\n            else {\r\n                return this.injectorDefTypes.has(def.providedIn);\r\n            }\r\n        };\r\n        return R3Injector;\r\n    }());\r\n    function injectableDefOrInjectorDefFactory(token) {\r\n        // Most tokens will have an ngInjectableDef directly on them, which specifies a factory directly.\r\n        var injectableDef = getInjectableDef(token);\r\n        if (injectableDef !== null) {\r\n            return injectableDef.factory;\r\n        }\r\n        // If the token is an NgModule, it's also injectable but the factory is on its ngInjectorDef.\r\n        var injectorDef = getInjectorDef(token);\r\n        if (injectorDef !== null) {\r\n            return injectorDef.factory;\r\n        }\r\n        // InjectionTokens should have an ngInjectableDef and thus should be handled above.\r\n        // If it's missing that, it's an error.\r\n        if (token instanceof InjectionToken) {\r\n            throw new Error(\"Token \" + stringify(token) + \" is missing an ngInjectableDef definition.\");\r\n        }\r\n        // Undecorated types can sometimes be created if they have no constructor arguments.\r\n        if (token instanceof Function) {\r\n            return getUndecoratedInjectableFactory(token);\r\n        }\r\n        // There was no way to resolve a factory for this token.\r\n        throw new Error('unreachable');\r\n    }\r\n    function getUndecoratedInjectableFactory(token) {\r\n        // If the token has parameters then it has dependencies that we cannot resolve implicitly.\r\n        var paramLength = token.length;\r\n        if (paramLength > 0) {\r\n            var args = new Array(paramLength).fill('?');\r\n            throw new Error(\"Can't resolve all parameters for \" + stringify(token) + \": (\" + args.join(', ') + \").\");\r\n        }\r\n        // The constructor function appears to have no parameters.\r\n        // This might be because it inherits from a super-class. In which case, use an ngInjectableDef\r\n        // from an ancestor if there is one.\r\n        // Otherwise this really is a simple class with no dependencies, so return a factory that\r\n        // just instantiates the zero-arg constructor.\r\n        var inheritedInjectableDef = getInheritedInjectableDef(token);\r\n        if (inheritedInjectableDef !== null) {\r\n            return function () { return inheritedInjectableDef.factory(token); };\r\n        }\r\n        else {\r\n            return function () { return new token(); };\r\n        }\r\n    }\r\n    function providerToRecord(provider, ngModuleType, providers) {\r\n        var factory = providerToFactory(provider, ngModuleType, providers);\r\n        if (isValueProvider(provider)) {\r\n            return makeRecord(undefined, provider.useValue);\r\n        }\r\n        else {\r\n            return makeRecord(factory, NOT_YET);\r\n        }\r\n    }\r\n    /**\r\n     * Converts a `SingleProvider` into a factory function.\r\n     *\r\n     * @param provider provider to convert to factory\r\n     */\r\n    function providerToFactory(provider, ngModuleType, providers) {\r\n        var factory = undefined;\r\n        if (isTypeProvider(provider)) {\r\n            return injectableDefOrInjectorDefFactory(resolveForwardRef(provider));\r\n        }\r\n        else {\r\n            if (isValueProvider(provider)) {\r\n                factory = function () { return resolveForwardRef(provider.useValue); };\r\n            }\r\n            else if (isExistingProvider(provider)) {\r\n                factory = function () { return ɵɵinject(resolveForwardRef(provider.useExisting)); };\r\n            }\r\n            else if (isFactoryProvider(provider)) {\r\n                factory = function () { return provider.useFactory.apply(provider, __spread(injectArgs(provider.deps || []))); };\r\n            }\r\n            else {\r\n                var classRef_1 = resolveForwardRef(provider &&\r\n                    (provider.useClass || provider.provide));\r\n                if (!classRef_1) {\r\n                    throwInvalidProviderError(ngModuleType, providers, provider);\r\n                }\r\n                if (hasDeps(provider)) {\r\n                    factory = function () { return new ((classRef_1).bind.apply((classRef_1), __spread([void 0], injectArgs(provider.deps))))(); };\r\n                }\r\n                else {\r\n                    return injectableDefOrInjectorDefFactory(classRef_1);\r\n                }\r\n            }\r\n        }\r\n        return factory;\r\n    }\r\n    function makeRecord(factory, value, multi) {\r\n        if (multi === void 0) { multi = false; }\r\n        return {\r\n            factory: factory,\r\n            value: value,\r\n            multi: multi ? [] : undefined,\r\n        };\r\n    }\r\n    function isValueProvider(value) {\r\n        return value !== null && typeof value == 'object' && USE_VALUE in value;\r\n    }\r\n    function isExistingProvider(value) {\r\n        return !!(value && value.useExisting);\r\n    }\r\n    function isFactoryProvider(value) {\r\n        return !!(value && value.useFactory);\r\n    }\r\n    function isTypeProvider(value) {\r\n        return typeof value === 'function';\r\n    }\r\n    function isClassProvider(value) {\r\n        return !!value.useClass;\r\n    }\r\n    function hasDeps(value) {\r\n        return !!value.deps;\r\n    }\r\n    function hasOnDestroy(value) {\r\n        return value !== null && typeof value === 'object' &&\r\n            typeof value.ngOnDestroy === 'function';\r\n    }\r\n    function couldBeInjectableType(value) {\r\n        return (typeof value === 'function') ||\r\n            (typeof value === 'object' && value instanceof InjectionToken);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function INJECTOR_IMPL__PRE_R3__(providers, parent, name) {\r\n        return new StaticInjector(providers, parent, name);\r\n    }\r\n    function INJECTOR_IMPL__POST_R3__(providers, parent, name) {\r\n        return createInjector({ name: name }, parent, providers, name);\r\n    }\r\n    var INJECTOR_IMPL = INJECTOR_IMPL__PRE_R3__;\r\n    /**\r\n     * Concrete injectors implement this interface.\r\n     *\r\n     * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * {@example core/di/ts/injector_spec.ts region='Injector'}\r\n     *\r\n     * `Injector` returns itself when given `Injector` as a token:\r\n     *\r\n     * {@example core/di/ts/injector_spec.ts region='injectInjector'}\r\n     *\r\n     * @publicApi\r\n     */\r\n    var Injector = /** @class */ (function () {\r\n        function Injector() {\r\n        }\r\n        /**\r\n         * Create a new Injector which is configure using `StaticProvider`s.\r\n         *\r\n         * @usageNotes\r\n         * ### Example\r\n         *\r\n         * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\r\n         */\r\n        Injector.create = function (options, parent) {\r\n            if (Array.isArray(options)) {\r\n                return INJECTOR_IMPL(options, parent, '');\r\n            }\r\n            else {\r\n                return INJECTOR_IMPL(options.providers, options.parent, options.name || '');\r\n            }\r\n        };\r\n        Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;\r\n        Injector.NULL = new NullInjector();\r\n        /** @nocollapse */\r\n        Injector.ngInjectableDef = ɵɵdefineInjectable({\r\n            token: Injector,\r\n            providedIn: 'any',\r\n            factory: function () { return ɵɵinject(INJECTOR); },\r\n        });\r\n        /**\r\n         * @internal\r\n         * @nocollapse\r\n         */\r\n        Injector.__NG_ELEMENT_ID__ = -1;\r\n        return Injector;\r\n    }());\r\n    var IDENT = function (value) {\r\n        return value;\r\n    };\r\n    var ɵ0$a = IDENT;\r\n    var EMPTY = [];\r\n    var CIRCULAR$1 = IDENT;\r\n    var MULTI_PROVIDER_FN = function () {\r\n        return Array.prototype.slice.call(arguments);\r\n    };\r\n    var ɵ1$2 = MULTI_PROVIDER_FN;\r\n    var NO_NEW_LINE$1 = 'ɵ';\r\n    var StaticInjector = /** @class */ (function () {\r\n        function StaticInjector(providers, parent, source) {\r\n            if (parent === void 0) { parent = Injector.NULL; }\r\n            if (source === void 0) { source = null; }\r\n            this.parent = parent;\r\n            this.source = source;\r\n            var records = this._records = new Map();\r\n            records.set(Injector, { token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false });\r\n            records.set(INJECTOR, { token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false });\r\n            recursivelyProcessProviders(records, providers);\r\n        }\r\n        StaticInjector.prototype.get = function (token, notFoundValue, flags) {\r\n            if (flags === void 0) { flags = exports.InjectFlags.Default; }\r\n            var record = this._records.get(token);\r\n            try {\r\n                return tryResolveToken(token, record, this._records, this.parent, notFoundValue, flags);\r\n            }\r\n            catch (e) {\r\n                return catchInjectorError(e, token, 'StaticInjectorError', this.source);\r\n            }\r\n        };\r\n        StaticInjector.prototype.toString = function () {\r\n            var tokens = [], records = this._records;\r\n            records.forEach(function (v, token) { return tokens.push(stringify(token)); });\r\n            return \"StaticInjector[\" + tokens.join(', ') + \"]\";\r\n        };\r\n        return StaticInjector;\r\n    }());\r\n    function resolveProvider(provider) {\r\n        var deps = computeDeps(provider);\r\n        var fn = IDENT;\r\n        var value = EMPTY;\r\n        var useNew = false;\r\n        var provide = resolveForwardRef(provider.provide);\r\n        if (USE_VALUE in provider) {\r\n            // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.\r\n            value = provider.useValue;\r\n        }\r\n        else if (provider.useFactory) {\r\n            fn = provider.useFactory;\r\n        }\r\n        else if (provider.useExisting) {\r\n            // Just use IDENT\r\n        }\r\n        else if (provider.useClass) {\r\n            useNew = true;\r\n            fn = resolveForwardRef(provider.useClass);\r\n        }\r\n        else if (typeof provide == 'function') {\r\n            useNew = true;\r\n            fn = provide;\r\n        }\r\n        else {\r\n            throw staticError('StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable', provider);\r\n        }\r\n        return { deps: deps, fn: fn, useNew: useNew, value: value };\r\n    }\r\n    function multiProviderMixError(token) {\r\n        return staticError('Cannot mix multi providers and regular providers', token);\r\n    }\r\n    function recursivelyProcessProviders(records, provider) {\r\n        if (provider) {\r\n            provider = resolveForwardRef(provider);\r\n            if (provider instanceof Array) {\r\n                // if we have an array recurse into the array\r\n                for (var i = 0; i < provider.length; i++) {\r\n                    recursivelyProcessProviders(records, provider[i]);\r\n                }\r\n            }\r\n            else if (typeof provider === 'function') {\r\n                // Functions were supported in ReflectiveInjector, but are not here. For safety give useful\r\n                // error messages\r\n                throw staticError('Function/Class not supported', provider);\r\n            }\r\n            else if (provider && typeof provider === 'object' && provider.provide) {\r\n                // At this point we have what looks like a provider: {provide: ?, ....}\r\n                var token = resolveForwardRef(provider.provide);\r\n                var resolvedProvider = resolveProvider(provider);\r\n                if (provider.multi === true) {\r\n                    // This is a multi provider.\r\n                    var multiProvider = records.get(token);\r\n                    if (multiProvider) {\r\n                        if (multiProvider.fn !== MULTI_PROVIDER_FN) {\r\n                            throw multiProviderMixError(token);\r\n                        }\r\n                    }\r\n                    else {\r\n                        // Create a placeholder factory which will look up the constituents of the multi provider.\r\n                        records.set(token, multiProvider = {\r\n                            token: provider.provide,\r\n                            deps: [],\r\n                            useNew: false,\r\n                            fn: MULTI_PROVIDER_FN,\r\n                            value: EMPTY\r\n                        });\r\n                    }\r\n                    // Treat the provider as the token.\r\n                    token = provider;\r\n                    multiProvider.deps.push({ token: token, options: 6 /* Default */ });\r\n                }\r\n                var record = records.get(token);\r\n                if (record && record.fn == MULTI_PROVIDER_FN) {\r\n                    throw multiProviderMixError(token);\r\n                }\r\n                records.set(token, resolvedProvider);\r\n            }\r\n            else {\r\n                throw staticError('Unexpected provider', provider);\r\n            }\r\n        }\r\n    }\r\n    function tryResolveToken(token, record, records, parent, notFoundValue, flags) {\r\n        try {\r\n            return resolveToken(token, record, records, parent, notFoundValue, flags);\r\n        }\r\n        catch (e) {\r\n            // ensure that 'e' is of type Error.\r\n            if (!(e instanceof Error)) {\r\n                e = new Error(e);\r\n            }\r\n            var path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\r\n            path.unshift(token);\r\n            if (record && record.value == CIRCULAR$1) {\r\n                // Reset the Circular flag.\r\n                record.value = EMPTY;\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n    function resolveToken(token, record, records, parent, notFoundValue, flags) {\r\n        var _a;\r\n        var value;\r\n        if (record && !(flags & exports.InjectFlags.SkipSelf)) {\r\n            // If we don't have a record, this implies that we don't own the provider hence don't know how\r\n            // to resolve it.\r\n            value = record.value;\r\n            if (value == CIRCULAR$1) {\r\n                throw Error(NO_NEW_LINE$1 + 'Circular dependency');\r\n            }\r\n            else if (value === EMPTY) {\r\n                record.value = CIRCULAR$1;\r\n                var obj = undefined;\r\n                var useNew = record.useNew;\r\n                var fn = record.fn;\r\n                var depRecords = record.deps;\r\n                var deps = EMPTY;\r\n                if (depRecords.length) {\r\n                    deps = [];\r\n                    for (var i = 0; i < depRecords.length; i++) {\r\n                        var depRecord = depRecords[i];\r\n                        var options = depRecord.options;\r\n                        var childRecord = options & 2 /* CheckSelf */ ? records.get(depRecord.token) : undefined;\r\n                        deps.push(tryResolveToken(\r\n                        // Current Token to resolve\r\n                        depRecord.token, \r\n                        // A record which describes how to resolve the token.\r\n                        // If undefined, this means we don't have such a record\r\n                        childRecord, \r\n                        // Other records we know about.\r\n                        records, \r\n                        // If we don't know how to resolve dependency and we should not check parent for it,\r\n                        // than pass in Null injector.\r\n                        !childRecord && !(options & 4 /* CheckParent */) ? Injector.NULL : parent, options & 1 /* Optional */ ? null : Injector.THROW_IF_NOT_FOUND, exports.InjectFlags.Default));\r\n                    }\r\n                }\r\n                record.value = value = useNew ? new ((_a = fn).bind.apply(_a, __spread([void 0], deps)))() : fn.apply(obj, deps);\r\n            }\r\n        }\r\n        else if (!(flags & exports.InjectFlags.Self)) {\r\n            value = parent.get(token, notFoundValue, exports.InjectFlags.Default);\r\n        }\r\n        return value;\r\n    }\r\n    function computeDeps(provider) {\r\n        var deps = EMPTY;\r\n        var providerDeps = provider.deps;\r\n        if (providerDeps && providerDeps.length) {\r\n            deps = [];\r\n            for (var i = 0; i < providerDeps.length; i++) {\r\n                var options = 6 /* Default */;\r\n                var token = resolveForwardRef(providerDeps[i]);\r\n                if (token instanceof Array) {\r\n                    for (var j = 0, annotations = token; j < annotations.length; j++) {\r\n                        var annotation = annotations[j];\r\n                        if (annotation instanceof Optional || annotation == Optional) {\r\n                            options = options | 1 /* Optional */;\r\n                        }\r\n                        else if (annotation instanceof SkipSelf || annotation == SkipSelf) {\r\n                            options = options & ~2 /* CheckSelf */;\r\n                        }\r\n                        else if (annotation instanceof Self || annotation == Self) {\r\n                            options = options & ~4 /* CheckParent */;\r\n                        }\r\n                        else if (annotation instanceof Inject) {\r\n                            token = annotation.token;\r\n                        }\r\n                        else {\r\n                            token = resolveForwardRef(annotation);\r\n                        }\r\n                    }\r\n                }\r\n                deps.push({ token: token, options: options });\r\n            }\r\n        }\r\n        else if (provider.useExisting) {\r\n            var token = resolveForwardRef(provider.useExisting);\r\n            deps = [{ token: token, options: 6 /* Default */ }];\r\n        }\r\n        else if (!providerDeps && !(USE_VALUE in provider)) {\r\n            // useValue & useExisting are the only ones which are exempt from deps all others need it.\r\n            throw staticError('\\'deps\\' required', provider);\r\n        }\r\n        return deps;\r\n    }\r\n    function staticError(text, obj) {\r\n        return new Error(formatError(text, obj, 'StaticInjectorError'));\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function findFirstClosedCycle(keys) {\r\n        var res = [];\r\n        for (var i = 0; i < keys.length; ++i) {\r\n            if (res.indexOf(keys[i]) > -1) {\r\n                res.push(keys[i]);\r\n                return res;\r\n            }\r\n            res.push(keys[i]);\r\n        }\r\n        return res;\r\n    }\r\n    function constructResolvingPath(keys) {\r\n        if (keys.length > 1) {\r\n            var reversed = findFirstClosedCycle(keys.slice().reverse());\r\n            var tokenStrs = reversed.map(function (k) { return stringify(k.token); });\r\n            return ' (' + tokenStrs.join(' -> ') + ')';\r\n        }\r\n        return '';\r\n    }\r\n    function injectionError(injector, key, constructResolvingMessage, originalError) {\r\n        var keys = [key];\r\n        var errMsg = constructResolvingMessage(keys);\r\n        var error = (originalError ? wrappedError(errMsg, originalError) : Error(errMsg));\r\n        error.addKey = addKey;\r\n        error.keys = keys;\r\n        error.injectors = [injector];\r\n        error.constructResolvingMessage = constructResolvingMessage;\r\n        error[ERROR_ORIGINAL_ERROR] = originalError;\r\n        return error;\r\n    }\r\n    function addKey(injector, key) {\r\n        this.injectors.push(injector);\r\n        this.keys.push(key);\r\n        // Note: This updated message won't be reflected in the `.stack` property\r\n        this.message = this.constructResolvingMessage(this.keys);\r\n    }\r\n    /**\r\n     * Thrown when trying to retrieve a dependency by key from {@link Injector}, but the\r\n     * {@link Injector} does not have a {@link Provider} for the given key.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * class A {\r\n     *   constructor(b:B) {}\r\n     * }\r\n     *\r\n     * expect(() => Injector.resolveAndCreate([A])).toThrowError();\r\n     * ```\r\n     */\r\n    function noProviderError(injector, key) {\r\n        return injectionError(injector, key, function (keys) {\r\n            var first = stringify(keys[0].token);\r\n            return \"No provider for \" + first + \"!\" + constructResolvingPath(keys);\r\n        });\r\n    }\r\n    /**\r\n     * Thrown when dependencies form a cycle.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * var injector = Injector.resolveAndCreate([\r\n     *   {provide: \"one\", useFactory: (two) => \"two\", deps: [[new Inject(\"two\")]]},\r\n     *   {provide: \"two\", useFactory: (one) => \"one\", deps: [[new Inject(\"one\")]]}\r\n     * ]);\r\n     *\r\n     * expect(() => injector.get(\"one\")).toThrowError();\r\n     * ```\r\n     *\r\n     * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.\r\n     */\r\n    function cyclicDependencyError(injector, key) {\r\n        return injectionError(injector, key, function (keys) {\r\n            return \"Cannot instantiate cyclic dependency!\" + constructResolvingPath(keys);\r\n        });\r\n    }\r\n    /**\r\n     * Thrown when a constructing type returns with an Error.\r\n     *\r\n     * The `InstantiationError` class contains the original error plus the dependency graph which caused\r\n     * this object to be instantiated.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * class A {\r\n     *   constructor() {\r\n     *     throw new Error('message');\r\n     *   }\r\n     * }\r\n     *\r\n     * var injector = Injector.resolveAndCreate([A]);\r\n\r\n     * try {\r\n     *   injector.get(A);\r\n     * } catch (e) {\r\n     *   expect(e instanceof InstantiationError).toBe(true);\r\n     *   expect(e.originalException.message).toEqual(\"message\");\r\n     *   expect(e.originalStack).toBeDefined();\r\n     * }\r\n     * ```\r\n     */\r\n    function instantiationError(injector, originalException, originalStack, key) {\r\n        return injectionError(injector, key, function (keys) {\r\n            var first = stringify(keys[0].token);\r\n            return originalException.message + \": Error during instantiation of \" + first + \"!\" + constructResolvingPath(keys) + \".\";\r\n        }, originalException);\r\n    }\r\n    /**\r\n     * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}\r\n     * creation.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * expect(() => Injector.resolveAndCreate([\"not a type\"])).toThrowError();\r\n     * ```\r\n     */\r\n    function invalidProviderError(provider) {\r\n        return Error(\"Invalid provider - only instances of Provider and Type are allowed, got: \" + provider);\r\n    }\r\n    /**\r\n     * Thrown when the class has no annotation information.\r\n     *\r\n     * Lack of annotation information prevents the {@link Injector} from determining which dependencies\r\n     * need to be injected into the constructor.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * class A {\r\n     *   constructor(b) {}\r\n     * }\r\n     *\r\n     * expect(() => Injector.resolveAndCreate([A])).toThrowError();\r\n     * ```\r\n     *\r\n     * This error is also thrown when the class not marked with {@link Injectable} has parameter types.\r\n     *\r\n     * ```typescript\r\n     * class B {}\r\n     *\r\n     * class A {\r\n     *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.\r\n     * }\r\n     *\r\n     * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();\r\n     * ```\r\n     *\r\n     */\r\n    function noAnnotationError(typeOrFunc, params) {\r\n        var signature = [];\r\n        for (var i = 0, ii = params.length; i < ii; i++) {\r\n            var parameter = params[i];\r\n            if (!parameter || parameter.length == 0) {\r\n                signature.push('?');\r\n            }\r\n            else {\r\n                signature.push(parameter.map(stringify).join(' '));\r\n            }\r\n        }\r\n        return Error('Cannot resolve all parameters for \\'' + stringify(typeOrFunc) + '\\'(' +\r\n            signature.join(', ') + '). ' +\r\n            'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \\'' +\r\n            stringify(typeOrFunc) + '\\' is decorated with Injectable.');\r\n    }\r\n    /**\r\n     * Thrown when getting an object by index.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * class A {}\r\n     *\r\n     * var injector = Injector.resolveAndCreate([A]);\r\n     *\r\n     * expect(() => injector.getAt(100)).toThrowError();\r\n     * ```\r\n     *\r\n     */\r\n    function outOfBoundsError(index) {\r\n        return Error(\"Index \" + index + \" is out-of-bounds.\");\r\n    }\r\n    // TODO: add a working example after alpha38 is released\r\n    /**\r\n     * Thrown when a multi provider and a regular provider are bound to the same token.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * expect(() => Injector.resolveAndCreate([\r\n     *   { provide: \"Strings\", useValue: \"string1\", multi: true},\r\n     *   { provide: \"Strings\", useValue: \"string2\", multi: false}\r\n     * ])).toThrowError();\r\n     * ```\r\n     */\r\n    function mixingMultiProvidersWithRegularProvidersError(provider1, provider2) {\r\n        return Error(\"Cannot mix multi providers and regular providers, got: \" + provider1 + \" \" + provider2);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * A unique object used for retrieving items from the {@link ReflectiveInjector}.\r\n     *\r\n     * Keys have:\r\n     * - a system-wide unique `id`.\r\n     * - a `token`.\r\n     *\r\n     * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows\r\n     * the\r\n     * injector to store created objects in a more efficient way.\r\n     *\r\n     * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when\r\n     * resolving\r\n     * providers.\r\n     *\r\n     * @deprecated No replacement\r\n     * @publicApi\r\n     */\r\n    var ReflectiveKey = /** @class */ (function () {\r\n        /**\r\n         * Private\r\n         */\r\n        function ReflectiveKey(token, id) {\r\n            this.token = token;\r\n            this.id = id;\r\n            if (!token) {\r\n                throw new Error('Token must be defined!');\r\n            }\r\n            this.displayName = stringify(this.token);\r\n        }\r\n        /**\r\n         * Retrieves a `Key` for a token.\r\n         */\r\n        ReflectiveKey.get = function (token) {\r\n            return _globalKeyRegistry.get(resolveForwardRef(token));\r\n        };\r\n        Object.defineProperty(ReflectiveKey, \"numberOfKeys\", {\r\n            /**\r\n             * @returns the number of keys registered in the system.\r\n             */\r\n            get: function () { return _globalKeyRegistry.numberOfKeys; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return ReflectiveKey;\r\n    }());\r\n    var KeyRegistry = /** @class */ (function () {\r\n        function KeyRegistry() {\r\n            this._allKeys = new Map();\r\n        }\r\n        KeyRegistry.prototype.get = function (token) {\r\n            if (token instanceof ReflectiveKey)\r\n                return token;\r\n            if (this._allKeys.has(token)) {\r\n                return this._allKeys.get(token);\r\n            }\r\n            var newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);\r\n            this._allKeys.set(token, newKey);\r\n            return newKey;\r\n        };\r\n        Object.defineProperty(KeyRegistry.prototype, \"numberOfKeys\", {\r\n            get: function () { return this._allKeys.size; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return KeyRegistry;\r\n    }());\r\n    var _globalKeyRegistry = new KeyRegistry();\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Provides access to reflection data about symbols. Used internally by Angular\r\n     * to power dependency injection and compilation.\r\n     */\r\n    var Reflector = /** @class */ (function () {\r\n        function Reflector(reflectionCapabilities) {\r\n            this.reflectionCapabilities = reflectionCapabilities;\r\n        }\r\n        Reflector.prototype.updateCapabilities = function (caps) { this.reflectionCapabilities = caps; };\r\n        Reflector.prototype.factory = function (type) { return this.reflectionCapabilities.factory(type); };\r\n        Reflector.prototype.parameters = function (typeOrFunc) {\r\n            return this.reflectionCapabilities.parameters(typeOrFunc);\r\n        };\r\n        Reflector.prototype.annotations = function (typeOrFunc) {\r\n            return this.reflectionCapabilities.annotations(typeOrFunc);\r\n        };\r\n        Reflector.prototype.propMetadata = function (typeOrFunc) {\r\n            return this.reflectionCapabilities.propMetadata(typeOrFunc);\r\n        };\r\n        Reflector.prototype.hasLifecycleHook = function (type, lcProperty) {\r\n            return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);\r\n        };\r\n        Reflector.prototype.getter = function (name) { return this.reflectionCapabilities.getter(name); };\r\n        Reflector.prototype.setter = function (name) { return this.reflectionCapabilities.setter(name); };\r\n        Reflector.prototype.method = function (name) { return this.reflectionCapabilities.method(name); };\r\n        Reflector.prototype.importUri = function (type) { return this.reflectionCapabilities.importUri(type); };\r\n        Reflector.prototype.resourceUri = function (type) { return this.reflectionCapabilities.resourceUri(type); };\r\n        Reflector.prototype.resolveIdentifier = function (name, moduleUrl, members, runtime) {\r\n            return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, members, runtime);\r\n        };\r\n        Reflector.prototype.resolveEnum = function (identifier, name) {\r\n            return this.reflectionCapabilities.resolveEnum(identifier, name);\r\n        };\r\n        return Reflector;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * The {@link Reflector} used internally in Angular to access metadata\r\n     * about symbols.\r\n     */\r\n    var reflector = new Reflector(new ReflectionCapabilities());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * `Dependency` is used by the framework to extend DI.\r\n     * This is internal to Angular and should not be used directly.\r\n     */\r\n    var ReflectiveDependency = /** @class */ (function () {\r\n        function ReflectiveDependency(key, optional, visibility) {\r\n            this.key = key;\r\n            this.optional = optional;\r\n            this.visibility = visibility;\r\n        }\r\n        ReflectiveDependency.fromKey = function (key) {\r\n            return new ReflectiveDependency(key, false, null);\r\n        };\r\n        return ReflectiveDependency;\r\n    }());\r\n    var _EMPTY_LIST = [];\r\n    var ResolvedReflectiveProvider_ = /** @class */ (function () {\r\n        function ResolvedReflectiveProvider_(key, resolvedFactories, multiProvider) {\r\n            this.key = key;\r\n            this.resolvedFactories = resolvedFactories;\r\n            this.multiProvider = multiProvider;\r\n            this.resolvedFactory = this.resolvedFactories[0];\r\n        }\r\n        return ResolvedReflectiveProvider_;\r\n    }());\r\n    /**\r\n     * An internal resolved representation of a factory function created by resolving `Provider`.\r\n     * @publicApi\r\n     */\r\n    var ResolvedReflectiveFactory = /** @class */ (function () {\r\n        function ResolvedReflectiveFactory(\r\n        /**\r\n         * Factory function which can return an instance of an object represented by a key.\r\n         */\r\n        factory, \r\n        /**\r\n         * Arguments (dependencies) to the `factory` function.\r\n         */\r\n        dependencies) {\r\n            this.factory = factory;\r\n            this.dependencies = dependencies;\r\n        }\r\n        return ResolvedReflectiveFactory;\r\n    }());\r\n    /**\r\n     * Resolve a single provider.\r\n     */\r\n    function resolveReflectiveFactory(provider) {\r\n        var factoryFn;\r\n        var resolvedDeps;\r\n        if (provider.useClass) {\r\n            var useClass = resolveForwardRef(provider.useClass);\r\n            factoryFn = reflector.factory(useClass);\r\n            resolvedDeps = _dependenciesFor(useClass);\r\n        }\r\n        else if (provider.useExisting) {\r\n            factoryFn = function (aliasInstance) { return aliasInstance; };\r\n            resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];\r\n        }\r\n        else if (provider.useFactory) {\r\n            factoryFn = provider.useFactory;\r\n            resolvedDeps = constructDependencies(provider.useFactory, provider.deps);\r\n        }\r\n        else {\r\n            factoryFn = function () { return provider.useValue; };\r\n            resolvedDeps = _EMPTY_LIST;\r\n        }\r\n        return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);\r\n    }\r\n    /**\r\n     * Converts the `Provider` into `ResolvedProvider`.\r\n     *\r\n     * `Injector` internally only uses `ResolvedProvider`, `Provider` contains convenience provider\r\n     * syntax.\r\n     */\r\n    function resolveReflectiveProvider(provider) {\r\n        return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi || false);\r\n    }\r\n    /**\r\n     * Resolve a list of Providers.\r\n     */\r\n    function resolveReflectiveProviders(providers) {\r\n        var normalized = _normalizeProviders(providers, []);\r\n        var resolved = normalized.map(resolveReflectiveProvider);\r\n        var resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());\r\n        return Array.from(resolvedProviderMap.values());\r\n    }\r\n    /**\r\n     * Merges a list of ResolvedProviders into a list where each key is contained exactly once and\r\n     * multi providers have been merged.\r\n     */\r\n    function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {\r\n        for (var i = 0; i < providers.length; i++) {\r\n            var provider = providers[i];\r\n            var existing = normalizedProvidersMap.get(provider.key.id);\r\n            if (existing) {\r\n                if (provider.multiProvider !== existing.multiProvider) {\r\n                    throw mixingMultiProvidersWithRegularProvidersError(existing, provider);\r\n                }\r\n                if (provider.multiProvider) {\r\n                    for (var j = 0; j < provider.resolvedFactories.length; j++) {\r\n                        existing.resolvedFactories.push(provider.resolvedFactories[j]);\r\n                    }\r\n                }\r\n                else {\r\n                    normalizedProvidersMap.set(provider.key.id, provider);\r\n                }\r\n            }\r\n            else {\r\n                var resolvedProvider = void 0;\r\n                if (provider.multiProvider) {\r\n                    resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);\r\n                }\r\n                else {\r\n                    resolvedProvider = provider;\r\n                }\r\n                normalizedProvidersMap.set(provider.key.id, resolvedProvider);\r\n            }\r\n        }\r\n        return normalizedProvidersMap;\r\n    }\r\n    function _normalizeProviders(providers, res) {\r\n        providers.forEach(function (b) {\r\n            if (b instanceof Type) {\r\n                res.push({ provide: b, useClass: b });\r\n            }\r\n            else if (b && typeof b == 'object' && b.provide !== undefined) {\r\n                res.push(b);\r\n            }\r\n            else if (b instanceof Array) {\r\n                _normalizeProviders(b, res);\r\n            }\r\n            else {\r\n                throw invalidProviderError(b);\r\n            }\r\n        });\r\n        return res;\r\n    }\r\n    function constructDependencies(typeOrFunc, dependencies) {\r\n        if (!dependencies) {\r\n            return _dependenciesFor(typeOrFunc);\r\n        }\r\n        else {\r\n            var params_1 = dependencies.map(function (t) { return [t]; });\r\n            return dependencies.map(function (t) { return _extractToken(typeOrFunc, t, params_1); });\r\n        }\r\n    }\r\n    function _dependenciesFor(typeOrFunc) {\r\n        var params = reflector.parameters(typeOrFunc);\r\n        if (!params)\r\n            return [];\r\n        if (params.some(function (p) { return p == null; })) {\r\n            throw noAnnotationError(typeOrFunc, params);\r\n        }\r\n        return params.map(function (p) { return _extractToken(typeOrFunc, p, params); });\r\n    }\r\n    function _extractToken(typeOrFunc, metadata, params) {\r\n        var token = null;\r\n        var optional = false;\r\n        if (!Array.isArray(metadata)) {\r\n            if (metadata instanceof Inject) {\r\n                return _createDependency(metadata.token, optional, null);\r\n            }\r\n            else {\r\n                return _createDependency(metadata, optional, null);\r\n            }\r\n        }\r\n        var visibility = null;\r\n        for (var i = 0; i < metadata.length; ++i) {\r\n            var paramMetadata = metadata[i];\r\n            if (paramMetadata instanceof Type) {\r\n                token = paramMetadata;\r\n            }\r\n            else if (paramMetadata instanceof Inject) {\r\n                token = paramMetadata.token;\r\n            }\r\n            else if (paramMetadata instanceof Optional) {\r\n                optional = true;\r\n            }\r\n            else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {\r\n                visibility = paramMetadata;\r\n            }\r\n            else if (paramMetadata instanceof InjectionToken) {\r\n                token = paramMetadata;\r\n            }\r\n        }\r\n        token = resolveForwardRef(token);\r\n        if (token != null) {\r\n            return _createDependency(token, optional, visibility);\r\n        }\r\n        else {\r\n            throw noAnnotationError(typeOrFunc, params);\r\n        }\r\n    }\r\n    function _createDependency(token, optional, visibility) {\r\n        return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    // Threshold for the dynamic version\r\n    var UNDEFINED = new Object();\r\n    /**\r\n     * A ReflectiveDependency injection container used for instantiating objects and resolving\r\n     * dependencies.\r\n     *\r\n     * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\r\n     * constructor dependencies.\r\n     *\r\n     * In typical use, application code asks for the dependencies in the constructor and they are\r\n     * resolved by the `Injector`.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * The following example creates an `Injector` configured to create `Engine` and `Car`.\r\n     *\r\n     * ```typescript\r\n     * @Injectable()\r\n     * class Engine {\r\n     * }\r\n     *\r\n     * @Injectable()\r\n     * class Car {\r\n     *   constructor(public engine:Engine) {}\r\n     * }\r\n     *\r\n     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\r\n     * var car = injector.get(Car);\r\n     * expect(car instanceof Car).toBe(true);\r\n     * expect(car.engine instanceof Engine).toBe(true);\r\n     * ```\r\n     *\r\n     * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\r\n     * resolve all of the object's dependencies automatically.\r\n     *\r\n     * @deprecated from v5 - slow and brings in a lot of code, Use `Injector.create` instead.\r\n     * @publicApi\r\n     */\r\n    var ReflectiveInjector = /** @class */ (function () {\r\n        function ReflectiveInjector() {\r\n        }\r\n        /**\r\n         * Turns an array of provider definitions into an array of resolved providers.\r\n         *\r\n         * A resolution is a process of flattening multiple nested arrays and converting individual\r\n         * providers into an array of `ResolvedReflectiveProvider`s.\r\n         *\r\n         * @usageNotes\r\n         * ### Example\r\n         *\r\n         * ```typescript\r\n         * @Injectable()\r\n         * class Engine {\r\n         * }\r\n         *\r\n         * @Injectable()\r\n         * class Car {\r\n         *   constructor(public engine:Engine) {}\r\n         * }\r\n         *\r\n         * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\r\n         *\r\n         * expect(providers.length).toEqual(2);\r\n         *\r\n         * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\r\n         * expect(providers[0].key.displayName).toBe(\"Car\");\r\n         * expect(providers[0].dependencies.length).toEqual(1);\r\n         * expect(providers[0].factory).toBeDefined();\r\n         *\r\n         * expect(providers[1].key.displayName).toBe(\"Engine\");\r\n         * });\r\n         * ```\r\n         *\r\n         */\r\n        ReflectiveInjector.resolve = function (providers) {\r\n            return resolveReflectiveProviders(providers);\r\n        };\r\n        /**\r\n         * Resolves an array of providers and creates an injector from those providers.\r\n         *\r\n         * The passed-in providers can be an array of `Type`, `Provider`,\r\n         * or a recursive array of more providers.\r\n         *\r\n         * @usageNotes\r\n         * ### Example\r\n         *\r\n         * ```typescript\r\n         * @Injectable()\r\n         * class Engine {\r\n         * }\r\n         *\r\n         * @Injectable()\r\n         * class Car {\r\n         *   constructor(public engine:Engine) {}\r\n         * }\r\n         *\r\n         * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\r\n         * expect(injector.get(Car) instanceof Car).toBe(true);\r\n         * ```\r\n         */\r\n        ReflectiveInjector.resolveAndCreate = function (providers, parent) {\r\n            var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\r\n            return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);\r\n        };\r\n        /**\r\n         * Creates an injector from previously resolved providers.\r\n         *\r\n         * This API is the recommended way to construct injectors in performance-sensitive parts.\r\n         *\r\n         * @usageNotes\r\n         * ### Example\r\n         *\r\n         * ```typescript\r\n         * @Injectable()\r\n         * class Engine {\r\n         * }\r\n         *\r\n         * @Injectable()\r\n         * class Car {\r\n         *   constructor(public engine:Engine) {}\r\n         * }\r\n         *\r\n         * var providers = ReflectiveInjector.resolve([Car, Engine]);\r\n         * var injector = ReflectiveInjector.fromResolvedProviders(providers);\r\n         * expect(injector.get(Car) instanceof Car).toBe(true);\r\n         * ```\r\n         */\r\n        ReflectiveInjector.fromResolvedProviders = function (providers, parent) {\r\n            return new ReflectiveInjector_(providers, parent);\r\n        };\r\n        return ReflectiveInjector;\r\n    }());\r\n    var ReflectiveInjector_ = /** @class */ (function () {\r\n        /**\r\n         * Private\r\n         */\r\n        function ReflectiveInjector_(_providers, _parent) {\r\n            /** @internal */\r\n            this._constructionCounter = 0;\r\n            this._providers = _providers;\r\n            this.parent = _parent || null;\r\n            var len = _providers.length;\r\n            this.keyIds = new Array(len);\r\n            this.objs = new Array(len);\r\n            for (var i = 0; i < len; i++) {\r\n                this.keyIds[i] = _providers[i].key.id;\r\n                this.objs[i] = UNDEFINED;\r\n            }\r\n        }\r\n        ReflectiveInjector_.prototype.get = function (token, notFoundValue) {\r\n            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }\r\n            return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);\r\n        };\r\n        ReflectiveInjector_.prototype.resolveAndCreateChild = function (providers) {\r\n            var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\r\n            return this.createChildFromResolved(ResolvedReflectiveProviders);\r\n        };\r\n        ReflectiveInjector_.prototype.createChildFromResolved = function (providers) {\r\n            var inj = new ReflectiveInjector_(providers);\r\n            inj.parent = this;\r\n            return inj;\r\n        };\r\n        ReflectiveInjector_.prototype.resolveAndInstantiate = function (provider) {\r\n            return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);\r\n        };\r\n        ReflectiveInjector_.prototype.instantiateResolved = function (provider) {\r\n            return this._instantiateProvider(provider);\r\n        };\r\n        ReflectiveInjector_.prototype.getProviderAtIndex = function (index) {\r\n            if (index < 0 || index >= this._providers.length) {\r\n                throw outOfBoundsError(index);\r\n            }\r\n            return this._providers[index];\r\n        };\r\n        /** @internal */\r\n        ReflectiveInjector_.prototype._new = function (provider) {\r\n            if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {\r\n                throw cyclicDependencyError(this, provider.key);\r\n            }\r\n            return this._instantiateProvider(provider);\r\n        };\r\n        ReflectiveInjector_.prototype._getMaxNumberOfObjects = function () { return this.objs.length; };\r\n        ReflectiveInjector_.prototype._instantiateProvider = function (provider) {\r\n            if (provider.multiProvider) {\r\n                var res = new Array(provider.resolvedFactories.length);\r\n                for (var i = 0; i < provider.resolvedFactories.length; ++i) {\r\n                    res[i] = this._instantiate(provider, provider.resolvedFactories[i]);\r\n                }\r\n                return res;\r\n            }\r\n            else {\r\n                return this._instantiate(provider, provider.resolvedFactories[0]);\r\n            }\r\n        };\r\n        ReflectiveInjector_.prototype._instantiate = function (provider, ResolvedReflectiveFactory) {\r\n            var _this = this;\r\n            var factory = ResolvedReflectiveFactory.factory;\r\n            var deps;\r\n            try {\r\n                deps =\r\n                    ResolvedReflectiveFactory.dependencies.map(function (dep) { return _this._getByReflectiveDependency(dep); });\r\n            }\r\n            catch (e) {\r\n                if (e.addKey) {\r\n                    e.addKey(this, provider.key);\r\n                }\r\n                throw e;\r\n            }\r\n            var obj;\r\n            try {\r\n                obj = factory.apply(void 0, __spread(deps));\r\n            }\r\n            catch (e) {\r\n                throw instantiationError(this, e, e.stack, provider.key);\r\n            }\r\n            return obj;\r\n        };\r\n        ReflectiveInjector_.prototype._getByReflectiveDependency = function (dep) {\r\n            return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);\r\n        };\r\n        ReflectiveInjector_.prototype._getByKey = function (key, visibility, notFoundValue) {\r\n            if (key === ReflectiveInjector_.INJECTOR_KEY) {\r\n                return this;\r\n            }\r\n            if (visibility instanceof Self) {\r\n                return this._getByKeySelf(key, notFoundValue);\r\n            }\r\n            else {\r\n                return this._getByKeyDefault(key, notFoundValue, visibility);\r\n            }\r\n        };\r\n        ReflectiveInjector_.prototype._getObjByKeyId = function (keyId) {\r\n            for (var i = 0; i < this.keyIds.length; i++) {\r\n                if (this.keyIds[i] === keyId) {\r\n                    if (this.objs[i] === UNDEFINED) {\r\n                        this.objs[i] = this._new(this._providers[i]);\r\n                    }\r\n                    return this.objs[i];\r\n                }\r\n            }\r\n            return UNDEFINED;\r\n        };\r\n        /** @internal */\r\n        ReflectiveInjector_.prototype._throwOrNull = function (key, notFoundValue) {\r\n            if (notFoundValue !== THROW_IF_NOT_FOUND) {\r\n                return notFoundValue;\r\n            }\r\n            else {\r\n                throw noProviderError(this, key);\r\n            }\r\n        };\r\n        /** @internal */\r\n        ReflectiveInjector_.prototype._getByKeySelf = function (key, notFoundValue) {\r\n            var obj = this._getObjByKeyId(key.id);\r\n            return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);\r\n        };\r\n        /** @internal */\r\n        ReflectiveInjector_.prototype._getByKeyDefault = function (key, notFoundValue, visibility) {\r\n            var inj;\r\n            if (visibility instanceof SkipSelf) {\r\n                inj = this.parent;\r\n            }\r\n            else {\r\n                inj = this;\r\n            }\r\n            while (inj instanceof ReflectiveInjector_) {\r\n                var inj_ = inj;\r\n                var obj = inj_._getObjByKeyId(key.id);\r\n                if (obj !== UNDEFINED)\r\n                    return obj;\r\n                inj = inj_.parent;\r\n            }\r\n            if (inj !== null) {\r\n                return inj.get(key.token, notFoundValue);\r\n            }\r\n            else {\r\n                return this._throwOrNull(key, notFoundValue);\r\n            }\r\n        };\r\n        Object.defineProperty(ReflectiveInjector_.prototype, \"displayName\", {\r\n            get: function () {\r\n                var providers = _mapProviders(this, function (b) { return ' \"' + b.key.displayName + '\" '; })\r\n                    .join(', ');\r\n                return \"ReflectiveInjector(providers: [\" + providers + \"])\";\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        ReflectiveInjector_.prototype.toString = function () { return this.displayName; };\r\n        ReflectiveInjector_.INJECTOR_KEY = ReflectiveKey.get(Injector);\r\n        return ReflectiveInjector_;\r\n    }());\r\n    function _mapProviders(injector, fn) {\r\n        var res = new Array(injector._providers.length);\r\n        for (var i = 0; i < injector._providers.length; ++i) {\r\n            res[i] = fn(injector.getProviderAtIndex(i));\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * A DI token that you can use to create a virtual [provider](guide/glossary#provider)\r\n     * that will populate the `entryComponents` field of components and NgModules\r\n     * based on its `useValue` property value.\r\n     * All components that are referenced in the `useValue` value (either directly\r\n     * or in a nested array or map) are added to the `entryComponents` property.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * The following example shows how the router can populate the `entryComponents`\r\n     * field of an NgModule based on a router configuration that refers\r\n     * to components.\r\n     *\r\n     * ```typescript\r\n     * // helper function inside the router\r\n     * function provideRoutes(routes) {\r\n     *   return [\r\n     *     {provide: ROUTES, useValue: routes},\r\n     *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}\r\n     *   ];\r\n     * }\r\n     *\r\n     * // user code\r\n     * let routes = [\r\n     *   {path: '/root', component: RootComp},\r\n     *   {path: '/teams', component: TeamsComp}\r\n     * ];\r\n     *\r\n     * @NgModule({\r\n     *   providers: [provideRoutes(routes)]\r\n     * })\r\n     * class ModuleWithRoutes {}\r\n     * ```\r\n     *\r\n     * @publicApi\r\n     */\r\n    var ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken('AnalyzeForEntryComponents');\r\n    /**\r\n     * Base class for query metadata.\r\n     *\r\n     * @see `ContentChildren`.\r\n     * @see `ContentChild`.\r\n     * @see `ViewChildren`.\r\n     * @see `ViewChild`.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var Query = /** @class */ (function () {\r\n        function Query() {\r\n        }\r\n        return Query;\r\n    }());\r\n    var ɵ0$b = function (selector, data) {\r\n        if (data === void 0) { data = {}; }\r\n        return (__assign({ selector: selector, first: false, isViewQuery: false, descendants: false }, data));\r\n    };\r\n    /**\r\n     * ContentChildren decorator and metadata.\r\n     *\r\n     *\r\n     * @Annotation\r\n     * @publicApi\r\n     */\r\n    var ContentChildren = makePropDecorator('ContentChildren', ɵ0$b, Query);\r\n    var ɵ1$3 = function (selector, data) {\r\n        if (data === void 0) { data = {}; }\r\n        return (__assign({ selector: selector, first: true, isViewQuery: false, descendants: true }, data));\r\n    };\r\n    /**\r\n     * ContentChild decorator and metadata.\r\n     *\r\n     *\r\n     * @Annotation\r\n     *\r\n     * @publicApi\r\n     */\r\n    var ContentChild = makePropDecorator('ContentChild', ɵ1$3, Query);\r\n    var ɵ2 = function (selector, data) {\r\n        if (data === void 0) { data = {}; }\r\n        return (__assign({ selector: selector, first: false, isViewQuery: true, descendants: true }, data));\r\n    };\r\n    /**\r\n     * ViewChildren decorator and metadata.\r\n     *\r\n     * @Annotation\r\n     * @publicApi\r\n     */\r\n    var ViewChildren = makePropDecorator('ViewChildren', ɵ2, Query);\r\n    var ɵ3 = function (selector, data) {\r\n        return (__assign({ selector: selector, first: true, isViewQuery: true, descendants: true }, data));\r\n    };\r\n    /**\r\n     * ViewChild decorator and metadata.\r\n     *\r\n     * @Annotation\r\n     * @publicApi\r\n     */\r\n    var ViewChild = makePropDecorator('ViewChild', ɵ3, Query);\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Used to resolve resource URLs on `@Component` when used with JIT compilation.\r\n     *\r\n     * Example:\r\n     * ```\r\n     * @Component({\r\n     *   selector: 'my-comp',\r\n     *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\r\n     * })\r\n     * class MyComponent{\r\n     * }\r\n     *\r\n     * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process\r\n     * // and `MyComponent`'s `@Component.templateUrl` needs to be resolved asynchronously.\r\n     *\r\n     * // Calling `resolveComponentResources()` will resolve `@Component.templateUrl` into\r\n     * // `@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.\r\n     *\r\n     * // Use browser's `fetch()` function as the default resource resolution strategy.\r\n     * resolveComponentResources(fetch).then(() => {\r\n     *   // After resolution all URLs have been converted into `template` strings.\r\n     *   renderComponent(MyComponent);\r\n     * });\r\n     *\r\n     * ```\r\n     *\r\n     * NOTE: In AOT the resolution happens during compilation, and so there should be no need\r\n     * to call this method outside JIT mode.\r\n     *\r\n     * @param resourceResolver a function which is responsible for returning a `Promise` to the\r\n     * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.\r\n     */\r\n    function resolveComponentResources(resourceResolver) {\r\n        // Store all promises which are fetching the resources.\r\n        var componentResolved = [];\r\n        // Cache so that we don't fetch the same resource more than once.\r\n        var urlMap = new Map();\r\n        function cachedResourceResolve(url) {\r\n            var promise = urlMap.get(url);\r\n            if (!promise) {\r\n                var resp = resourceResolver(url);\r\n                urlMap.set(url, promise = resp.then(unwrapResponse));\r\n            }\r\n            return promise;\r\n        }\r\n        componentResourceResolutionQueue.forEach(function (component, type) {\r\n            var promises = [];\r\n            if (component.templateUrl) {\r\n                promises.push(cachedResourceResolve(component.templateUrl).then(function (template) {\r\n                    component.template = template;\r\n                }));\r\n            }\r\n            var styleUrls = component.styleUrls;\r\n            var styles = component.styles || (component.styles = []);\r\n            var styleOffset = component.styles.length;\r\n            styleUrls && styleUrls.forEach(function (styleUrl, index) {\r\n                styles.push(''); // pre-allocate array.\r\n                promises.push(cachedResourceResolve(styleUrl).then(function (style) {\r\n                    styles[styleOffset + index] = style;\r\n                    styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\r\n                    if (styleUrls.length == 0) {\r\n                        component.styleUrls = undefined;\r\n                    }\r\n                }));\r\n            });\r\n            var fullyResolved = Promise.all(promises).then(function () { return componentDefResolved(type); });\r\n            componentResolved.push(fullyResolved);\r\n        });\r\n        clearResolutionOfComponentResourcesQueue();\r\n        return Promise.all(componentResolved).then(function () { return undefined; });\r\n    }\r\n    var componentResourceResolutionQueue = new Map();\r\n    // Track when existing ngComponentDef for a Type is waiting on resources.\r\n    var componentDefPendingResolution = new Set();\r\n    function maybeQueueResolutionOfComponentResources(type, metadata) {\r\n        if (componentNeedsResolution(metadata)) {\r\n            componentResourceResolutionQueue.set(type, metadata);\r\n            componentDefPendingResolution.add(type);\r\n        }\r\n    }\r\n    function isComponentDefPendingResolution(type) {\r\n        return componentDefPendingResolution.has(type);\r\n    }\r\n    function componentNeedsResolution(component) {\r\n        return !!((component.templateUrl && !component.hasOwnProperty('template')) ||\r\n            component.styleUrls && component.styleUrls.length);\r\n    }\r\n    function clearResolutionOfComponentResourcesQueue() {\r\n        var old = componentResourceResolutionQueue;\r\n        componentResourceResolutionQueue = new Map();\r\n        return old;\r\n    }\r\n    function restoreComponentResolutionQueue(queue) {\r\n        componentDefPendingResolution.clear();\r\n        queue.forEach(function (_, type) { return componentDefPendingResolution.add(type); });\r\n        componentResourceResolutionQueue = queue;\r\n    }\r\n    function isComponentResourceResolutionQueueEmpty() {\r\n        return componentResourceResolutionQueue.size === 0;\r\n    }\r\n    function unwrapResponse(response) {\r\n        return typeof response == 'string' ? response : response.text();\r\n    }\r\n    function componentDefResolved(type) {\r\n        componentDefPendingResolution.delete(type);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Allocates the necessary amount of slots for host vars.\r\n     *\r\n     * @param count Amount of vars to be allocated\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵallocHostVars(count) {\r\n        var lView = getLView();\r\n        var tView = lView[TVIEW];\r\n        if (!tView.firstTemplatePass)\r\n            return;\r\n        queueHostBindingForCheck(tView, getCurrentDirectiveDef(), count);\r\n        prefillHostVars(tView, lView, count);\r\n    }\r\n    /**\r\n     * Stores host binding fn and number of host vars so it will be queued for binding refresh during\r\n     * CD.\r\n     */\r\n    function queueHostBindingForCheck(tView, def, hostVars) {\r\n        ngDevMode &&\r\n            assertEqual(tView.firstTemplatePass, true, 'Should only be called in first template pass.');\r\n        var expando = tView.expandoInstructions;\r\n        var length = expando.length;\r\n        // Check whether a given `hostBindings` function already exists in expandoInstructions,\r\n        // which can happen in case directive definition was extended from base definition (as a part of\r\n        // the `InheritDefinitionFeature` logic). If we found the same `hostBindings` function in the\r\n        // list, we just increase the number of host vars associated with that function, but do not add it\r\n        // into the list again.\r\n        if (length >= 2 && expando[length - 2] === def.hostBindings) {\r\n            expando[length - 1] = expando[length - 1] + hostVars;\r\n        }\r\n        else {\r\n            expando.push(def.hostBindings, hostVars);\r\n        }\r\n    }\r\n    /**\r\n     * On the first template pass, we need to reserve space for host binding values\r\n     * after directives are matched (so all directives are saved, then bindings).\r\n     * Because we are updating the blueprint, we only need to do this once.\r\n     */\r\n    function prefillHostVars(tView, lView, totalHostVars) {\r\n        ngDevMode &&\r\n            assertEqual(tView.firstTemplatePass, true, 'Should only be called in first template pass.');\r\n        for (var i = 0; i < totalHostVars; i++) {\r\n            lView.push(NO_CHANGE);\r\n            tView.blueprint.push(NO_CHANGE);\r\n            tView.data.push(null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var _symbolIterator = null;\r\n    function getSymbolIterator() {\r\n        if (!_symbolIterator) {\r\n            var Symbol_1 = _global['Symbol'];\r\n            if (Symbol_1 && Symbol_1.iterator) {\r\n                _symbolIterator = Symbol_1.iterator;\r\n            }\r\n            else {\r\n                // es6-shim specific logic\r\n                var keys = Object.getOwnPropertyNames(Map.prototype);\r\n                for (var i = 0; i < keys.length; ++i) {\r\n                    var key = keys[i];\r\n                    if (key !== 'entries' && key !== 'size' &&\r\n                        Map.prototype[key] === Map.prototype['entries']) {\r\n                        _symbolIterator = key;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return _symbolIterator;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function isListLikeIterable(obj) {\r\n        if (!isJsObject(obj))\r\n            return false;\r\n        return Array.isArray(obj) ||\r\n            (!(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]\r\n                getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop\r\n    }\r\n    function areIterablesEqual(a, b, comparator) {\r\n        var iterator1 = a[getSymbolIterator()]();\r\n        var iterator2 = b[getSymbolIterator()]();\r\n        while (true) {\r\n            var item1 = iterator1.next();\r\n            var item2 = iterator2.next();\r\n            if (item1.done && item2.done)\r\n                return true;\r\n            if (item1.done || item2.done)\r\n                return false;\r\n            if (!comparator(item1.value, item2.value))\r\n                return false;\r\n        }\r\n    }\r\n    function iterateListLike(obj, fn) {\r\n        if (Array.isArray(obj)) {\r\n            for (var i = 0; i < obj.length; i++) {\r\n                fn(obj[i]);\r\n            }\r\n        }\r\n        else {\r\n            var iterator = obj[getSymbolIterator()]();\r\n            var item = void 0;\r\n            while (!((item = iterator.next()).done)) {\r\n                fn(item.value);\r\n            }\r\n        }\r\n    }\r\n    function isJsObject(o) {\r\n        return o !== null && (typeof o === 'function' || typeof o === 'object');\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    // JS has NaN !== NaN\r\n    function looseIdentical(a, b) {\r\n        return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);\r\n    }\r\n    function devModeEqual(a, b) {\r\n        var isListLikeIterableA = isListLikeIterable(a);\r\n        var isListLikeIterableB = isListLikeIterable(b);\r\n        if (isListLikeIterableA && isListLikeIterableB) {\r\n            return areIterablesEqual(a, b, devModeEqual);\r\n        }\r\n        else {\r\n            var isAObject = a && (typeof a === 'object' || typeof a === 'function');\r\n            var isBObject = b && (typeof b === 'object' || typeof b === 'function');\r\n            if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {\r\n                return true;\r\n            }\r\n            else {\r\n                return looseIdentical(a, b);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function devModeEqual$1(a, b) {\r\n        var isListLikeIterableA = isListLikeIterable$1(a);\r\n        var isListLikeIterableB = isListLikeIterable$1(b);\r\n        if (isListLikeIterableA && isListLikeIterableB) {\r\n            return areIterablesEqual$1(a, b, devModeEqual$1);\r\n        }\r\n        else {\r\n            var isAObject = a && (typeof a === 'object' || typeof a === 'function');\r\n            var isBObject = b && (typeof b === 'object' || typeof b === 'function');\r\n            if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {\r\n                return true;\r\n            }\r\n            else {\r\n                return looseIdentical(a, b);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Indicates that the result of a {@link Pipe} transformation has changed even though the\r\n     * reference has not changed.\r\n     *\r\n     * Wrapped values are unwrapped automatically during the change detection, and the unwrapped value\r\n     * is stored.\r\n     *\r\n     * Example:\r\n     *\r\n     * ```\r\n     * if (this._latestValue === this._latestReturnedValue) {\r\n     *    return this._latestReturnedValue;\r\n     *  } else {\r\n     *    this._latestReturnedValue = this._latestValue;\r\n     *    return WrappedValue.wrap(this._latestValue); // this will force update\r\n     *  }\r\n     * ```\r\n     *\r\n     * @publicApi\r\n     */\r\n    var WrappedValue = /** @class */ (function () {\r\n        function WrappedValue(value) {\r\n            this.wrapped = value;\r\n        }\r\n        /** Creates a wrapped value. */\r\n        WrappedValue.wrap = function (value) { return new WrappedValue(value); };\r\n        /**\r\n         * Returns the underlying value of a wrapped value.\r\n         * Returns the given `value` when it is not wrapped.\r\n         **/\r\n        WrappedValue.unwrap = function (value) { return WrappedValue.isWrapped(value) ? value.wrapped : value; };\r\n        /** Returns true if `value` is a wrapped value. */\r\n        WrappedValue.isWrapped = function (value) { return value instanceof WrappedValue; };\r\n        return WrappedValue;\r\n    }());\r\n    function isListLikeIterable$1(obj) {\r\n        if (!isJsObject$1(obj))\r\n            return false;\r\n        return Array.isArray(obj) ||\r\n            (!(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]\r\n                getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop\r\n    }\r\n    function areIterablesEqual$1(a, b, comparator) {\r\n        var iterator1 = a[getSymbolIterator()]();\r\n        var iterator2 = b[getSymbolIterator()]();\r\n        while (true) {\r\n            var item1 = iterator1.next();\r\n            var item2 = iterator2.next();\r\n            if (item1.done && item2.done)\r\n                return true;\r\n            if (item1.done || item2.done)\r\n                return false;\r\n            if (!comparator(item1.value, item2.value))\r\n                return false;\r\n        }\r\n    }\r\n    function iterateListLike$1(obj, fn) {\r\n        if (Array.isArray(obj)) {\r\n            for (var i = 0; i < obj.length; i++) {\r\n                fn(obj[i]);\r\n            }\r\n        }\r\n        else {\r\n            var iterator = obj[getSymbolIterator()]();\r\n            var item = void 0;\r\n            while (!((item = iterator.next()).done)) {\r\n                fn(item.value);\r\n            }\r\n        }\r\n    }\r\n    function isJsObject$1(o) {\r\n        return o !== null && (typeof o === 'function' || typeof o === 'object');\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    // TODO(misko): consider inlining\r\n    /** Updates binding and returns the value. */\r\n    function updateBinding(lView, bindingIndex, value) {\r\n        return lView[bindingIndex] = value;\r\n    }\r\n    /** Gets the current binding value. */\r\n    function getBinding(lView, bindingIndex) {\r\n        ngDevMode && assertDataInRange(lView, bindingIndex);\r\n        ngDevMode &&\r\n            assertNotSame(lView[bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');\r\n        return lView[bindingIndex];\r\n    }\r\n    /** Updates binding if changed, then returns whether it was updated. */\r\n    function bindingUpdated(lView, bindingIndex, value) {\r\n        ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\r\n        ngDevMode &&\r\n            assertLessThan(bindingIndex, lView.length, \"Slot should have been initialized to NO_CHANGE\");\r\n        var oldValue = lView[bindingIndex];\r\n        if (isDifferent(oldValue, value)) {\r\n            if (ngDevMode && getCheckNoChangesMode()) {\r\n                // View engine didn't report undefined values as changed on the first checkNoChanges pass\r\n                // (before the change detection was run).\r\n                var oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : undefined;\r\n                if (!devModeEqual$1(oldValueToCompare, value)) {\r\n                    throwErrorIfNoChangesMode(oldValue === NO_CHANGE, oldValueToCompare, value);\r\n                }\r\n            }\r\n            lView[bindingIndex] = value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /** Updates 2 bindings if changed, then returns whether either was updated. */\r\n    function bindingUpdated2(lView, bindingIndex, exp1, exp2) {\r\n        var different = bindingUpdated(lView, bindingIndex, exp1);\r\n        return bindingUpdated(lView, bindingIndex + 1, exp2) || different;\r\n    }\r\n    /** Updates 3 bindings if changed, then returns whether any was updated. */\r\n    function bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {\r\n        var different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\r\n        return bindingUpdated(lView, bindingIndex + 2, exp3) || different;\r\n    }\r\n    /** Updates 4 bindings if changed, then returns whether any was updated. */\r\n    function bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {\r\n        var different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\r\n        return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Update a property on a selected element.\r\n     *\r\n     * Operates on the element selected by index via the {@link select} instruction.\r\n     *\r\n     * If the property name also exists as an input property on one of the element's directives,\r\n     * the component property will be set instead of the element property. This check must\r\n     * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled\r\n     *\r\n     * @param propName Name of property. Because it is going to DOM, this is not subject to\r\n     *        renaming as part of minification.\r\n     * @param value New value to write.\r\n     * @param sanitizer An optional function used to sanitize the value.\r\n     * @returns This function returns itself so that it may be chained\r\n     * (e.g. `property('name', ctx.name)('title', ctx.title)`)\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵproperty(propName, value, sanitizer) {\r\n        var index = getSelectedIndex();\r\n        ngDevMode && assertNotEqual(index, -1, 'selected index cannot be -1');\r\n        var lView = getLView();\r\n        var bindReconciledValue = bind(lView, value);\r\n        if (bindReconciledValue !== NO_CHANGE) {\r\n            elementPropertyInternal(index, propName, bindReconciledValue, sanitizer);\r\n        }\r\n        return ɵɵproperty;\r\n    }\r\n    /**\r\n     * Creates a single value binding.\r\n     *\r\n     * @param lView Current view\r\n     * @param value Value to diff\r\n     */\r\n    function bind(lView, value) {\r\n        var bindingIndex = lView[BINDING_INDEX]++;\r\n        storeBindingMetadata(lView);\r\n        return bindingUpdated(lView, bindingIndex, value) ? value : NO_CHANGE;\r\n    }\r\n\r\n    /**\r\n     * Updates the value of or removes a bound attribute on an Element.\r\n     *\r\n     * Used in the case of `[attr.title]=\"value\"`\r\n     *\r\n     * @param name name The name of the attribute.\r\n     * @param value value The attribute is removed when value is `null` or `undefined`.\r\n     *                  Otherwise the attribute value is set to the stringified value.\r\n     * @param sanitizer An optional function used to sanitize the value.\r\n     * @param namespace Optional namespace to use when setting the attribute.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵattribute(name, value, sanitizer, namespace) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var bound = bind(lView, value);\r\n        if (bound !== NO_CHANGE) {\r\n            elementAttributeInternal(index, name, bound, lView, sanitizer, namespace);\r\n        }\r\n        return ɵɵattribute;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Create interpolation bindings with a variable number of expressions.\r\n     *\r\n     * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\r\n     * Those are faster because there is no need to create an array of expressions and iterate over it.\r\n     *\r\n     * `values`:\r\n     * - has static text at even indexes,\r\n     * - has evaluated expressions at odd indexes.\r\n     *\r\n     * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\r\n     */\r\n    function interpolationV(lView, values) {\r\n        ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');\r\n        ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');\r\n        var isBindingUpdated = false;\r\n        var tData = lView[TVIEW].data;\r\n        var bindingIndex = lView[BINDING_INDEX];\r\n        if (tData[bindingIndex] == null) {\r\n            // 2 is the index of the first static interstitial value (ie. not prefix)\r\n            for (var i = 2; i < values.length; i += 2) {\r\n                tData[bindingIndex++] = values[i];\r\n            }\r\n            bindingIndex = lView[BINDING_INDEX];\r\n        }\r\n        for (var i = 1; i < values.length; i += 2) {\r\n            // Check if bindings (odd indexes) have changed\r\n            isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;\r\n        }\r\n        lView[BINDING_INDEX] = bindingIndex;\r\n        storeBindingMetadata(lView, values[0], values[values.length - 1]);\r\n        if (!isBindingUpdated) {\r\n            return NO_CHANGE;\r\n        }\r\n        // Build the updated content\r\n        var content = values[0];\r\n        for (var i = 1; i < values.length; i += 2) {\r\n            content += renderStringify(values[i]) + values[i + 1];\r\n        }\r\n        return content;\r\n    }\r\n    /**\r\n     * Creates an interpolation binding with 1 expression.\r\n     *\r\n     * @param prefix static value used for concatenation only.\r\n     * @param v0 value checked for change.\r\n     * @param suffix static value used for concatenation only.\r\n     */\r\n    function interpolation1(lView, prefix, v0, suffix) {\r\n        var different = bindingUpdated(lView, lView[BINDING_INDEX]++, v0);\r\n        storeBindingMetadata(lView, prefix, suffix);\r\n        return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;\r\n    }\r\n    /**\r\n     * Creates an interpolation binding with 2 expressions.\r\n     */\r\n    function interpolation2(lView, prefix, v0, i0, v1, suffix) {\r\n        var bindingIndex = lView[BINDING_INDEX];\r\n        var different = bindingUpdated2(lView, bindingIndex, v0, v1);\r\n        lView[BINDING_INDEX] += 2;\r\n        // Only set static strings the first time (data will be null subsequent runs).\r\n        var data = storeBindingMetadata(lView, prefix, suffix);\r\n        if (data) {\r\n            lView[TVIEW].data[bindingIndex] = i0;\r\n        }\r\n        return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;\r\n    }\r\n    /**\r\n     * Creates an interpolation binding with 3 expressions.\r\n     */\r\n    function interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix) {\r\n        var bindingIndex = lView[BINDING_INDEX];\r\n        var different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);\r\n        lView[BINDING_INDEX] += 3;\r\n        // Only set static strings the first time (data will be null subsequent runs).\r\n        var data = storeBindingMetadata(lView, prefix, suffix);\r\n        if (data) {\r\n            var tData = lView[TVIEW].data;\r\n            tData[bindingIndex] = i0;\r\n            tData[bindingIndex + 1] = i1;\r\n        }\r\n        return different ?\r\n            prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix :\r\n            NO_CHANGE;\r\n    }\r\n    /**\r\n     * Create an interpolation binding with 4 expressions.\r\n     */\r\n    function interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\r\n        var bindingIndex = lView[BINDING_INDEX];\r\n        var different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\r\n        lView[BINDING_INDEX] += 4;\r\n        // Only set static strings the first time (data will be null subsequent runs).\r\n        var data = storeBindingMetadata(lView, prefix, suffix);\r\n        if (data) {\r\n            var tData = lView[TVIEW].data;\r\n            tData[bindingIndex] = i0;\r\n            tData[bindingIndex + 1] = i1;\r\n            tData[bindingIndex + 2] = i2;\r\n        }\r\n        return different ?\r\n            prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 +\r\n                renderStringify(v3) + suffix :\r\n            NO_CHANGE;\r\n    }\r\n    /**\r\n     * Creates an interpolation binding with 5 expressions.\r\n     */\r\n    function interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\r\n        var bindingIndex = lView[BINDING_INDEX];\r\n        var different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\r\n        different = bindingUpdated(lView, bindingIndex + 4, v4) || different;\r\n        lView[BINDING_INDEX] += 5;\r\n        // Only set static strings the first time (data will be null subsequent runs).\r\n        var data = storeBindingMetadata(lView, prefix, suffix);\r\n        if (data) {\r\n            var tData = lView[TVIEW].data;\r\n            tData[bindingIndex] = i0;\r\n            tData[bindingIndex + 1] = i1;\r\n            tData[bindingIndex + 2] = i2;\r\n            tData[bindingIndex + 3] = i3;\r\n        }\r\n        return different ?\r\n            prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 +\r\n                renderStringify(v3) + i3 + renderStringify(v4) + suffix :\r\n            NO_CHANGE;\r\n    }\r\n    /**\r\n     * Creates an interpolation binding with 6 expressions.\r\n     */\r\n    function interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\r\n        var bindingIndex = lView[BINDING_INDEX];\r\n        var different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\r\n        different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;\r\n        lView[BINDING_INDEX] += 6;\r\n        // Only set static strings the first time (data will be null subsequent runs).\r\n        var data = storeBindingMetadata(lView, prefix, suffix);\r\n        if (data) {\r\n            var tData = lView[TVIEW].data;\r\n            tData[bindingIndex] = i0;\r\n            tData[bindingIndex + 1] = i1;\r\n            tData[bindingIndex + 2] = i2;\r\n            tData[bindingIndex + 3] = i3;\r\n            tData[bindingIndex + 4] = i4;\r\n        }\r\n        return different ?\r\n            prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 +\r\n                renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix :\r\n            NO_CHANGE;\r\n    }\r\n    /**\r\n     * Creates an interpolation binding with 7 expressions.\r\n     */\r\n    function interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\r\n        var bindingIndex = lView[BINDING_INDEX];\r\n        var different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\r\n        different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;\r\n        lView[BINDING_INDEX] += 7;\r\n        // Only set static strings the first time (data will be null subsequent runs).\r\n        var data = storeBindingMetadata(lView, prefix, suffix);\r\n        if (data) {\r\n            var tData = lView[TVIEW].data;\r\n            tData[bindingIndex] = i0;\r\n            tData[bindingIndex + 1] = i1;\r\n            tData[bindingIndex + 2] = i2;\r\n            tData[bindingIndex + 3] = i3;\r\n            tData[bindingIndex + 4] = i4;\r\n            tData[bindingIndex + 5] = i5;\r\n        }\r\n        return different ?\r\n            prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 +\r\n                renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 +\r\n                renderStringify(v6) + suffix :\r\n            NO_CHANGE;\r\n    }\r\n    /**\r\n     * Creates an interpolation binding with 8 expressions.\r\n     */\r\n    function interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\r\n        var bindingIndex = lView[BINDING_INDEX];\r\n        var different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\r\n        different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;\r\n        lView[BINDING_INDEX] += 8;\r\n        // Only set static strings the first time (data will be null subsequent runs).\r\n        var data = storeBindingMetadata(lView, prefix, suffix);\r\n        if (data) {\r\n            var tData = lView[TVIEW].data;\r\n            tData[bindingIndex] = i0;\r\n            tData[bindingIndex + 1] = i1;\r\n            tData[bindingIndex + 2] = i2;\r\n            tData[bindingIndex + 3] = i3;\r\n            tData[bindingIndex + 4] = i4;\r\n            tData[bindingIndex + 5] = i5;\r\n            tData[bindingIndex + 6] = i6;\r\n        }\r\n        return different ?\r\n            prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 +\r\n                renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 +\r\n                renderStringify(v6) + i6 + renderStringify(v7) + suffix :\r\n            NO_CHANGE;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Update an interpolated attribute on an element with single bound value surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 1 interpolated value in it:\r\n     *\r\n     * ```html\r\n     * <div attr.title=\"prefix{{v0}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is::\r\n     *\r\n     * ```ts\r\n     * ɵɵattributeInterpolate1('title', 'prefix', v0, 'suffix');\r\n     * ```\r\n     *\r\n     * @param attrName The name of the attribute to update\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param sanitizer An optional sanitizer function\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵattributeInterpolate1(attrName, prefix, v0, suffix, sanitizer, namespace) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation1(lView, prefix, v0, suffix);\r\n        if (interpolatedValue !== NO_CHANGE) {\r\n            elementAttributeInternal(index, attrName, interpolatedValue, lView, sanitizer, namespace);\r\n        }\r\n        return ɵɵattributeInterpolate1;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated attribute on an element with 2 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 2 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div attr.title=\"prefix{{v0}}-{{v1}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is::\r\n     *\r\n     * ```ts\r\n     * ɵɵattributeInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\r\n     * ```\r\n     *\r\n     * @param attrName The name of the attribute to update\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param sanitizer An optional sanitizer function\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵattributeInterpolate2(attrName, prefix, v0, i0, v1, suffix, sanitizer, namespace) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\r\n        if (interpolatedValue !== NO_CHANGE) {\r\n            elementAttributeInternal(index, attrName, interpolatedValue, lView, sanitizer, namespace);\r\n        }\r\n        return ɵɵattributeInterpolate2;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated attribute on an element with 3 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 3 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is::\r\n     *\r\n     * ```ts\r\n     * ɵɵattributeInterpolate3(\r\n     * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\r\n     * ```\r\n     *\r\n     * @param attrName The name of the attribute to update\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param sanitizer An optional sanitizer function\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵattributeInterpolate3(attrName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer, namespace) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\r\n        if (interpolatedValue !== NO_CHANGE) {\r\n            elementAttributeInternal(index, attrName, interpolatedValue, lView, sanitizer, namespace);\r\n        }\r\n        return ɵɵattributeInterpolate3;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated attribute on an element with 4 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 4 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is::\r\n     *\r\n     * ```ts\r\n     * ɵɵattributeInterpolate4(\r\n     * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\r\n     * ```\r\n     *\r\n     * @param attrName The name of the attribute to update\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param sanitizer An optional sanitizer function\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵattributeInterpolate4(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer, namespace) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\r\n        if (interpolatedValue !== NO_CHANGE) {\r\n            elementAttributeInternal(index, attrName, interpolatedValue, lView, sanitizer, namespace);\r\n        }\r\n        return ɵɵattributeInterpolate4;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated attribute on an element with 5 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 5 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is::\r\n     *\r\n     * ```ts\r\n     * ɵɵattributeInterpolate5(\r\n     * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\r\n     * ```\r\n     *\r\n     * @param attrName The name of the attribute to update\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param i3 Static value used for concatenation only.\r\n     * @param v4 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param sanitizer An optional sanitizer function\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵattributeInterpolate5(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer, namespace) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\r\n        if (interpolatedValue !== NO_CHANGE) {\r\n            elementAttributeInternal(index, attrName, interpolatedValue, lView, sanitizer, namespace);\r\n        }\r\n        return ɵɵattributeInterpolate5;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated attribute on an element with 6 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 6 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is::\r\n     *\r\n     * ```ts\r\n     * ɵɵattributeInterpolate6(\r\n     *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\r\n     * ```\r\n     *\r\n     * @param attrName The name of the attribute to update\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param i3 Static value used for concatenation only.\r\n     * @param v4 Value checked for change.\r\n     * @param i4 Static value used for concatenation only.\r\n     * @param v5 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param sanitizer An optional sanitizer function\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵattributeInterpolate6(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer, namespace) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\r\n        if (interpolatedValue !== NO_CHANGE) {\r\n            elementAttributeInternal(index, attrName, interpolatedValue, lView, sanitizer, namespace);\r\n        }\r\n        return ɵɵattributeInterpolate6;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated attribute on an element with 7 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 7 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is::\r\n     *\r\n     * ```ts\r\n     * ɵɵattributeInterpolate7(\r\n     *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\r\n     * ```\r\n     *\r\n     * @param attrName The name of the attribute to update\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param i3 Static value used for concatenation only.\r\n     * @param v4 Value checked for change.\r\n     * @param i4 Static value used for concatenation only.\r\n     * @param v5 Value checked for change.\r\n     * @param i5 Static value used for concatenation only.\r\n     * @param v6 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param sanitizer An optional sanitizer function\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵattributeInterpolate7(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer, namespace) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\r\n        if (interpolatedValue !== NO_CHANGE) {\r\n            elementAttributeInternal(index, attrName, interpolatedValue, lView, sanitizer, namespace);\r\n        }\r\n        return ɵɵattributeInterpolate7;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated attribute on an element with 8 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 8 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is::\r\n     *\r\n     * ```ts\r\n     * ɵɵattributeInterpolate8(\r\n     *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\r\n     * ```\r\n     *\r\n     * @param attrName The name of the attribute to update\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param i3 Static value used for concatenation only.\r\n     * @param v4 Value checked for change.\r\n     * @param i4 Static value used for concatenation only.\r\n     * @param v5 Value checked for change.\r\n     * @param i5 Static value used for concatenation only.\r\n     * @param v6 Value checked for change.\r\n     * @param i6 Static value used for concatenation only.\r\n     * @param v7 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param sanitizer An optional sanitizer function\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵattributeInterpolate8(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer, namespace) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\r\n        if (interpolatedValue !== NO_CHANGE) {\r\n            elementAttributeInternal(index, attrName, interpolatedValue, lView, sanitizer, namespace);\r\n        }\r\n        return ɵɵattributeInterpolate8;\r\n    }\r\n    /**\r\n     * Update an interpolated attribute on an element with 8 or more bound values surrounded by text.\r\n     *\r\n     * Used when the number of interpolated values exceeds 7.\r\n     *\r\n     * ```html\r\n     * <div\r\n     *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is::\r\n     *\r\n     * ```ts\r\n     * ɵɵattributeInterpolateV(\r\n     *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\r\n     *  'suffix']);\r\n     * ```\r\n     *\r\n     * @param attrName The name of the attribute to update.\r\n     * @param values The a collection of values and the strings in-between those values, beginning with\r\n     * a string prefix and ending with a string suffix.\r\n     * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\r\n     * @param sanitizer An optional sanitizer function\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵattributeInterpolateV(attrName, values, sanitizer, namespace) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var interpolated = interpolationV(lView, values);\r\n        if (interpolated !== NO_CHANGE) {\r\n            elementAttributeInternal(index, attrName, interpolated, lView, sanitizer, namespace);\r\n        }\r\n        return ɵɵattributeInterpolateV;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Synchronously perform change detection on a component (and possibly its sub-components).\r\n     *\r\n     * This function triggers change detection in a synchronous way on a component. There should\r\n     * be very little reason to call this function directly since a preferred way to do change\r\n     * detection is to {@link markDirty} the component and wait for the scheduler to call this method\r\n     * at some future point in time. This is because a single user action often results in many\r\n     * components being invalidated and calling change detection on each component synchronously\r\n     * would be inefficient. It is better to wait until all components are marked as dirty and\r\n     * then perform single change detection across all of the components\r\n     *\r\n     * @param component The component which the change detection should be performed on.\r\n     */\r\n    function detectChanges(component) {\r\n        var view = getComponentViewByInstance(component);\r\n        detectChangesInternal(view, component);\r\n    }\r\n    /**\r\n     * Mark the component as dirty (needing change detection).\r\n     *\r\n     * Marking a component dirty will schedule a change detection on this\r\n     * component at some point in the future. Marking an already dirty\r\n     * component as dirty is a noop. Only one outstanding change detection\r\n     * can be scheduled per component tree. (Two components bootstrapped with\r\n     * separate `renderComponent` will have separate schedulers)\r\n     *\r\n     * When the root component is bootstrapped with `renderComponent`, a scheduler\r\n     * can be provided.\r\n     *\r\n     * @param component Component to mark as dirty.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function markDirty(component) {\r\n        ngDevMode && assertDefined(component, 'component');\r\n        var rootView = markViewDirty(getComponentViewByInstance(component));\r\n        ngDevMode && assertDefined(rootView[CONTEXT], 'rootContext should be defined');\r\n        scheduleTick(rootView[CONTEXT], 1 /* DetectChanges */);\r\n    }\r\n    /**\r\n     * Used to perform change detection on the whole application.\r\n     *\r\n     * This is equivalent to `detectChanges`, but invoked on root component. Additionally, `tick`\r\n     * executes lifecycle hooks and conditionally checks components based on their\r\n     * `ChangeDetectionStrategy` and dirtiness.\r\n     *\r\n     * The preferred way to trigger change detection is to call `markDirty`. `markDirty` internally\r\n     * schedules `tick` using a scheduler in order to coalesce multiple `markDirty` calls into a\r\n     * single change detection run. By default, the scheduler is `requestAnimationFrame`, but can\r\n     * be changed when calling `renderComponent` and providing the `scheduler` option.\r\n     */\r\n    function tick(component) {\r\n        var rootView = getRootView(component);\r\n        var rootContext = rootView[CONTEXT];\r\n        tickRootContext(rootContext);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Creates an LContainer for inline views, e.g.\r\n     *\r\n     * % if (showing) {\r\n     *   <div></div>\r\n     * % }\r\n     *\r\n     * @param index The index of the container in the data array\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵcontainer(index) {\r\n        var lView = getLView();\r\n        var tNode = containerInternal(lView, index, null, null);\r\n        if (lView[TVIEW].firstTemplatePass) {\r\n            tNode.tViews = [];\r\n        }\r\n        setIsNotParent();\r\n    }\r\n    /**\r\n     * Creates an LContainer for an ng-template (dynamically-inserted view), e.g.\r\n     *\r\n     * <ng-template #foo>\r\n     *    <div></div>\r\n     * </ng-template>\r\n     *\r\n     * @param index The index of the container in the data array\r\n     * @param templateFn Inline template\r\n     * @param consts The number of nodes, local refs, and pipes for this template\r\n     * @param vars The number of bindings for this template\r\n     * @param tagName The name of the container element, if applicable\r\n     * @param attrs The attrs attached to the container, if applicable\r\n     * @param localRefs A set of local reference bindings on the element.\r\n     * @param localRefExtractor A function which extracts local-refs values from the template.\r\n     *        Defaults to the current element associated with the local-ref.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵtemplate(index, templateFn, consts, vars, tagName, attrs, localRefs, localRefExtractor) {\r\n        var lView = getLView();\r\n        var tView = lView[TVIEW];\r\n        // TODO: consider a separate node type for templates\r\n        var tContainerNode = containerInternal(lView, index, tagName || null, attrs || null);\r\n        if (tView.firstTemplatePass) {\r\n            ngDevMode && ngDevMode.firstTemplatePass++;\r\n            resolveDirectives(tView, lView, tContainerNode, localRefs || null);\r\n            var embeddedTView = tContainerNode.tViews = createTView(-1, templateFn, consts, vars, tView.directiveRegistry, tView.pipeRegistry, null, null);\r\n            if (tView.queries !== null) {\r\n                tView.queries.template(tView, tContainerNode);\r\n                embeddedTView.queries = tView.queries.embeddedTView(tContainerNode);\r\n            }\r\n        }\r\n        createDirectivesAndLocals(tView, lView, tContainerNode, localRefExtractor);\r\n        attachPatchData(getNativeByTNode(tContainerNode, lView), lView);\r\n        registerPostOrderHooks(tView, tContainerNode);\r\n        setIsNotParent();\r\n    }\r\n    /**\r\n     * Sets a container up to receive views.\r\n     *\r\n     * @param index The index of the container in the data array\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵcontainerRefreshStart(index) {\r\n        var lView = getLView();\r\n        var tView = lView[TVIEW];\r\n        var previousOrParentTNode = loadInternal(tView.data, index);\r\n        ngDevMode && assertNodeType(previousOrParentTNode, 0 /* Container */);\r\n        setPreviousOrParentTNode(previousOrParentTNode, true);\r\n        lView[index + HEADER_OFFSET][ACTIVE_INDEX] = 0;\r\n        // We need to execute init hooks here so ngOnInit hooks are called in top level views\r\n        // before they are called in embedded views (for backwards compatibility).\r\n        executePreOrderHooks(lView, tView, getCheckNoChangesMode(), undefined);\r\n    }\r\n    /**\r\n     * Marks the end of the LContainer.\r\n     *\r\n     * Marking the end of LContainer is the time when to child views get inserted or removed.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵcontainerRefreshEnd() {\r\n        var previousOrParentTNode = getPreviousOrParentTNode();\r\n        if (getIsParent()) {\r\n            setIsNotParent();\r\n        }\r\n        else {\r\n            ngDevMode && assertNodeType(previousOrParentTNode, 2 /* View */);\r\n            ngDevMode && assertHasParent(previousOrParentTNode);\r\n            previousOrParentTNode = previousOrParentTNode.parent;\r\n            setPreviousOrParentTNode(previousOrParentTNode, false);\r\n        }\r\n        ngDevMode && assertNodeType(previousOrParentTNode, 0 /* Container */);\r\n        var lContainer = getLView()[previousOrParentTNode.index];\r\n        var nextIndex = lContainer[ACTIVE_INDEX];\r\n        // remove extra views at the end of the container\r\n        while (nextIndex < lContainer.length - CONTAINER_HEADER_OFFSET) {\r\n            removeView(lContainer, nextIndex);\r\n        }\r\n    }\r\n    function containerInternal(lView, nodeIndex, tagName, attrs) {\r\n        ngDevMode && assertEqual(lView[BINDING_INDEX], lView[TVIEW].bindingStartIndex, 'container nodes should be created before any bindings');\r\n        var adjustedIndex = nodeIndex + HEADER_OFFSET;\r\n        ngDevMode && assertDataInRange(lView, nodeIndex + HEADER_OFFSET);\r\n        ngDevMode && ngDevMode.rendererCreateComment++;\r\n        var comment = lView[adjustedIndex] =\r\n            lView[RENDERER].createComment(ngDevMode ? 'container' : '');\r\n        var tNode = getOrCreateTNode(lView[TVIEW], lView[T_HOST], nodeIndex, 0 /* Container */, tagName, attrs);\r\n        var lContainer = lView[adjustedIndex] = createLContainer(comment, lView, comment, tNode);\r\n        appendChild(comment, tNode, lView);\r\n        // Containers are added to the current view tree instead of their embedded views\r\n        // because views can be removed and re-inserted.\r\n        addToViewTree(lView, lContainer);\r\n        ngDevMode && assertNodeType(getPreviousOrParentTNode(), 0 /* Container */);\r\n        return tNode;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /** Store a value in the `data` at a given `index`. */\r\n    function store(index, value) {\r\n        var lView = getLView();\r\n        var tView = lView[TVIEW];\r\n        // We don't store any static data for local variables, so the first time\r\n        // we see the template, we should store as null to avoid a sparse array\r\n        var adjustedIndex = index + HEADER_OFFSET;\r\n        if (adjustedIndex >= tView.data.length) {\r\n            tView.data[adjustedIndex] = null;\r\n            tView.blueprint[adjustedIndex] = null;\r\n        }\r\n        lView[adjustedIndex] = value;\r\n    }\r\n    /**\r\n     * Retrieves a local reference from the current contextViewData.\r\n     *\r\n     * If the reference to retrieve is in a parent view, this instruction is used in conjunction\r\n     * with a nextContext() call, which walks up the tree and updates the contextViewData instance.\r\n     *\r\n     * @param index The index of the local ref in contextViewData.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵreference(index) {\r\n        var contextLView = getContextLView();\r\n        return loadInternal(contextLView, index);\r\n    }\r\n    /**\r\n     * Retrieves a value from current `viewData`.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵload(index) {\r\n        return loadInternal(getLView(), index);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function ɵɵdirectiveInject(token, flags) {\r\n        if (flags === void 0) { flags = exports.InjectFlags.Default; }\r\n        token = resolveForwardRef(token);\r\n        var lView = getLView();\r\n        // Fall back to inject() if view hasn't been created. This situation can happen in tests\r\n        // if inject utilities are used before bootstrapping.\r\n        if (lView == null)\r\n            return ɵɵinject(token, flags);\r\n        return getOrCreateInjectable(getPreviousOrParentTNode(), lView, token, flags);\r\n    }\r\n    /**\r\n     * Facade for the attribute injection from DI.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵinjectAttribute(attrNameToInject) {\r\n        return injectAttributeImpl(getPreviousOrParentTNode(), attrNameToInject);\r\n    }\r\n\r\n    /**\r\n     * --------\r\n     *\r\n     * This file contains the core logic for how styling instructions are processed in Angular.\r\n     *\r\n     * To learn more about the algorithm see `TStylingContext`.\r\n     *\r\n     * --------\r\n     */\r\n    /**\r\n     * Temporary function to bridge styling functionality between this new\r\n     * refactor (which is here inside of `styling_next/`) and the old\r\n     * implementation (which lives inside of `styling/`).\r\n     *\r\n     * This function is executed during the creation block of an element.\r\n     * Because the existing styling implementation issues a call to the\r\n     * `styling()` instruction, this instruction will also get run. The\r\n     * central idea here is that the directive index values are bound\r\n     * into the context. The directive index is temporary and is only\r\n     * required until the `select(n)` instruction is fully functional.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵstyling() {\r\n        var tView = getLView()[TVIEW];\r\n        if (tView.firstTemplatePass) {\r\n            updateLastDirectiveIndex$1(getPreviousOrParentTNode(), getActiveDirectiveStylingIndex());\r\n        }\r\n    }\r\n    /**\r\n     * Sets the current style sanitizer function which will then be used\r\n     * within all follow-up prop and map-based style binding instructions\r\n     * for the given element.\r\n     *\r\n     * Note that once styling has been applied to the element (i.e. once\r\n     * `select(n)` is executed or the hostBindings/template function exits)\r\n     * then the active `sanitizerFn` will be set to `null`. This means that\r\n     * once styling is applied to another element then a another call to\r\n     * `styleSanitizer` will need to be made.\r\n     *\r\n     * @param sanitizerFn The sanitization function that will be used to\r\n     *       process style prop/value entries.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵstyleSanitizer(sanitizer) {\r\n        setCurrentStyleSanitizer(sanitizer);\r\n    }\r\n    /**\r\n     * Update a style binding on an element with the provided value.\r\n     *\r\n     * If the style value is falsy then it will be removed from the element\r\n     * (or assigned a different value depending if there are any styles placed\r\n     * on the element with `styleMap` or any static styles that are\r\n     * present from when the element was created with `styling`).\r\n     *\r\n     * Note that the styling element is updated as part of `stylingApply`.\r\n     *\r\n     * @param prop A valid CSS property.\r\n     * @param value New value to write (`null` or an empty string to remove).\r\n     * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\r\n     *        Note that when a suffix is provided then the underlying sanitizer will\r\n     *        be ignored.\r\n     *\r\n     * Note that this will apply the provided style value to the host element if this function is called\r\n     * within a host binding.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵstyleProp(prop, value, suffix) {\r\n        stylePropInternal(getSelectedIndex(), prop, value, suffix);\r\n    }\r\n    function stylePropInternal(elementIndex, prop, value, suffix) {\r\n        var lView = getLView();\r\n        // if a value is interpolated then it may render a `NO_CHANGE` value.\r\n        // in this case we do not need to do anything, but the binding index\r\n        // still needs to be incremented because all styling binding values\r\n        // are stored inside of the lView.\r\n        var bindingIndex = lView[BINDING_INDEX]++;\r\n        var updated = _stylingProp(elementIndex, bindingIndex, prop, resolveStylePropValue(value, suffix), false, deferStylingUpdate());\r\n        if (ngDevMode) {\r\n            ngDevMode.styleProp++;\r\n            if (updated) {\r\n                ngDevMode.stylePropCacheMiss++;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Update a class binding on an element with the provided value.\r\n     *\r\n     * This instruction is meant to handle the `[class.foo]=\"exp\"` case and,\r\n     * therefore, the class binding itself must already be allocated using\r\n     * `styling` within the creation block.\r\n     *\r\n     * @param prop A valid CSS class (only one).\r\n     * @param value A true/false value which will turn the class on or off.\r\n     *\r\n     * Note that this will apply the provided class value to the host element if this function\r\n     * is called within a host binding.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵclassProp(className, value) {\r\n        var lView = getLView();\r\n        // if a value is interpolated then it may render a `NO_CHANGE` value.\r\n        // in this case we do not need to do anything, but the binding index\r\n        // still needs to be incremented because all styling binding values\r\n        // are stored inside of the lView.\r\n        var bindingIndex = lView[BINDING_INDEX]++;\r\n        var updated = _stylingProp(getSelectedIndex(), bindingIndex, className, value, true, deferStylingUpdate());\r\n        if (ngDevMode) {\r\n            ngDevMode.classProp++;\r\n            if (updated) {\r\n                ngDevMode.classPropCacheMiss++;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Shared function used to update a prop-based styling binding for an element.\r\n     */\r\n    function _stylingProp(elementIndex, bindingIndex, prop, value, isClassBased, defer) {\r\n        var lView = getLView();\r\n        var tNode = getTNode(elementIndex, lView);\r\n        var native = getNativeByTNode(tNode, lView);\r\n        var updated = false;\r\n        if (value !== NO_CHANGE) {\r\n            if (isClassBased) {\r\n                updated = updateClassBinding(getClassesContext(tNode), lView, native, prop, bindingIndex, value, defer, false);\r\n            }\r\n            else {\r\n                var sanitizer = getCurrentStyleSanitizer();\r\n                updated = updateStyleBinding(getStylesContext(tNode), lView, native, prop, bindingIndex, value, sanitizer, defer, false);\r\n            }\r\n        }\r\n        return updated;\r\n    }\r\n    /**\r\n     * Update style bindings using an object literal on an element.\r\n     *\r\n     * This instruction is meant to apply styling via the `[style]=\"exp\"` template bindings.\r\n     * When styles are applied to the element they will then be updated with respect to\r\n     * any styles/classes set via `styleProp`. If any styles are set to falsy\r\n     * then they will be removed from the element.\r\n     *\r\n     * Note that the styling instruction will not be applied until `stylingApply` is called.\r\n     *\r\n     * @param styles A key/value style map of the styles that will be applied to the given element.\r\n     *        Any missing styles (that have already been applied to the element beforehand) will be\r\n     *        removed (unset) from the element's styling.\r\n     *\r\n     * Note that this will apply the provided styleMap value to the host element if this function\r\n     * is called within a host binding.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵstyleMap(styles) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var tNode = getTNode(index, lView);\r\n        var context = getStylesContext(tNode);\r\n        var directiveIndex = getActiveDirectiveStylingIndex();\r\n        // if a value is interpolated then it may render a `NO_CHANGE` value.\r\n        // in this case we do not need to do anything, but the binding index\r\n        // still needs to be incremented because all styling binding values\r\n        // are stored inside of the lView.\r\n        var bindingIndex = lView[BINDING_INDEX]++;\r\n        // inputs are only evaluated from a template binding into a directive, therefore,\r\n        // there should not be a situation where a directive host bindings function\r\n        // evaluates the inputs (this should only happen in the template function)\r\n        if (!directiveIndex && hasStyleInput(tNode) && styles !== NO_CHANGE) {\r\n            updateDirectiveInputValue(context, lView, tNode, bindingIndex, styles, false);\r\n            styles = NO_CHANGE;\r\n        }\r\n        var updated = _stylingMap(index, context, bindingIndex, styles, false, deferStylingUpdate());\r\n        if (ngDevMode) {\r\n            ngDevMode.styleMap++;\r\n            if (updated) {\r\n                ngDevMode.styleMapCacheMiss++;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Update class bindings using an object literal or class-string on an element.\r\n     *\r\n     * This instruction is meant to apply styling via the `[class]=\"exp\"` template bindings.\r\n     * When classes are applied to the element they will then be updated with\r\n     * respect to any styles/classes set via `classProp`. If any\r\n     * classes are set to falsy then they will be removed from the element.\r\n     *\r\n     * Note that the styling instruction will not be applied until `stylingApply` is called.\r\n     * Note that this will the provided classMap value to the host element if this function is called\r\n     * within a host binding.\r\n     *\r\n     * @param classes A key/value map or string of CSS classes that will be added to the\r\n     *        given element. Any missing classes (that have already been applied to the element\r\n     *        beforehand) will be removed (unset) from the element's list of CSS classes.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵclassMap(classes) {\r\n        classMapInternal(getSelectedIndex(), classes);\r\n    }\r\n    function classMapInternal(elementIndex, classes) {\r\n        var lView = getLView();\r\n        var tNode = getTNode(elementIndex, lView);\r\n        var context = getClassesContext(tNode);\r\n        var directiveIndex = getActiveDirectiveStylingIndex();\r\n        // if a value is interpolated then it may render a `NO_CHANGE` value.\r\n        // in this case we do not need to do anything, but the binding index\r\n        // still needs to be incremented because all styling binding values\r\n        // are stored inside of the lView.\r\n        var bindingIndex = lView[BINDING_INDEX]++;\r\n        // inputs are only evaluated from a template binding into a directive, therefore,\r\n        // there should not be a situation where a directive host bindings function\r\n        // evaluates the inputs (this should only happen in the template function)\r\n        if (!directiveIndex && hasClassInput(tNode) && classes !== NO_CHANGE) {\r\n            updateDirectiveInputValue(context, lView, tNode, bindingIndex, classes, true);\r\n            classes = NO_CHANGE;\r\n        }\r\n        var updated = _stylingMap(elementIndex, context, bindingIndex, classes, true, deferStylingUpdate());\r\n        if (ngDevMode) {\r\n            ngDevMode.classMap++;\r\n            if (updated) {\r\n                ngDevMode.classMapCacheMiss++;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Shared function used to update a map-based styling binding for an element.\r\n     *\r\n     * When this function is called it will activate support for `[style]` and\r\n     * `[class]` bindings in Angular.\r\n     */\r\n    function _stylingMap(elementIndex, context, bindingIndex, value, isClassBased, defer) {\r\n        activateStylingMapFeature();\r\n        var lView = getLView();\r\n        var valueHasChanged = false;\r\n        if (value !== NO_CHANGE) {\r\n            var tNode = getTNode(elementIndex, lView);\r\n            var native = getNativeByTNode(tNode, lView);\r\n            var oldValue = lView[bindingIndex];\r\n            valueHasChanged = hasValueChanged(oldValue, value);\r\n            var stylingMapArr = normalizeIntoStylingMap(oldValue, value, !isClassBased);\r\n            if (isClassBased) {\r\n                updateClassBinding(context, lView, native, null, bindingIndex, stylingMapArr, defer, valueHasChanged);\r\n            }\r\n            else {\r\n                var sanitizer = getCurrentStyleSanitizer();\r\n                updateStyleBinding(context, lView, native, null, bindingIndex, stylingMapArr, sanitizer, defer, valueHasChanged);\r\n            }\r\n        }\r\n        return valueHasChanged;\r\n    }\r\n    /**\r\n     * Writes a value to a directive's `style` or `class` input binding (if it has changed).\r\n     *\r\n     * If a directive has a `@Input` binding that is set on `style` or `class` then that value\r\n     * will take priority over the underlying style/class styling bindings. This value will\r\n     * be updated for the binding each time during change detection.\r\n     *\r\n     * When this occurs this function will attempt to write the value to the input binding\r\n     * depending on the following situations:\r\n     *\r\n     * - If `oldValue !== newValue`\r\n     * - If `newValue` is `null` (but this is skipped if it is during the first update pass--\r\n     *    which is when the context is not locked yet)\r\n     */\r\n    function updateDirectiveInputValue(context, lView, tNode, bindingIndex, newValue, isClassBased) {\r\n        var oldValue = lView[bindingIndex];\r\n        if (oldValue !== newValue) {\r\n            // even if the value has changed we may not want to emit it to the\r\n            // directive input(s) in the event that it is falsy during the\r\n            // first update pass.\r\n            if (newValue || isContextLocked(context)) {\r\n                var inputs = tNode.inputs[isClassBased ? 'class' : 'style'];\r\n                var initialValue = getInitialStylingValue(context);\r\n                var value = normalizeStylingDirectiveInputValue(initialValue, newValue, isClassBased);\r\n                setInputsForProperty(lView, inputs, value);\r\n            }\r\n            lView[bindingIndex] = newValue;\r\n        }\r\n    }\r\n    /**\r\n     * Returns the appropriate directive input value for `style` or `class`.\r\n     *\r\n     * Earlier versions of Angular expect a binding value to be passed into directive code\r\n     * exactly as it is unless there is a static value present (in which case both values\r\n     * will be stringified and concatenated).\r\n     */\r\n    function normalizeStylingDirectiveInputValue(initialValue, bindingValue, isClassBased) {\r\n        var value = bindingValue;\r\n        // we only concat values if there is an initial value, otherwise we return the value as is.\r\n        // Note that this is to satisfy backwards-compatibility in Angular.\r\n        if (initialValue.length > 0) {\r\n            if (isClassBased) {\r\n                value = concatString(initialValue, forceClassesAsString(bindingValue));\r\n            }\r\n            else {\r\n                value = concatString(initialValue, forceStylesAsString(bindingValue), ';');\r\n            }\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n     * Flushes all styling code to the element.\r\n     *\r\n     * This function is designed to be called from the template and hostBindings\r\n     * functions and may be called multiple times depending whether multiple\r\n     * sources of styling exist. If called multiple times, only the last call\r\n     * to `stlyingApply()` will render styling to the element.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵstylingApply() {\r\n        var elementIndex = getSelectedIndex();\r\n        var lView = getLView();\r\n        var tNode = getTNode(elementIndex, lView);\r\n        var renderer = getRenderer(tNode, lView);\r\n        var native = getNativeByTNode(tNode, lView);\r\n        var directiveIndex = getActiveDirectiveStylingIndex();\r\n        var sanitizer = getCurrentStyleSanitizer();\r\n        flushStyling(renderer, lView, getClassesContext(tNode), getStylesContext(tNode), native, directiveIndex, sanitizer);\r\n        setCurrentStyleSanitizer(null);\r\n    }\r\n    function getRenderer(tNode, lView) {\r\n        return tNode.type === 3 /* Element */ ? lView[RENDERER] : null;\r\n    }\r\n    /**\r\n     * Searches and assigns provided all static style/class entries (found in the `attrs` value)\r\n     * and registers them in their respective styling contexts.\r\n     */\r\n    function registerInitialStylingOnTNode(tNode, attrs, startIndex) {\r\n        var hasAdditionalInitialStyling = false;\r\n        var styles = getStylingMapArray(tNode.styles);\r\n        var classes = getStylingMapArray(tNode.classes);\r\n        var mode = -1;\r\n        for (var i = startIndex; i < attrs.length; i++) {\r\n            var attr = attrs[i];\r\n            if (typeof attr == 'number') {\r\n                mode = attr;\r\n            }\r\n            else if (mode == 1 /* Classes */) {\r\n                classes = classes || [''];\r\n                addItemToStylingMap(classes, attr, true);\r\n                hasAdditionalInitialStyling = true;\r\n            }\r\n            else if (mode == 2 /* Styles */) {\r\n                var value = attrs[++i];\r\n                styles = styles || [''];\r\n                addItemToStylingMap(styles, attr, value);\r\n                hasAdditionalInitialStyling = true;\r\n            }\r\n        }\r\n        if (classes && classes.length > 1 /* ValuesStartPosition */) {\r\n            if (!tNode.classes) {\r\n                tNode.classes = classes;\r\n            }\r\n            updateRawValueOnContext(tNode.classes, stylingMapToString(classes, true));\r\n        }\r\n        if (styles && styles.length > 1 /* ValuesStartPosition */) {\r\n            if (!tNode.styles) {\r\n                tNode.styles = styles;\r\n            }\r\n            updateRawValueOnContext(tNode.styles, stylingMapToString(styles, false));\r\n        }\r\n        return hasAdditionalInitialStyling;\r\n    }\r\n    function updateRawValueOnContext(context, value) {\r\n        var stylingMapArr = getStylingMapArray(context);\r\n        stylingMapArr[0 /* RawValuePosition */] = value;\r\n    }\r\n    function getActiveDirectiveStylingIndex() {\r\n        // whenever a directive's hostBindings function is called a uniqueId value\r\n        // is assigned. Normally this is enough to help distinguish one directive\r\n        // from another for the styling context, but there are situations where a\r\n        // sub-class directive could inherit and assign styling in concert with a\r\n        // parent directive. To help the styling code distinguish between a parent\r\n        // sub-classed directive the inheritance depth is taken into account as well.\r\n        return getActiveDirectiveId() + getActiveDirectiveSuperClassDepth();\r\n    }\r\n    /**\r\n     * Temporary function that will update the max directive index value in\r\n     * both the classes and styles contexts present on the provided `tNode`.\r\n     *\r\n     * This code is only used because the `select(n)` code functionality is not\r\n     * yet 100% functional. The `select(n)` instruction cannot yet evaluate host\r\n     * bindings function code in sync with the associated template function code.\r\n     * For this reason the styling algorithm needs to track the last directive index\r\n     * value so that it knows exactly when to render styling to the element since\r\n     * `stylingApply()` is called multiple times per CD (`stylingApply` will be\r\n     * removed once `select(n)` is fixed).\r\n     */\r\n    function updateLastDirectiveIndex$1(tNode, directiveIndex) {\r\n        updateLastDirectiveIndex(getClassesContext(tNode), directiveIndex);\r\n        updateLastDirectiveIndex(getStylesContext(tNode), directiveIndex);\r\n    }\r\n    function getStylesContext(tNode) {\r\n        return getContext(tNode, false);\r\n    }\r\n    function getClassesContext(tNode) {\r\n        return getContext(tNode, true);\r\n    }\r\n    /**\r\n     * Returns/instantiates a styling context from/to a `tNode` instance.\r\n     */\r\n    function getContext(tNode, isClassBased) {\r\n        var context = isClassBased ? tNode.classes : tNode.styles;\r\n        if (!isStylingContext(context)) {\r\n            context = allocTStylingContext(context);\r\n            if (ngDevMode) {\r\n                attachStylingDebugObject(context);\r\n            }\r\n            if (isClassBased) {\r\n                tNode.classes = context;\r\n            }\r\n            else {\r\n                tNode.styles = context;\r\n            }\r\n        }\r\n        return context;\r\n    }\r\n    function resolveStylePropValue(value, suffix) {\r\n        if (value === NO_CHANGE)\r\n            return value;\r\n        var resolvedValue = null;\r\n        if (value !== null) {\r\n            if (suffix) {\r\n                // when a suffix is applied then it will bypass\r\n                // sanitization entirely (b/c a new string is created)\r\n                resolvedValue = renderStringify(value) + suffix;\r\n            }\r\n            else {\r\n                // sanitization happens by dealing with a String value\r\n                // this means that the string value will be passed through\r\n                // into the style rendering later (which is where the value\r\n                // will be sanitized before it is applied)\r\n                resolvedValue = value;\r\n            }\r\n        }\r\n        return resolvedValue;\r\n    }\r\n    /**\r\n     * Whether or not a style/class binding update should be applied later.\r\n     *\r\n     * This function will decide whether a binding should be applied immediately\r\n     * or later (just before the styles/classes are flushed to the element). The\r\n     * reason why this feature exists is because of super/sub directive inheritance.\r\n     * Angular will evaluate host bindings on the super directive first and the sub\r\n     * directive, but the styling bindings on the sub directive are of higher priority\r\n     * than the super directive. For this reason all styling bindings that take place\r\n     * in this circumstance will need to be deferred until later so that they can be\r\n     * applied together and in a different order (the algorithm handles that part).\r\n     */\r\n    function deferStylingUpdate() {\r\n        return getActiveDirectiveSuperClassHeight() > 0;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Create DOM element. The instruction must later be followed by `elementEnd()` call.\r\n     *\r\n     * @param index Index of the element in the LView array\r\n     * @param name Name of the DOM Node\r\n     * @param attrs Statically bound set of attributes, classes, and styles to be written into the DOM\r\n     *              element on creation. Use [AttributeMarker] to denote the meaning of this array.\r\n     * @param localRefs A set of local reference bindings on the element.\r\n     *\r\n     * Attributes and localRefs are passed as an array of strings where elements with an even index\r\n     * hold an attribute name and elements with an odd index hold an attribute value, ex.:\r\n     * ['id', 'warning5', 'class', 'alert']\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵelementStart(index, name, attrs, localRefs) {\r\n        var lView = getLView();\r\n        var tView = lView[TVIEW];\r\n        ngDevMode && assertEqual(lView[BINDING_INDEX], tView.bindingStartIndex, 'elements should be created before any bindings ');\r\n        ngDevMode && ngDevMode.rendererCreateElement++;\r\n        ngDevMode && assertDataInRange(lView, index + HEADER_OFFSET);\r\n        var native = lView[index + HEADER_OFFSET] = elementCreate(name);\r\n        var renderer = lView[RENDERER];\r\n        var tNode = getOrCreateTNode(tView, lView[T_HOST], index, 3 /* Element */, name, attrs || null);\r\n        if (attrs != null) {\r\n            var lastAttrIndex = setUpAttributes(native, attrs);\r\n            if (tView.firstTemplatePass) {\r\n                registerInitialStylingOnTNode(tNode, attrs, lastAttrIndex);\r\n            }\r\n        }\r\n        renderInitialStyling(renderer, native, tNode);\r\n        appendChild(native, tNode, lView);\r\n        // any immediate children of a component or template container must be pre-emptively\r\n        // monkey-patched with the component view data so that the element can be inspected\r\n        // later on using any element discovery utility methods (see `element_discovery.ts`)\r\n        if (getElementDepthCount() === 0) {\r\n            attachPatchData(native, lView);\r\n        }\r\n        increaseElementDepthCount();\r\n        // if a directive contains a host binding for \"class\" then all class-based data will\r\n        // flow through that (except for `[class.prop]` bindings). This also includes initial\r\n        // static class values as well. (Note that this will be fixed once map-based `[style]`\r\n        // and `[class]` bindings work for multiple directives.)\r\n        if (tView.firstTemplatePass) {\r\n            ngDevMode && ngDevMode.firstTemplatePass++;\r\n            resolveDirectives(tView, lView, tNode, localRefs || null);\r\n            var inputData = initializeTNodeInputs(tNode);\r\n            if (inputData && inputData.hasOwnProperty('class')) {\r\n                tNode.flags |= 8 /* hasClassInput */;\r\n            }\r\n            if (inputData && inputData.hasOwnProperty('style')) {\r\n                tNode.flags |= 16 /* hasStyleInput */;\r\n            }\r\n            if (tView.queries !== null) {\r\n                tView.queries.elementStart(tView, tNode);\r\n            }\r\n        }\r\n        createDirectivesAndLocals(tView, lView, tNode);\r\n        executeContentQueries(tView, tNode, lView);\r\n    }\r\n    /**\r\n     * Mark the end of the element.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵelementEnd() {\r\n        var previousOrParentTNode = getPreviousOrParentTNode();\r\n        ngDevMode && assertDefined(previousOrParentTNode, 'No parent node to close.');\r\n        if (getIsParent()) {\r\n            setIsNotParent();\r\n        }\r\n        else {\r\n            ngDevMode && assertHasParent(getPreviousOrParentTNode());\r\n            previousOrParentTNode = previousOrParentTNode.parent;\r\n            setPreviousOrParentTNode(previousOrParentTNode, false);\r\n        }\r\n        var tNode = previousOrParentTNode;\r\n        ngDevMode && assertNodeType(tNode, 3 /* Element */);\r\n        var lView = getLView();\r\n        var tView = lView[TVIEW];\r\n        registerPostOrderHooks(tView, previousOrParentTNode);\r\n        decreaseElementDepthCount();\r\n        if (tView.firstTemplatePass && tView.queries !== null &&\r\n            isContentQueryHost(previousOrParentTNode)) {\r\n            tView.queries.elementEnd(previousOrParentTNode);\r\n        }\r\n        if (hasClassInput(tNode) && tNode.classes) {\r\n            setDirectiveStylingInput(tNode.classes, lView, tNode.inputs['class']);\r\n        }\r\n        if (hasStyleInput(tNode) && tNode.styles) {\r\n            setDirectiveStylingInput(tNode.styles, lView, tNode.inputs['style']);\r\n        }\r\n    }\r\n    /**\r\n     * Creates an empty element using {@link elementStart} and {@link elementEnd}\r\n     *\r\n     * @param index Index of the element in the data array\r\n     * @param name Name of the DOM Node\r\n     * @param attrs Statically bound set of attributes, classes, and styles to be written into the DOM\r\n     *              element on creation. Use [AttributeMarker] to denote the meaning of this array.\r\n     * @param localRefs A set of local reference bindings on the element.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵelement(index, name, attrs, localRefs) {\r\n        ɵɵelementStart(index, name, attrs, localRefs);\r\n        ɵɵelementEnd();\r\n    }\r\n    /**\r\n     * Assign static attribute values to a host element.\r\n     *\r\n     * This instruction will assign static attribute values as well as class and style\r\n     * values to an element within the host bindings function. Since attribute values\r\n     * can consist of different types of values, the `attrs` array must include the values in\r\n     * the following format:\r\n     *\r\n     * attrs = [\r\n     *   // static attributes (like `title`, `name`, `id`...)\r\n     *   attr1, value1, attr2, value,\r\n     *\r\n     *   // a single namespace value (like `x:id`)\r\n     *   NAMESPACE_MARKER, namespaceUri1, name1, value1,\r\n     *\r\n     *   // another single namespace value (like `x:name`)\r\n     *   NAMESPACE_MARKER, namespaceUri2, name2, value2,\r\n     *\r\n     *   // a series of CSS classes that will be applied to the element (no spaces)\r\n     *   CLASSES_MARKER, class1, class2, class3,\r\n     *\r\n     *   // a series of CSS styles (property + value) that will be applied to the element\r\n     *   STYLES_MARKER, prop1, value1, prop2, value2\r\n     * ]\r\n     *\r\n     * All non-class and non-style attributes must be defined at the start of the list\r\n     * first before all class and style values are set. When there is a change in value\r\n     * type (like when classes and styles are introduced) a marker must be used to separate\r\n     * the entries. The marker values themselves are set via entries found in the\r\n     * [AttributeMarker] enum.\r\n     *\r\n     * NOTE: This instruction is meant to used from `hostBindings` function only.\r\n     *\r\n     * @param directive A directive instance the styling is associated with.\r\n     * @param attrs An array of static values (attributes, classes and styles) with the correct marker\r\n     * values.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵelementHostAttrs(attrs) {\r\n        var hostElementIndex = getSelectedIndex();\r\n        var lView = getLView();\r\n        var tView = lView[TVIEW];\r\n        var tNode = getTNode(hostElementIndex, lView);\r\n        // non-element nodes (e.g. `<ng-container>`) are not rendered as actual\r\n        // element nodes and adding styles/classes on to them will cause runtime\r\n        // errors...\r\n        if (tNode.type === 3 /* Element */) {\r\n            var native = getNativeByTNode(tNode, lView);\r\n            var lastAttrIndex = setUpAttributes(native, attrs);\r\n            if (tView.firstTemplatePass) {\r\n                var stylingNeedsToBeRendered = registerInitialStylingOnTNode(tNode, attrs, lastAttrIndex);\r\n                // this is only called during the first template pass in the\r\n                // event that this current directive assigned initial style/class\r\n                // host attribute values to the element. Because initial styling\r\n                // values are applied before directives are first rendered (within\r\n                // `createElement`) this means that initial styling for any directives\r\n                // still needs to be applied. Note that this will only happen during\r\n                // the first template pass and not each time a directive applies its\r\n                // attribute values to the element.\r\n                if (stylingNeedsToBeRendered) {\r\n                    var renderer = lView[RENDERER];\r\n                    renderInitialStyling(renderer, native, tNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function setDirectiveStylingInput(context, lView, stylingInputs) {\r\n        // older versions of Angular treat the input as `null` in the\r\n        // event that the value does not exist at all. For this reason\r\n        // we can't have a styling value be an empty string.\r\n        var value = getInitialStylingValue(context) || null;\r\n        // Ivy does an extra `[class]` write with a falsy value since the value\r\n        // is applied during creation mode. This is a deviation from VE and should\r\n        // be (Jira Issue = FW-1467).\r\n        setInputsForProperty(lView, stylingInputs, value);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Creates a logical container for other nodes (<ng-container>) backed by a comment node in the DOM.\r\n     * The instruction must later be followed by `elementContainerEnd()` call.\r\n     *\r\n     * @param index Index of the element in the LView array\r\n     * @param attrs Set of attributes to be used when matching directives.\r\n     * @param localRefs A set of local reference bindings on the element.\r\n     *\r\n     * Even if this instruction accepts a set of attributes no actual attribute values are propagated to\r\n     * the DOM (as a comment node can't have attributes). Attributes are here only for directive\r\n     * matching purposes and setting initial inputs of directives.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵelementContainerStart(index, attrs, localRefs) {\r\n        var lView = getLView();\r\n        var tView = lView[TVIEW];\r\n        var renderer = lView[RENDERER];\r\n        var tagName = 'ng-container';\r\n        ngDevMode && assertEqual(lView[BINDING_INDEX], tView.bindingStartIndex, 'element containers should be created before any bindings');\r\n        ngDevMode && ngDevMode.rendererCreateComment++;\r\n        ngDevMode && assertDataInRange(lView, index + HEADER_OFFSET);\r\n        var native = lView[index + HEADER_OFFSET] = renderer.createComment(ngDevMode ? tagName : '');\r\n        ngDevMode && assertDataInRange(lView, index - 1);\r\n        var tNode = getOrCreateTNode(tView, lView[T_HOST], index, 4 /* ElementContainer */, tagName, attrs || null);\r\n        if (attrs && tView.firstTemplatePass) {\r\n            // While ng-container doesn't necessarily support styling, we use the style context to identify\r\n            // and execute directives on the ng-container.\r\n            registerInitialStylingOnTNode(tNode, attrs, 0);\r\n        }\r\n        appendChild(native, tNode, lView);\r\n        if (tView.firstTemplatePass) {\r\n            ngDevMode && ngDevMode.firstTemplatePass++;\r\n            resolveDirectives(tView, lView, tNode, localRefs || null);\r\n            if (tView.queries) {\r\n                tView.queries.elementStart(tView, tNode);\r\n            }\r\n        }\r\n        createDirectivesAndLocals(tView, lView, tNode);\r\n        attachPatchData(native, lView);\r\n        executeContentQueries(tView, tNode, lView);\r\n    }\r\n    /**\r\n     * Mark the end of the <ng-container>.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵelementContainerEnd() {\r\n        var previousOrParentTNode = getPreviousOrParentTNode();\r\n        var lView = getLView();\r\n        var tView = lView[TVIEW];\r\n        if (getIsParent()) {\r\n            setIsNotParent();\r\n        }\r\n        else {\r\n            ngDevMode && assertHasParent(previousOrParentTNode);\r\n            previousOrParentTNode = previousOrParentTNode.parent;\r\n            setPreviousOrParentTNode(previousOrParentTNode, false);\r\n        }\r\n        ngDevMode && assertNodeType(previousOrParentTNode, 4 /* ElementContainer */);\r\n        registerPostOrderHooks(tView, previousOrParentTNode);\r\n        if (tView.firstTemplatePass && tView.queries !== null &&\r\n            isContentQueryHost(previousOrParentTNode)) {\r\n            tView.queries.elementEnd(previousOrParentTNode);\r\n        }\r\n    }\r\n    /**\r\n     * Creates an empty logical container using {@link elementContainerStart}\r\n     * and {@link elementContainerEnd}\r\n     *\r\n     * @param index Index of the element in the LView array\r\n     * @param attrs Set of attributes to be used when matching directives.\r\n     * @param localRefs A set of local reference bindings on the element.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵelementContainer(index, attrs, localRefs) {\r\n        ɵɵelementContainerStart(index, attrs, localRefs);\r\n        ɵɵelementContainerEnd();\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Marks the start of an embedded view.\r\n     *\r\n     * @param viewBlockId The ID of this view\r\n     * @return boolean Whether or not this view is in creation mode\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵembeddedViewStart(viewBlockId, consts, vars) {\r\n        var lView = getLView();\r\n        var previousOrParentTNode = getPreviousOrParentTNode();\r\n        // The previous node can be a view node if we are processing an inline for loop\r\n        var containerTNode = previousOrParentTNode.type === 2 /* View */ ?\r\n            previousOrParentTNode.parent :\r\n            previousOrParentTNode;\r\n        var lContainer = lView[containerTNode.index];\r\n        ngDevMode && assertNodeType(containerTNode, 0 /* Container */);\r\n        var viewToRender = scanForView(lContainer, lContainer[ACTIVE_INDEX], viewBlockId);\r\n        if (viewToRender) {\r\n            setIsParent();\r\n            enterView(viewToRender, viewToRender[TVIEW].node);\r\n        }\r\n        else {\r\n            // When we create a new LView, we always reset the state of the instructions.\r\n            viewToRender = createLView(lView, getOrCreateEmbeddedTView(viewBlockId, consts, vars, containerTNode), null, 16 /* CheckAlways */, null, null);\r\n            var tParentNode = getIsParent() ? previousOrParentTNode :\r\n                previousOrParentTNode && previousOrParentTNode.parent;\r\n            assignTViewNodeToLView(viewToRender[TVIEW], tParentNode, viewBlockId, viewToRender);\r\n            enterView(viewToRender, viewToRender[TVIEW].node);\r\n        }\r\n        if (lContainer) {\r\n            if (isCreationMode(viewToRender)) {\r\n                // it is a new view, insert it into collection of views for a given container\r\n                insertView(viewToRender, lContainer, lContainer[ACTIVE_INDEX]);\r\n            }\r\n            lContainer[ACTIVE_INDEX]++;\r\n        }\r\n        return isCreationMode(viewToRender) ? 1 /* Create */ | 2 /* Update */ :\r\n            2 /* Update */;\r\n    }\r\n    /**\r\n     * Initialize the TView (e.g. static data) for the active embedded view.\r\n     *\r\n     * Each embedded view block must create or retrieve its own TView. Otherwise, the embedded view's\r\n     * static data for a particular node would overwrite the static data for a node in the view above\r\n     * it with the same index (since it's in the same template).\r\n     *\r\n     * @param viewIndex The index of the TView in TNode.tViews\r\n     * @param consts The number of nodes, local refs, and pipes in this template\r\n     * @param vars The number of bindings and pure function bindings in this template\r\n     * @param container The parent container in which to look for the view's static data\r\n     * @returns TView\r\n     */\r\n    function getOrCreateEmbeddedTView(viewIndex, consts, vars, parent) {\r\n        var tView = getLView()[TVIEW];\r\n        ngDevMode && assertNodeType(parent, 0 /* Container */);\r\n        var containerTViews = parent.tViews;\r\n        ngDevMode && assertDefined(containerTViews, 'TView expected');\r\n        ngDevMode && assertEqual(Array.isArray(containerTViews), true, 'TViews should be in an array');\r\n        if (viewIndex >= containerTViews.length || containerTViews[viewIndex] == null) {\r\n            containerTViews[viewIndex] = createTView(viewIndex, null, consts, vars, tView.directiveRegistry, tView.pipeRegistry, null, null);\r\n        }\r\n        return containerTViews[viewIndex];\r\n    }\r\n    /**\r\n     * Looks for a view with a given view block id inside a provided LContainer.\r\n     * Removes views that need to be deleted in the process.\r\n     *\r\n     * @param lContainer to search for views\r\n     * @param startIdx starting index in the views array to search from\r\n     * @param viewBlockId exact view block id to look for\r\n     */\r\n    function scanForView(lContainer, startIdx, viewBlockId) {\r\n        for (var i = startIdx + CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\r\n            var viewAtPositionId = lContainer[i][TVIEW].id;\r\n            if (viewAtPositionId === viewBlockId) {\r\n                return lContainer[i];\r\n            }\r\n            else if (viewAtPositionId < viewBlockId) {\r\n                // found a view that should not be at this position - remove\r\n                removeView(lContainer, i - CONTAINER_HEADER_OFFSET);\r\n            }\r\n            else {\r\n                // found a view with id greater than the one we are searching for\r\n                // which means that required view doesn't exist and can't be found at\r\n                // later positions in the views array - stop the searchdef.cont here\r\n                break;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Marks the end of an embedded view.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵembeddedViewEnd() {\r\n        var lView = getLView();\r\n        var viewHost = lView[T_HOST];\r\n        if (isCreationMode(lView)) {\r\n            refreshDescendantViews(lView); // creation mode pass\r\n            lView[FLAGS] &= ~4 /* CreationMode */;\r\n        }\r\n        resetPreOrderHookFlags(lView);\r\n        refreshDescendantViews(lView); // update mode pass\r\n        var lContainer = lView[PARENT];\r\n        ngDevMode && assertLContainerOrUndefined(lContainer);\r\n        // It's always safe to run hooks here, as `leaveView` is not called during the 'finally' block\r\n        // of a try-catch-finally statement, so it can never be reached while unwinding the stack due to\r\n        // an error being thrown.\r\n        leaveView(lContainer[PARENT], /* safeToRunHooks */ true);\r\n        setPreviousOrParentTNode(viewHost, false);\r\n    }\r\n\r\n    /**\r\n     * Returns the current OpaqueViewState instance.\r\n     *\r\n     * Used in conjunction with the restoreView() instruction to save a snapshot\r\n     * of the current view and restore it when listeners are invoked. This allows\r\n     * walking the declaration view tree in listeners to get vars from parent views.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵgetCurrentView() {\r\n        return getLView();\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Determine if the argument is shaped like a Promise\r\n     */\r\n    function isPromise(obj) {\r\n        // allow any Promise/A+ compliant thenable.\r\n        // It's up to the caller to ensure that obj.then conforms to the spec\r\n        return !!obj && typeof obj.then === 'function';\r\n    }\r\n    /**\r\n     * Determine if the argument is an Observable\r\n     */\r\n    function isObservable(obj) {\r\n        // TODO: use isObservable once we update pass rxjs 6.1\r\n        // https://github.com/ReactiveX/rxjs/blob/master/CHANGELOG.md#610-2018-05-03\r\n        return !!obj && typeof obj.subscribe === 'function';\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Adds an event listener to the current node.\r\n     *\r\n     * If an output exists on one of the node's directives, it also subscribes to the output\r\n     * and saves the subscription for later cleanup.\r\n     *\r\n     * @param eventName Name of the event\r\n     * @param listenerFn The function to be called when event emits\r\n     * @param useCapture Whether or not to use capture in event listener\r\n     * @param eventTargetResolver Function that returns global target information in case this listener\r\n     * should be attached to a global object like window, document or body\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵlistener(eventName, listenerFn, useCapture, eventTargetResolver) {\r\n        if (useCapture === void 0) { useCapture = false; }\r\n        listenerInternal(eventName, listenerFn, useCapture, eventTargetResolver);\r\n    }\r\n    /**\r\n    * Registers a synthetic host listener (e.g. `(@foo.start)`) on a component.\r\n    *\r\n    * This instruction is for compatibility purposes and is designed to ensure that a\r\n    * synthetic host listener (e.g. `@HostListener('@foo.start')`) properly gets rendered\r\n    * in the component's renderer. Normally all host listeners are evaluated with the\r\n    * parent component's renderer, but, in the case of animation @triggers, they need\r\n    * to be evaluated with the sub component's renderer (because that's where the\r\n    * animation triggers are defined).\r\n    *\r\n    * Do not use this instruction as a replacement for `listener`. This instruction\r\n    * only exists to ensure compatibility with the ViewEngine's host binding behavior.\r\n    *\r\n    * @param eventName Name of the event\r\n    * @param listenerFn The function to be called when event emits\r\n    * @param useCapture Whether or not to use capture in event listener\r\n    * @param eventTargetResolver Function that returns global target information in case this listener\r\n    * should be attached to a global object like window, document or body\r\n     *\r\n     * @codeGenApi\r\n    */\r\n    function ɵɵcomponentHostSyntheticListener(eventName, listenerFn, useCapture, eventTargetResolver) {\r\n        if (useCapture === void 0) { useCapture = false; }\r\n        listenerInternal(eventName, listenerFn, useCapture, eventTargetResolver, loadComponentRenderer);\r\n    }\r\n    /**\r\n     * A utility function that checks if a given element has already an event handler registered for an\r\n     * event with a specified name. The TView.cleanup data structure is used to find out which events\r\n     * are registered for a given element.\r\n     */\r\n    function findExistingListener(lView, eventName, tNodeIdx) {\r\n        var tView = lView[TVIEW];\r\n        var tCleanup = tView.cleanup;\r\n        if (tCleanup != null) {\r\n            for (var i = 0; i < tCleanup.length - 1; i += 2) {\r\n                var cleanupEventName = tCleanup[i];\r\n                if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {\r\n                    // We have found a matching event name on the same node but it might not have been\r\n                    // registered yet, so we must explicitly verify entries in the LView cleanup data\r\n                    // structures.\r\n                    var lCleanup = lView[CLEANUP];\r\n                    var listenerIdxInLCleanup = tCleanup[i + 2];\r\n                    return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;\r\n                }\r\n                // TView.cleanup can have a mix of 4-elements entries (for event handler cleanups) or\r\n                // 2-element entries (for directive and queries destroy hooks). As such we can encounter\r\n                // blocks of 4 or 2 items in the tView.cleanup and this is why we iterate over 2 elements\r\n                // first and jump another 2 elements if we detect listeners cleanup (4 elements). Also check\r\n                // documentation of TView.cleanup for more details of this data structure layout.\r\n                if (typeof cleanupEventName === 'string') {\r\n                    i += 2;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    function listenerInternal(eventName, listenerFn, useCapture, eventTargetResolver, loadRendererFn) {\r\n        if (useCapture === void 0) { useCapture = false; }\r\n        var lView = getLView();\r\n        var tNode = getPreviousOrParentTNode();\r\n        var tView = lView[TVIEW];\r\n        var firstTemplatePass = tView.firstTemplatePass;\r\n        var tCleanup = firstTemplatePass && (tView.cleanup || (tView.cleanup = []));\r\n        ngDevMode && assertNodeOfPossibleTypes(tNode, 3 /* Element */, 0 /* Container */, 4 /* ElementContainer */);\r\n        var processOutputs = true;\r\n        // add native event listener - applicable to elements only\r\n        if (tNode.type === 3 /* Element */) {\r\n            var native = getNativeByTNode(tNode, lView);\r\n            var resolved = eventTargetResolver ? eventTargetResolver(native) : EMPTY_OBJ;\r\n            var target = resolved.target || native;\r\n            var renderer = loadRendererFn ? loadRendererFn(tNode, lView) : lView[RENDERER];\r\n            var lCleanup = getCleanup(lView);\r\n            var lCleanupIndex = lCleanup.length;\r\n            var idxOrTargetGetter = eventTargetResolver ?\r\n                function (_lView) { return eventTargetResolver(unwrapRNode(_lView[tNode.index])).target; } :\r\n                tNode.index;\r\n            // In order to match current behavior, native DOM event listeners must be added for all\r\n            // events (including outputs).\r\n            if (isProceduralRenderer(renderer)) {\r\n                // There might be cases where multiple directives on the same element try to register an event\r\n                // handler function for the same event. In this situation we want to avoid registration of\r\n                // several native listeners as each registration would be intercepted by NgZone and\r\n                // trigger change detection. This would mean that a single user action would result in several\r\n                // change detections being invoked. To avoid this situation we want to have only one call to\r\n                // native handler registration (for the same element and same type of event).\r\n                //\r\n                // In order to have just one native event handler in presence of multiple handler functions,\r\n                // we just register a first handler function as a native event listener and then chain\r\n                // (coalesce) other handler functions on top of the first native handler function.\r\n                var existingListener = null;\r\n                // Please note that the coalescing described here doesn't happen for events specifying an\r\n                // alternative target (ex. (document:click)) - this is to keep backward compatibility with the\r\n                // view engine.\r\n                // Also, we don't have to search for existing listeners is there are no directives\r\n                // matching on a given node as we can't register multiple event handlers for the same event in\r\n                // a template (this would mean having duplicate attributes).\r\n                if (!eventTargetResolver && hasDirectives(tNode)) {\r\n                    existingListener = findExistingListener(lView, eventName, tNode.index);\r\n                }\r\n                if (existingListener !== null) {\r\n                    // Attach a new listener at the head of the coalesced listeners list.\r\n                    listenerFn.__ngNextListenerFn__ = existingListener.__ngNextListenerFn__;\r\n                    existingListener.__ngNextListenerFn__ = listenerFn;\r\n                    processOutputs = false;\r\n                }\r\n                else {\r\n                    // The first argument of `listen` function in Procedural Renderer is:\r\n                    // - either a target name (as a string) in case of global target (window, document, body)\r\n                    // - or element reference (in all other cases)\r\n                    listenerFn = wrapListener(tNode, lView, listenerFn, false /** preventDefault */);\r\n                    var cleanupFn = renderer.listen(resolved.name || target, eventName, listenerFn);\r\n                    ngDevMode && ngDevMode.rendererAddEventListener++;\r\n                    lCleanup.push(listenerFn, cleanupFn);\r\n                    tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);\r\n                }\r\n            }\r\n            else {\r\n                listenerFn = wrapListener(tNode, lView, listenerFn, true /** preventDefault */);\r\n                target.addEventListener(eventName, listenerFn, useCapture);\r\n                ngDevMode && ngDevMode.rendererAddEventListener++;\r\n                lCleanup.push(listenerFn);\r\n                tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, useCapture);\r\n            }\r\n        }\r\n        // subscribe to directive outputs\r\n        if (tNode.outputs === undefined) {\r\n            // if we create TNode here, inputs must be undefined so we know they still need to be\r\n            // checked\r\n            tNode.outputs = generatePropertyAliases(tNode, 1 /* Output */);\r\n        }\r\n        var outputs = tNode.outputs;\r\n        var props;\r\n        if (processOutputs && outputs && (props = outputs[eventName])) {\r\n            var propsLength = props.length;\r\n            if (propsLength) {\r\n                var lCleanup = getCleanup(lView);\r\n                for (var i = 0; i < propsLength; i += 3) {\r\n                    var index = props[i];\r\n                    ngDevMode && assertDataInRange(lView, index);\r\n                    var minifiedName = props[i + 2];\r\n                    var directiveInstance = lView[index];\r\n                    var output = directiveInstance[minifiedName];\r\n                    if (ngDevMode && !isObservable(output)) {\r\n                        throw new Error(\"@Output \" + minifiedName + \" not initialized in '\" + directiveInstance.constructor.name + \"'.\");\r\n                    }\r\n                    var subscription = output.subscribe(listenerFn);\r\n                    var idx = lCleanup.length;\r\n                    lCleanup.push(listenerFn, subscription);\r\n                    tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function executeListenerWithErrorHandling(lView, listenerFn, e) {\r\n        try {\r\n            // Only explicitly returning false from a listener should preventDefault\r\n            return listenerFn(e) !== false;\r\n        }\r\n        catch (error) {\r\n            handleError(lView, error);\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Wraps an event listener with a function that marks ancestors dirty and prevents default behavior,\r\n     * if applicable.\r\n     *\r\n     * @param tNode The TNode associated with this listener\r\n     * @param lView The LView that contains this listener\r\n     * @param listenerFn The listener function to call\r\n     * @param wrapWithPreventDefault Whether or not to prevent default behavior\r\n     * (the procedural renderer does this already, so in those cases, we should skip)\r\n     */\r\n    function wrapListener(tNode, lView, listenerFn, wrapWithPreventDefault) {\r\n        // Note: we are performing most of the work in the listener function itself\r\n        // to optimize listener registration.\r\n        return function wrapListenerIn_markDirtyAndPreventDefault(e) {\r\n            // In order to be backwards compatible with View Engine, events on component host nodes\r\n            // must also mark the component view itself dirty (i.e. the view that it owns).\r\n            var startView = tNode.flags & 1 /* isComponent */ ? getComponentViewByIndex(tNode.index, lView) : lView;\r\n            // See interfaces/view.ts for more on LViewFlags.ManualOnPush\r\n            if ((lView[FLAGS] & 32 /* ManualOnPush */) === 0) {\r\n                markViewDirty(startView);\r\n            }\r\n            var result = executeListenerWithErrorHandling(lView, listenerFn, e);\r\n            // A just-invoked listener function might have coalesced listeners so we need to check for\r\n            // their presence and invoke as needed.\r\n            var nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;\r\n            while (nextListenerFn) {\r\n                // We should prevent default if any of the listeners explicitly return false\r\n                result = executeListenerWithErrorHandling(lView, nextListenerFn, e) && result;\r\n                nextListenerFn = nextListenerFn.__ngNextListenerFn__;\r\n            }\r\n            if (wrapWithPreventDefault && result === false) {\r\n                e.preventDefault();\r\n                // Necessary for legacy browsers that don't support preventDefault (e.g. IE)\r\n                e.returnValue = false;\r\n            }\r\n            return result;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Retrieves a context at the level specified and saves it as the global, contextViewData.\r\n     * Will get the next level up if level is not specified.\r\n     *\r\n     * This is used to save contexts of parent views so they can be bound in embedded views, or\r\n     * in conjunction with reference() to bind a ref from a parent view.\r\n     *\r\n     * @param level The relative level of the view from which to grab context compared to contextVewData\r\n     * @returns context\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵnextContext(level) {\r\n        if (level === void 0) { level = 1; }\r\n        return nextContextImpl(level);\r\n    }\r\n\r\n    /**\r\n     * Checks a given node against matching projection slots and returns the\r\n     * determined slot index. Returns \"null\" if no slot matched the given node.\r\n     *\r\n     * This function takes into account the parsed ngProjectAs selector from the\r\n     * node's attributes. If present, it will check whether the ngProjectAs selector\r\n     * matches any of the projection slot selectors.\r\n     */\r\n    function matchingProjectionSlotIndex(tNode, projectionSlots) {\r\n        var wildcardNgContentIndex = null;\r\n        var ngProjectAsAttrVal = getProjectAsAttrValue(tNode);\r\n        for (var i = 0; i < projectionSlots.length; i++) {\r\n            var slotValue = projectionSlots[i];\r\n            // The last wildcard projection slot should match all nodes which aren't matching\r\n            // any selector. This is necessary to be backwards compatible with view engine.\r\n            if (slotValue === '*') {\r\n                wildcardNgContentIndex = i;\r\n                continue;\r\n            }\r\n            // If we ran into an `ngProjectAs` attribute, we should match its parsed selector\r\n            // to the list of selectors, otherwise we fall back to matching against the node.\r\n            if (ngProjectAsAttrVal === null ?\r\n                isNodeMatchingSelectorList(tNode, slotValue, /* isProjectionMode */ true) :\r\n                isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {\r\n                return i; // first matching selector \"captures\" a given node\r\n            }\r\n        }\r\n        return wildcardNgContentIndex;\r\n    }\r\n    /**\r\n     * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\r\n     * It takes all the selectors from the entire component's template and decides where\r\n     * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\r\n     * backed by a selector).\r\n     *\r\n     * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\r\n     * un-parsed form.\r\n     *\r\n     * The parsed form is needed for efficient matching of a node against a given CSS selector.\r\n     * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\r\n     *\r\n     * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\r\n     * drawbacks:\r\n     * - having only a textual form would require runtime parsing of CSS selectors;\r\n     * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\r\n     * template author).\r\n     *\r\n     * @param projectionSlots? A collection of projection slots. A projection slot can be based\r\n     *        on a parsed CSS selectors or set to the wildcard selector (\"*\") in order to match\r\n     *        all nodes which do not match any selector. If not specified, a single wildcard\r\n     *        selector projection slot will be defined.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵprojectionDef(projectionSlots) {\r\n        var componentNode = findComponentView(getLView())[T_HOST];\r\n        if (!componentNode.projection) {\r\n            // If no explicit projection slots are defined, fall back to a single\r\n            // projection slot with the wildcard selector.\r\n            var numProjectionSlots = projectionSlots ? projectionSlots.length : 1;\r\n            var projectionHeads = componentNode.projection =\r\n                new Array(numProjectionSlots).fill(null);\r\n            var tails = projectionHeads.slice();\r\n            var componentChild = componentNode.child;\r\n            while (componentChild !== null) {\r\n                var slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;\r\n                if (slotIndex !== null) {\r\n                    if (tails[slotIndex]) {\r\n                        tails[slotIndex].projectionNext = componentChild;\r\n                    }\r\n                    else {\r\n                        projectionHeads[slotIndex] = componentChild;\r\n                    }\r\n                    tails[slotIndex] = componentChild;\r\n                }\r\n                componentChild = componentChild.next;\r\n            }\r\n        }\r\n    }\r\n    var delayProjection = false;\r\n    function setDelayProjection(value) {\r\n        delayProjection = value;\r\n    }\r\n    /**\r\n     * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\r\n     * to the projectionDef instruction.\r\n     *\r\n     * @param nodeIndex\r\n     * @param selectorIndex:\r\n     *        - 0 when the selector is `*` (or unspecified as this is the default value),\r\n     *        - 1 based index of the selector from the {@link projectionDef}\r\n     *\r\n     * @codeGenApi\r\n    */\r\n    function ɵɵprojection(nodeIndex, selectorIndex, attrs) {\r\n        if (selectorIndex === void 0) { selectorIndex = 0; }\r\n        var lView = getLView();\r\n        var tProjectionNode = getOrCreateTNode(lView[TVIEW], lView[T_HOST], nodeIndex, 1 /* Projection */, null, attrs || null);\r\n        // We can't use viewData[HOST_NODE] because projection nodes can be nested in embedded views.\r\n        if (tProjectionNode.projection === null)\r\n            tProjectionNode.projection = selectorIndex;\r\n        // `<ng-content>` has no content\r\n        setIsNotParent();\r\n        // We might need to delay the projection of nodes if they are in the middle of an i18n block\r\n        if (!delayProjection) {\r\n            // re-distribution of projectable nodes is stored on a component's view level\r\n            appendProjectedNodes(lView, tProjectionNode, selectorIndex, findComponentView(lView));\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Update an interpolated property on an element with a lone bound value\r\n     *\r\n     * Used when the value passed to a property has 1 interpolated value in it, an no additional text\r\n     * surrounds that interpolated value:\r\n     *\r\n     * ```html\r\n     * <div title=\"{{v0}}\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is::\r\n     *\r\n     * ```ts\r\n     * ɵɵpropertyInterpolate('title', v0);\r\n     * ```\r\n     *\r\n     * If the property name also exists as an input property on one of the element's directives,\r\n     * the component property will be set instead of the element property. This check must\r\n     * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\r\n     *\r\n     * @param propName The name of the property to update\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param sanitizer An optional sanitizer function\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpropertyInterpolate(propName, v0, sanitizer) {\r\n        ɵɵpropertyInterpolate1(propName, '', v0, '', sanitizer);\r\n        return ɵɵpropertyInterpolate;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated property on an element with single bound value surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 1 interpolated value in it:\r\n     *\r\n     * ```html\r\n     * <div title=\"prefix{{v0}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is::\r\n     *\r\n     * ```ts\r\n     * ɵɵpropertyInterpolate1('title', 'prefix', v0, 'suffix');\r\n     * ```\r\n     *\r\n     * If the property name also exists as an input property on one of the element's directives,\r\n     * the component property will be set instead of the element property. This check must\r\n     * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\r\n     *\r\n     * @param propName The name of the property to update\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param sanitizer An optional sanitizer function\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpropertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {\r\n        var index = getSelectedIndex();\r\n        var interpolatedValue = interpolation1(getLView(), prefix, v0, suffix);\r\n        if (interpolatedValue !== NO_CHANGE) {\r\n            elementPropertyInternal(index, propName, interpolatedValue, sanitizer);\r\n        }\r\n        return ɵɵpropertyInterpolate1;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated property on an element with 2 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 2 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div title=\"prefix{{v0}}-{{v1}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is::\r\n     *\r\n     * ```ts\r\n     * ɵɵpropertyInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\r\n     * ```\r\n     *\r\n     * If the property name also exists as an input property on one of the element's directives,\r\n     * the component property will be set instead of the element property. This check must\r\n     * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\r\n     *\r\n     * @param propName The name of the property to update\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param sanitizer An optional sanitizer function\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpropertyInterpolate2(propName, prefix, v0, i0, v1, suffix, sanitizer) {\r\n        var index = getSelectedIndex();\r\n        var interpolatedValue = interpolation2(getLView(), prefix, v0, i0, v1, suffix);\r\n        if (interpolatedValue !== NO_CHANGE) {\r\n            elementPropertyInternal(index, propName, interpolatedValue, sanitizer);\r\n        }\r\n        return ɵɵpropertyInterpolate2;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated property on an element with 3 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 3 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is::\r\n     *\r\n     * ```ts\r\n     * ɵɵpropertyInterpolate3(\r\n     * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\r\n     * ```\r\n     *\r\n     * If the property name also exists as an input property on one of the element's directives,\r\n     * the component property will be set instead of the element property. This check must\r\n     * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\r\n     *\r\n     * @param propName The name of the property to update\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param sanitizer An optional sanitizer function\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpropertyInterpolate3(propName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer) {\r\n        var index = getSelectedIndex();\r\n        var interpolatedValue = interpolation3(getLView(), prefix, v0, i0, v1, i1, v2, suffix);\r\n        if (interpolatedValue !== NO_CHANGE) {\r\n            elementPropertyInternal(index, propName, interpolatedValue, sanitizer);\r\n        }\r\n        return ɵɵpropertyInterpolate3;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated property on an element with 4 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 4 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is::\r\n     *\r\n     * ```ts\r\n     * ɵɵpropertyInterpolate4(\r\n     * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\r\n     * ```\r\n     *\r\n     * If the property name also exists as an input property on one of the element's directives,\r\n     * the component property will be set instead of the element property. This check must\r\n     * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\r\n     *\r\n     * @param propName The name of the property to update\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param sanitizer An optional sanitizer function\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpropertyInterpolate4(propName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer) {\r\n        var index = getSelectedIndex();\r\n        var interpolatedValue = interpolation4(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\r\n        if (interpolatedValue !== NO_CHANGE) {\r\n            elementPropertyInternal(index, propName, interpolatedValue, sanitizer);\r\n        }\r\n        return ɵɵpropertyInterpolate4;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated property on an element with 5 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 5 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is::\r\n     *\r\n     * ```ts\r\n     * ɵɵpropertyInterpolate5(\r\n     * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\r\n     * ```\r\n     *\r\n     * If the property name also exists as an input property on one of the element's directives,\r\n     * the component property will be set instead of the element property. This check must\r\n     * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\r\n     *\r\n     * @param propName The name of the property to update\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param i3 Static value used for concatenation only.\r\n     * @param v4 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param sanitizer An optional sanitizer function\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpropertyInterpolate5(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer) {\r\n        var index = getSelectedIndex();\r\n        var interpolatedValue = interpolation5(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\r\n        if (interpolatedValue !== NO_CHANGE) {\r\n            elementPropertyInternal(index, propName, interpolatedValue, sanitizer);\r\n        }\r\n        return ɵɵpropertyInterpolate5;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated property on an element with 6 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 6 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is::\r\n     *\r\n     * ```ts\r\n     * ɵɵpropertyInterpolate6(\r\n     *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\r\n     * ```\r\n     *\r\n     * If the property name also exists as an input property on one of the element's directives,\r\n     * the component property will be set instead of the element property. This check must\r\n     * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\r\n     *\r\n     * @param propName The name of the property to update\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param i3 Static value used for concatenation only.\r\n     * @param v4 Value checked for change.\r\n     * @param i4 Static value used for concatenation only.\r\n     * @param v5 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param sanitizer An optional sanitizer function\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpropertyInterpolate6(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer) {\r\n        var index = getSelectedIndex();\r\n        var interpolatedValue = interpolation6(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\r\n        if (interpolatedValue !== NO_CHANGE) {\r\n            elementPropertyInternal(index, propName, interpolatedValue, sanitizer);\r\n        }\r\n        return ɵɵpropertyInterpolate6;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated property on an element with 7 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 7 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is::\r\n     *\r\n     * ```ts\r\n     * ɵɵpropertyInterpolate7(\r\n     *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\r\n     * ```\r\n     *\r\n     * If the property name also exists as an input property on one of the element's directives,\r\n     * the component property will be set instead of the element property. This check must\r\n     * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\r\n     *\r\n     * @param propName The name of the property to update\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param i3 Static value used for concatenation only.\r\n     * @param v4 Value checked for change.\r\n     * @param i4 Static value used for concatenation only.\r\n     * @param v5 Value checked for change.\r\n     * @param i5 Static value used for concatenation only.\r\n     * @param v6 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param sanitizer An optional sanitizer function\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpropertyInterpolate7(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer) {\r\n        var index = getSelectedIndex();\r\n        var interpolatedValue = interpolation7(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\r\n        if (interpolatedValue !== NO_CHANGE) {\r\n            elementPropertyInternal(index, propName, interpolatedValue, sanitizer);\r\n        }\r\n        return ɵɵpropertyInterpolate7;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated property on an element with 8 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 8 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is::\r\n     *\r\n     * ```ts\r\n     * ɵɵpropertyInterpolate8(\r\n     *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\r\n     * ```\r\n     *\r\n     * If the property name also exists as an input property on one of the element's directives,\r\n     * the component property will be set instead of the element property. This check must\r\n     * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\r\n     *\r\n     * @param propName The name of the property to update\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param i3 Static value used for concatenation only.\r\n     * @param v4 Value checked for change.\r\n     * @param i4 Static value used for concatenation only.\r\n     * @param v5 Value checked for change.\r\n     * @param i5 Static value used for concatenation only.\r\n     * @param v6 Value checked for change.\r\n     * @param i6 Static value used for concatenation only.\r\n     * @param v7 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param sanitizer An optional sanitizer function\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpropertyInterpolate8(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer) {\r\n        var index = getSelectedIndex();\r\n        var interpolatedValue = interpolation8(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\r\n        if (interpolatedValue !== NO_CHANGE) {\r\n            elementPropertyInternal(index, propName, interpolatedValue, sanitizer);\r\n        }\r\n        return ɵɵpropertyInterpolate8;\r\n    }\r\n    /**\r\n     * Update an interpolated property on an element with 8 or more bound values surrounded by text.\r\n     *\r\n     * Used when the number of interpolated values exceeds 7.\r\n     *\r\n     * ```html\r\n     * <div\r\n     *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is::\r\n     *\r\n     * ```ts\r\n     * ɵɵpropertyInterpolateV(\r\n     *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\r\n     *  'suffix']);\r\n     * ```\r\n     *\r\n     * If the property name also exists as an input property on one of the element's directives,\r\n     * the component property will be set instead of the element property. This check must\r\n     * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\r\n     *\r\n     * @param propName The name of the property to update.\r\n     * @param values The a collection of values and the strings inbetween those values, beginning with a\r\n     * string prefix and ending with a string suffix.\r\n     * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\r\n     * @param sanitizer An optional sanitizer function\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpropertyInterpolateV(propName, values, sanitizer) {\r\n        var index = getSelectedIndex();\r\n        var interpolatedValue = interpolationV(getLView(), values);\r\n        if (interpolatedValue !== NO_CHANGE) {\r\n            elementPropertyInternal(index, propName, interpolatedValue, sanitizer);\r\n        }\r\n        return ɵɵpropertyInterpolateV;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Create static text node\r\n     *\r\n     * @param index Index of the node in the data array\r\n     * @param value Value to write. This value will be stringified.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵtext(index, value) {\r\n        var lView = getLView();\r\n        ngDevMode && assertEqual(lView[BINDING_INDEX], lView[TVIEW].bindingStartIndex, 'text nodes should be created before any bindings');\r\n        ngDevMode && ngDevMode.rendererCreateTextNode++;\r\n        ngDevMode && assertDataInRange(lView, index + HEADER_OFFSET);\r\n        var textNative = lView[index + HEADER_OFFSET] = createTextNode(value, lView[RENDERER]);\r\n        ngDevMode && ngDevMode.rendererSetText++;\r\n        var tNode = getOrCreateTNode(lView[TVIEW], lView[T_HOST], index, 3 /* Element */, null, null);\r\n        // Text nodes are self closing.\r\n        setIsNotParent();\r\n        appendChild(textNative, tNode, lView);\r\n    }\r\n    /**\r\n     * Create text node with binding\r\n     * Bindings should be handled externally with the proper interpolation(1-8) method\r\n     *\r\n     * @param value Stringified value to write.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵtextBinding(value) {\r\n        var lView = getLView();\r\n        var index = getSelectedIndex();\r\n        var bound = bind(lView, value);\r\n        if (bound !== NO_CHANGE) {\r\n            textBindingInternal(lView, index, renderStringify(bound));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     *\r\n     * Update text content with a lone bound value\r\n     *\r\n     * Used when a text node has 1 interpolated value in it, an no additional text\r\n     * surrounds that interpolated value:\r\n     *\r\n     * ```html\r\n     * <div>{{v0}}</div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵtextInterpolate(v0);\r\n     * ```\r\n     * @returns itself, so that it may be chained.\r\n     * @see textInterpolateV\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵtextInterpolate(v0) {\r\n        ɵɵtextInterpolate1('', v0, '');\r\n        return ɵɵtextInterpolate;\r\n    }\r\n    /**\r\n     *\r\n     * Update text content with single bound value surrounded by other text.\r\n     *\r\n     * Used when a text node has 1 interpolated value in it:\r\n     *\r\n     * ```html\r\n     * <div>prefix{{v0}}suffix</div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵtextInterpolate1('prefix', v0, 'suffix');\r\n     * ```\r\n     * @returns itself, so that it may be chained.\r\n     * @see textInterpolateV\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵtextInterpolate1(prefix, v0, suffix) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var interpolated = interpolation1(lView, prefix, v0, suffix);\r\n        if (interpolated !== NO_CHANGE) {\r\n            textBindingInternal(lView, index, interpolated);\r\n        }\r\n        return ɵɵtextInterpolate1;\r\n    }\r\n    /**\r\n     *\r\n     * Update text content with 2 bound values surrounded by other text.\r\n     *\r\n     * Used when a text node has 2 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div>prefix{{v0}}-{{v1}}suffix</div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵtextInterpolate2('prefix', v0, '-', v1, 'suffix');\r\n     * ```\r\n     * @returns itself, so that it may be chained.\r\n     * @see textInterpolateV\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵtextInterpolate2(prefix, v0, i0, v1, suffix) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);\r\n        if (interpolated !== NO_CHANGE) {\r\n            textBindingInternal(lView, index, interpolated);\r\n        }\r\n        return ɵɵtextInterpolate2;\r\n    }\r\n    /**\r\n     *\r\n     * Update text content with 3 bound values surrounded by other text.\r\n     *\r\n     * Used when a text node has 3 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div>prefix{{v0}}-{{v1}}-{{v2}}suffix</div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵtextInterpolate3(\r\n     * 'prefix', v0, '-', v1, '-', v2, 'suffix');\r\n     * ```\r\n     * @returns itself, so that it may be chained.\r\n     * @see textInterpolateV\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵtextInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\r\n        if (interpolated !== NO_CHANGE) {\r\n            textBindingInternal(lView, index, interpolated);\r\n        }\r\n        return ɵɵtextInterpolate3;\r\n    }\r\n    /**\r\n     *\r\n     * Update text content with 4 bound values surrounded by other text.\r\n     *\r\n     * Used when a text node has 4 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix</div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵtextInterpolate4(\r\n     * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\r\n     * ```\r\n     * @returns itself, so that it may be chained.\r\n     * @see ɵɵtextInterpolateV\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵtextInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\r\n        if (interpolated !== NO_CHANGE) {\r\n            textBindingInternal(lView, index, interpolated);\r\n        }\r\n        return ɵɵtextInterpolate4;\r\n    }\r\n    /**\r\n     *\r\n     * Update text content with 5 bound values surrounded by other text.\r\n     *\r\n     * Used when a text node has 5 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix</div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵtextInterpolate5(\r\n     * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\r\n     * ```\r\n     * @returns itself, so that it may be chained.\r\n     * @see textInterpolateV\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵtextInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\r\n        if (interpolated !== NO_CHANGE) {\r\n            textBindingInternal(lView, index, interpolated);\r\n        }\r\n        return ɵɵtextInterpolate5;\r\n    }\r\n    /**\r\n     *\r\n     * Update text content with 6 bound values surrounded by other text.\r\n     *\r\n     * Used when a text node has 6 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix</div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵtextInterpolate6(\r\n     *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\r\n     * ```\r\n     *\r\n     * @param i4 Static value used for concatenation only.\r\n     * @param v5 Value checked for change. @returns itself, so that it may be chained.\r\n     * @see textInterpolateV\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵtextInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\r\n        if (interpolated !== NO_CHANGE) {\r\n            textBindingInternal(lView, index, interpolated);\r\n        }\r\n        return ɵɵtextInterpolate6;\r\n    }\r\n    /**\r\n     *\r\n     * Update text content with 7 bound values surrounded by other text.\r\n     *\r\n     * Used when a text node has 7 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix</div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵtextInterpolate7(\r\n     *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\r\n     * ```\r\n     * @returns itself, so that it may be chained.\r\n     * @see textInterpolateV\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵtextInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\r\n        if (interpolated !== NO_CHANGE) {\r\n            textBindingInternal(lView, index, interpolated);\r\n        }\r\n        return ɵɵtextInterpolate7;\r\n    }\r\n    /**\r\n     *\r\n     * Update text content with 8 bound values surrounded by other text.\r\n     *\r\n     * Used when a text node has 8 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix</div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵtextInterpolate8(\r\n     *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\r\n     * ```\r\n     * @returns itself, so that it may be chained.\r\n     * @see textInterpolateV\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵtextInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\r\n        if (interpolated !== NO_CHANGE) {\r\n            textBindingInternal(lView, index, interpolated);\r\n        }\r\n        return ɵɵtextInterpolate8;\r\n    }\r\n    /**\r\n     * Update text content with 9 or more bound values other surrounded by text.\r\n     *\r\n     * Used when the number of interpolated values exceeds 8.\r\n     *\r\n     * ```html\r\n     * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix</div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵtextInterpolateV(\r\n     *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\r\n     *  'suffix']);\r\n     * ```\r\n     *.\r\n     * @param values The a collection of values and the strings in between those values, beginning with\r\n     * a string prefix and ending with a string suffix.\r\n     * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\r\n     *\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵtextInterpolateV(values) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        var interpolated = interpolationV(lView, values);\r\n        if (interpolated !== NO_CHANGE) {\r\n            textBindingInternal(lView, index, interpolated);\r\n        }\r\n        return ɵɵtextInterpolateV;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     *\r\n     * Update an interpolated class on an element with single bound value surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 1 interpolated value in it:\r\n     *\r\n     * ```html\r\n     * <div class=\"prefix{{v0}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵclassMapInterpolate1('prefix', v0, 'suffix');\r\n     * ```\r\n     *\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵclassMapInterpolate1(prefix, v0, suffix) {\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation1(lView, prefix, v0, suffix);\r\n        classMapInternal(getSelectedIndex(), interpolatedValue);\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated class on an element with 2 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 2 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div class=\"prefix{{v0}}-{{v1}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵclassMapInterpolate2('prefix', v0, '-', v1, 'suffix');\r\n     * ```\r\n     *\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵclassMapInterpolate2(prefix, v0, i0, v1, suffix) {\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\r\n        classMapInternal(getSelectedIndex(), interpolatedValue);\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated class on an element with 3 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 3 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵclassMapInterpolate3(\r\n     * 'prefix', v0, '-', v1, '-', v2, 'suffix');\r\n     * ```\r\n     *\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵclassMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\r\n        classMapInternal(getSelectedIndex(), interpolatedValue);\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated class on an element with 4 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 4 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵclassMapInterpolate4(\r\n     * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\r\n     * ```\r\n     *\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵclassMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\r\n        classMapInternal(getSelectedIndex(), interpolatedValue);\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated class on an element with 5 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 5 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵclassMapInterpolate5(\r\n     * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\r\n     * ```\r\n     *\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param i3 Static value used for concatenation only.\r\n     * @param v4 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵclassMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\r\n        classMapInternal(getSelectedIndex(), interpolatedValue);\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated class on an element with 6 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 6 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵclassMapInterpolate6(\r\n     *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\r\n     * ```\r\n     *\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param i3 Static value used for concatenation only.\r\n     * @param v4 Value checked for change.\r\n     * @param i4 Static value used for concatenation only.\r\n     * @param v5 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵclassMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\r\n        classMapInternal(getSelectedIndex(), interpolatedValue);\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated class on an element with 7 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 7 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵclassMapInterpolate7(\r\n     *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\r\n     * ```\r\n     *\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param i3 Static value used for concatenation only.\r\n     * @param v4 Value checked for change.\r\n     * @param i4 Static value used for concatenation only.\r\n     * @param v5 Value checked for change.\r\n     * @param i5 Static value used for concatenation only.\r\n     * @param v6 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵclassMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\r\n        classMapInternal(getSelectedIndex(), interpolatedValue);\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated class on an element with 8 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 8 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵclassMapInterpolate8(\r\n     *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\r\n     * ```\r\n     *\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param i3 Static value used for concatenation only.\r\n     * @param v4 Value checked for change.\r\n     * @param i4 Static value used for concatenation only.\r\n     * @param v5 Value checked for change.\r\n     * @param i5 Static value used for concatenation only.\r\n     * @param v6 Value checked for change.\r\n     * @param i6 Static value used for concatenation only.\r\n     * @param v7 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵclassMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\r\n        classMapInternal(getSelectedIndex(), interpolatedValue);\r\n    }\r\n    /**\r\n     * Update an interpolated class on an element with 8 or more bound values surrounded by text.\r\n     *\r\n     * Used when the number of interpolated values exceeds 7.\r\n     *\r\n     * ```html\r\n     * <div\r\n     *  class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵclassMapInterpolateV(\r\n     *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\r\n     *  'suffix']);\r\n     * ```\r\n     *.\r\n     * @param values The a collection of values and the strings in-between those values, beginning with\r\n     * a string prefix and ending with a string suffix.\r\n     * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵclassMapInterpolateV(values) {\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolationV(lView, values);\r\n        classMapInternal(getSelectedIndex(), interpolatedValue);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     *\r\n     * Update an interpolated style property on an element with single bound value surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 1 interpolated value in it:\r\n     *\r\n     * ```html\r\n     * <div style.color=\"prefix{{v0}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵstylePropInterpolate1(0, 'prefix', v0, 'suffix');\r\n     * ```\r\n     *\r\n     * @param styleIndex Index of style to update. This index value refers to the\r\n     *        index of the style in the style bindings array that was passed into\r\n     *        `styling`.\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵstylePropInterpolate1(prop, prefix, v0, suffix, valueSuffix) {\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation1(lView, prefix, v0, suffix);\r\n        stylePropInternal(getSelectedIndex(), prop, interpolatedValue, valueSuffix);\r\n        return ɵɵstylePropInterpolate1;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated style property on an element with 2 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 2 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div style.color=\"prefix{{v0}}-{{v1}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵstylePropInterpolate2(0, 'prefix', v0, '-', v1, 'suffix');\r\n     * ```\r\n     *\r\n     * @param styleIndex Index of style to update. This index value refers to the\r\n     *        index of the style in the style bindings array that was passed into\r\n     *        `styling`.\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵstylePropInterpolate2(prop, prefix, v0, i0, v1, suffix, valueSuffix) {\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\r\n        stylePropInternal(getSelectedIndex(), prop, interpolatedValue, valueSuffix);\r\n        return ɵɵstylePropInterpolate2;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated style property on an element with 3 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 3 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵstylePropInterpolate3(0, 'prefix', v0, '-', v1, '-', v2, 'suffix');\r\n     * ```\r\n     *\r\n     * @param styleIndex Index of style to update. This index value refers to the\r\n     *        index of the style in the style bindings array that was passed into\r\n     *        `styling`.\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵstylePropInterpolate3(prop, prefix, v0, i0, v1, i1, v2, suffix, valueSuffix) {\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\r\n        stylePropInternal(getSelectedIndex(), prop, interpolatedValue, valueSuffix);\r\n        return ɵɵstylePropInterpolate3;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated style property on an element with 4 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 4 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵstylePropInterpolate4(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\r\n     * ```\r\n     *\r\n     * @param styleIndex Index of style to update. This index value refers to the\r\n     *        index of the style in the style bindings array that was passed into\r\n     *        `styling`.\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵstylePropInterpolate4(prop, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, valueSuffix) {\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\r\n        stylePropInternal(getSelectedIndex(), prop, interpolatedValue, valueSuffix);\r\n        return ɵɵstylePropInterpolate4;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated style property on an element with 5 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 5 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵstylePropInterpolate5(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\r\n     * ```\r\n     *\r\n     * @param styleIndex Index of style to update. This index value refers to the\r\n     *        index of the style in the style bindings array that was passed into\r\n     *        `styling`.\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param i3 Static value used for concatenation only.\r\n     * @param v4 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵstylePropInterpolate5(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, valueSuffix) {\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\r\n        stylePropInternal(getSelectedIndex(), prop, interpolatedValue, valueSuffix);\r\n        return ɵɵstylePropInterpolate5;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated style property on an element with 6 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 6 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵstylePropInterpolate6(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\r\n     * ```\r\n     *\r\n     * @param styleIndex Index of style to update. This index value refers to the\r\n     *        index of the style in the style bindings array that was passed into\r\n     *        `styling`.\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param i3 Static value used for concatenation only.\r\n     * @param v4 Value checked for change.\r\n     * @param i4 Static value used for concatenation only.\r\n     * @param v5 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵstylePropInterpolate6(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, valueSuffix) {\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\r\n        stylePropInternal(getSelectedIndex(), prop, interpolatedValue, valueSuffix);\r\n        return ɵɵstylePropInterpolate6;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated style property on an element with 7 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 7 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵstylePropInterpolate7(\r\n     *    0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\r\n     * ```\r\n     *\r\n     * @param styleIndex Index of style to update. This index value refers to the\r\n     *        index of the style in the style bindings array that was passed into\r\n     *        `styling`.\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param i3 Static value used for concatenation only.\r\n     * @param v4 Value checked for change.\r\n     * @param i4 Static value used for concatenation only.\r\n     * @param v5 Value checked for change.\r\n     * @param i5 Static value used for concatenation only.\r\n     * @param v6 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵstylePropInterpolate7(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, valueSuffix) {\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\r\n        stylePropInternal(getSelectedIndex(), prop, interpolatedValue, valueSuffix);\r\n        return ɵɵstylePropInterpolate7;\r\n    }\r\n    /**\r\n     *\r\n     * Update an interpolated style property on an element with 8 bound values surrounded by text.\r\n     *\r\n     * Used when the value passed to a property has 8 interpolated values in it:\r\n     *\r\n     * ```html\r\n     * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵstylePropInterpolate8(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6,\r\n     * '-', v7, 'suffix');\r\n     * ```\r\n     *\r\n     * @param styleIndex Index of style to update. This index value refers to the\r\n     *        index of the style in the style bindings array that was passed into\r\n     *        `styling`.\r\n     * @param prefix Static value used for concatenation only.\r\n     * @param v0 Value checked for change.\r\n     * @param i0 Static value used for concatenation only.\r\n     * @param v1 Value checked for change.\r\n     * @param i1 Static value used for concatenation only.\r\n     * @param v2 Value checked for change.\r\n     * @param i2 Static value used for concatenation only.\r\n     * @param v3 Value checked for change.\r\n     * @param i3 Static value used for concatenation only.\r\n     * @param v4 Value checked for change.\r\n     * @param i4 Static value used for concatenation only.\r\n     * @param v5 Value checked for change.\r\n     * @param i5 Static value used for concatenation only.\r\n     * @param v6 Value checked for change.\r\n     * @param i6 Static value used for concatenation only.\r\n     * @param v7 Value checked for change.\r\n     * @param suffix Static value used for concatenation only.\r\n     * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵstylePropInterpolate8(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, valueSuffix) {\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\r\n        stylePropInternal(getSelectedIndex(), prop, interpolatedValue, valueSuffix);\r\n        return ɵɵstylePropInterpolate8;\r\n    }\r\n    /**\r\n     * Update an interpolated style property on an element with 8 or more bound values surrounded by\r\n     * text.\r\n     *\r\n     * Used when the number of interpolated values exceeds 7.\r\n     *\r\n     * ```html\r\n     * <div\r\n     *  style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\">\r\n     * </div>\r\n     * ```\r\n     *\r\n     * Its compiled representation is:\r\n     *\r\n     * ```ts\r\n     * ɵɵstylePropInterpolateV(\r\n     *  0, ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\r\n     *  'suffix']);\r\n     * ```\r\n     *\r\n     * @param styleIndex Index of style to update. This index value refers to the\r\n     *        index of the style in the style bindings array that was passed into\r\n     *        `styling`..\r\n     * @param values The a collection of values and the strings in-between those values, beginning with\r\n     * a string prefix and ending with a string suffix.\r\n     * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\r\n     * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\r\n     * @returns itself, so that it may be chained.\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵstylePropInterpolateV(prop, values, valueSuffix) {\r\n        var lView = getLView();\r\n        var interpolatedValue = interpolationV(lView, values);\r\n        stylePropInternal(getSelectedIndex(), prop, interpolatedValue, valueSuffix);\r\n        return ɵɵstylePropInterpolateV;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Update a property on a host element. Only applies to native node properties, not inputs.\r\n     *\r\n     * Operates on the element selected by index via the {@link select} instruction.\r\n     *\r\n     * @param propName Name of property. Because it is going to DOM, this is not subject to\r\n     *        renaming as part of minification.\r\n     * @param value New value to write.\r\n     * @param sanitizer An optional function used to sanitize the value.\r\n     * @returns This function returns itself so that it may be chained\r\n     * (e.g. `property('name', ctx.name)('title', ctx.title)`)\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵhostProperty(propName, value, sanitizer) {\r\n        var index = getSelectedIndex();\r\n        ngDevMode && assertNotEqual(index, -1, 'selected index cannot be -1');\r\n        var lView = getLView();\r\n        var bindReconciledValue = bind(lView, value);\r\n        if (bindReconciledValue !== NO_CHANGE) {\r\n            elementPropertyInternal(index, propName, bindReconciledValue, sanitizer, true);\r\n        }\r\n        return ɵɵhostProperty;\r\n    }\r\n    /**\r\n     * Updates a synthetic host binding (e.g. `[@foo]`) on a component.\r\n     *\r\n     * This instruction is for compatibility purposes and is designed to ensure that a\r\n     * synthetic host binding (e.g. `@HostBinding('@foo')`) properly gets rendered in\r\n     * the component's renderer. Normally all host bindings are evaluated with the parent\r\n     * component's renderer, but, in the case of animation @triggers, they need to be\r\n     * evaluated with the sub component's renderer (because that's where the animation\r\n     * triggers are defined).\r\n     *\r\n     * Do not use this instruction as a replacement for `elementProperty`. This instruction\r\n     * only exists to ensure compatibility with the ViewEngine's host binding behavior.\r\n     *\r\n     * @param index The index of the element to update in the data array\r\n     * @param propName Name of property. Because it is going to DOM, this is not subject to\r\n     *        renaming as part of minification.\r\n     * @param value New value to write.\r\n     * @param sanitizer An optional function used to sanitize the value.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵupdateSyntheticHostBinding(propName, value, sanitizer) {\r\n        var index = getSelectedIndex();\r\n        var lView = getLView();\r\n        // TODO(benlesh): remove bind call here.\r\n        var bound = bind(lView, value);\r\n        if (bound !== NO_CHANGE) {\r\n            elementPropertyInternal(index, propName, bound, sanitizer, true, loadComponentRenderer);\r\n        }\r\n        return ɵɵupdateSyntheticHostBinding;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Returns the component instance associated with a given DOM host element.\r\n     * Elements which don't represent components return `null`.\r\n     *\r\n     * @param element Host DOM element from which the component should be retrieved.\r\n     *\r\n     * ```\r\n     * <my-app>\r\n     *   #VIEW\r\n     *     <div>\r\n     *       <child-comp></child-comp>\r\n     *     </div>\r\n     * </mp-app>\r\n     *\r\n     * expect(getComponent(<child-comp>) instanceof ChildComponent).toBeTruthy();\r\n     * expect(getComponent(<my-app>) instanceof MyApp).toBeTruthy();\r\n     * ```\r\n     *\r\n     * @publicApi\r\n     */\r\n    function getComponent(element) {\r\n        var context = loadLContextFromNode(element);\r\n        if (context.component === undefined) {\r\n            context.component = getComponentAtNodeIndex(context.nodeIndex, context.lView);\r\n        }\r\n        return context.component;\r\n    }\r\n    /**\r\n     * Returns the component instance associated with a given DOM host element.\r\n     * Elements which don't represent components return `null`.\r\n     *\r\n     * @param element Host DOM element from which the component should be retrieved.\r\n     *\r\n     * ```\r\n     * <my-app>\r\n     *   #VIEW\r\n     *     <div>\r\n     *       <child-comp></child-comp>\r\n     *     </div>\r\n     * </mp-app>\r\n     *\r\n     * expect(getComponent(<child-comp>) instanceof ChildComponent).toBeTruthy();\r\n     * expect(getComponent(<my-app>) instanceof MyApp).toBeTruthy();\r\n     * ```\r\n     *\r\n     * @publicApi\r\n     */\r\n    function getContext$1(element) {\r\n        var context = loadLContextFromNode(element);\r\n        return context.lView[CONTEXT];\r\n    }\r\n    /**\r\n     * Returns the component instance associated with view which owns the DOM element (`null`\r\n     * otherwise).\r\n     *\r\n     * @param element DOM element which is owned by an existing component's view.\r\n     *\r\n     * ```\r\n     * <my-app>\r\n     *   #VIEW\r\n     *     <div>\r\n     *       <child-comp></child-comp>\r\n     *     </div>\r\n     * </mp-app>\r\n     *\r\n     * expect(getViewComponent(<child-comp>) instanceof MyApp).toBeTruthy();\r\n     * expect(getViewComponent(<my-app>)).toEqual(null);\r\n     * ```\r\n     *\r\n     * @publicApi\r\n     */\r\n    function getViewComponent(element) {\r\n        var context = loadLContext(element);\r\n        var lView = context.lView;\r\n        var parent;\r\n        ngDevMode && assertLView(lView);\r\n        while (lView[HOST] === null && (parent = getLViewParent(lView))) {\r\n            // As long as lView[HOST] is null we know we are part of sub-template such as `*ngIf`\r\n            lView = parent;\r\n        }\r\n        return lView[FLAGS] & 512 /* IsRoot */ ? null : lView[CONTEXT];\r\n    }\r\n    /**\r\n     * Retrieve all root components.\r\n     *\r\n     * Root components are those which have been bootstrapped by Angular.\r\n     *\r\n     * @param target A DOM element, component or directive instance.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function getRootComponents(target) {\r\n        return __spread(getRootContext(target).components);\r\n    }\r\n    /**\r\n     * Retrieves an `Injector` associated with the element, component or directive.\r\n     *\r\n     * @param target A DOM element, component or directive instance.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function getInjector(target) {\r\n        var context = loadLContext(target);\r\n        var tNode = context.lView[TVIEW].data[context.nodeIndex];\r\n        return new NodeInjector(tNode, context.lView);\r\n    }\r\n    /**\r\n     * Retrieve a set of injection tokens at a given DOM node.\r\n     *\r\n     * @param element Element for which the injection tokens should be retrieved.\r\n     * @publicApi\r\n     */\r\n    function getInjectionTokens(element) {\r\n        var context = loadLContext(element, false);\r\n        if (!context)\r\n            return [];\r\n        var lView = context.lView;\r\n        var tView = lView[TVIEW];\r\n        var tNode = tView.data[context.nodeIndex];\r\n        var providerTokens = [];\r\n        var startIndex = tNode.providerIndexes & 65535 /* ProvidersStartIndexMask */;\r\n        var endIndex = tNode.directiveEnd;\r\n        for (var i = startIndex; i < endIndex; i++) {\r\n            var value = tView.data[i];\r\n            if (isDirectiveDefHack(value)) {\r\n                // The fact that we sometimes store Type and sometimes DirectiveDef in this location is a\r\n                // design flaw.  We should always store same type so that we can be monomorphic. The issue\r\n                // is that for Components/Directives we store the def instead the type. The correct behavior\r\n                // is that we should always be storing injectable type in this location.\r\n                value = value.type;\r\n            }\r\n            providerTokens.push(value);\r\n        }\r\n        return providerTokens;\r\n    }\r\n    /**\r\n     * Retrieves directives associated with a given DOM host element.\r\n     *\r\n     * @param target A DOM element, component or directive instance.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function getDirectives(target) {\r\n        var context = loadLContext(target);\r\n        if (context.directives === undefined) {\r\n            context.directives = getDirectivesAtNodeIndex(context.nodeIndex, context.lView, false);\r\n        }\r\n        return context.directives || [];\r\n    }\r\n    function loadLContext(target, throwOnNotFound) {\r\n        if (throwOnNotFound === void 0) { throwOnNotFound = true; }\r\n        var context = getLContext(target);\r\n        if (!context && throwOnNotFound) {\r\n            throw new Error(ngDevMode ? \"Unable to find context associated with \" + stringifyForError(target) :\r\n                'Invalid ng target');\r\n        }\r\n        return context;\r\n    }\r\n    /**\r\n     * Retrieve map of local references.\r\n     *\r\n     * The references are retrieved as a map of local reference name to element or directive instance.\r\n     *\r\n     * @param target A DOM element, component or directive instance.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function getLocalRefs(target) {\r\n        var context = loadLContext(target);\r\n        if (context.localRefs === undefined) {\r\n            context.localRefs = discoverLocalRefs(context.lView, context.nodeIndex);\r\n        }\r\n        return context.localRefs || {};\r\n    }\r\n    /**\r\n     * Retrieve the host element of the component.\r\n     *\r\n     * Use this function to retrieve the host element of the component. The host\r\n     * element is the element which the component is associated with.\r\n     *\r\n     * @param directive Component or Directive for which the host element should be retrieved.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function getHostElement(directive) {\r\n        return getLContext(directive).native;\r\n    }\r\n    /**\r\n     * Retrieves the rendered text for a given component.\r\n     *\r\n     * This function retrieves the host element of a component and\r\n     * and then returns the `textContent` for that element. This implies\r\n     * that the text returned will include re-projected content of\r\n     * the component as well.\r\n     *\r\n     * @param component The component to return the content text for.\r\n     */\r\n    function getRenderedText(component) {\r\n        var hostElement = getHostElement(component);\r\n        return hostElement.textContent || '';\r\n    }\r\n    function loadLContextFromNode(node) {\r\n        if (!(node instanceof Node))\r\n            throw new Error('Expecting instance of DOM Node');\r\n        return loadLContext(node);\r\n    }\r\n    function isBrowserEvents(listener) {\r\n        // Browser events are those which don't have `useCapture` as boolean.\r\n        return typeof listener.useCapture === 'boolean';\r\n    }\r\n    /**\r\n     * Retrieves a list of DOM listeners.\r\n     *\r\n     * ```\r\n     * <my-app>\r\n     *   #VIEW\r\n     *     <div (click)=\"doSomething()\">\r\n     *     </div>\r\n     * </mp-app>\r\n     *\r\n     * expect(getListeners(<div>)).toEqual({\r\n     *   name: 'click',\r\n     *   element: <div>,\r\n     *   callback: () => doSomething(),\r\n     *   useCapture: false\r\n     * });\r\n     * ```\r\n     *\r\n     * @param element Element for which the DOM listeners should be retrieved.\r\n     * @publicApi\r\n     */\r\n    function getListeners(element) {\r\n        var lContext = loadLContextFromNode(element);\r\n        var lView = lContext.lView;\r\n        var tView = lView[TVIEW];\r\n        var lCleanup = lView[CLEANUP];\r\n        var tCleanup = tView.cleanup;\r\n        var listeners = [];\r\n        if (tCleanup && lCleanup) {\r\n            for (var i = 0; i < tCleanup.length;) {\r\n                var firstParam = tCleanup[i++];\r\n                var secondParam = tCleanup[i++];\r\n                if (typeof firstParam === 'string') {\r\n                    var name_1 = firstParam;\r\n                    var listenerElement = unwrapRNode(lView[secondParam]);\r\n                    var callback = lCleanup[tCleanup[i++]];\r\n                    var useCaptureOrIndx = tCleanup[i++];\r\n                    // if useCaptureOrIndx is boolean then report it as is.\r\n                    // if useCaptureOrIndx is positive number then it in unsubscribe method\r\n                    // if useCaptureOrIndx is negative number then it is a Subscription\r\n                    var useCapture = typeof useCaptureOrIndx === 'boolean' ?\r\n                        useCaptureOrIndx :\r\n                        (useCaptureOrIndx >= 0 ? false : null);\r\n                    if (element == listenerElement) {\r\n                        listeners.push({ element: element, name: name_1, callback: callback, useCapture: useCapture });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        listeners.sort(sortListeners);\r\n        return listeners;\r\n    }\r\n    function sortListeners(a, b) {\r\n        if (a.name == b.name)\r\n            return 0;\r\n        return a.name < b.name ? -1 : 1;\r\n    }\r\n    /**\r\n     * This function should not exist because it is megamorphic and only mostly correct.\r\n     *\r\n     * See call site for more info.\r\n     */\r\n    function isDirectiveDefHack(obj) {\r\n        return obj.type !== undefined && obj.template !== undefined && obj.declaredInputs !== undefined;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * This file introduces series of globally accessible debug tools\r\n     * to allow for the Angular debugging story to function.\r\n     *\r\n     * To see this in action run the following command:\r\n     *\r\n     *   bazel run --define=compile=aot\r\n     *   //packages/core/test/bundling/todo:devserver\r\n     *\r\n     *  Then load `localhost:5432` and start using the console tools.\r\n     */\r\n    /**\r\n     * This value reflects the property on the window where the dev\r\n     * tools are patched (window.ng).\r\n     * */\r\n    var GLOBAL_PUBLISH_EXPANDO_KEY = 'ng';\r\n    var _published = false;\r\n    /**\r\n     * Publishes a collection of default debug tools onto`window.ng`.\r\n     *\r\n     * These functions are available globally when Angular is in development\r\n     * mode and are automatically stripped away from prod mode is on.\r\n     */\r\n    function publishDefaultGlobalUtils() {\r\n        if (!_published) {\r\n            _published = true;\r\n            publishGlobalUtil('getComponent', getComponent);\r\n            publishGlobalUtil('getContext', getContext$1);\r\n            publishGlobalUtil('getListeners', getListeners);\r\n            publishGlobalUtil('getViewComponent', getViewComponent);\r\n            publishGlobalUtil('getHostElement', getHostElement);\r\n            publishGlobalUtil('getInjector', getInjector);\r\n            publishGlobalUtil('getRootComponents', getRootComponents);\r\n            publishGlobalUtil('getDirectives', getDirectives);\r\n            publishGlobalUtil('markDirty', markDirty);\r\n        }\r\n    }\r\n    /**\r\n     * Publishes the given function to `window.ng` so that it can be\r\n     * used from the browser console when an application is not in production.\r\n     */\r\n    function publishGlobalUtil(name, fn) {\r\n        var w = _global;\r\n        ngDevMode && assertDefined(fn, 'function not defined');\r\n        if (w) {\r\n            var container = w[GLOBAL_PUBLISH_EXPANDO_KEY];\r\n            if (!container) {\r\n                container = w[GLOBAL_PUBLISH_EXPANDO_KEY] = {};\r\n            }\r\n            container[name] = fn;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var ɵ0$c = function (token, notFoundValue) {\r\n        throw new Error('NullInjector: Not found: ' + stringifyForError(token));\r\n    };\r\n    // TODO: A hack to not pull in the NullInjector from @angular/core.\r\n    var NULL_INJECTOR$1 = {\r\n        get: ɵ0$c\r\n    };\r\n    /**\r\n     * Bootstraps a Component into an existing host element and returns an instance\r\n     * of the component.\r\n     *\r\n     * Use this function to bootstrap a component into the DOM tree. Each invocation\r\n     * of this function will create a separate tree of components, injectors and\r\n     * change detection cycles and lifetimes. To dynamically insert a new component\r\n     * into an existing tree such that it shares the same injection, change detection\r\n     * and object lifetime, use {@link ViewContainer#createComponent}.\r\n     *\r\n     * @param componentType Component to bootstrap\r\n     * @param options Optional parameters which control bootstrapping\r\n     */\r\n    function renderComponent(componentType /* Type as workaround for: Microsoft/TypeScript/issues/4881 */, opts) {\r\n        if (opts === void 0) { opts = {}; }\r\n        ngDevMode && publishDefaultGlobalUtils();\r\n        ngDevMode && assertComponentType(componentType);\r\n        // this is preemptively set to avoid having test and debug code accidentally\r\n        // read data from a previous application state...\r\n        setActiveHostElement(null);\r\n        var rendererFactory = opts.rendererFactory || domRendererFactory3;\r\n        var sanitizer = opts.sanitizer || null;\r\n        var componentDef = getComponentDef(componentType);\r\n        if (componentDef.type != componentType)\r\n            componentDef.type = componentType;\r\n        // The first index of the first selector is the tag name.\r\n        var componentTag = componentDef.selectors[0][0];\r\n        var hostRNode = locateHostElement(rendererFactory, opts.host || componentTag);\r\n        var rootFlags = componentDef.onPush ? 64 /* Dirty */ | 512 /* IsRoot */ :\r\n            16 /* CheckAlways */ | 512 /* IsRoot */;\r\n        var rootContext = createRootContext(opts.scheduler, opts.playerHandler);\r\n        var renderer = rendererFactory.createRenderer(hostRNode, componentDef);\r\n        var rootView = createLView(null, createTView(-1, null, 1, 0, null, null, null, null), rootContext, rootFlags, null, null, rendererFactory, renderer, undefined, opts.injector || null);\r\n        var oldView = enterView(rootView, null);\r\n        var component;\r\n        // Will become true if the `try` block executes with no errors.\r\n        var safeToRunHooks = false;\r\n        try {\r\n            if (rendererFactory.begin)\r\n                rendererFactory.begin();\r\n            var componentView = createRootComponentView(hostRNode, componentDef, rootView, rendererFactory, renderer, sanitizer);\r\n            component = createRootComponent(componentView, componentDef, rootView, rootContext, opts.hostFeatures || null);\r\n            addToViewTree(rootView, componentView);\r\n            refreshDescendantViews(rootView); // creation mode pass\r\n            rootView[FLAGS] &= ~4 /* CreationMode */;\r\n            resetPreOrderHookFlags(rootView);\r\n            refreshDescendantViews(rootView); // update mode pass\r\n            safeToRunHooks = true;\r\n        }\r\n        finally {\r\n            leaveView(oldView, safeToRunHooks);\r\n            if (rendererFactory.end)\r\n                rendererFactory.end();\r\n        }\r\n        return component;\r\n    }\r\n    /**\r\n     * Creates the root component view and the root component node.\r\n     *\r\n     * @param rNode Render host element.\r\n     * @param def ComponentDef\r\n     * @param rootView The parent view where the host node is stored\r\n     * @param renderer The current renderer\r\n     * @param sanitizer The sanitizer, if provided\r\n     *\r\n     * @returns Component view created\r\n     */\r\n    function createRootComponentView(rNode, def, rootView, rendererFactory, renderer, sanitizer) {\r\n        resetComponentState();\r\n        var tView = rootView[TVIEW];\r\n        ngDevMode && assertDataInRange(rootView, 0 + HEADER_OFFSET);\r\n        rootView[0 + HEADER_OFFSET] = rNode;\r\n        var tNode = getOrCreateTNode(tView, null, 0, 3 /* Element */, null, null);\r\n        var componentView = createLView(rootView, getOrCreateTView(def), null, def.onPush ? 64 /* Dirty */ : 16 /* CheckAlways */, rootView[HEADER_OFFSET], tNode, rendererFactory, renderer, sanitizer);\r\n        if (tView.firstTemplatePass) {\r\n            diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), tView, def.type);\r\n            tNode.flags = 1 /* isComponent */;\r\n            initNodeFlags(tNode, rootView.length, 1);\r\n            queueComponentIndexForCheck(tNode);\r\n        }\r\n        // Store component view at node index, with node as the HOST\r\n        return rootView[HEADER_OFFSET] = componentView;\r\n    }\r\n    /**\r\n     * Creates a root component and sets it up with features and host bindings. Shared by\r\n     * renderComponent() and ViewContainerRef.createComponent().\r\n     */\r\n    function createRootComponent(componentView, componentDef, rootView, rootContext, hostFeatures) {\r\n        var tView = rootView[TVIEW];\r\n        // Create directive instance with factory() and store at next index in viewData\r\n        var component = instantiateRootComponent(tView, rootView, componentDef);\r\n        rootContext.components.push(component);\r\n        componentView[CONTEXT] = component;\r\n        hostFeatures && hostFeatures.forEach(function (feature) { return feature(component, componentDef); });\r\n        // We want to generate an empty QueryList for root content queries for backwards\r\n        // compatibility with ViewEngine.\r\n        if (componentDef.contentQueries) {\r\n            componentDef.contentQueries(1 /* Create */, component, rootView.length - 1);\r\n        }\r\n        var rootTNode = getPreviousOrParentTNode();\r\n        if (tView.firstTemplatePass && componentDef.hostBindings) {\r\n            var elementIndex = rootTNode.index - HEADER_OFFSET;\r\n            setActiveHostElement(elementIndex);\r\n            var expando = tView.expandoInstructions;\r\n            invokeHostBindingsInCreationMode(componentDef, expando, component, rootTNode, tView.firstTemplatePass);\r\n            setActiveHostElement(null);\r\n        }\r\n        return component;\r\n    }\r\n    function createRootContext(scheduler, playerHandler) {\r\n        return {\r\n            components: [],\r\n            scheduler: scheduler || defaultScheduler,\r\n            clean: CLEAN_PROMISE,\r\n            playerHandler: playerHandler || null,\r\n            flags: 0 /* Empty */\r\n        };\r\n    }\r\n    /**\r\n     * Used to enable lifecycle hooks on the root component.\r\n     *\r\n     * Include this feature when calling `renderComponent` if the root component\r\n     * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't\r\n     * be called properly.\r\n     *\r\n     * Example:\r\n     *\r\n     * ```\r\n     * renderComponent(AppComponent, {features: [RootLifecycleHooks]});\r\n     * ```\r\n     */\r\n    function LifecycleHooksFeature(component, def) {\r\n        var rootTView = readPatchedLView(component)[TVIEW];\r\n        var dirIndex = rootTView.data.length - 1;\r\n        registerPreOrderHooks(dirIndex, def, rootTView, -1, -1, -1);\r\n        // TODO(misko): replace `as TNode` with createTNode call. (needs refactoring to lose dep on\r\n        // LNode).\r\n        registerPostOrderHooks(rootTView, { directiveStart: dirIndex, directiveEnd: dirIndex + 1 });\r\n    }\r\n    /**\r\n     * Wait on component until it is rendered.\r\n     *\r\n     * This function returns a `Promise` which is resolved when the component's\r\n     * change detection is executed. This is determined by finding the scheduler\r\n     * associated with the `component`'s render tree and waiting until the scheduler\r\n     * flushes. If nothing is scheduled, the function returns a resolved promise.\r\n     *\r\n     * Example:\r\n     * ```\r\n     * await whenRendered(myComponent);\r\n     * ```\r\n     *\r\n     * @param component Component to wait upon\r\n     * @returns Promise which resolves when the component is rendered.\r\n     */\r\n    function whenRendered(component) {\r\n        return getRootContext(component).clean;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Represents a basic change from a previous to a new value for a single\r\n     * property on a directive instance. Passed as a value in a\r\n     * {@link SimpleChanges} object to the `ngOnChanges` hook.\r\n     *\r\n     * @see `OnChanges`\r\n     *\r\n     * @publicApi\r\n     */\r\n    var SimpleChange = /** @class */ (function () {\r\n        function SimpleChange(previousValue, currentValue, firstChange) {\r\n            this.previousValue = previousValue;\r\n            this.currentValue = currentValue;\r\n            this.firstChange = firstChange;\r\n        }\r\n        /**\r\n         * Check whether the new value is the first value assigned.\r\n         */\r\n        SimpleChange.prototype.isFirstChange = function () { return this.firstChange; };\r\n        return SimpleChange;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var PRIVATE_PREFIX = '__ngOnChanges_';\r\n    /**\r\n     * The NgOnChangesFeature decorates a component with support for the ngOnChanges\r\n     * lifecycle hook, so it should be included in any component that implements\r\n     * that hook.\r\n     *\r\n     * If the component or directive uses inheritance, the NgOnChangesFeature MUST\r\n     * be included as a feature AFTER {@link InheritDefinitionFeature}, otherwise\r\n     * inherited properties will not be propagated to the ngOnChanges lifecycle\r\n     * hook.\r\n     *\r\n     * Example usage:\r\n     *\r\n     * ```\r\n     * static ngComponentDef = defineComponent({\r\n     *   ...\r\n     *   inputs: {name: 'publicName'},\r\n     *   features: [NgOnChangesFeature()]\r\n     * });\r\n     * ```\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵNgOnChangesFeature() {\r\n        // This option ensures that the ngOnChanges lifecycle hook will be inherited\r\n        // from superclasses (in InheritDefinitionFeature).\r\n        NgOnChangesFeatureImpl.ngInherit = true;\r\n        return NgOnChangesFeatureImpl;\r\n    }\r\n    function NgOnChangesFeatureImpl(definition) {\r\n        if (definition.type.prototype.ngOnChanges) {\r\n            definition.setInput = ngOnChangesSetInput;\r\n            definition.onChanges = wrapOnChanges();\r\n        }\r\n    }\r\n    function wrapOnChanges() {\r\n        return function wrapOnChangesHook_inPreviousChangesStorage() {\r\n            var simpleChangesStore = getSimpleChangesStore(this);\r\n            var current = simpleChangesStore && simpleChangesStore.current;\r\n            if (current) {\r\n                var previous = simpleChangesStore.previous;\r\n                if (previous === EMPTY_OBJ) {\r\n                    simpleChangesStore.previous = current;\r\n                }\r\n                else {\r\n                    // New changes are copied to the previous store, so that we don't lose history for inputs\r\n                    // which were not changed this time\r\n                    for (var key in current) {\r\n                        previous[key] = current[key];\r\n                    }\r\n                }\r\n                simpleChangesStore.current = null;\r\n                this.ngOnChanges(current);\r\n            }\r\n        };\r\n    }\r\n    function ngOnChangesSetInput(instance, value, publicName, privateName) {\r\n        var simpleChangesStore = getSimpleChangesStore(instance) ||\r\n            setSimpleChangesStore(instance, { previous: EMPTY_OBJ, current: null });\r\n        var current = simpleChangesStore.current || (simpleChangesStore.current = {});\r\n        var previous = simpleChangesStore.previous;\r\n        var declaredName = this.declaredInputs[publicName];\r\n        var previousChange = previous[declaredName];\r\n        current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);\r\n        instance[privateName] = value;\r\n    }\r\n    var SIMPLE_CHANGES_STORE = '__ngSimpleChanges__';\r\n    function getSimpleChangesStore(instance) {\r\n        return instance[SIMPLE_CHANGES_STORE] || null;\r\n    }\r\n    function setSimpleChangesStore(instance, store) {\r\n        return instance[SIMPLE_CHANGES_STORE] = store;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function getSuperType(type) {\r\n        return Object.getPrototypeOf(type.prototype).constructor;\r\n    }\r\n    /**\r\n     * Merges the definition from a super class to a sub class.\r\n     * @param definition The definition that is a SubClass of another directive of component\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵInheritDefinitionFeature(definition) {\r\n        var e_1, _a;\r\n        var superType = getSuperType(definition.type);\r\n        while (superType) {\r\n            var superDef = undefined;\r\n            if (isComponentDef(definition)) {\r\n                // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\r\n                superDef = superType.ngComponentDef || superType.ngDirectiveDef;\r\n            }\r\n            else {\r\n                if (superType.ngComponentDef) {\r\n                    throw new Error('Directives cannot inherit Components');\r\n                }\r\n                // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\r\n                superDef = superType.ngDirectiveDef;\r\n            }\r\n            var baseDef = superType.ngBaseDef;\r\n            // Some fields in the definition may be empty, if there were no values to put in them that\r\n            // would've justified object creation. Unwrap them if necessary.\r\n            if (baseDef || superDef) {\r\n                var writeableDef = definition;\r\n                writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);\r\n                writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);\r\n                writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);\r\n            }\r\n            if (baseDef) {\r\n                var baseViewQuery = baseDef.viewQuery;\r\n                var baseContentQueries = baseDef.contentQueries;\r\n                var baseHostBindings = baseDef.hostBindings;\r\n                baseHostBindings && inheritHostBindings(definition, baseHostBindings);\r\n                baseViewQuery && inheritViewQuery(definition, baseViewQuery);\r\n                baseContentQueries && inheritContentQueries(definition, baseContentQueries);\r\n                fillProperties(definition.inputs, baseDef.inputs);\r\n                fillProperties(definition.declaredInputs, baseDef.declaredInputs);\r\n                fillProperties(definition.outputs, baseDef.outputs);\r\n            }\r\n            if (superDef) {\r\n                // Merge hostBindings\r\n                var superHostBindings = superDef.hostBindings;\r\n                superHostBindings && inheritHostBindings(definition, superHostBindings);\r\n                // Merge queries\r\n                var superViewQuery = superDef.viewQuery;\r\n                var superContentQueries = superDef.contentQueries;\r\n                superViewQuery && inheritViewQuery(definition, superViewQuery);\r\n                superContentQueries && inheritContentQueries(definition, superContentQueries);\r\n                // Merge inputs and outputs\r\n                fillProperties(definition.inputs, superDef.inputs);\r\n                fillProperties(definition.declaredInputs, superDef.declaredInputs);\r\n                fillProperties(definition.outputs, superDef.outputs);\r\n                // Inherit hooks\r\n                // Assume super class inheritance feature has already run.\r\n                definition.afterContentChecked =\r\n                    definition.afterContentChecked || superDef.afterContentChecked;\r\n                definition.afterContentInit = definition.afterContentInit || superDef.afterContentInit;\r\n                definition.afterViewChecked = definition.afterViewChecked || superDef.afterViewChecked;\r\n                definition.afterViewInit = definition.afterViewInit || superDef.afterViewInit;\r\n                definition.doCheck = definition.doCheck || superDef.doCheck;\r\n                definition.onDestroy = definition.onDestroy || superDef.onDestroy;\r\n                definition.onInit = definition.onInit || superDef.onInit;\r\n                // Run parent features\r\n                var features = superDef.features;\r\n                if (features) {\r\n                    try {\r\n                        for (var features_1 = (e_1 = void 0, __values(features)), features_1_1 = features_1.next(); !features_1_1.done; features_1_1 = features_1.next()) {\r\n                            var feature = features_1_1.value;\r\n                            if (feature && feature.ngInherit) {\r\n                                feature(definition);\r\n                            }\r\n                        }\r\n                    }\r\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n                    finally {\r\n                        try {\r\n                            if (features_1_1 && !features_1_1.done && (_a = features_1.return)) _a.call(features_1);\r\n                        }\r\n                        finally { if (e_1) throw e_1.error; }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Even if we don't have a definition, check the type for the hooks and use those if need be\r\n                var superPrototype = superType.prototype;\r\n                if (superPrototype) {\r\n                    definition.afterContentChecked =\r\n                        definition.afterContentChecked || superPrototype.ngAfterContentChecked;\r\n                    definition.afterContentInit =\r\n                        definition.afterContentInit || superPrototype.ngAfterContentInit;\r\n                    definition.afterViewChecked =\r\n                        definition.afterViewChecked || superPrototype.ngAfterViewChecked;\r\n                    definition.afterViewInit = definition.afterViewInit || superPrototype.ngAfterViewInit;\r\n                    definition.doCheck = definition.doCheck || superPrototype.ngDoCheck;\r\n                    definition.onDestroy = definition.onDestroy || superPrototype.ngOnDestroy;\r\n                    definition.onInit = definition.onInit || superPrototype.ngOnInit;\r\n                    if (superPrototype.ngOnChanges) {\r\n                        ɵɵNgOnChangesFeature()(definition);\r\n                    }\r\n                }\r\n            }\r\n            superType = Object.getPrototypeOf(superType);\r\n        }\r\n    }\r\n    function maybeUnwrapEmpty(value) {\r\n        if (value === EMPTY_OBJ) {\r\n            return {};\r\n        }\r\n        else if (value === EMPTY_ARRAY) {\r\n            return [];\r\n        }\r\n        else {\r\n            return value;\r\n        }\r\n    }\r\n    function inheritViewQuery(definition, superViewQuery) {\r\n        var prevViewQuery = definition.viewQuery;\r\n        if (prevViewQuery) {\r\n            definition.viewQuery = function (rf, ctx) {\r\n                superViewQuery(rf, ctx);\r\n                prevViewQuery(rf, ctx);\r\n            };\r\n        }\r\n        else {\r\n            definition.viewQuery = superViewQuery;\r\n        }\r\n    }\r\n    function inheritContentQueries(definition, superContentQueries) {\r\n        var prevContentQueries = definition.contentQueries;\r\n        if (prevContentQueries) {\r\n            definition.contentQueries = function (rf, ctx, directiveIndex) {\r\n                superContentQueries(rf, ctx, directiveIndex);\r\n                prevContentQueries(rf, ctx, directiveIndex);\r\n            };\r\n        }\r\n        else {\r\n            definition.contentQueries = superContentQueries;\r\n        }\r\n    }\r\n    function inheritHostBindings(definition, superHostBindings) {\r\n        var prevHostBindings = definition.hostBindings;\r\n        // If the subclass does not have a host bindings function, we set the subclass host binding\r\n        // function to be the superclass's (in this feature). We should check if they're the same here\r\n        // to ensure we don't inherit it twice.\r\n        if (superHostBindings !== prevHostBindings) {\r\n            if (prevHostBindings) {\r\n                // because inheritance is unknown during compile time, the runtime code\r\n                // needs to be informed of the super-class depth so that instruction code\r\n                // can distinguish one host bindings function from another. The reason why\r\n                // relying on the directive uniqueId exclusively is not enough is because the\r\n                // uniqueId value and the directive instance stay the same between hostBindings\r\n                // calls throughout the directive inheritance chain. This means that without\r\n                // a super-class depth value, there is no way to know whether a parent or\r\n                // sub-class host bindings function is currently being executed.\r\n                definition.hostBindings = function (rf, ctx, elementIndex) {\r\n                    // The reason why we increment first and then decrement is so that parent\r\n                    // hostBindings calls have a higher id value compared to sub-class hostBindings\r\n                    // calls (this way the leaf directive is always at a super-class depth of 0).\r\n                    adjustActiveDirectiveSuperClassDepthPosition(1);\r\n                    try {\r\n                        superHostBindings(rf, ctx, elementIndex);\r\n                    }\r\n                    finally {\r\n                        adjustActiveDirectiveSuperClassDepthPosition(-1);\r\n                    }\r\n                    prevHostBindings(rf, ctx, elementIndex);\r\n                };\r\n            }\r\n            else {\r\n                definition.hostBindings = superHostBindings;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Resolves the providers which are defined in the DirectiveDef.\r\n     *\r\n     * When inserting the tokens and the factories in their respective arrays, we can assume that\r\n     * this method is called first for the component (if any), and then for other directives on the same\r\n     * node.\r\n     * As a consequence,the providers are always processed in that order:\r\n     * 1) The view providers of the component\r\n     * 2) The providers of the component\r\n     * 3) The providers of the other directives\r\n     * This matches the structure of the injectables arrays of a view (for each node).\r\n     * So the tokens and the factories can be pushed at the end of the arrays, except\r\n     * in one case for multi providers.\r\n     *\r\n     * @param def the directive definition\r\n     * @param providers: Array of `providers`.\r\n     * @param viewProviders: Array of `viewProviders`.\r\n     */\r\n    function providersResolver(def, providers, viewProviders) {\r\n        var lView = getLView();\r\n        var tView = lView[TVIEW];\r\n        if (tView.firstTemplatePass) {\r\n            var isComponent = isComponentDef(def);\r\n            // The list of view providers is processed first, and the flags are updated\r\n            resolveProvider$1(viewProviders, tView.data, tView.blueprint, isComponent, true);\r\n            // Then, the list of providers is processed, and the flags are updated\r\n            resolveProvider$1(providers, tView.data, tView.blueprint, isComponent, false);\r\n        }\r\n    }\r\n    /**\r\n     * Resolves a provider and publishes it to the DI system.\r\n     */\r\n    function resolveProvider$1(provider, tInjectables, lInjectablesBlueprint, isComponent, isViewProvider) {\r\n        provider = resolveForwardRef(provider);\r\n        if (Array.isArray(provider)) {\r\n            // Recursively call `resolveProvider`\r\n            // Recursion is OK in this case because this code will not be in hot-path once we implement\r\n            // cloning of the initial state.\r\n            for (var i = 0; i < provider.length; i++) {\r\n                resolveProvider$1(provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider);\r\n            }\r\n        }\r\n        else {\r\n            var lView = getLView();\r\n            var tView = lView[TVIEW];\r\n            var token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);\r\n            var providerFactory = providerToFactory(provider);\r\n            var tNode = getPreviousOrParentTNode();\r\n            var beginIndex = tNode.providerIndexes & 65535 /* ProvidersStartIndexMask */;\r\n            var endIndex = tNode.directiveStart;\r\n            var cptViewProvidersCount = tNode.providerIndexes >> 16 /* CptViewProvidersCountShift */;\r\n            if (isClassProvider(provider) || isTypeProvider(provider)) {\r\n                var prototype = (provider.useClass || provider).prototype;\r\n                var ngOnDestroy = prototype.ngOnDestroy;\r\n                if (ngOnDestroy) {\r\n                    (tView.destroyHooks || (tView.destroyHooks = [])).push(tInjectables.length, ngOnDestroy);\r\n                }\r\n            }\r\n            if (isTypeProvider(provider) || !provider.multi) {\r\n                // Single provider case: the factory is created and pushed immediately\r\n                var factory = new NodeInjectorFactory(providerFactory, isViewProvider, ɵɵdirectiveInject);\r\n                var existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);\r\n                if (existingFactoryIndex == -1) {\r\n                    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);\r\n                    tInjectables.push(token);\r\n                    tNode.directiveStart++;\r\n                    tNode.directiveEnd++;\r\n                    if (isViewProvider) {\r\n                        tNode.providerIndexes += 65536 /* CptViewProvidersCountShifter */;\r\n                    }\r\n                    lInjectablesBlueprint.push(factory);\r\n                    lView.push(factory);\r\n                }\r\n                else {\r\n                    lInjectablesBlueprint[existingFactoryIndex] = factory;\r\n                    lView[existingFactoryIndex] = factory;\r\n                }\r\n            }\r\n            else {\r\n                // Multi provider case:\r\n                // We create a multi factory which is going to aggregate all the values.\r\n                // Since the output of such a factory depends on content or view injection,\r\n                // we create two of them, which are linked together.\r\n                //\r\n                // The first one (for view providers) is always in the first block of the injectables array,\r\n                // and the second one (for providers) is always in the second block.\r\n                // This is important because view providers have higher priority. When a multi token\r\n                // is being looked up, the view providers should be found first.\r\n                // Note that it is not possible to have a multi factory in the third block (directive block).\r\n                //\r\n                // The algorithm to process multi providers is as follows:\r\n                // 1) If the multi provider comes from the `viewProviders` of the component:\r\n                //   a) If the special view providers factory doesn't exist, it is created and pushed.\r\n                //   b) Else, the multi provider is added to the existing multi factory.\r\n                // 2) If the multi provider comes from the `providers` of the component or of another\r\n                // directive:\r\n                //   a) If the multi factory doesn't exist, it is created and provider pushed into it.\r\n                //      It is also linked to the multi factory for view providers, if it exists.\r\n                //   b) Else, the multi provider is added to the existing multi factory.\r\n                var existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);\r\n                var existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);\r\n                var doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 &&\r\n                    lInjectablesBlueprint[existingProvidersFactoryIndex];\r\n                var doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 &&\r\n                    lInjectablesBlueprint[existingViewProvidersFactoryIndex];\r\n                if (isViewProvider && !doesViewProvidersFactoryExist ||\r\n                    !isViewProvider && !doesProvidersFactoryExist) {\r\n                    // Cases 1.a and 2.a\r\n                    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);\r\n                    var factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory);\r\n                    if (!isViewProvider && doesViewProvidersFactoryExist) {\r\n                        lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;\r\n                    }\r\n                    tInjectables.push(token);\r\n                    tNode.directiveStart++;\r\n                    tNode.directiveEnd++;\r\n                    if (isViewProvider) {\r\n                        tNode.providerIndexes += 65536 /* CptViewProvidersCountShifter */;\r\n                    }\r\n                    lInjectablesBlueprint.push(factory);\r\n                    lView.push(factory);\r\n                }\r\n                else {\r\n                    // Cases 1.b and 2.b\r\n                    multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent);\r\n                }\r\n                if (!isViewProvider && isComponent && doesViewProvidersFactoryExist) {\r\n                    lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Add a factory in a multi factory.\r\n     */\r\n    function multiFactoryAdd(multiFactory, factory, isComponentProvider) {\r\n        multiFactory.multi.push(factory);\r\n        if (isComponentProvider) {\r\n            multiFactory.componentProviders++;\r\n        }\r\n    }\r\n    /**\r\n     * Returns the index of item in the array, but only in the begin to end range.\r\n     */\r\n    function indexOf(item, arr, begin, end) {\r\n        for (var i = begin; i < end; i++) {\r\n            if (arr[i] === item)\r\n                return i;\r\n        }\r\n        return -1;\r\n    }\r\n    /**\r\n     * Use this with `multi` `providers`.\r\n     */\r\n    function multiProvidersFactoryResolver(_, tData, lData, tNode) {\r\n        return multiResolve(this.multi, []);\r\n    }\r\n    /**\r\n     * Use this with `multi` `viewProviders`.\r\n     *\r\n     * This factory knows how to concatenate itself with the existing `multi` `providers`.\r\n     */\r\n    function multiViewProvidersFactoryResolver(_, tData, lData, tNode) {\r\n        var factories = this.multi;\r\n        var result;\r\n        if (this.providerFactory) {\r\n            var componentCount = this.providerFactory.componentProviders;\r\n            var multiProviders = getNodeInjectable(tData, lData, this.providerFactory.index, tNode);\r\n            // Copy the section of the array which contains `multi` `providers` from the component\r\n            result = multiProviders.slice(0, componentCount);\r\n            // Insert the `viewProvider` instances.\r\n            multiResolve(factories, result);\r\n            // Copy the section of the array which contains `multi` `providers` from other directives\r\n            for (var i = componentCount; i < multiProviders.length; i++) {\r\n                result.push(multiProviders[i]);\r\n            }\r\n        }\r\n        else {\r\n            result = [];\r\n            // Insert the `viewProvider` instances.\r\n            multiResolve(factories, result);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Maps an array of factories into an array of values.\r\n     */\r\n    function multiResolve(factories, result) {\r\n        for (var i = 0; i < factories.length; i++) {\r\n            var factory = factories[i];\r\n            result.push(factory());\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a multi factory.\r\n     */\r\n    function multiFactory(factoryFn, index, isViewProvider, isComponent, f) {\r\n        var factory = new NodeInjectorFactory(factoryFn, isViewProvider, ɵɵdirectiveInject);\r\n        factory.multi = [];\r\n        factory.index = index;\r\n        factory.componentProviders = 0;\r\n        multiFactoryAdd(factory, f, isComponent && !isViewProvider);\r\n        return factory;\r\n    }\r\n\r\n    /**\r\n     * This feature resolves the providers of a directive (or component),\r\n     * and publish them into the DI system, making it visible to others for injection.\r\n     *\r\n     * For example:\r\n     * ```ts\r\n     * class ComponentWithProviders {\r\n     *   constructor(private greeter: GreeterDE) {}\r\n     *\r\n     *   static ngComponentDef = defineComponent({\r\n     *     type: ComponentWithProviders,\r\n     *     selectors: [['component-with-providers']],\r\n     *    factory: () => new ComponentWithProviders(directiveInject(GreeterDE as any)),\r\n     *    consts: 1,\r\n     *    vars: 1,\r\n     *    template: function(fs: RenderFlags, ctx: ComponentWithProviders) {\r\n     *      if (fs & RenderFlags.Create) {\r\n     *        ɵɵtext(0);\r\n     *      }\r\n     *      if (fs & RenderFlags.Update) {\r\n     *        ɵɵselect(0);\r\n     *        ɵɵtextBinding(ctx.greeter.greet());\r\n     *      }\r\n     *    },\r\n     *    features: [ProvidersFeature([GreeterDE])]\r\n     *  });\r\n     * }\r\n     * ```\r\n     *\r\n     * @param definition\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵProvidersFeature(providers, viewProviders) {\r\n        if (viewProviders === void 0) { viewProviders = []; }\r\n        return function (definition) {\r\n            definition.providersResolver =\r\n                function (def, processProvidersFn) {\r\n                    return providersResolver(def, //\r\n                    processProvidersFn ? processProvidersFn(providers) : providers, //\r\n                    viewProviders);\r\n                };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Represents a component created by a `ComponentFactory`.\r\n     * Provides access to the component instance and related objects,\r\n     * and provides the means of destroying the instance.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var ComponentRef = /** @class */ (function () {\r\n        function ComponentRef() {\r\n        }\r\n        return ComponentRef;\r\n    }());\r\n    /**\r\n     * Base class for a factory that can create a component dynamically.\r\n     * Instantiate a factory for a given type of component with `resolveComponentFactory()`.\r\n     * Use the resulting `ComponentFactory.create()` method to create a component of that type.\r\n     *\r\n     * @see [Dynamic Components](guide/dynamic-component-loader)\r\n     *\r\n     * @publicApi\r\n     */\r\n    var ComponentFactory = /** @class */ (function () {\r\n        function ComponentFactory() {\r\n        }\r\n        return ComponentFactory;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function noComponentFactoryError(component) {\r\n        var error = Error(\"No component factory found for \" + stringify(component) + \". Did you add it to @NgModule.entryComponents?\");\r\n        error[ERROR_COMPONENT] = component;\r\n        return error;\r\n    }\r\n    var ERROR_COMPONENT = 'ngComponent';\r\n    function getComponent$1(error) {\r\n        return error[ERROR_COMPONENT];\r\n    }\r\n    var _NullComponentFactoryResolver = /** @class */ (function () {\r\n        function _NullComponentFactoryResolver() {\r\n        }\r\n        _NullComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {\r\n            throw noComponentFactoryError(component);\r\n        };\r\n        return _NullComponentFactoryResolver;\r\n    }());\r\n    /**\r\n     * A simple registry that maps `Components` to generated `ComponentFactory` classes\r\n     * that can be used to create instances of components.\r\n     * Use to obtain the factory for a given component type,\r\n     * then use the factory's `create()` method to create a component of that type.\r\n     *\r\n     * @see [Dynamic Components](guide/dynamic-component-loader)\r\n     * @publicApi\r\n     */\r\n    var ComponentFactoryResolver = /** @class */ (function () {\r\n        function ComponentFactoryResolver() {\r\n        }\r\n        ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();\r\n        return ComponentFactoryResolver;\r\n    }());\r\n    var CodegenComponentFactoryResolver = /** @class */ (function () {\r\n        function CodegenComponentFactoryResolver(factories, _parent, _ngModule) {\r\n            this._parent = _parent;\r\n            this._ngModule = _ngModule;\r\n            this._factories = new Map();\r\n            for (var i = 0; i < factories.length; i++) {\r\n                var factory = factories[i];\r\n                this._factories.set(factory.componentType, factory);\r\n            }\r\n        }\r\n        CodegenComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {\r\n            var factory = this._factories.get(component);\r\n            if (!factory && this._parent) {\r\n                factory = this._parent.resolveComponentFactory(component);\r\n            }\r\n            if (!factory) {\r\n                throw noComponentFactoryError(component);\r\n            }\r\n            return new ComponentFactoryBoundToModule(factory, this._ngModule);\r\n        };\r\n        return CodegenComponentFactoryResolver;\r\n    }());\r\n    var ComponentFactoryBoundToModule = /** @class */ (function (_super) {\r\n        __extends(ComponentFactoryBoundToModule, _super);\r\n        function ComponentFactoryBoundToModule(factory, ngModule) {\r\n            var _this = _super.call(this) || this;\r\n            _this.factory = factory;\r\n            _this.ngModule = ngModule;\r\n            _this.selector = factory.selector;\r\n            _this.componentType = factory.componentType;\r\n            _this.ngContentSelectors = factory.ngContentSelectors;\r\n            _this.inputs = factory.inputs;\r\n            _this.outputs = factory.outputs;\r\n            return _this;\r\n        }\r\n        ComponentFactoryBoundToModule.prototype.create = function (injector, projectableNodes, rootSelectorOrNode, ngModule) {\r\n            return this.factory.create(injector, projectableNodes, rootSelectorOrNode, ngModule || this.ngModule);\r\n        };\r\n        return ComponentFactoryBoundToModule;\r\n    }(ComponentFactory));\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function noop() {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        // Do nothing.\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * A wrapper around a native element inside of a View.\r\n     *\r\n     * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\r\n     * element.\r\n     *\r\n     * @security Permitting direct access to the DOM can make your application more vulnerable to\r\n     * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the\r\n     * [Security Guide](http://g.co/ng/security).\r\n     *\r\n     * @publicApi\r\n     */\r\n    // Note: We don't expose things like `Injector`, `ViewContainer`, ... here,\r\n    // i.e. users have to ask for what they need. With that, we can build better analysis tools\r\n    // and could do better codegen in the future.\r\n    var ElementRef = /** @class */ (function () {\r\n        function ElementRef(nativeElement) {\r\n            this.nativeElement = nativeElement;\r\n        }\r\n        /**\r\n         * @internal\r\n         * @nocollapse\r\n         */\r\n        ElementRef.__NG_ELEMENT_ID__ = function () { return SWITCH_ELEMENT_REF_FACTORY(ElementRef); };\r\n        return ElementRef;\r\n    }());\r\n    var SWITCH_ELEMENT_REF_FACTORY__POST_R3__ = injectElementRef;\r\n    var SWITCH_ELEMENT_REF_FACTORY__PRE_R3__ = noop;\r\n    var SWITCH_ELEMENT_REF_FACTORY = SWITCH_ELEMENT_REF_FACTORY__PRE_R3__;\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * @deprecated Use `RendererType2` (and `Renderer2`) instead.\r\n     * @publicApi\r\n     */\r\n    var RenderComponentType = /** @class */ (function () {\r\n        function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles, animations) {\r\n            this.id = id;\r\n            this.templateUrl = templateUrl;\r\n            this.slotCount = slotCount;\r\n            this.encapsulation = encapsulation;\r\n            this.styles = styles;\r\n            this.animations = animations;\r\n        }\r\n        return RenderComponentType;\r\n    }());\r\n    /**\r\n     * @deprecated Debug info is handled internally in the view engine now.\r\n     */\r\n    var RenderDebugInfo = /** @class */ (function () {\r\n        function RenderDebugInfo() {\r\n        }\r\n        return RenderDebugInfo;\r\n    }());\r\n    /**\r\n     * @deprecated Use the `Renderer2` instead.\r\n     * @publicApi\r\n     */\r\n    var Renderer = /** @class */ (function () {\r\n        function Renderer() {\r\n        }\r\n        return Renderer;\r\n    }());\r\n    var Renderer2Interceptor = new InjectionToken('Renderer2Interceptor');\r\n    /**\r\n     * Injectable service that provides a low-level interface for modifying the UI.\r\n     *\r\n     * Use this service to bypass Angular's templating and make custom UI changes that can't be\r\n     * expressed declaratively. For example if you need to set a property or an attribute whose name is\r\n     * not statically known, use {@link Renderer#setElementProperty setElementProperty} or\r\n     * {@link Renderer#setElementAttribute setElementAttribute} respectively.\r\n     *\r\n     * If you are implementing a custom renderer, you must implement this interface.\r\n     *\r\n     * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.\r\n     *\r\n     * @deprecated Use `RendererFactory2` instead.\r\n     * @publicApi\r\n     */\r\n    var RootRenderer = /** @class */ (function () {\r\n        function RootRenderer() {\r\n        }\r\n        return RootRenderer;\r\n    }());\r\n    /**\r\n     * Creates and initializes a custom renderer that implements the `Renderer2` base class.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var RendererFactory2 = /** @class */ (function () {\r\n        function RendererFactory2() {\r\n        }\r\n        return RendererFactory2;\r\n    }());\r\n    (function (RendererStyleFlags2) {\r\n        /**\r\n         * Marks a style as important.\r\n         */\r\n        RendererStyleFlags2[RendererStyleFlags2[\"Important\"] = 1] = \"Important\";\r\n        /**\r\n         * Marks a style as using dash case naming (this-is-dash-case).\r\n         */\r\n        RendererStyleFlags2[RendererStyleFlags2[\"DashCase\"] = 2] = \"DashCase\";\r\n    })(exports.RendererStyleFlags2 || (exports.RendererStyleFlags2 = {}));\r\n    /**\r\n     * Extend this base class to implement custom rendering. By default, Angular\r\n     * renders a template into DOM. You can use custom rendering to intercept\r\n     * rendering calls, or to render to something other than DOM.\r\n     *\r\n     * Create your custom renderer using `RendererFactory2`.\r\n     *\r\n     * Use a custom renderer to bypass Angular's templating and\r\n     * make custom UI changes that can't be expressed declaratively.\r\n     * For example if you need to set a property or an attribute whose name is\r\n     * not statically known, use the `setProperty()` or\r\n     * `setAttribute()` method.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var Renderer2 = /** @class */ (function () {\r\n        function Renderer2() {\r\n        }\r\n        /**\r\n         * @internal\r\n         * @nocollapse\r\n         */\r\n        Renderer2.__NG_ELEMENT_ID__ = function () { return SWITCH_RENDERER2_FACTORY(); };\r\n        return Renderer2;\r\n    }());\r\n    var SWITCH_RENDERER2_FACTORY__POST_R3__ = injectRenderer2;\r\n    var SWITCH_RENDERER2_FACTORY__PRE_R3__ = noop;\r\n    var SWITCH_RENDERER2_FACTORY = SWITCH_RENDERER2_FACTORY__PRE_R3__;\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * @description Represents the version of Angular\r\n     *\r\n     * @publicApi\r\n     */\r\n    var Version = /** @class */ (function () {\r\n        function Version(full) {\r\n            this.full = full;\r\n            this.major = full.split('.')[0];\r\n            this.minor = full.split('.')[1];\r\n            this.patch = full.split('.').slice(2).join('.');\r\n        }\r\n        return Version;\r\n    }());\r\n    /**\r\n     * @publicApi\r\n     */\r\n    var VERSION = new Version('8.2.14');\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var DefaultIterableDifferFactory = /** @class */ (function () {\r\n        function DefaultIterableDifferFactory() {\r\n        }\r\n        DefaultIterableDifferFactory.prototype.supports = function (obj) { return isListLikeIterable$1(obj); };\r\n        DefaultIterableDifferFactory.prototype.create = function (trackByFn) {\r\n            return new DefaultIterableDiffer(trackByFn);\r\n        };\r\n        return DefaultIterableDifferFactory;\r\n    }());\r\n    var trackByIdentity = function (index, item) { return item; };\r\n    var ɵ0$d = trackByIdentity;\r\n    /**\r\n     * @deprecated v4.0.0 - Should not be part of public API.\r\n     * @publicApi\r\n     */\r\n    var DefaultIterableDiffer = /** @class */ (function () {\r\n        function DefaultIterableDiffer(trackByFn) {\r\n            this.length = 0;\r\n            // Keeps track of the used records at any point in time (during & across `_check()` calls)\r\n            this._linkedRecords = null;\r\n            // Keeps track of the removed records at any point in time during `_check()` calls.\r\n            this._unlinkedRecords = null;\r\n            this._previousItHead = null;\r\n            this._itHead = null;\r\n            this._itTail = null;\r\n            this._additionsHead = null;\r\n            this._additionsTail = null;\r\n            this._movesHead = null;\r\n            this._movesTail = null;\r\n            this._removalsHead = null;\r\n            this._removalsTail = null;\r\n            // Keeps track of records where custom track by is the same, but item identity has changed\r\n            this._identityChangesHead = null;\r\n            this._identityChangesTail = null;\r\n            this._trackByFn = trackByFn || trackByIdentity;\r\n        }\r\n        DefaultIterableDiffer.prototype.forEachItem = function (fn) {\r\n            var record;\r\n            for (record = this._itHead; record !== null; record = record._next) {\r\n                fn(record);\r\n            }\r\n        };\r\n        DefaultIterableDiffer.prototype.forEachOperation = function (fn) {\r\n            var nextIt = this._itHead;\r\n            var nextRemove = this._removalsHead;\r\n            var addRemoveOffset = 0;\r\n            var moveOffsets = null;\r\n            while (nextIt || nextRemove) {\r\n                // Figure out which is the next record to process\r\n                // Order: remove, add, move\r\n                var record = !nextRemove ||\r\n                    nextIt &&\r\n                        nextIt.currentIndex <\r\n                            getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?\r\n                    nextIt :\r\n                    nextRemove;\r\n                var adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);\r\n                var currentIndex = record.currentIndex;\r\n                // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary\r\n                if (record === nextRemove) {\r\n                    addRemoveOffset--;\r\n                    nextRemove = nextRemove._nextRemoved;\r\n                }\r\n                else {\r\n                    nextIt = nextIt._next;\r\n                    if (record.previousIndex == null) {\r\n                        addRemoveOffset++;\r\n                    }\r\n                    else {\r\n                        // INVARIANT:  currentIndex < previousIndex\r\n                        if (!moveOffsets)\r\n                            moveOffsets = [];\r\n                        var localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;\r\n                        var localCurrentIndex = currentIndex - addRemoveOffset;\r\n                        if (localMovePreviousIndex != localCurrentIndex) {\r\n                            for (var i = 0; i < localMovePreviousIndex; i++) {\r\n                                var offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);\r\n                                var index = offset + i;\r\n                                if (localCurrentIndex <= index && index < localMovePreviousIndex) {\r\n                                    moveOffsets[i] = offset + 1;\r\n                                }\r\n                            }\r\n                            var previousIndex = record.previousIndex;\r\n                            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;\r\n                        }\r\n                    }\r\n                }\r\n                if (adjPreviousIndex !== currentIndex) {\r\n                    fn(record, adjPreviousIndex, currentIndex);\r\n                }\r\n            }\r\n        };\r\n        DefaultIterableDiffer.prototype.forEachPreviousItem = function (fn) {\r\n            var record;\r\n            for (record = this._previousItHead; record !== null; record = record._nextPrevious) {\r\n                fn(record);\r\n            }\r\n        };\r\n        DefaultIterableDiffer.prototype.forEachAddedItem = function (fn) {\r\n            var record;\r\n            for (record = this._additionsHead; record !== null; record = record._nextAdded) {\r\n                fn(record);\r\n            }\r\n        };\r\n        DefaultIterableDiffer.prototype.forEachMovedItem = function (fn) {\r\n            var record;\r\n            for (record = this._movesHead; record !== null; record = record._nextMoved) {\r\n                fn(record);\r\n            }\r\n        };\r\n        DefaultIterableDiffer.prototype.forEachRemovedItem = function (fn) {\r\n            var record;\r\n            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\r\n                fn(record);\r\n            }\r\n        };\r\n        DefaultIterableDiffer.prototype.forEachIdentityChange = function (fn) {\r\n            var record;\r\n            for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {\r\n                fn(record);\r\n            }\r\n        };\r\n        DefaultIterableDiffer.prototype.diff = function (collection) {\r\n            if (collection == null)\r\n                collection = [];\r\n            if (!isListLikeIterable$1(collection)) {\r\n                throw new Error(\"Error trying to diff '\" + stringify(collection) + \"'. Only arrays and iterables are allowed\");\r\n            }\r\n            if (this.check(collection)) {\r\n                return this;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        };\r\n        DefaultIterableDiffer.prototype.onDestroy = function () { };\r\n        DefaultIterableDiffer.prototype.check = function (collection) {\r\n            var _this = this;\r\n            this._reset();\r\n            var record = this._itHead;\r\n            var mayBeDirty = false;\r\n            var index;\r\n            var item;\r\n            var itemTrackBy;\r\n            if (Array.isArray(collection)) {\r\n                this.length = collection.length;\r\n                for (var index_1 = 0; index_1 < this.length; index_1++) {\r\n                    item = collection[index_1];\r\n                    itemTrackBy = this._trackByFn(index_1, item);\r\n                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {\r\n                        record = this._mismatch(record, item, itemTrackBy, index_1);\r\n                        mayBeDirty = true;\r\n                    }\r\n                    else {\r\n                        if (mayBeDirty) {\r\n                            // TODO(misko): can we limit this to duplicates only?\r\n                            record = this._verifyReinsertion(record, item, itemTrackBy, index_1);\r\n                        }\r\n                        if (!looseIdentical(record.item, item))\r\n                            this._addIdentityChange(record, item);\r\n                    }\r\n                    record = record._next;\r\n                }\r\n            }\r\n            else {\r\n                index = 0;\r\n                iterateListLike$1(collection, function (item) {\r\n                    itemTrackBy = _this._trackByFn(index, item);\r\n                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {\r\n                        record = _this._mismatch(record, item, itemTrackBy, index);\r\n                        mayBeDirty = true;\r\n                    }\r\n                    else {\r\n                        if (mayBeDirty) {\r\n                            // TODO(misko): can we limit this to duplicates only?\r\n                            record = _this._verifyReinsertion(record, item, itemTrackBy, index);\r\n                        }\r\n                        if (!looseIdentical(record.item, item))\r\n                            _this._addIdentityChange(record, item);\r\n                    }\r\n                    record = record._next;\r\n                    index++;\r\n                });\r\n                this.length = index;\r\n            }\r\n            this._truncate(record);\r\n            this.collection = collection;\r\n            return this.isDirty;\r\n        };\r\n        Object.defineProperty(DefaultIterableDiffer.prototype, \"isDirty\", {\r\n            /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity\r\n             * changes.\r\n             */\r\n            get: function () {\r\n                return this._additionsHead !== null || this._movesHead !== null ||\r\n                    this._removalsHead !== null || this._identityChangesHead !== null;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * Reset the state of the change objects to show no changes. This means set previousKey to\r\n         * currentKey, and clear all of the queues (additions, moves, removals).\r\n         * Set the previousIndexes of moved and added items to their currentIndexes\r\n         * Reset the list of additions, moves and removals\r\n         *\r\n         * @internal\r\n         */\r\n        DefaultIterableDiffer.prototype._reset = function () {\r\n            if (this.isDirty) {\r\n                var record = void 0;\r\n                var nextRecord = void 0;\r\n                for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {\r\n                    record._nextPrevious = record._next;\r\n                }\r\n                for (record = this._additionsHead; record !== null; record = record._nextAdded) {\r\n                    record.previousIndex = record.currentIndex;\r\n                }\r\n                this._additionsHead = this._additionsTail = null;\r\n                for (record = this._movesHead; record !== null; record = nextRecord) {\r\n                    record.previousIndex = record.currentIndex;\r\n                    nextRecord = record._nextMoved;\r\n                }\r\n                this._movesHead = this._movesTail = null;\r\n                this._removalsHead = this._removalsTail = null;\r\n                this._identityChangesHead = this._identityChangesTail = null;\r\n                // TODO(vicb): when assert gets supported\r\n                // assert(!this.isDirty);\r\n            }\r\n        };\r\n        /**\r\n         * This is the core function which handles differences between collections.\r\n         *\r\n         * - `record` is the record which we saw at this position last time. If null then it is a new\r\n         *   item.\r\n         * - `item` is the current item in the collection\r\n         * - `index` is the position of the item in the collection\r\n         *\r\n         * @internal\r\n         */\r\n        DefaultIterableDiffer.prototype._mismatch = function (record, item, itemTrackBy, index) {\r\n            // The previous record after which we will append the current one.\r\n            var previousRecord;\r\n            if (record === null) {\r\n                previousRecord = this._itTail;\r\n            }\r\n            else {\r\n                previousRecord = record._prev;\r\n                // Remove the record from the collection since we know it does not match the item.\r\n                this._remove(record);\r\n            }\r\n            // Attempt to see if we have seen the item before.\r\n            record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);\r\n            if (record !== null) {\r\n                // We have seen this before, we need to move it forward in the collection.\r\n                // But first we need to check if identity changed, so we can update in view if necessary\r\n                if (!looseIdentical(record.item, item))\r\n                    this._addIdentityChange(record, item);\r\n                this._moveAfter(record, previousRecord, index);\r\n            }\r\n            else {\r\n                // Never seen it, check evicted list.\r\n                record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);\r\n                if (record !== null) {\r\n                    // It is an item which we have evicted earlier: reinsert it back into the list.\r\n                    // But first we need to check if identity changed, so we can update in view if necessary\r\n                    if (!looseIdentical(record.item, item))\r\n                        this._addIdentityChange(record, item);\r\n                    this._reinsertAfter(record, previousRecord, index);\r\n                }\r\n                else {\r\n                    // It is a new item: add it.\r\n                    record =\r\n                        this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);\r\n                }\r\n            }\r\n            return record;\r\n        };\r\n        /**\r\n         * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)\r\n         *\r\n         * Use case: `[a, a]` => `[b, a, a]`\r\n         *\r\n         * If we did not have this check then the insertion of `b` would:\r\n         *   1) evict first `a`\r\n         *   2) insert `b` at `0` index.\r\n         *   3) leave `a` at index `1` as is. <-- this is wrong!\r\n         *   3) reinsert `a` at index 2. <-- this is wrong!\r\n         *\r\n         * The correct behavior is:\r\n         *   1) evict first `a`\r\n         *   2) insert `b` at `0` index.\r\n         *   3) reinsert `a` at index 1.\r\n         *   3) move `a` at from `1` to `2`.\r\n         *\r\n         *\r\n         * Double check that we have not evicted a duplicate item. We need to check if the item type may\r\n         * have already been removed:\r\n         * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted\r\n         * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a\r\n         * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'\r\n         * at the end.\r\n         *\r\n         * @internal\r\n         */\r\n        DefaultIterableDiffer.prototype._verifyReinsertion = function (record, item, itemTrackBy, index) {\r\n            var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);\r\n            if (reinsertRecord !== null) {\r\n                record = this._reinsertAfter(reinsertRecord, record._prev, index);\r\n            }\r\n            else if (record.currentIndex != index) {\r\n                record.currentIndex = index;\r\n                this._addToMoves(record, index);\r\n            }\r\n            return record;\r\n        };\r\n        /**\r\n         * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection\r\n         *\r\n         * - `record` The first excess {@link IterableChangeRecord_}.\r\n         *\r\n         * @internal\r\n         */\r\n        DefaultIterableDiffer.prototype._truncate = function (record) {\r\n            // Anything after that needs to be removed;\r\n            while (record !== null) {\r\n                var nextRecord = record._next;\r\n                this._addToRemovals(this._unlink(record));\r\n                record = nextRecord;\r\n            }\r\n            if (this._unlinkedRecords !== null) {\r\n                this._unlinkedRecords.clear();\r\n            }\r\n            if (this._additionsTail !== null) {\r\n                this._additionsTail._nextAdded = null;\r\n            }\r\n            if (this._movesTail !== null) {\r\n                this._movesTail._nextMoved = null;\r\n            }\r\n            if (this._itTail !== null) {\r\n                this._itTail._next = null;\r\n            }\r\n            if (this._removalsTail !== null) {\r\n                this._removalsTail._nextRemoved = null;\r\n            }\r\n            if (this._identityChangesTail !== null) {\r\n                this._identityChangesTail._nextIdentityChange = null;\r\n            }\r\n        };\r\n        /** @internal */\r\n        DefaultIterableDiffer.prototype._reinsertAfter = function (record, prevRecord, index) {\r\n            if (this._unlinkedRecords !== null) {\r\n                this._unlinkedRecords.remove(record);\r\n            }\r\n            var prev = record._prevRemoved;\r\n            var next = record._nextRemoved;\r\n            if (prev === null) {\r\n                this._removalsHead = next;\r\n            }\r\n            else {\r\n                prev._nextRemoved = next;\r\n            }\r\n            if (next === null) {\r\n                this._removalsTail = prev;\r\n            }\r\n            else {\r\n                next._prevRemoved = prev;\r\n            }\r\n            this._insertAfter(record, prevRecord, index);\r\n            this._addToMoves(record, index);\r\n            return record;\r\n        };\r\n        /** @internal */\r\n        DefaultIterableDiffer.prototype._moveAfter = function (record, prevRecord, index) {\r\n            this._unlink(record);\r\n            this._insertAfter(record, prevRecord, index);\r\n            this._addToMoves(record, index);\r\n            return record;\r\n        };\r\n        /** @internal */\r\n        DefaultIterableDiffer.prototype._addAfter = function (record, prevRecord, index) {\r\n            this._insertAfter(record, prevRecord, index);\r\n            if (this._additionsTail === null) {\r\n                // TODO(vicb):\r\n                // assert(this._additionsHead === null);\r\n                this._additionsTail = this._additionsHead = record;\r\n            }\r\n            else {\r\n                // TODO(vicb):\r\n                // assert(_additionsTail._nextAdded === null);\r\n                // assert(record._nextAdded === null);\r\n                this._additionsTail = this._additionsTail._nextAdded = record;\r\n            }\r\n            return record;\r\n        };\r\n        /** @internal */\r\n        DefaultIterableDiffer.prototype._insertAfter = function (record, prevRecord, index) {\r\n            // TODO(vicb):\r\n            // assert(record != prevRecord);\r\n            // assert(record._next === null);\r\n            // assert(record._prev === null);\r\n            var next = prevRecord === null ? this._itHead : prevRecord._next;\r\n            // TODO(vicb):\r\n            // assert(next != record);\r\n            // assert(prevRecord != record);\r\n            record._next = next;\r\n            record._prev = prevRecord;\r\n            if (next === null) {\r\n                this._itTail = record;\r\n            }\r\n            else {\r\n                next._prev = record;\r\n            }\r\n            if (prevRecord === null) {\r\n                this._itHead = record;\r\n            }\r\n            else {\r\n                prevRecord._next = record;\r\n            }\r\n            if (this._linkedRecords === null) {\r\n                this._linkedRecords = new _DuplicateMap();\r\n            }\r\n            this._linkedRecords.put(record);\r\n            record.currentIndex = index;\r\n            return record;\r\n        };\r\n        /** @internal */\r\n        DefaultIterableDiffer.prototype._remove = function (record) {\r\n            return this._addToRemovals(this._unlink(record));\r\n        };\r\n        /** @internal */\r\n        DefaultIterableDiffer.prototype._unlink = function (record) {\r\n            if (this._linkedRecords !== null) {\r\n                this._linkedRecords.remove(record);\r\n            }\r\n            var prev = record._prev;\r\n            var next = record._next;\r\n            // TODO(vicb):\r\n            // assert((record._prev = null) === null);\r\n            // assert((record._next = null) === null);\r\n            if (prev === null) {\r\n                this._itHead = next;\r\n            }\r\n            else {\r\n                prev._next = next;\r\n            }\r\n            if (next === null) {\r\n                this._itTail = prev;\r\n            }\r\n            else {\r\n                next._prev = prev;\r\n            }\r\n            return record;\r\n        };\r\n        /** @internal */\r\n        DefaultIterableDiffer.prototype._addToMoves = function (record, toIndex) {\r\n            // TODO(vicb):\r\n            // assert(record._nextMoved === null);\r\n            if (record.previousIndex === toIndex) {\r\n                return record;\r\n            }\r\n            if (this._movesTail === null) {\r\n                // TODO(vicb):\r\n                // assert(_movesHead === null);\r\n                this._movesTail = this._movesHead = record;\r\n            }\r\n            else {\r\n                // TODO(vicb):\r\n                // assert(_movesTail._nextMoved === null);\r\n                this._movesTail = this._movesTail._nextMoved = record;\r\n            }\r\n            return record;\r\n        };\r\n        DefaultIterableDiffer.prototype._addToRemovals = function (record) {\r\n            if (this._unlinkedRecords === null) {\r\n                this._unlinkedRecords = new _DuplicateMap();\r\n            }\r\n            this._unlinkedRecords.put(record);\r\n            record.currentIndex = null;\r\n            record._nextRemoved = null;\r\n            if (this._removalsTail === null) {\r\n                // TODO(vicb):\r\n                // assert(_removalsHead === null);\r\n                this._removalsTail = this._removalsHead = record;\r\n                record._prevRemoved = null;\r\n            }\r\n            else {\r\n                // TODO(vicb):\r\n                // assert(_removalsTail._nextRemoved === null);\r\n                // assert(record._nextRemoved === null);\r\n                record._prevRemoved = this._removalsTail;\r\n                this._removalsTail = this._removalsTail._nextRemoved = record;\r\n            }\r\n            return record;\r\n        };\r\n        /** @internal */\r\n        DefaultIterableDiffer.prototype._addIdentityChange = function (record, item) {\r\n            record.item = item;\r\n            if (this._identityChangesTail === null) {\r\n                this._identityChangesTail = this._identityChangesHead = record;\r\n            }\r\n            else {\r\n                this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;\r\n            }\r\n            return record;\r\n        };\r\n        return DefaultIterableDiffer;\r\n    }());\r\n    var IterableChangeRecord_ = /** @class */ (function () {\r\n        function IterableChangeRecord_(item, trackById) {\r\n            this.item = item;\r\n            this.trackById = trackById;\r\n            this.currentIndex = null;\r\n            this.previousIndex = null;\r\n            /** @internal */\r\n            this._nextPrevious = null;\r\n            /** @internal */\r\n            this._prev = null;\r\n            /** @internal */\r\n            this._next = null;\r\n            /** @internal */\r\n            this._prevDup = null;\r\n            /** @internal */\r\n            this._nextDup = null;\r\n            /** @internal */\r\n            this._prevRemoved = null;\r\n            /** @internal */\r\n            this._nextRemoved = null;\r\n            /** @internal */\r\n            this._nextAdded = null;\r\n            /** @internal */\r\n            this._nextMoved = null;\r\n            /** @internal */\r\n            this._nextIdentityChange = null;\r\n        }\r\n        return IterableChangeRecord_;\r\n    }());\r\n    // A linked list of CollectionChangeRecords with the same IterableChangeRecord_.item\r\n    var _DuplicateItemRecordList = /** @class */ (function () {\r\n        function _DuplicateItemRecordList() {\r\n            /** @internal */\r\n            this._head = null;\r\n            /** @internal */\r\n            this._tail = null;\r\n        }\r\n        /**\r\n         * Append the record to the list of duplicates.\r\n         *\r\n         * Note: by design all records in the list of duplicates hold the same value in record.item.\r\n         */\r\n        _DuplicateItemRecordList.prototype.add = function (record) {\r\n            if (this._head === null) {\r\n                this._head = this._tail = record;\r\n                record._nextDup = null;\r\n                record._prevDup = null;\r\n            }\r\n            else {\r\n                // TODO(vicb):\r\n                // assert(record.item ==  _head.item ||\r\n                //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);\r\n                this._tail._nextDup = record;\r\n                record._prevDup = this._tail;\r\n                record._nextDup = null;\r\n                this._tail = record;\r\n            }\r\n        };\r\n        // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and\r\n        // IterableChangeRecord_.currentIndex >= atOrAfterIndex\r\n        _DuplicateItemRecordList.prototype.get = function (trackById, atOrAfterIndex) {\r\n            var record;\r\n            for (record = this._head; record !== null; record = record._nextDup) {\r\n                if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) &&\r\n                    looseIdentical(record.trackById, trackById)) {\r\n                    return record;\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        /**\r\n         * Remove one {@link IterableChangeRecord_} from the list of duplicates.\r\n         *\r\n         * Returns whether the list of duplicates is empty.\r\n         */\r\n        _DuplicateItemRecordList.prototype.remove = function (record) {\r\n            // TODO(vicb):\r\n            // assert(() {\r\n            //  // verify that the record being removed is in the list.\r\n            //  for (IterableChangeRecord_ cursor = _head; cursor != null; cursor = cursor._nextDup) {\r\n            //    if (identical(cursor, record)) return true;\r\n            //  }\r\n            //  return false;\r\n            //});\r\n            var prev = record._prevDup;\r\n            var next = record._nextDup;\r\n            if (prev === null) {\r\n                this._head = next;\r\n            }\r\n            else {\r\n                prev._nextDup = next;\r\n            }\r\n            if (next === null) {\r\n                this._tail = prev;\r\n            }\r\n            else {\r\n                next._prevDup = prev;\r\n            }\r\n            return this._head === null;\r\n        };\r\n        return _DuplicateItemRecordList;\r\n    }());\r\n    var _DuplicateMap = /** @class */ (function () {\r\n        function _DuplicateMap() {\r\n            this.map = new Map();\r\n        }\r\n        _DuplicateMap.prototype.put = function (record) {\r\n            var key = record.trackById;\r\n            var duplicates = this.map.get(key);\r\n            if (!duplicates) {\r\n                duplicates = new _DuplicateItemRecordList();\r\n                this.map.set(key, duplicates);\r\n            }\r\n            duplicates.add(record);\r\n        };\r\n        /**\r\n         * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we\r\n         * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.\r\n         *\r\n         * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we\r\n         * have any more `a`s needs to return the second `a`.\r\n         */\r\n        _DuplicateMap.prototype.get = function (trackById, atOrAfterIndex) {\r\n            var key = trackById;\r\n            var recordList = this.map.get(key);\r\n            return recordList ? recordList.get(trackById, atOrAfterIndex) : null;\r\n        };\r\n        /**\r\n         * Removes a {@link IterableChangeRecord_} from the list of duplicates.\r\n         *\r\n         * The list of duplicates also is removed from the map if it gets empty.\r\n         */\r\n        _DuplicateMap.prototype.remove = function (record) {\r\n            var key = record.trackById;\r\n            var recordList = this.map.get(key);\r\n            // Remove the list of duplicates when it gets empty\r\n            if (recordList.remove(record)) {\r\n                this.map.delete(key);\r\n            }\r\n            return record;\r\n        };\r\n        Object.defineProperty(_DuplicateMap.prototype, \"isEmpty\", {\r\n            get: function () { return this.map.size === 0; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        _DuplicateMap.prototype.clear = function () { this.map.clear(); };\r\n        return _DuplicateMap;\r\n    }());\r\n    function getPreviousIndex(item, addRemoveOffset, moveOffsets) {\r\n        var previousIndex = item.previousIndex;\r\n        if (previousIndex === null)\r\n            return previousIndex;\r\n        var moveOffset = 0;\r\n        if (moveOffsets && previousIndex < moveOffsets.length) {\r\n            moveOffset = moveOffsets[previousIndex];\r\n        }\r\n        return previousIndex + addRemoveOffset + moveOffset;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var DefaultKeyValueDifferFactory = /** @class */ (function () {\r\n        function DefaultKeyValueDifferFactory() {\r\n        }\r\n        DefaultKeyValueDifferFactory.prototype.supports = function (obj) { return obj instanceof Map || isJsObject$1(obj); };\r\n        DefaultKeyValueDifferFactory.prototype.create = function () { return new DefaultKeyValueDiffer(); };\r\n        return DefaultKeyValueDifferFactory;\r\n    }());\r\n    var DefaultKeyValueDiffer = /** @class */ (function () {\r\n        function DefaultKeyValueDiffer() {\r\n            this._records = new Map();\r\n            this._mapHead = null;\r\n            // _appendAfter is used in the check loop\r\n            this._appendAfter = null;\r\n            this._previousMapHead = null;\r\n            this._changesHead = null;\r\n            this._changesTail = null;\r\n            this._additionsHead = null;\r\n            this._additionsTail = null;\r\n            this._removalsHead = null;\r\n            this._removalsTail = null;\r\n        }\r\n        Object.defineProperty(DefaultKeyValueDiffer.prototype, \"isDirty\", {\r\n            get: function () {\r\n                return this._additionsHead !== null || this._changesHead !== null ||\r\n                    this._removalsHead !== null;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        DefaultKeyValueDiffer.prototype.forEachItem = function (fn) {\r\n            var record;\r\n            for (record = this._mapHead; record !== null; record = record._next) {\r\n                fn(record);\r\n            }\r\n        };\r\n        DefaultKeyValueDiffer.prototype.forEachPreviousItem = function (fn) {\r\n            var record;\r\n            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {\r\n                fn(record);\r\n            }\r\n        };\r\n        DefaultKeyValueDiffer.prototype.forEachChangedItem = function (fn) {\r\n            var record;\r\n            for (record = this._changesHead; record !== null; record = record._nextChanged) {\r\n                fn(record);\r\n            }\r\n        };\r\n        DefaultKeyValueDiffer.prototype.forEachAddedItem = function (fn) {\r\n            var record;\r\n            for (record = this._additionsHead; record !== null; record = record._nextAdded) {\r\n                fn(record);\r\n            }\r\n        };\r\n        DefaultKeyValueDiffer.prototype.forEachRemovedItem = function (fn) {\r\n            var record;\r\n            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\r\n                fn(record);\r\n            }\r\n        };\r\n        DefaultKeyValueDiffer.prototype.diff = function (map) {\r\n            if (!map) {\r\n                map = new Map();\r\n            }\r\n            else if (!(map instanceof Map || isJsObject$1(map))) {\r\n                throw new Error(\"Error trying to diff '\" + stringify(map) + \"'. Only maps and objects are allowed\");\r\n            }\r\n            return this.check(map) ? this : null;\r\n        };\r\n        DefaultKeyValueDiffer.prototype.onDestroy = function () { };\r\n        /**\r\n         * Check the current state of the map vs the previous.\r\n         * The algorithm is optimised for when the keys do no change.\r\n         */\r\n        DefaultKeyValueDiffer.prototype.check = function (map) {\r\n            var _this = this;\r\n            this._reset();\r\n            var insertBefore = this._mapHead;\r\n            this._appendAfter = null;\r\n            this._forEach(map, function (value, key) {\r\n                if (insertBefore && insertBefore.key === key) {\r\n                    _this._maybeAddToChanges(insertBefore, value);\r\n                    _this._appendAfter = insertBefore;\r\n                    insertBefore = insertBefore._next;\r\n                }\r\n                else {\r\n                    var record = _this._getOrCreateRecordForKey(key, value);\r\n                    insertBefore = _this._insertBeforeOrAppend(insertBefore, record);\r\n                }\r\n            });\r\n            // Items remaining at the end of the list have been deleted\r\n            if (insertBefore) {\r\n                if (insertBefore._prev) {\r\n                    insertBefore._prev._next = null;\r\n                }\r\n                this._removalsHead = insertBefore;\r\n                for (var record = insertBefore; record !== null; record = record._nextRemoved) {\r\n                    if (record === this._mapHead) {\r\n                        this._mapHead = null;\r\n                    }\r\n                    this._records.delete(record.key);\r\n                    record._nextRemoved = record._next;\r\n                    record.previousValue = record.currentValue;\r\n                    record.currentValue = null;\r\n                    record._prev = null;\r\n                    record._next = null;\r\n                }\r\n            }\r\n            // Make sure tails have no next records from previous runs\r\n            if (this._changesTail)\r\n                this._changesTail._nextChanged = null;\r\n            if (this._additionsTail)\r\n                this._additionsTail._nextAdded = null;\r\n            return this.isDirty;\r\n        };\r\n        /**\r\n         * Inserts a record before `before` or append at the end of the list when `before` is null.\r\n         *\r\n         * Notes:\r\n         * - This method appends at `this._appendAfter`,\r\n         * - This method updates `this._appendAfter`,\r\n         * - The return value is the new value for the insertion pointer.\r\n         */\r\n        DefaultKeyValueDiffer.prototype._insertBeforeOrAppend = function (before, record) {\r\n            if (before) {\r\n                var prev = before._prev;\r\n                record._next = before;\r\n                record._prev = prev;\r\n                before._prev = record;\r\n                if (prev) {\r\n                    prev._next = record;\r\n                }\r\n                if (before === this._mapHead) {\r\n                    this._mapHead = record;\r\n                }\r\n                this._appendAfter = before;\r\n                return before;\r\n            }\r\n            if (this._appendAfter) {\r\n                this._appendAfter._next = record;\r\n                record._prev = this._appendAfter;\r\n            }\r\n            else {\r\n                this._mapHead = record;\r\n            }\r\n            this._appendAfter = record;\r\n            return null;\r\n        };\r\n        DefaultKeyValueDiffer.prototype._getOrCreateRecordForKey = function (key, value) {\r\n            if (this._records.has(key)) {\r\n                var record_1 = this._records.get(key);\r\n                this._maybeAddToChanges(record_1, value);\r\n                var prev = record_1._prev;\r\n                var next = record_1._next;\r\n                if (prev) {\r\n                    prev._next = next;\r\n                }\r\n                if (next) {\r\n                    next._prev = prev;\r\n                }\r\n                record_1._next = null;\r\n                record_1._prev = null;\r\n                return record_1;\r\n            }\r\n            var record = new KeyValueChangeRecord_(key);\r\n            this._records.set(key, record);\r\n            record.currentValue = value;\r\n            this._addToAdditions(record);\r\n            return record;\r\n        };\r\n        /** @internal */\r\n        DefaultKeyValueDiffer.prototype._reset = function () {\r\n            if (this.isDirty) {\r\n                var record = void 0;\r\n                // let `_previousMapHead` contain the state of the map before the changes\r\n                this._previousMapHead = this._mapHead;\r\n                for (record = this._previousMapHead; record !== null; record = record._next) {\r\n                    record._nextPrevious = record._next;\r\n                }\r\n                // Update `record.previousValue` with the value of the item before the changes\r\n                // We need to update all changed items (that's those which have been added and changed)\r\n                for (record = this._changesHead; record !== null; record = record._nextChanged) {\r\n                    record.previousValue = record.currentValue;\r\n                }\r\n                for (record = this._additionsHead; record != null; record = record._nextAdded) {\r\n                    record.previousValue = record.currentValue;\r\n                }\r\n                this._changesHead = this._changesTail = null;\r\n                this._additionsHead = this._additionsTail = null;\r\n                this._removalsHead = null;\r\n            }\r\n        };\r\n        // Add the record or a given key to the list of changes only when the value has actually changed\r\n        DefaultKeyValueDiffer.prototype._maybeAddToChanges = function (record, newValue) {\r\n            if (!looseIdentical(newValue, record.currentValue)) {\r\n                record.previousValue = record.currentValue;\r\n                record.currentValue = newValue;\r\n                this._addToChanges(record);\r\n            }\r\n        };\r\n        DefaultKeyValueDiffer.prototype._addToAdditions = function (record) {\r\n            if (this._additionsHead === null) {\r\n                this._additionsHead = this._additionsTail = record;\r\n            }\r\n            else {\r\n                this._additionsTail._nextAdded = record;\r\n                this._additionsTail = record;\r\n            }\r\n        };\r\n        DefaultKeyValueDiffer.prototype._addToChanges = function (record) {\r\n            if (this._changesHead === null) {\r\n                this._changesHead = this._changesTail = record;\r\n            }\r\n            else {\r\n                this._changesTail._nextChanged = record;\r\n                this._changesTail = record;\r\n            }\r\n        };\r\n        /** @internal */\r\n        DefaultKeyValueDiffer.prototype._forEach = function (obj, fn) {\r\n            if (obj instanceof Map) {\r\n                obj.forEach(fn);\r\n            }\r\n            else {\r\n                Object.keys(obj).forEach(function (k) { return fn(obj[k], k); });\r\n            }\r\n        };\r\n        return DefaultKeyValueDiffer;\r\n    }());\r\n    var KeyValueChangeRecord_ = /** @class */ (function () {\r\n        function KeyValueChangeRecord_(key) {\r\n            this.key = key;\r\n            this.previousValue = null;\r\n            this.currentValue = null;\r\n            /** @internal */\r\n            this._nextPrevious = null;\r\n            /** @internal */\r\n            this._next = null;\r\n            /** @internal */\r\n            this._prev = null;\r\n            /** @internal */\r\n            this._nextAdded = null;\r\n            /** @internal */\r\n            this._nextRemoved = null;\r\n            /** @internal */\r\n            this._nextChanged = null;\r\n        }\r\n        return KeyValueChangeRecord_;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var IterableDiffers = /** @class */ (function () {\r\n        function IterableDiffers(factories) {\r\n            this.factories = factories;\r\n        }\r\n        IterableDiffers.create = function (factories, parent) {\r\n            if (parent != null) {\r\n                var copied = parent.factories.slice();\r\n                factories = factories.concat(copied);\r\n            }\r\n            return new IterableDiffers(factories);\r\n        };\r\n        /**\r\n         * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the\r\n         * inherited {@link IterableDiffers} instance with the provided factories and return a new\r\n         * {@link IterableDiffers} instance.\r\n         *\r\n         * @usageNotes\r\n         * ### Example\r\n         *\r\n         * The following example shows how to extend an existing list of factories,\r\n         * which will only be applied to the injector for this component and its children.\r\n         * This step is all that's required to make a new {@link IterableDiffer} available.\r\n         *\r\n         * ```\r\n         * @Component({\r\n         *   viewProviders: [\r\n         *     IterableDiffers.extend([new ImmutableListDiffer()])\r\n         *   ]\r\n         * })\r\n         * ```\r\n         */\r\n        IterableDiffers.extend = function (factories) {\r\n            return {\r\n                provide: IterableDiffers,\r\n                useFactory: function (parent) {\r\n                    if (!parent) {\r\n                        // Typically would occur when calling IterableDiffers.extend inside of dependencies passed\r\n                        // to\r\n                        // bootstrap(), which would override default pipes instead of extending them.\r\n                        throw new Error('Cannot extend IterableDiffers without a parent injector');\r\n                    }\r\n                    return IterableDiffers.create(factories, parent);\r\n                },\r\n                // Dependency technically isn't optional, but we can provide a better error message this way.\r\n                deps: [[IterableDiffers, new SkipSelf(), new Optional()]]\r\n            };\r\n        };\r\n        IterableDiffers.prototype.find = function (iterable) {\r\n            var factory = this.factories.find(function (f) { return f.supports(iterable); });\r\n            if (factory != null) {\r\n                return factory;\r\n            }\r\n            else {\r\n                throw new Error(\"Cannot find a differ supporting object '\" + iterable + \"' of type '\" + getTypeNameForDebugging(iterable) + \"'\");\r\n            }\r\n        };\r\n        /** @nocollapse */\r\n        IterableDiffers.ngInjectableDef = ɵɵdefineInjectable({\r\n            token: IterableDiffers,\r\n            providedIn: 'root',\r\n            factory: function () { return new IterableDiffers([new DefaultIterableDifferFactory()]); }\r\n        });\r\n        return IterableDiffers;\r\n    }());\r\n    function getTypeNameForDebugging(type) {\r\n        return type['name'] || typeof type;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var KeyValueDiffers = /** @class */ (function () {\r\n        function KeyValueDiffers(factories) {\r\n            this.factories = factories;\r\n        }\r\n        KeyValueDiffers.create = function (factories, parent) {\r\n            if (parent) {\r\n                var copied = parent.factories.slice();\r\n                factories = factories.concat(copied);\r\n            }\r\n            return new KeyValueDiffers(factories);\r\n        };\r\n        /**\r\n         * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the\r\n         * inherited {@link KeyValueDiffers} instance with the provided factories and return a new\r\n         * {@link KeyValueDiffers} instance.\r\n         *\r\n         * @usageNotes\r\n         * ### Example\r\n         *\r\n         * The following example shows how to extend an existing list of factories,\r\n         * which will only be applied to the injector for this component and its children.\r\n         * This step is all that's required to make a new {@link KeyValueDiffer} available.\r\n         *\r\n         * ```\r\n         * @Component({\r\n         *   viewProviders: [\r\n         *     KeyValueDiffers.extend([new ImmutableMapDiffer()])\r\n         *   ]\r\n         * })\r\n         * ```\r\n         */\r\n        KeyValueDiffers.extend = function (factories) {\r\n            return {\r\n                provide: KeyValueDiffers,\r\n                useFactory: function (parent) {\r\n                    if (!parent) {\r\n                        // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed\r\n                        // to bootstrap(), which would override default pipes instead of extending them.\r\n                        throw new Error('Cannot extend KeyValueDiffers without a parent injector');\r\n                    }\r\n                    return KeyValueDiffers.create(factories, parent);\r\n                },\r\n                // Dependency technically isn't optional, but we can provide a better error message this way.\r\n                deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]\r\n            };\r\n        };\r\n        KeyValueDiffers.prototype.find = function (kv) {\r\n            var factory = this.factories.find(function (f) { return f.supports(kv); });\r\n            if (factory) {\r\n                return factory;\r\n            }\r\n            throw new Error(\"Cannot find a differ supporting object '\" + kv + \"'\");\r\n        };\r\n        /** @nocollapse */\r\n        KeyValueDiffers.ngInjectableDef = ɵɵdefineInjectable({\r\n            token: KeyValueDiffers,\r\n            providedIn: 'root',\r\n            factory: function () { return new KeyValueDiffers([new DefaultKeyValueDifferFactory()]); }\r\n        });\r\n        return KeyValueDiffers;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Structural diffing for `Object`s and `Map`s.\r\n     */\r\n    var keyValDiff = [new DefaultKeyValueDifferFactory()];\r\n    /**\r\n     * Structural diffing for `Iterable` types such as `Array`s.\r\n     */\r\n    var iterableDiff = [new DefaultIterableDifferFactory()];\r\n    var defaultIterableDiffers = new IterableDiffers(iterableDiff);\r\n    var defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Represents an embedded template that can be used to instantiate embedded views.\r\n     * To instantiate embedded views based on a template, use the `ViewContainerRef`\r\n     * method `createEmbeddedView()`.\r\n     *\r\n     * Access a `TemplateRef` instance by placing a directive on an `<ng-template>`\r\n     * element (or directive prefixed with `*`). The `TemplateRef` for the embedded view\r\n     * is injected into the constructor of the directive,\r\n     * using the `TemplateRef` token.\r\n     *\r\n     * You can also use a `Query` to find a `TemplateRef` associated with\r\n     * a component or a directive.\r\n     *\r\n     * @see `ViewContainerRef`\r\n     * @see [Navigate the Component Tree with DI](guide/dependency-injection-navtree)\r\n     *\r\n     * @publicApi\r\n     */\r\n    var TemplateRef = /** @class */ (function () {\r\n        function TemplateRef() {\r\n        }\r\n        /**\r\n         * @internal\r\n         * @nocollapse\r\n         */\r\n        TemplateRef.__NG_ELEMENT_ID__ = function () { return SWITCH_TEMPLATE_REF_FACTORY(TemplateRef, ElementRef); };\r\n        return TemplateRef;\r\n    }());\r\n    var SWITCH_TEMPLATE_REF_FACTORY__POST_R3__ = injectTemplateRef;\r\n    var SWITCH_TEMPLATE_REF_FACTORY__PRE_R3__ = noop;\r\n    var SWITCH_TEMPLATE_REF_FACTORY = SWITCH_TEMPLATE_REF_FACTORY__PRE_R3__;\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Represents a container where one or more views can be attached to a component.\r\n     *\r\n     * Can contain *host views* (created by instantiating a\r\n     * component with the `createComponent()` method), and *embedded views*\r\n     * (created by instantiating a `TemplateRef` with the `createEmbeddedView()` method).\r\n     *\r\n     * A view container instance can contain other view containers,\r\n     * creating a [view hierarchy](guide/glossary#view-tree).\r\n     *\r\n     * @see `ComponentRef`\r\n     * @see `EmbeddedViewRef`\r\n     *\r\n     * @publicApi\r\n     */\r\n    var ViewContainerRef = /** @class */ (function () {\r\n        function ViewContainerRef() {\r\n        }\r\n        /**\r\n         * @internal\r\n         * @nocollapse\r\n         */\r\n        ViewContainerRef.__NG_ELEMENT_ID__ = function () { return SWITCH_VIEW_CONTAINER_REF_FACTORY(ViewContainerRef, ElementRef); };\r\n        return ViewContainerRef;\r\n    }());\r\n    var SWITCH_VIEW_CONTAINER_REF_FACTORY__POST_R3__ = injectViewContainerRef;\r\n    var SWITCH_VIEW_CONTAINER_REF_FACTORY__PRE_R3__ = noop;\r\n    var SWITCH_VIEW_CONTAINER_REF_FACTORY = SWITCH_VIEW_CONTAINER_REF_FACTORY__PRE_R3__;\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function expressionChangedAfterItHasBeenCheckedError(context, oldValue, currValue, isFirstCheck) {\r\n        var msg = \"ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: '\" + oldValue + \"'. Current value: '\" + currValue + \"'.\";\r\n        if (isFirstCheck) {\r\n            msg +=\r\n                \" It seems like the view has been created after its parent and its children have been dirty checked.\" +\r\n                    \" Has it been created in a change detection hook ?\";\r\n        }\r\n        return viewDebugError(msg, context);\r\n    }\r\n    function viewWrappedDebugError(err, context) {\r\n        if (!(err instanceof Error)) {\r\n            // errors that are not Error instances don't have a stack,\r\n            // so it is ok to wrap them into a new Error object...\r\n            err = new Error(err.toString());\r\n        }\r\n        _addDebugContext(err, context);\r\n        return err;\r\n    }\r\n    function viewDebugError(msg, context) {\r\n        var err = new Error(msg);\r\n        _addDebugContext(err, context);\r\n        return err;\r\n    }\r\n    function _addDebugContext(err, context) {\r\n        err[ERROR_DEBUG_CONTEXT] = context;\r\n        err[ERROR_LOGGER] = context.logError.bind(context);\r\n    }\r\n    function isViewDebugError(err) {\r\n        return !!getDebugContext(err);\r\n    }\r\n    function viewDestroyedError(action) {\r\n        return new Error(\"ViewDestroyedError: Attempt to use a destroyed view: \" + action);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    // Called before each cycle of a view's check to detect whether this is in the\r\n    // initState for which we need to call ngOnInit, ngAfterContentInit or ngAfterViewInit\r\n    // lifecycle methods. Returns true if this check cycle should call lifecycle\r\n    // methods.\r\n    function shiftInitState(view, priorInitState, newInitState) {\r\n        // Only update the InitState if we are currently in the prior state.\r\n        // For example, only move into CallingInit if we are in BeforeInit. Only\r\n        // move into CallingContentInit if we are in CallingInit. Normally this will\r\n        // always be true because of how checkCycle is called in checkAndUpdateView.\r\n        // However, if checkAndUpdateView is called recursively or if an exception is\r\n        // thrown while checkAndUpdateView is running, checkAndUpdateView starts over\r\n        // from the beginning. This ensures the state is monotonically increasing,\r\n        // terminating in the AfterInit state, which ensures the Init methods are called\r\n        // at least once and only once.\r\n        var state = view.state;\r\n        var initState = state & 1792 /* InitState_Mask */;\r\n        if (initState === priorInitState) {\r\n            view.state = (state & ~1792 /* InitState_Mask */) | newInitState;\r\n            view.initIndex = -1;\r\n            return true;\r\n        }\r\n        return initState === newInitState;\r\n    }\r\n    // Returns true if the lifecycle init method should be called for the node with\r\n    // the given init index.\r\n    function shouldCallLifecycleInitHook(view, initState, index) {\r\n        if ((view.state & 1792 /* InitState_Mask */) === initState && view.initIndex <= index) {\r\n            view.initIndex = index + 1;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Node instance data.\r\n     *\r\n     * We have a separate type per NodeType to save memory\r\n     * (TextData | ElementData | ProviderData | PureExpressionData | QueryList<any>)\r\n     *\r\n     * To keep our code monomorphic,\r\n     * we prohibit using `NodeData` directly but enforce the use of accessors (`asElementData`, ...).\r\n     * This way, no usage site can get a `NodeData` from view.nodes and then use it for different\r\n     * purposes.\r\n     */\r\n    var NodeData = /** @class */ (function () {\r\n        function NodeData() {\r\n        }\r\n        return NodeData;\r\n    }());\r\n    /**\r\n     * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\r\n     */\r\n    function asTextData(view, index) {\r\n        return view.nodes[index];\r\n    }\r\n    /**\r\n     * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\r\n     */\r\n    function asElementData(view, index) {\r\n        return view.nodes[index];\r\n    }\r\n    /**\r\n     * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\r\n     */\r\n    function asProviderData(view, index) {\r\n        return view.nodes[index];\r\n    }\r\n    /**\r\n     * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\r\n     */\r\n    function asPureExpressionData(view, index) {\r\n        return view.nodes[index];\r\n    }\r\n    /**\r\n     * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\r\n     */\r\n    function asQueryList(view, index) {\r\n        return view.nodes[index];\r\n    }\r\n    var DebugContext = /** @class */ (function () {\r\n        function DebugContext() {\r\n        }\r\n        return DebugContext;\r\n    }());\r\n    /**\r\n     * This object is used to prevent cycles in the source files and to have a place where\r\n     * debug mode can hook it. It is lazily filled when `isDevMode` is known.\r\n     */\r\n    var Services = {\r\n        setCurrentNode: undefined,\r\n        createRootView: undefined,\r\n        createEmbeddedView: undefined,\r\n        createComponentView: undefined,\r\n        createNgModuleRef: undefined,\r\n        overrideProvider: undefined,\r\n        overrideComponentView: undefined,\r\n        clearOverrides: undefined,\r\n        checkAndUpdateView: undefined,\r\n        checkNoChangesView: undefined,\r\n        destroyView: undefined,\r\n        resolveDep: undefined,\r\n        createDebugContext: undefined,\r\n        handleEvent: undefined,\r\n        updateDirectives: undefined,\r\n        updateRenderer: undefined,\r\n        dirtyParentQueries: undefined,\r\n    };\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var NOOP = function () { };\r\n    var _tokenKeyCache = new Map();\r\n    function tokenKey(token) {\r\n        var key = _tokenKeyCache.get(token);\r\n        if (!key) {\r\n            key = stringify(token) + '_' + _tokenKeyCache.size;\r\n            _tokenKeyCache.set(token, key);\r\n        }\r\n        return key;\r\n    }\r\n    function unwrapValue(view, nodeIdx, bindingIdx, value) {\r\n        if (WrappedValue.isWrapped(value)) {\r\n            value = WrappedValue.unwrap(value);\r\n            var globalBindingIdx = view.def.nodes[nodeIdx].bindingIndex + bindingIdx;\r\n            var oldValue = WrappedValue.unwrap(view.oldValues[globalBindingIdx]);\r\n            view.oldValues[globalBindingIdx] = new WrappedValue(oldValue);\r\n        }\r\n        return value;\r\n    }\r\n    var UNDEFINED_RENDERER_TYPE_ID = '$$undefined';\r\n    var EMPTY_RENDERER_TYPE_ID = '$$empty';\r\n    // Attention: this function is called as top level function.\r\n    // Putting any logic in here will destroy closure tree shaking!\r\n    function createRendererType2(values) {\r\n        return {\r\n            id: UNDEFINED_RENDERER_TYPE_ID,\r\n            styles: values.styles,\r\n            encapsulation: values.encapsulation,\r\n            data: values.data\r\n        };\r\n    }\r\n    var _renderCompCount$1 = 0;\r\n    function resolveRendererType2(type) {\r\n        if (type && type.id === UNDEFINED_RENDERER_TYPE_ID) {\r\n            // first time we see this RendererType2. Initialize it...\r\n            var isFilled = ((type.encapsulation != null && type.encapsulation !== exports.ViewEncapsulation.None) ||\r\n                type.styles.length || Object.keys(type.data).length);\r\n            if (isFilled) {\r\n                type.id = \"c\" + _renderCompCount$1++;\r\n            }\r\n            else {\r\n                type.id = EMPTY_RENDERER_TYPE_ID;\r\n            }\r\n        }\r\n        if (type && type.id === EMPTY_RENDERER_TYPE_ID) {\r\n            type = null;\r\n        }\r\n        return type || null;\r\n    }\r\n    function checkBinding(view, def, bindingIdx, value) {\r\n        var oldValues = view.oldValues;\r\n        if ((view.state & 2 /* FirstCheck */) ||\r\n            !looseIdentical(oldValues[def.bindingIndex + bindingIdx], value)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function checkAndUpdateBinding(view, def, bindingIdx, value) {\r\n        if (checkBinding(view, def, bindingIdx, value)) {\r\n            view.oldValues[def.bindingIndex + bindingIdx] = value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function checkBindingNoChanges(view, def, bindingIdx, value) {\r\n        var oldValue = view.oldValues[def.bindingIndex + bindingIdx];\r\n        if ((view.state & 1 /* BeforeFirstCheck */) || !devModeEqual$1(oldValue, value)) {\r\n            var bindingName = def.bindings[bindingIdx].name;\r\n            throw expressionChangedAfterItHasBeenCheckedError(Services.createDebugContext(view, def.nodeIndex), bindingName + \": \" + oldValue, bindingName + \": \" + value, (view.state & 1 /* BeforeFirstCheck */) !== 0);\r\n        }\r\n    }\r\n    function markParentViewsForCheck(view) {\r\n        var currView = view;\r\n        while (currView) {\r\n            if (currView.def.flags & 2 /* OnPush */) {\r\n                currView.state |= 8 /* ChecksEnabled */;\r\n            }\r\n            currView = currView.viewContainerParent || currView.parent;\r\n        }\r\n    }\r\n    function markParentViewsForCheckProjectedViews(view, endView) {\r\n        var currView = view;\r\n        while (currView && currView !== endView) {\r\n            currView.state |= 64 /* CheckProjectedViews */;\r\n            currView = currView.viewContainerParent || currView.parent;\r\n        }\r\n    }\r\n    function dispatchEvent(view, nodeIndex, eventName, event) {\r\n        try {\r\n            var nodeDef = view.def.nodes[nodeIndex];\r\n            var startView = nodeDef.flags & 33554432 /* ComponentView */ ?\r\n                asElementData(view, nodeIndex).componentView :\r\n                view;\r\n            markParentViewsForCheck(startView);\r\n            return Services.handleEvent(view, nodeIndex, eventName, event);\r\n        }\r\n        catch (e) {\r\n            // Attention: Don't rethrow, as it would cancel Observable subscriptions!\r\n            view.root.errorHandler.handleError(e);\r\n        }\r\n    }\r\n    function declaredViewContainer(view) {\r\n        if (view.parent) {\r\n            var parentView = view.parent;\r\n            return asElementData(parentView, view.parentNodeDef.nodeIndex);\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * for component views, this is the host element.\r\n     * for embedded views, this is the index of the parent node\r\n     * that contains the view container.\r\n     */\r\n    function viewParentEl(view) {\r\n        var parentView = view.parent;\r\n        if (parentView) {\r\n            return view.parentNodeDef.parent;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    function renderNode(view, def) {\r\n        switch (def.flags & 201347067 /* Types */) {\r\n            case 1 /* TypeElement */:\r\n                return asElementData(view, def.nodeIndex).renderElement;\r\n            case 2 /* TypeText */:\r\n                return asTextData(view, def.nodeIndex).renderText;\r\n        }\r\n    }\r\n    function elementEventFullName(target, name) {\r\n        return target ? target + \":\" + name : name;\r\n    }\r\n    function isComponentView(view) {\r\n        return !!view.parent && !!(view.parentNodeDef.flags & 32768 /* Component */);\r\n    }\r\n    function isEmbeddedView(view) {\r\n        return !!view.parent && !(view.parentNodeDef.flags & 32768 /* Component */);\r\n    }\r\n    function filterQueryId(queryId) {\r\n        return 1 << (queryId % 32);\r\n    }\r\n    function splitMatchedQueriesDsl(matchedQueriesDsl) {\r\n        var matchedQueries = {};\r\n        var matchedQueryIds = 0;\r\n        var references = {};\r\n        if (matchedQueriesDsl) {\r\n            matchedQueriesDsl.forEach(function (_a) {\r\n                var _b = __read(_a, 2), queryId = _b[0], valueType = _b[1];\r\n                if (typeof queryId === 'number') {\r\n                    matchedQueries[queryId] = valueType;\r\n                    matchedQueryIds |= filterQueryId(queryId);\r\n                }\r\n                else {\r\n                    references[queryId] = valueType;\r\n                }\r\n            });\r\n        }\r\n        return { matchedQueries: matchedQueries, references: references, matchedQueryIds: matchedQueryIds };\r\n    }\r\n    function splitDepsDsl(deps, sourceName) {\r\n        return deps.map(function (value) {\r\n            var _a;\r\n            var token;\r\n            var flags;\r\n            if (Array.isArray(value)) {\r\n                _a = __read(value, 2), flags = _a[0], token = _a[1];\r\n            }\r\n            else {\r\n                flags = 0 /* None */;\r\n                token = value;\r\n            }\r\n            if (token && (typeof token === 'function' || typeof token === 'object') && sourceName) {\r\n                Object.defineProperty(token, SOURCE, { value: sourceName, configurable: true });\r\n            }\r\n            return { flags: flags, token: token, tokenKey: tokenKey(token) };\r\n        });\r\n    }\r\n    function getParentRenderElement(view, renderHost, def) {\r\n        var renderParent = def.renderParent;\r\n        if (renderParent) {\r\n            if ((renderParent.flags & 1 /* TypeElement */) === 0 ||\r\n                (renderParent.flags & 33554432 /* ComponentView */) === 0 ||\r\n                (renderParent.element.componentRendererType &&\r\n                    renderParent.element.componentRendererType.encapsulation ===\r\n                        exports.ViewEncapsulation.Native)) {\r\n                // only children of non components, or children of components with native encapsulation should\r\n                // be attached.\r\n                return asElementData(view, def.renderParent.nodeIndex).renderElement;\r\n            }\r\n        }\r\n        else {\r\n            return renderHost;\r\n        }\r\n    }\r\n    var DEFINITION_CACHE = new WeakMap();\r\n    function resolveDefinition(factory) {\r\n        var value = DEFINITION_CACHE.get(factory);\r\n        if (!value) {\r\n            value = factory(function () { return NOOP; });\r\n            value.factory = factory;\r\n            DEFINITION_CACHE.set(factory, value);\r\n        }\r\n        return value;\r\n    }\r\n    function rootRenderNodes(view) {\r\n        var renderNodes = [];\r\n        visitRootRenderNodes(view, 0 /* Collect */, undefined, undefined, renderNodes);\r\n        return renderNodes;\r\n    }\r\n    function visitRootRenderNodes(view, action, parentNode, nextSibling, target) {\r\n        // We need to re-compute the parent node in case the nodes have been moved around manually\r\n        if (action === 3 /* RemoveChild */) {\r\n            parentNode = view.renderer.parentNode(renderNode(view, view.def.lastRenderRootNode));\r\n        }\r\n        visitSiblingRenderNodes(view, action, 0, view.def.nodes.length - 1, parentNode, nextSibling, target);\r\n    }\r\n    function visitSiblingRenderNodes(view, action, startIndex, endIndex, parentNode, nextSibling, target) {\r\n        for (var i = startIndex; i <= endIndex; i++) {\r\n            var nodeDef = view.def.nodes[i];\r\n            if (nodeDef.flags & (1 /* TypeElement */ | 2 /* TypeText */ | 8 /* TypeNgContent */)) {\r\n                visitRenderNode(view, nodeDef, action, parentNode, nextSibling, target);\r\n            }\r\n            // jump to next sibling\r\n            i += nodeDef.childCount;\r\n        }\r\n    }\r\n    function visitProjectedRenderNodes(view, ngContentIndex, action, parentNode, nextSibling, target) {\r\n        var compView = view;\r\n        while (compView && !isComponentView(compView)) {\r\n            compView = compView.parent;\r\n        }\r\n        var hostView = compView.parent;\r\n        var hostElDef = viewParentEl(compView);\r\n        var startIndex = hostElDef.nodeIndex + 1;\r\n        var endIndex = hostElDef.nodeIndex + hostElDef.childCount;\r\n        for (var i = startIndex; i <= endIndex; i++) {\r\n            var nodeDef = hostView.def.nodes[i];\r\n            if (nodeDef.ngContentIndex === ngContentIndex) {\r\n                visitRenderNode(hostView, nodeDef, action, parentNode, nextSibling, target);\r\n            }\r\n            // jump to next sibling\r\n            i += nodeDef.childCount;\r\n        }\r\n        if (!hostView.parent) {\r\n            // a root view\r\n            var projectedNodes = view.root.projectableNodes[ngContentIndex];\r\n            if (projectedNodes) {\r\n                for (var i = 0; i < projectedNodes.length; i++) {\r\n                    execRenderNodeAction(view, projectedNodes[i], action, parentNode, nextSibling, target);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function visitRenderNode(view, nodeDef, action, parentNode, nextSibling, target) {\r\n        if (nodeDef.flags & 8 /* TypeNgContent */) {\r\n            visitProjectedRenderNodes(view, nodeDef.ngContent.index, action, parentNode, nextSibling, target);\r\n        }\r\n        else {\r\n            var rn = renderNode(view, nodeDef);\r\n            if (action === 3 /* RemoveChild */ && (nodeDef.flags & 33554432 /* ComponentView */) &&\r\n                (nodeDef.bindingFlags & 48 /* CatSyntheticProperty */)) {\r\n                // Note: we might need to do both actions.\r\n                if (nodeDef.bindingFlags & (16 /* SyntheticProperty */)) {\r\n                    execRenderNodeAction(view, rn, action, parentNode, nextSibling, target);\r\n                }\r\n                if (nodeDef.bindingFlags & (32 /* SyntheticHostProperty */)) {\r\n                    var compView = asElementData(view, nodeDef.nodeIndex).componentView;\r\n                    execRenderNodeAction(compView, rn, action, parentNode, nextSibling, target);\r\n                }\r\n            }\r\n            else {\r\n                execRenderNodeAction(view, rn, action, parentNode, nextSibling, target);\r\n            }\r\n            if (nodeDef.flags & 16777216 /* EmbeddedViews */) {\r\n                var embeddedViews = asElementData(view, nodeDef.nodeIndex).viewContainer._embeddedViews;\r\n                for (var k = 0; k < embeddedViews.length; k++) {\r\n                    visitRootRenderNodes(embeddedViews[k], action, parentNode, nextSibling, target);\r\n                }\r\n            }\r\n            if (nodeDef.flags & 1 /* TypeElement */ && !nodeDef.element.name) {\r\n                visitSiblingRenderNodes(view, action, nodeDef.nodeIndex + 1, nodeDef.nodeIndex + nodeDef.childCount, parentNode, nextSibling, target);\r\n            }\r\n        }\r\n    }\r\n    function execRenderNodeAction(view, renderNode, action, parentNode, nextSibling, target) {\r\n        var renderer = view.renderer;\r\n        switch (action) {\r\n            case 1 /* AppendChild */:\r\n                renderer.appendChild(parentNode, renderNode);\r\n                break;\r\n            case 2 /* InsertBefore */:\r\n                renderer.insertBefore(parentNode, renderNode, nextSibling);\r\n                break;\r\n            case 3 /* RemoveChild */:\r\n                renderer.removeChild(parentNode, renderNode);\r\n                break;\r\n            case 0 /* Collect */:\r\n                target.push(renderNode);\r\n                break;\r\n        }\r\n    }\r\n    var NS_PREFIX_RE = /^:([^:]+):(.+)$/;\r\n    function splitNamespace(name) {\r\n        if (name[0] === ':') {\r\n            var match = name.match(NS_PREFIX_RE);\r\n            return [match[1], match[2]];\r\n        }\r\n        return ['', name];\r\n    }\r\n    function calcBindingFlags(bindings) {\r\n        var flags = 0;\r\n        for (var i = 0; i < bindings.length; i++) {\r\n            flags |= bindings[i].flags;\r\n        }\r\n        return flags;\r\n    }\r\n    function interpolate(valueCount, constAndInterp) {\r\n        var result = '';\r\n        for (var i = 0; i < valueCount * 2; i = i + 2) {\r\n            result = result + constAndInterp[i] + _toStringWithNull(constAndInterp[i + 1]);\r\n        }\r\n        return result + constAndInterp[valueCount * 2];\r\n    }\r\n    function inlineInterpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {\r\n        switch (valueCount) {\r\n            case 1:\r\n                return c0 + _toStringWithNull(a1) + c1;\r\n            case 2:\r\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;\r\n            case 3:\r\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\r\n                    c3;\r\n            case 4:\r\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\r\n                    c3 + _toStringWithNull(a4) + c4;\r\n            case 5:\r\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\r\n                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;\r\n            case 6:\r\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\r\n                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;\r\n            case 7:\r\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\r\n                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +\r\n                    c6 + _toStringWithNull(a7) + c7;\r\n            case 8:\r\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\r\n                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +\r\n                    c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;\r\n            case 9:\r\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\r\n                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +\r\n                    c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;\r\n            default:\r\n                throw new Error(\"Does not support more than 9 expressions\");\r\n        }\r\n    }\r\n    function _toStringWithNull(v) {\r\n        return v != null ? v.toString() : '';\r\n    }\r\n    var EMPTY_ARRAY$3 = [];\r\n    var EMPTY_MAP = {};\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var UNDEFINED_VALUE = new Object();\r\n    var InjectorRefTokenKey = tokenKey(Injector);\r\n    var INJECTORRefTokenKey = tokenKey(INJECTOR);\r\n    var NgModuleRefTokenKey = tokenKey(NgModuleRef);\r\n    function moduleProvideDef(flags, token, value, deps) {\r\n        // Need to resolve forwardRefs as e.g. for `useValue` we\r\n        // lowered the expression and then stopped evaluating it,\r\n        // i.e. also didn't unwrap it.\r\n        value = resolveForwardRef(value);\r\n        var depDefs = splitDepsDsl(deps, stringify(token));\r\n        return {\r\n            // will bet set by the module definition\r\n            index: -1,\r\n            deps: depDefs, flags: flags, token: token, value: value\r\n        };\r\n    }\r\n    function moduleDef(providers) {\r\n        var providersByKey = {};\r\n        var modules = [];\r\n        var isRoot = false;\r\n        for (var i = 0; i < providers.length; i++) {\r\n            var provider = providers[i];\r\n            if (provider.token === APP_ROOT && provider.value === true) {\r\n                isRoot = true;\r\n            }\r\n            if (provider.flags & 1073741824 /* TypeNgModule */) {\r\n                modules.push(provider.token);\r\n            }\r\n            provider.index = i;\r\n            providersByKey[tokenKey(provider.token)] = provider;\r\n        }\r\n        return {\r\n            // Will be filled later...\r\n            factory: null,\r\n            providersByKey: providersByKey,\r\n            providers: providers,\r\n            modules: modules,\r\n            isRoot: isRoot,\r\n        };\r\n    }\r\n    function initNgModule(data) {\r\n        var def = data._def;\r\n        var providers = data._providers = new Array(def.providers.length);\r\n        for (var i = 0; i < def.providers.length; i++) {\r\n            var provDef = def.providers[i];\r\n            if (!(provDef.flags & 4096 /* LazyProvider */)) {\r\n                // Make sure the provider has not been already initialized outside this loop.\r\n                if (providers[i] === undefined) {\r\n                    providers[i] = _createProviderInstance(data, provDef);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function resolveNgModuleDep(data, depDef, notFoundValue) {\r\n        if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }\r\n        var former = setCurrentInjector(data);\r\n        try {\r\n            if (depDef.flags & 8 /* Value */) {\r\n                return depDef.token;\r\n            }\r\n            if (depDef.flags & 2 /* Optional */) {\r\n                notFoundValue = null;\r\n            }\r\n            if (depDef.flags & 1 /* SkipSelf */) {\r\n                return data._parent.get(depDef.token, notFoundValue);\r\n            }\r\n            var tokenKey_1 = depDef.tokenKey;\r\n            switch (tokenKey_1) {\r\n                case InjectorRefTokenKey:\r\n                case INJECTORRefTokenKey:\r\n                case NgModuleRefTokenKey:\r\n                    return data;\r\n            }\r\n            var providerDef = data._def.providersByKey[tokenKey_1];\r\n            var injectableDef = void 0;\r\n            if (providerDef) {\r\n                var providerInstance = data._providers[providerDef.index];\r\n                if (providerInstance === undefined) {\r\n                    providerInstance = data._providers[providerDef.index] =\r\n                        _createProviderInstance(data, providerDef);\r\n                }\r\n                return providerInstance === UNDEFINED_VALUE ? undefined : providerInstance;\r\n            }\r\n            else if ((injectableDef = getInjectableDef(depDef.token)) && targetsModule(data, injectableDef)) {\r\n                var index = data._providers.length;\r\n                data._def.providers[index] = data._def.providersByKey[depDef.tokenKey] = {\r\n                    flags: 1024 /* TypeFactoryProvider */ | 4096 /* LazyProvider */,\r\n                    value: injectableDef.factory,\r\n                    deps: [], index: index,\r\n                    token: depDef.token,\r\n                };\r\n                data._providers[index] = UNDEFINED_VALUE;\r\n                return (data._providers[index] =\r\n                    _createProviderInstance(data, data._def.providersByKey[depDef.tokenKey]));\r\n            }\r\n            else if (depDef.flags & 4 /* Self */) {\r\n                return notFoundValue;\r\n            }\r\n            return data._parent.get(depDef.token, notFoundValue);\r\n        }\r\n        finally {\r\n            setCurrentInjector(former);\r\n        }\r\n    }\r\n    function moduleTransitivelyPresent(ngModule, scope) {\r\n        return ngModule._def.modules.indexOf(scope) > -1;\r\n    }\r\n    function targetsModule(ngModule, def) {\r\n        return def.providedIn != null && (moduleTransitivelyPresent(ngModule, def.providedIn) ||\r\n            def.providedIn === 'root' && ngModule._def.isRoot);\r\n    }\r\n    function _createProviderInstance(ngModule, providerDef) {\r\n        var injectable;\r\n        switch (providerDef.flags & 201347067 /* Types */) {\r\n            case 512 /* TypeClassProvider */:\r\n                injectable = _createClass(ngModule, providerDef.value, providerDef.deps);\r\n                break;\r\n            case 1024 /* TypeFactoryProvider */:\r\n                injectable = _callFactory(ngModule, providerDef.value, providerDef.deps);\r\n                break;\r\n            case 2048 /* TypeUseExistingProvider */:\r\n                injectable = resolveNgModuleDep(ngModule, providerDef.deps[0]);\r\n                break;\r\n            case 256 /* TypeValueProvider */:\r\n                injectable = providerDef.value;\r\n                break;\r\n        }\r\n        // The read of `ngOnDestroy` here is slightly expensive as it's megamorphic, so it should be\r\n        // avoided if possible. The sequence of checks here determines whether ngOnDestroy needs to be\r\n        // checked. It might not if the `injectable` isn't an object or if NodeFlags.OnDestroy is already\r\n        // set (ngOnDestroy was detected statically).\r\n        if (injectable !== UNDEFINED_VALUE && injectable !== null && typeof injectable === 'object' &&\r\n            !(providerDef.flags & 131072 /* OnDestroy */) && typeof injectable.ngOnDestroy === 'function') {\r\n            providerDef.flags |= 131072 /* OnDestroy */;\r\n        }\r\n        return injectable === undefined ? UNDEFINED_VALUE : injectable;\r\n    }\r\n    function _createClass(ngModule, ctor, deps) {\r\n        var len = deps.length;\r\n        switch (len) {\r\n            case 0:\r\n                return new ctor();\r\n            case 1:\r\n                return new ctor(resolveNgModuleDep(ngModule, deps[0]));\r\n            case 2:\r\n                return new ctor(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]));\r\n            case 3:\r\n                return new ctor(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]), resolveNgModuleDep(ngModule, deps[2]));\r\n            default:\r\n                var depValues = new Array(len);\r\n                for (var i = 0; i < len; i++) {\r\n                    depValues[i] = resolveNgModuleDep(ngModule, deps[i]);\r\n                }\r\n                return new (ctor.bind.apply(ctor, __spread([void 0], depValues)))();\r\n        }\r\n    }\r\n    function _callFactory(ngModule, factory, deps) {\r\n        var len = deps.length;\r\n        switch (len) {\r\n            case 0:\r\n                return factory();\r\n            case 1:\r\n                return factory(resolveNgModuleDep(ngModule, deps[0]));\r\n            case 2:\r\n                return factory(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]));\r\n            case 3:\r\n                return factory(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]), resolveNgModuleDep(ngModule, deps[2]));\r\n            default:\r\n                var depValues = Array(len);\r\n                for (var i = 0; i < len; i++) {\r\n                    depValues[i] = resolveNgModuleDep(ngModule, deps[i]);\r\n                }\r\n                return factory.apply(void 0, __spread(depValues));\r\n        }\r\n    }\r\n    function callNgModuleLifecycle(ngModule, lifecycles) {\r\n        var def = ngModule._def;\r\n        var destroyed = new Set();\r\n        for (var i = 0; i < def.providers.length; i++) {\r\n            var provDef = def.providers[i];\r\n            if (provDef.flags & 131072 /* OnDestroy */) {\r\n                var instance = ngModule._providers[i];\r\n                if (instance && instance !== UNDEFINED_VALUE) {\r\n                    var onDestroy = instance.ngOnDestroy;\r\n                    if (typeof onDestroy === 'function' && !destroyed.has(instance)) {\r\n                        onDestroy.apply(instance);\r\n                        destroyed.add(instance);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function attachEmbeddedView(parentView, elementData, viewIndex, view) {\r\n        var embeddedViews = elementData.viewContainer._embeddedViews;\r\n        if (viewIndex === null || viewIndex === undefined) {\r\n            viewIndex = embeddedViews.length;\r\n        }\r\n        view.viewContainerParent = parentView;\r\n        addToArray(embeddedViews, viewIndex, view);\r\n        attachProjectedView(elementData, view);\r\n        Services.dirtyParentQueries(view);\r\n        var prevView = viewIndex > 0 ? embeddedViews[viewIndex - 1] : null;\r\n        renderAttachEmbeddedView(elementData, prevView, view);\r\n    }\r\n    function attachProjectedView(vcElementData, view) {\r\n        var dvcElementData = declaredViewContainer(view);\r\n        if (!dvcElementData || dvcElementData === vcElementData ||\r\n            view.state & 16 /* IsProjectedView */) {\r\n            return;\r\n        }\r\n        // Note: For performance reasons, we\r\n        // - add a view to template._projectedViews only 1x throughout its lifetime,\r\n        //   and remove it not until the view is destroyed.\r\n        //   (hard, as when a parent view is attached/detached we would need to attach/detach all\r\n        //    nested projected views as well, even across component boundaries).\r\n        // - don't track the insertion order of views in the projected views array\r\n        //   (hard, as when the views of the same template are inserted different view containers)\r\n        view.state |= 16 /* IsProjectedView */;\r\n        var projectedViews = dvcElementData.template._projectedViews;\r\n        if (!projectedViews) {\r\n            projectedViews = dvcElementData.template._projectedViews = [];\r\n        }\r\n        projectedViews.push(view);\r\n        // Note: we are changing the NodeDef here as we cannot calculate\r\n        // the fact whether a template is used for projection during compilation.\r\n        markNodeAsProjectedTemplate(view.parent.def, view.parentNodeDef);\r\n    }\r\n    function markNodeAsProjectedTemplate(viewDef, nodeDef) {\r\n        if (nodeDef.flags & 4 /* ProjectedTemplate */) {\r\n            return;\r\n        }\r\n        viewDef.nodeFlags |= 4 /* ProjectedTemplate */;\r\n        nodeDef.flags |= 4 /* ProjectedTemplate */;\r\n        var parentNodeDef = nodeDef.parent;\r\n        while (parentNodeDef) {\r\n            parentNodeDef.childFlags |= 4 /* ProjectedTemplate */;\r\n            parentNodeDef = parentNodeDef.parent;\r\n        }\r\n    }\r\n    function detachEmbeddedView(elementData, viewIndex) {\r\n        var embeddedViews = elementData.viewContainer._embeddedViews;\r\n        if (viewIndex == null || viewIndex >= embeddedViews.length) {\r\n            viewIndex = embeddedViews.length - 1;\r\n        }\r\n        if (viewIndex < 0) {\r\n            return null;\r\n        }\r\n        var view = embeddedViews[viewIndex];\r\n        view.viewContainerParent = null;\r\n        removeFromArray(embeddedViews, viewIndex);\r\n        // See attachProjectedView for why we don't update projectedViews here.\r\n        Services.dirtyParentQueries(view);\r\n        renderDetachView$1(view);\r\n        return view;\r\n    }\r\n    function detachProjectedView(view) {\r\n        if (!(view.state & 16 /* IsProjectedView */)) {\r\n            return;\r\n        }\r\n        var dvcElementData = declaredViewContainer(view);\r\n        if (dvcElementData) {\r\n            var projectedViews = dvcElementData.template._projectedViews;\r\n            if (projectedViews) {\r\n                removeFromArray(projectedViews, projectedViews.indexOf(view));\r\n                Services.dirtyParentQueries(view);\r\n            }\r\n        }\r\n    }\r\n    function moveEmbeddedView(elementData, oldViewIndex, newViewIndex) {\r\n        var embeddedViews = elementData.viewContainer._embeddedViews;\r\n        var view = embeddedViews[oldViewIndex];\r\n        removeFromArray(embeddedViews, oldViewIndex);\r\n        if (newViewIndex == null) {\r\n            newViewIndex = embeddedViews.length;\r\n        }\r\n        addToArray(embeddedViews, newViewIndex, view);\r\n        // Note: Don't need to change projectedViews as the order in there\r\n        // as always invalid...\r\n        Services.dirtyParentQueries(view);\r\n        renderDetachView$1(view);\r\n        var prevView = newViewIndex > 0 ? embeddedViews[newViewIndex - 1] : null;\r\n        renderAttachEmbeddedView(elementData, prevView, view);\r\n        return view;\r\n    }\r\n    function renderAttachEmbeddedView(elementData, prevView, view) {\r\n        var prevRenderNode = prevView ? renderNode(prevView, prevView.def.lastRenderRootNode) :\r\n            elementData.renderElement;\r\n        var parentNode = view.renderer.parentNode(prevRenderNode);\r\n        var nextSibling = view.renderer.nextSibling(prevRenderNode);\r\n        // Note: We can't check if `nextSibling` is present, as on WebWorkers it will always be!\r\n        // However, browsers automatically do `appendChild` when there is no `nextSibling`.\r\n        visitRootRenderNodes(view, 2 /* InsertBefore */, parentNode, nextSibling, undefined);\r\n    }\r\n    function renderDetachView$1(view) {\r\n        visitRootRenderNodes(view, 3 /* RemoveChild */, null, null, undefined);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var EMPTY_CONTEXT = new Object();\r\n    // Attention: this function is called as top level function.\r\n    // Putting any logic in here will destroy closure tree shaking!\r\n    function createComponentFactory(selector, componentType, viewDefFactory, inputs, outputs, ngContentSelectors) {\r\n        return new ComponentFactory_(selector, componentType, viewDefFactory, inputs, outputs, ngContentSelectors);\r\n    }\r\n    function getComponentViewDefinitionFactory(componentFactory) {\r\n        return componentFactory.viewDefFactory;\r\n    }\r\n    var ComponentFactory_ = /** @class */ (function (_super) {\r\n        __extends(ComponentFactory_, _super);\r\n        function ComponentFactory_(selector, componentType, viewDefFactory, _inputs, _outputs, ngContentSelectors) {\r\n            var _this = \r\n            // Attention: this ctor is called as top level function.\r\n            // Putting any logic in here will destroy closure tree shaking!\r\n            _super.call(this) || this;\r\n            _this.selector = selector;\r\n            _this.componentType = componentType;\r\n            _this._inputs = _inputs;\r\n            _this._outputs = _outputs;\r\n            _this.ngContentSelectors = ngContentSelectors;\r\n            _this.viewDefFactory = viewDefFactory;\r\n            return _this;\r\n        }\r\n        Object.defineProperty(ComponentFactory_.prototype, \"inputs\", {\r\n            get: function () {\r\n                var inputsArr = [];\r\n                var inputs = this._inputs;\r\n                for (var propName in inputs) {\r\n                    var templateName = inputs[propName];\r\n                    inputsArr.push({ propName: propName, templateName: templateName });\r\n                }\r\n                return inputsArr;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(ComponentFactory_.prototype, \"outputs\", {\r\n            get: function () {\r\n                var outputsArr = [];\r\n                for (var propName in this._outputs) {\r\n                    var templateName = this._outputs[propName];\r\n                    outputsArr.push({ propName: propName, templateName: templateName });\r\n                }\r\n                return outputsArr;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * Creates a new component.\r\n         */\r\n        ComponentFactory_.prototype.create = function (injector, projectableNodes, rootSelectorOrNode, ngModule) {\r\n            if (!ngModule) {\r\n                throw new Error('ngModule should be provided');\r\n            }\r\n            var viewDef = resolveDefinition(this.viewDefFactory);\r\n            var componentNodeIndex = viewDef.nodes[0].element.componentProvider.nodeIndex;\r\n            var view = Services.createRootView(injector, projectableNodes || [], rootSelectorOrNode, viewDef, ngModule, EMPTY_CONTEXT);\r\n            var component = asProviderData(view, componentNodeIndex).instance;\r\n            if (rootSelectorOrNode) {\r\n                view.renderer.setAttribute(asElementData(view, 0).renderElement, 'ng-version', VERSION.full);\r\n            }\r\n            return new ComponentRef_(view, new ViewRef_(view), component);\r\n        };\r\n        return ComponentFactory_;\r\n    }(ComponentFactory));\r\n    var ComponentRef_ = /** @class */ (function (_super) {\r\n        __extends(ComponentRef_, _super);\r\n        function ComponentRef_(_view, _viewRef, _component) {\r\n            var _this = _super.call(this) || this;\r\n            _this._view = _view;\r\n            _this._viewRef = _viewRef;\r\n            _this._component = _component;\r\n            _this._elDef = _this._view.def.nodes[0];\r\n            _this.hostView = _viewRef;\r\n            _this.changeDetectorRef = _viewRef;\r\n            _this.instance = _component;\r\n            return _this;\r\n        }\r\n        Object.defineProperty(ComponentRef_.prototype, \"location\", {\r\n            get: function () {\r\n                return new ElementRef(asElementData(this._view, this._elDef.nodeIndex).renderElement);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(ComponentRef_.prototype, \"injector\", {\r\n            get: function () { return new Injector_(this._view, this._elDef); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(ComponentRef_.prototype, \"componentType\", {\r\n            get: function () { return this._component.constructor; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        ComponentRef_.prototype.destroy = function () { this._viewRef.destroy(); };\r\n        ComponentRef_.prototype.onDestroy = function (callback) { this._viewRef.onDestroy(callback); };\r\n        return ComponentRef_;\r\n    }(ComponentRef));\r\n    function createViewContainerData(view, elDef, elData) {\r\n        return new ViewContainerRef_(view, elDef, elData);\r\n    }\r\n    var ViewContainerRef_ = /** @class */ (function () {\r\n        function ViewContainerRef_(_view, _elDef, _data) {\r\n            this._view = _view;\r\n            this._elDef = _elDef;\r\n            this._data = _data;\r\n            /**\r\n             * @internal\r\n             */\r\n            this._embeddedViews = [];\r\n        }\r\n        Object.defineProperty(ViewContainerRef_.prototype, \"element\", {\r\n            get: function () { return new ElementRef(this._data.renderElement); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(ViewContainerRef_.prototype, \"injector\", {\r\n            get: function () { return new Injector_(this._view, this._elDef); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(ViewContainerRef_.prototype, \"parentInjector\", {\r\n            /** @deprecated No replacement */\r\n            get: function () {\r\n                var view = this._view;\r\n                var elDef = this._elDef.parent;\r\n                while (!elDef && view) {\r\n                    elDef = viewParentEl(view);\r\n                    view = view.parent;\r\n                }\r\n                return view ? new Injector_(view, elDef) : new Injector_(this._view, null);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        ViewContainerRef_.prototype.clear = function () {\r\n            var len = this._embeddedViews.length;\r\n            for (var i = len - 1; i >= 0; i--) {\r\n                var view = detachEmbeddedView(this._data, i);\r\n                Services.destroyView(view);\r\n            }\r\n        };\r\n        ViewContainerRef_.prototype.get = function (index) {\r\n            var view = this._embeddedViews[index];\r\n            if (view) {\r\n                var ref = new ViewRef_(view);\r\n                ref.attachToViewContainerRef(this);\r\n                return ref;\r\n            }\r\n            return null;\r\n        };\r\n        Object.defineProperty(ViewContainerRef_.prototype, \"length\", {\r\n            get: function () { return this._embeddedViews.length; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, context, index) {\r\n            var viewRef = templateRef.createEmbeddedView(context || {});\r\n            this.insert(viewRef, index);\r\n            return viewRef;\r\n        };\r\n        ViewContainerRef_.prototype.createComponent = function (componentFactory, index, injector, projectableNodes, ngModuleRef) {\r\n            var contextInjector = injector || this.parentInjector;\r\n            if (!ngModuleRef && !(componentFactory instanceof ComponentFactoryBoundToModule)) {\r\n                ngModuleRef = contextInjector.get(NgModuleRef);\r\n            }\r\n            var componentRef = componentFactory.create(contextInjector, projectableNodes, undefined, ngModuleRef);\r\n            this.insert(componentRef.hostView, index);\r\n            return componentRef;\r\n        };\r\n        ViewContainerRef_.prototype.insert = function (viewRef, index) {\r\n            if (viewRef.destroyed) {\r\n                throw new Error('Cannot insert a destroyed View in a ViewContainer!');\r\n            }\r\n            var viewRef_ = viewRef;\r\n            var viewData = viewRef_._view;\r\n            attachEmbeddedView(this._view, this._data, index, viewData);\r\n            viewRef_.attachToViewContainerRef(this);\r\n            return viewRef;\r\n        };\r\n        ViewContainerRef_.prototype.move = function (viewRef, currentIndex) {\r\n            if (viewRef.destroyed) {\r\n                throw new Error('Cannot move a destroyed View in a ViewContainer!');\r\n            }\r\n            var previousIndex = this._embeddedViews.indexOf(viewRef._view);\r\n            moveEmbeddedView(this._data, previousIndex, currentIndex);\r\n            return viewRef;\r\n        };\r\n        ViewContainerRef_.prototype.indexOf = function (viewRef) {\r\n            return this._embeddedViews.indexOf(viewRef._view);\r\n        };\r\n        ViewContainerRef_.prototype.remove = function (index) {\r\n            var viewData = detachEmbeddedView(this._data, index);\r\n            if (viewData) {\r\n                Services.destroyView(viewData);\r\n            }\r\n        };\r\n        ViewContainerRef_.prototype.detach = function (index) {\r\n            var view = detachEmbeddedView(this._data, index);\r\n            return view ? new ViewRef_(view) : null;\r\n        };\r\n        return ViewContainerRef_;\r\n    }());\r\n    function createChangeDetectorRef(view) {\r\n        return new ViewRef_(view);\r\n    }\r\n    var ViewRef_ = /** @class */ (function () {\r\n        function ViewRef_(_view) {\r\n            this._view = _view;\r\n            this._viewContainerRef = null;\r\n            this._appRef = null;\r\n        }\r\n        Object.defineProperty(ViewRef_.prototype, \"rootNodes\", {\r\n            get: function () { return rootRenderNodes(this._view); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(ViewRef_.prototype, \"context\", {\r\n            get: function () { return this._view.context; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(ViewRef_.prototype, \"destroyed\", {\r\n            get: function () { return (this._view.state & 128 /* Destroyed */) !== 0; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        ViewRef_.prototype.markForCheck = function () { markParentViewsForCheck(this._view); };\r\n        ViewRef_.prototype.detach = function () { this._view.state &= ~4 /* Attached */; };\r\n        ViewRef_.prototype.detectChanges = function () {\r\n            var fs = this._view.root.rendererFactory;\r\n            if (fs.begin) {\r\n                fs.begin();\r\n            }\r\n            try {\r\n                Services.checkAndUpdateView(this._view);\r\n            }\r\n            finally {\r\n                if (fs.end) {\r\n                    fs.end();\r\n                }\r\n            }\r\n        };\r\n        ViewRef_.prototype.checkNoChanges = function () { Services.checkNoChangesView(this._view); };\r\n        ViewRef_.prototype.reattach = function () { this._view.state |= 4 /* Attached */; };\r\n        ViewRef_.prototype.onDestroy = function (callback) {\r\n            if (!this._view.disposables) {\r\n                this._view.disposables = [];\r\n            }\r\n            this._view.disposables.push(callback);\r\n        };\r\n        ViewRef_.prototype.destroy = function () {\r\n            if (this._appRef) {\r\n                this._appRef.detachView(this);\r\n            }\r\n            else if (this._viewContainerRef) {\r\n                this._viewContainerRef.detach(this._viewContainerRef.indexOf(this));\r\n            }\r\n            Services.destroyView(this._view);\r\n        };\r\n        ViewRef_.prototype.detachFromAppRef = function () {\r\n            this._appRef = null;\r\n            renderDetachView$1(this._view);\r\n            Services.dirtyParentQueries(this._view);\r\n        };\r\n        ViewRef_.prototype.attachToAppRef = function (appRef) {\r\n            if (this._viewContainerRef) {\r\n                throw new Error('This view is already attached to a ViewContainer!');\r\n            }\r\n            this._appRef = appRef;\r\n        };\r\n        ViewRef_.prototype.attachToViewContainerRef = function (vcRef) {\r\n            if (this._appRef) {\r\n                throw new Error('This view is already attached directly to the ApplicationRef!');\r\n            }\r\n            this._viewContainerRef = vcRef;\r\n        };\r\n        return ViewRef_;\r\n    }());\r\n    function createTemplateData(view, def) {\r\n        return new TemplateRef_(view, def);\r\n    }\r\n    var TemplateRef_ = /** @class */ (function (_super) {\r\n        __extends(TemplateRef_, _super);\r\n        function TemplateRef_(_parentView, _def) {\r\n            var _this = _super.call(this) || this;\r\n            _this._parentView = _parentView;\r\n            _this._def = _def;\r\n            return _this;\r\n        }\r\n        TemplateRef_.prototype.createEmbeddedView = function (context) {\r\n            return new ViewRef_(Services.createEmbeddedView(this._parentView, this._def, this._def.element.template, context));\r\n        };\r\n        Object.defineProperty(TemplateRef_.prototype, \"elementRef\", {\r\n            get: function () {\r\n                return new ElementRef(asElementData(this._parentView, this._def.nodeIndex).renderElement);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return TemplateRef_;\r\n    }(TemplateRef));\r\n    function createInjector$1(view, elDef) {\r\n        return new Injector_(view, elDef);\r\n    }\r\n    var Injector_ = /** @class */ (function () {\r\n        function Injector_(view, elDef) {\r\n            this.view = view;\r\n            this.elDef = elDef;\r\n        }\r\n        Injector_.prototype.get = function (token, notFoundValue) {\r\n            if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }\r\n            var allowPrivateServices = this.elDef ? (this.elDef.flags & 33554432 /* ComponentView */) !== 0 : false;\r\n            return Services.resolveDep(this.view, this.elDef, allowPrivateServices, { flags: 0 /* None */, token: token, tokenKey: tokenKey(token) }, notFoundValue);\r\n        };\r\n        return Injector_;\r\n    }());\r\n    function nodeValue(view, index) {\r\n        var def = view.def.nodes[index];\r\n        if (def.flags & 1 /* TypeElement */) {\r\n            var elData = asElementData(view, def.nodeIndex);\r\n            return def.element.template ? elData.template : elData.renderElement;\r\n        }\r\n        else if (def.flags & 2 /* TypeText */) {\r\n            return asTextData(view, def.nodeIndex).renderText;\r\n        }\r\n        else if (def.flags & (20224 /* CatProvider */ | 16 /* TypePipe */)) {\r\n            return asProviderData(view, def.nodeIndex).instance;\r\n        }\r\n        throw new Error(\"Illegal state: read nodeValue for node index \" + index);\r\n    }\r\n    function createRendererV1(view) {\r\n        return new RendererAdapter(view.renderer);\r\n    }\r\n    var RendererAdapter = /** @class */ (function () {\r\n        function RendererAdapter(delegate) {\r\n            this.delegate = delegate;\r\n        }\r\n        RendererAdapter.prototype.selectRootElement = function (selectorOrNode) {\r\n            return this.delegate.selectRootElement(selectorOrNode);\r\n        };\r\n        RendererAdapter.prototype.createElement = function (parent, namespaceAndName) {\r\n            var _a = __read(splitNamespace(namespaceAndName), 2), ns = _a[0], name = _a[1];\r\n            var el = this.delegate.createElement(name, ns);\r\n            if (parent) {\r\n                this.delegate.appendChild(parent, el);\r\n            }\r\n            return el;\r\n        };\r\n        RendererAdapter.prototype.createViewRoot = function (hostElement) { return hostElement; };\r\n        RendererAdapter.prototype.createTemplateAnchor = function (parentElement) {\r\n            var comment = this.delegate.createComment('');\r\n            if (parentElement) {\r\n                this.delegate.appendChild(parentElement, comment);\r\n            }\r\n            return comment;\r\n        };\r\n        RendererAdapter.prototype.createText = function (parentElement, value) {\r\n            var node = this.delegate.createText(value);\r\n            if (parentElement) {\r\n                this.delegate.appendChild(parentElement, node);\r\n            }\r\n            return node;\r\n        };\r\n        RendererAdapter.prototype.projectNodes = function (parentElement, nodes) {\r\n            for (var i = 0; i < nodes.length; i++) {\r\n                this.delegate.appendChild(parentElement, nodes[i]);\r\n            }\r\n        };\r\n        RendererAdapter.prototype.attachViewAfter = function (node, viewRootNodes) {\r\n            var parentElement = this.delegate.parentNode(node);\r\n            var nextSibling = this.delegate.nextSibling(node);\r\n            for (var i = 0; i < viewRootNodes.length; i++) {\r\n                this.delegate.insertBefore(parentElement, viewRootNodes[i], nextSibling);\r\n            }\r\n        };\r\n        RendererAdapter.prototype.detachView = function (viewRootNodes) {\r\n            for (var i = 0; i < viewRootNodes.length; i++) {\r\n                var node = viewRootNodes[i];\r\n                var parentElement = this.delegate.parentNode(node);\r\n                this.delegate.removeChild(parentElement, node);\r\n            }\r\n        };\r\n        RendererAdapter.prototype.destroyView = function (hostElement, viewAllNodes) {\r\n            for (var i = 0; i < viewAllNodes.length; i++) {\r\n                this.delegate.destroyNode(viewAllNodes[i]);\r\n            }\r\n        };\r\n        RendererAdapter.prototype.listen = function (renderElement, name, callback) {\r\n            return this.delegate.listen(renderElement, name, callback);\r\n        };\r\n        RendererAdapter.prototype.listenGlobal = function (target, name, callback) {\r\n            return this.delegate.listen(target, name, callback);\r\n        };\r\n        RendererAdapter.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {\r\n            this.delegate.setProperty(renderElement, propertyName, propertyValue);\r\n        };\r\n        RendererAdapter.prototype.setElementAttribute = function (renderElement, namespaceAndName, attributeValue) {\r\n            var _a = __read(splitNamespace(namespaceAndName), 2), ns = _a[0], name = _a[1];\r\n            if (attributeValue != null) {\r\n                this.delegate.setAttribute(renderElement, name, attributeValue, ns);\r\n            }\r\n            else {\r\n                this.delegate.removeAttribute(renderElement, name, ns);\r\n            }\r\n        };\r\n        RendererAdapter.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) { };\r\n        RendererAdapter.prototype.setElementClass = function (renderElement, className, isAdd) {\r\n            if (isAdd) {\r\n                this.delegate.addClass(renderElement, className);\r\n            }\r\n            else {\r\n                this.delegate.removeClass(renderElement, className);\r\n            }\r\n        };\r\n        RendererAdapter.prototype.setElementStyle = function (renderElement, styleName, styleValue) {\r\n            if (styleValue != null) {\r\n                this.delegate.setStyle(renderElement, styleName, styleValue);\r\n            }\r\n            else {\r\n                this.delegate.removeStyle(renderElement, styleName);\r\n            }\r\n        };\r\n        RendererAdapter.prototype.invokeElementMethod = function (renderElement, methodName, args) {\r\n            renderElement[methodName].apply(renderElement, args);\r\n        };\r\n        RendererAdapter.prototype.setText = function (renderNode, text) { this.delegate.setValue(renderNode, text); };\r\n        RendererAdapter.prototype.animate = function () { throw new Error('Renderer.animate is no longer supported!'); };\r\n        return RendererAdapter;\r\n    }());\r\n    function createNgModuleRef(moduleType, parent, bootstrapComponents, def) {\r\n        return new NgModuleRef_(moduleType, parent, bootstrapComponents, def);\r\n    }\r\n    var NgModuleRef_ = /** @class */ (function () {\r\n        function NgModuleRef_(_moduleType, _parent, _bootstrapComponents, _def) {\r\n            this._moduleType = _moduleType;\r\n            this._parent = _parent;\r\n            this._bootstrapComponents = _bootstrapComponents;\r\n            this._def = _def;\r\n            this._destroyListeners = [];\r\n            this._destroyed = false;\r\n            this.injector = this;\r\n            initNgModule(this);\r\n        }\r\n        NgModuleRef_.prototype.get = function (token, notFoundValue, injectFlags) {\r\n            if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }\r\n            if (injectFlags === void 0) { injectFlags = exports.InjectFlags.Default; }\r\n            var flags = 0 /* None */;\r\n            if (injectFlags & exports.InjectFlags.SkipSelf) {\r\n                flags |= 1 /* SkipSelf */;\r\n            }\r\n            else if (injectFlags & exports.InjectFlags.Self) {\r\n                flags |= 4 /* Self */;\r\n            }\r\n            return resolveNgModuleDep(this, { token: token, tokenKey: tokenKey(token), flags: flags }, notFoundValue);\r\n        };\r\n        Object.defineProperty(NgModuleRef_.prototype, \"instance\", {\r\n            get: function () { return this.get(this._moduleType); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(NgModuleRef_.prototype, \"componentFactoryResolver\", {\r\n            get: function () { return this.get(ComponentFactoryResolver); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        NgModuleRef_.prototype.destroy = function () {\r\n            if (this._destroyed) {\r\n                throw new Error(\"The ng module \" + stringify(this.instance.constructor) + \" has already been destroyed.\");\r\n            }\r\n            this._destroyed = true;\r\n            callNgModuleLifecycle(this, 131072 /* OnDestroy */);\r\n            this._destroyListeners.forEach(function (listener) { return listener(); });\r\n        };\r\n        NgModuleRef_.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };\r\n        return NgModuleRef_;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var RendererV1TokenKey = tokenKey(Renderer);\r\n    var Renderer2TokenKey = tokenKey(Renderer2);\r\n    var ElementRefTokenKey = tokenKey(ElementRef);\r\n    var ViewContainerRefTokenKey = tokenKey(ViewContainerRef);\r\n    var TemplateRefTokenKey = tokenKey(TemplateRef);\r\n    var ChangeDetectorRefTokenKey = tokenKey(ChangeDetectorRef);\r\n    var InjectorRefTokenKey$1 = tokenKey(Injector);\r\n    var INJECTORRefTokenKey$1 = tokenKey(INJECTOR);\r\n    function directiveDef(checkIndex, flags, matchedQueries, childCount, ctor, deps, props, outputs) {\r\n        var bindings = [];\r\n        if (props) {\r\n            for (var prop in props) {\r\n                var _a = __read(props[prop], 2), bindingIndex = _a[0], nonMinifiedName = _a[1];\r\n                bindings[bindingIndex] = {\r\n                    flags: 8 /* TypeProperty */,\r\n                    name: prop, nonMinifiedName: nonMinifiedName,\r\n                    ns: null,\r\n                    securityContext: null,\r\n                    suffix: null\r\n                };\r\n            }\r\n        }\r\n        var outputDefs = [];\r\n        if (outputs) {\r\n            for (var propName in outputs) {\r\n                outputDefs.push({ type: 1 /* DirectiveOutput */, propName: propName, target: null, eventName: outputs[propName] });\r\n            }\r\n        }\r\n        flags |= 16384 /* TypeDirective */;\r\n        return _def(checkIndex, flags, matchedQueries, childCount, ctor, ctor, deps, bindings, outputDefs);\r\n    }\r\n    function pipeDef(flags, ctor, deps) {\r\n        flags |= 16 /* TypePipe */;\r\n        return _def(-1, flags, null, 0, ctor, ctor, deps);\r\n    }\r\n    function providerDef(flags, matchedQueries, token, value, deps) {\r\n        return _def(-1, flags, matchedQueries, 0, token, value, deps);\r\n    }\r\n    function _def(checkIndex, flags, matchedQueriesDsl, childCount, token, value, deps, bindings, outputs) {\r\n        var _a = splitMatchedQueriesDsl(matchedQueriesDsl), matchedQueries = _a.matchedQueries, references = _a.references, matchedQueryIds = _a.matchedQueryIds;\r\n        if (!outputs) {\r\n            outputs = [];\r\n        }\r\n        if (!bindings) {\r\n            bindings = [];\r\n        }\r\n        // Need to resolve forwardRefs as e.g. for `useValue` we\r\n        // lowered the expression and then stopped evaluating it,\r\n        // i.e. also didn't unwrap it.\r\n        value = resolveForwardRef(value);\r\n        var depDefs = splitDepsDsl(deps, stringify(token));\r\n        return {\r\n            // will bet set by the view definition\r\n            nodeIndex: -1,\r\n            parent: null,\r\n            renderParent: null,\r\n            bindingIndex: -1,\r\n            outputIndex: -1,\r\n            // regular values\r\n            checkIndex: checkIndex,\r\n            flags: flags,\r\n            childFlags: 0,\r\n            directChildFlags: 0,\r\n            childMatchedQueries: 0, matchedQueries: matchedQueries, matchedQueryIds: matchedQueryIds, references: references,\r\n            ngContentIndex: -1, childCount: childCount, bindings: bindings,\r\n            bindingFlags: calcBindingFlags(bindings), outputs: outputs,\r\n            element: null,\r\n            provider: { token: token, value: value, deps: depDefs },\r\n            text: null,\r\n            query: null,\r\n            ngContent: null\r\n        };\r\n    }\r\n    function createProviderInstance(view, def) {\r\n        return _createProviderInstance$1(view, def);\r\n    }\r\n    function createPipeInstance(view, def) {\r\n        // deps are looked up from component.\r\n        var compView = view;\r\n        while (compView.parent && !isComponentView(compView)) {\r\n            compView = compView.parent;\r\n        }\r\n        // pipes can see the private services of the component\r\n        var allowPrivateServices = true;\r\n        // pipes are always eager and classes!\r\n        return createClass(compView.parent, viewParentEl(compView), allowPrivateServices, def.provider.value, def.provider.deps);\r\n    }\r\n    function createDirectiveInstance(view, def) {\r\n        // components can see other private services, other directives can't.\r\n        var allowPrivateServices = (def.flags & 32768 /* Component */) > 0;\r\n        // directives are always eager and classes!\r\n        var instance = createClass(view, def.parent, allowPrivateServices, def.provider.value, def.provider.deps);\r\n        if (def.outputs.length) {\r\n            for (var i = 0; i < def.outputs.length; i++) {\r\n                var output = def.outputs[i];\r\n                var outputObservable = instance[output.propName];\r\n                if (isObservable(outputObservable)) {\r\n                    var subscription = outputObservable.subscribe(eventHandlerClosure(view, def.parent.nodeIndex, output.eventName));\r\n                    view.disposables[def.outputIndex + i] = subscription.unsubscribe.bind(subscription);\r\n                }\r\n                else {\r\n                    throw new Error(\"@Output \" + output.propName + \" not initialized in '\" + instance.constructor.name + \"'.\");\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n    function eventHandlerClosure(view, index, eventName) {\r\n        return function (event) { return dispatchEvent(view, index, eventName, event); };\r\n    }\r\n    function checkAndUpdateDirectiveInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\r\n        var providerData = asProviderData(view, def.nodeIndex);\r\n        var directive = providerData.instance;\r\n        var changed = false;\r\n        var changes = undefined;\r\n        var bindLen = def.bindings.length;\r\n        if (bindLen > 0 && checkBinding(view, def, 0, v0)) {\r\n            changed = true;\r\n            changes = updateProp(view, providerData, def, 0, v0, changes);\r\n        }\r\n        if (bindLen > 1 && checkBinding(view, def, 1, v1)) {\r\n            changed = true;\r\n            changes = updateProp(view, providerData, def, 1, v1, changes);\r\n        }\r\n        if (bindLen > 2 && checkBinding(view, def, 2, v2)) {\r\n            changed = true;\r\n            changes = updateProp(view, providerData, def, 2, v2, changes);\r\n        }\r\n        if (bindLen > 3 && checkBinding(view, def, 3, v3)) {\r\n            changed = true;\r\n            changes = updateProp(view, providerData, def, 3, v3, changes);\r\n        }\r\n        if (bindLen > 4 && checkBinding(view, def, 4, v4)) {\r\n            changed = true;\r\n            changes = updateProp(view, providerData, def, 4, v4, changes);\r\n        }\r\n        if (bindLen > 5 && checkBinding(view, def, 5, v5)) {\r\n            changed = true;\r\n            changes = updateProp(view, providerData, def, 5, v5, changes);\r\n        }\r\n        if (bindLen > 6 && checkBinding(view, def, 6, v6)) {\r\n            changed = true;\r\n            changes = updateProp(view, providerData, def, 6, v6, changes);\r\n        }\r\n        if (bindLen > 7 && checkBinding(view, def, 7, v7)) {\r\n            changed = true;\r\n            changes = updateProp(view, providerData, def, 7, v7, changes);\r\n        }\r\n        if (bindLen > 8 && checkBinding(view, def, 8, v8)) {\r\n            changed = true;\r\n            changes = updateProp(view, providerData, def, 8, v8, changes);\r\n        }\r\n        if (bindLen > 9 && checkBinding(view, def, 9, v9)) {\r\n            changed = true;\r\n            changes = updateProp(view, providerData, def, 9, v9, changes);\r\n        }\r\n        if (changes) {\r\n            directive.ngOnChanges(changes);\r\n        }\r\n        if ((def.flags & 65536 /* OnInit */) &&\r\n            shouldCallLifecycleInitHook(view, 256 /* InitState_CallingOnInit */, def.nodeIndex)) {\r\n            directive.ngOnInit();\r\n        }\r\n        if (def.flags & 262144 /* DoCheck */) {\r\n            directive.ngDoCheck();\r\n        }\r\n        return changed;\r\n    }\r\n    function checkAndUpdateDirectiveDynamic(view, def, values) {\r\n        var providerData = asProviderData(view, def.nodeIndex);\r\n        var directive = providerData.instance;\r\n        var changed = false;\r\n        var changes = undefined;\r\n        for (var i = 0; i < values.length; i++) {\r\n            if (checkBinding(view, def, i, values[i])) {\r\n                changed = true;\r\n                changes = updateProp(view, providerData, def, i, values[i], changes);\r\n            }\r\n        }\r\n        if (changes) {\r\n            directive.ngOnChanges(changes);\r\n        }\r\n        if ((def.flags & 65536 /* OnInit */) &&\r\n            shouldCallLifecycleInitHook(view, 256 /* InitState_CallingOnInit */, def.nodeIndex)) {\r\n            directive.ngOnInit();\r\n        }\r\n        if (def.flags & 262144 /* DoCheck */) {\r\n            directive.ngDoCheck();\r\n        }\r\n        return changed;\r\n    }\r\n    function _createProviderInstance$1(view, def) {\r\n        // private services can see other private services\r\n        var allowPrivateServices = (def.flags & 8192 /* PrivateProvider */) > 0;\r\n        var providerDef = def.provider;\r\n        switch (def.flags & 201347067 /* Types */) {\r\n            case 512 /* TypeClassProvider */:\r\n                return createClass(view, def.parent, allowPrivateServices, providerDef.value, providerDef.deps);\r\n            case 1024 /* TypeFactoryProvider */:\r\n                return callFactory(view, def.parent, allowPrivateServices, providerDef.value, providerDef.deps);\r\n            case 2048 /* TypeUseExistingProvider */:\r\n                return resolveDep(view, def.parent, allowPrivateServices, providerDef.deps[0]);\r\n            case 256 /* TypeValueProvider */:\r\n                return providerDef.value;\r\n        }\r\n    }\r\n    function createClass(view, elDef, allowPrivateServices, ctor, deps) {\r\n        var len = deps.length;\r\n        switch (len) {\r\n            case 0:\r\n                return new ctor();\r\n            case 1:\r\n                return new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]));\r\n            case 2:\r\n                return new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]));\r\n            case 3:\r\n                return new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]), resolveDep(view, elDef, allowPrivateServices, deps[2]));\r\n            default:\r\n                var depValues = new Array(len);\r\n                for (var i = 0; i < len; i++) {\r\n                    depValues[i] = resolveDep(view, elDef, allowPrivateServices, deps[i]);\r\n                }\r\n                return new (ctor.bind.apply(ctor, __spread([void 0], depValues)))();\r\n        }\r\n    }\r\n    function callFactory(view, elDef, allowPrivateServices, factory, deps) {\r\n        var len = deps.length;\r\n        switch (len) {\r\n            case 0:\r\n                return factory();\r\n            case 1:\r\n                return factory(resolveDep(view, elDef, allowPrivateServices, deps[0]));\r\n            case 2:\r\n                return factory(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]));\r\n            case 3:\r\n                return factory(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]), resolveDep(view, elDef, allowPrivateServices, deps[2]));\r\n            default:\r\n                var depValues = Array(len);\r\n                for (var i = 0; i < len; i++) {\r\n                    depValues[i] = resolveDep(view, elDef, allowPrivateServices, deps[i]);\r\n                }\r\n                return factory.apply(void 0, __spread(depValues));\r\n        }\r\n    }\r\n    // This default value is when checking the hierarchy for a token.\r\n    //\r\n    // It means both:\r\n    // - the token is not provided by the current injector,\r\n    // - only the element injectors should be checked (ie do not check module injectors\r\n    //\r\n    //          mod1\r\n    //         /\r\n    //       el1   mod2\r\n    //         \\  /\r\n    //         el2\r\n    //\r\n    // When requesting el2.injector.get(token), we should check in the following order and return the\r\n    // first found value:\r\n    // - el2.injector.get(token, default)\r\n    // - el1.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) -> do not check the module\r\n    // - mod2.injector.get(token, default)\r\n    var NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};\r\n    function resolveDep(view, elDef, allowPrivateServices, depDef, notFoundValue) {\r\n        if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }\r\n        if (depDef.flags & 8 /* Value */) {\r\n            return depDef.token;\r\n        }\r\n        var startView = view;\r\n        if (depDef.flags & 2 /* Optional */) {\r\n            notFoundValue = null;\r\n        }\r\n        var tokenKey = depDef.tokenKey;\r\n        if (tokenKey === ChangeDetectorRefTokenKey) {\r\n            // directives on the same element as a component should be able to control the change detector\r\n            // of that component as well.\r\n            allowPrivateServices = !!(elDef && elDef.element.componentView);\r\n        }\r\n        if (elDef && (depDef.flags & 1 /* SkipSelf */)) {\r\n            allowPrivateServices = false;\r\n            elDef = elDef.parent;\r\n        }\r\n        var searchView = view;\r\n        while (searchView) {\r\n            if (elDef) {\r\n                switch (tokenKey) {\r\n                    case RendererV1TokenKey: {\r\n                        var compView = findCompView(searchView, elDef, allowPrivateServices);\r\n                        return createRendererV1(compView);\r\n                    }\r\n                    case Renderer2TokenKey: {\r\n                        var compView = findCompView(searchView, elDef, allowPrivateServices);\r\n                        return compView.renderer;\r\n                    }\r\n                    case ElementRefTokenKey:\r\n                        return new ElementRef(asElementData(searchView, elDef.nodeIndex).renderElement);\r\n                    case ViewContainerRefTokenKey:\r\n                        return asElementData(searchView, elDef.nodeIndex).viewContainer;\r\n                    case TemplateRefTokenKey: {\r\n                        if (elDef.element.template) {\r\n                            return asElementData(searchView, elDef.nodeIndex).template;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case ChangeDetectorRefTokenKey: {\r\n                        var cdView = findCompView(searchView, elDef, allowPrivateServices);\r\n                        return createChangeDetectorRef(cdView);\r\n                    }\r\n                    case InjectorRefTokenKey$1:\r\n                    case INJECTORRefTokenKey$1:\r\n                        return createInjector$1(searchView, elDef);\r\n                    default:\r\n                        var providerDef_1 = (allowPrivateServices ? elDef.element.allProviders :\r\n                            elDef.element.publicProviders)[tokenKey];\r\n                        if (providerDef_1) {\r\n                            var providerData = asProviderData(searchView, providerDef_1.nodeIndex);\r\n                            if (!providerData) {\r\n                                providerData = { instance: _createProviderInstance$1(searchView, providerDef_1) };\r\n                                searchView.nodes[providerDef_1.nodeIndex] = providerData;\r\n                            }\r\n                            return providerData.instance;\r\n                        }\r\n                }\r\n            }\r\n            allowPrivateServices = isComponentView(searchView);\r\n            elDef = viewParentEl(searchView);\r\n            searchView = searchView.parent;\r\n            if (depDef.flags & 4 /* Self */) {\r\n                searchView = null;\r\n            }\r\n        }\r\n        var value = startView.root.injector.get(depDef.token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR);\r\n        if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||\r\n            notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {\r\n            // Return the value from the root element injector when\r\n            // - it provides it\r\n            //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\r\n            // - the module injector should not be checked\r\n            //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\r\n            return value;\r\n        }\r\n        return startView.root.ngModule.injector.get(depDef.token, notFoundValue);\r\n    }\r\n    function findCompView(view, elDef, allowPrivateServices) {\r\n        var compView;\r\n        if (allowPrivateServices) {\r\n            compView = asElementData(view, elDef.nodeIndex).componentView;\r\n        }\r\n        else {\r\n            compView = view;\r\n            while (compView.parent && !isComponentView(compView)) {\r\n                compView = compView.parent;\r\n            }\r\n        }\r\n        return compView;\r\n    }\r\n    function updateProp(view, providerData, def, bindingIdx, value, changes) {\r\n        if (def.flags & 32768 /* Component */) {\r\n            var compView = asElementData(view, def.parent.nodeIndex).componentView;\r\n            if (compView.def.flags & 2 /* OnPush */) {\r\n                compView.state |= 8 /* ChecksEnabled */;\r\n            }\r\n        }\r\n        var binding = def.bindings[bindingIdx];\r\n        var propName = binding.name;\r\n        // Note: This is still safe with Closure Compiler as\r\n        // the user passed in the property name as an object has to `providerDef`,\r\n        // so Closure Compiler will have renamed the property correctly already.\r\n        providerData.instance[propName] = value;\r\n        if (def.flags & 524288 /* OnChanges */) {\r\n            changes = changes || {};\r\n            var oldValue = WrappedValue.unwrap(view.oldValues[def.bindingIndex + bindingIdx]);\r\n            var binding_1 = def.bindings[bindingIdx];\r\n            changes[binding_1.nonMinifiedName] =\r\n                new SimpleChange(oldValue, value, (view.state & 2 /* FirstCheck */) !== 0);\r\n        }\r\n        view.oldValues[def.bindingIndex + bindingIdx] = value;\r\n        return changes;\r\n    }\r\n    // This function calls the ngAfterContentCheck, ngAfterContentInit,\r\n    // ngAfterViewCheck, and ngAfterViewInit lifecycle hooks (depending on the node\r\n    // flags in lifecycle). Unlike ngDoCheck, ngOnChanges and ngOnInit, which are\r\n    // called during a pre-order traversal of the view tree (that is calling the\r\n    // parent hooks before the child hooks) these events are sent in using a\r\n    // post-order traversal of the tree (children before parents). This changes the\r\n    // meaning of initIndex in the view state. For ngOnInit, initIndex tracks the\r\n    // expected nodeIndex which a ngOnInit should be called. When sending\r\n    // ngAfterContentInit and ngAfterViewInit it is the expected count of\r\n    // ngAfterContentInit or ngAfterViewInit methods that have been called. This\r\n    // ensure that despite being called recursively or after picking up after an\r\n    // exception, the ngAfterContentInit or ngAfterViewInit will be called on the\r\n    // correct nodes. Consider for example, the following (where E is an element\r\n    // and D is a directive)\r\n    //  Tree:       pre-order index  post-order index\r\n    //    E1        0                6\r\n    //      E2      1                1\r\n    //       D3     2                0\r\n    //      E4      3                5\r\n    //       E5     4                4\r\n    //        E6    5                2\r\n    //        E7    6                3\r\n    // As can be seen, the post-order index has an unclear relationship to the\r\n    // pre-order index (postOrderIndex === preOrderIndex - parentCount +\r\n    // childCount). Since number of calls to ngAfterContentInit and ngAfterViewInit\r\n    // are stable (will be the same for the same view regardless of exceptions or\r\n    // recursion) we just need to count them which will roughly correspond to the\r\n    // post-order index (it skips elements and directives that do not have\r\n    // lifecycle hooks).\r\n    //\r\n    // For example, if an exception is raised in the E6.onAfterViewInit() the\r\n    // initIndex is left at 3 (by shouldCallLifecycleInitHook() which set it to\r\n    // initIndex + 1). When checkAndUpdateView() is called again D3, E2 and E6 will\r\n    // not have their ngAfterViewInit() called but, starting with E7, the rest of\r\n    // the view will begin getting ngAfterViewInit() called until a check and\r\n    // pass is complete.\r\n    //\r\n    // This algorthim also handles recursion. Consider if E4's ngAfterViewInit()\r\n    // indirectly calls E1's ChangeDetectorRef.detectChanges(). The expected\r\n    // initIndex is set to 6, the recusive checkAndUpdateView() starts walk again.\r\n    // D3, E2, E6, E7, E5 and E4 are skipped, ngAfterViewInit() is called on E1.\r\n    // When the recursion returns the initIndex will be 7 so E1 is skipped as it\r\n    // has already been called in the recursively called checkAnUpdateView().\r\n    function callLifecycleHooksChildrenFirst(view, lifecycles) {\r\n        if (!(view.def.nodeFlags & lifecycles)) {\r\n            return;\r\n        }\r\n        var nodes = view.def.nodes;\r\n        var initIndex = 0;\r\n        for (var i = 0; i < nodes.length; i++) {\r\n            var nodeDef = nodes[i];\r\n            var parent_1 = nodeDef.parent;\r\n            if (!parent_1 && nodeDef.flags & lifecycles) {\r\n                // matching root node (e.g. a pipe)\r\n                callProviderLifecycles(view, i, nodeDef.flags & lifecycles, initIndex++);\r\n            }\r\n            if ((nodeDef.childFlags & lifecycles) === 0) {\r\n                // no child matches one of the lifecycles\r\n                i += nodeDef.childCount;\r\n            }\r\n            while (parent_1 && (parent_1.flags & 1 /* TypeElement */) &&\r\n                i === parent_1.nodeIndex + parent_1.childCount) {\r\n                // last child of an element\r\n                if (parent_1.directChildFlags & lifecycles) {\r\n                    initIndex = callElementProvidersLifecycles(view, parent_1, lifecycles, initIndex);\r\n                }\r\n                parent_1 = parent_1.parent;\r\n            }\r\n        }\r\n    }\r\n    function callElementProvidersLifecycles(view, elDef, lifecycles, initIndex) {\r\n        for (var i = elDef.nodeIndex + 1; i <= elDef.nodeIndex + elDef.childCount; i++) {\r\n            var nodeDef = view.def.nodes[i];\r\n            if (nodeDef.flags & lifecycles) {\r\n                callProviderLifecycles(view, i, nodeDef.flags & lifecycles, initIndex++);\r\n            }\r\n            // only visit direct children\r\n            i += nodeDef.childCount;\r\n        }\r\n        return initIndex;\r\n    }\r\n    function callProviderLifecycles(view, index, lifecycles, initIndex) {\r\n        var providerData = asProviderData(view, index);\r\n        if (!providerData) {\r\n            return;\r\n        }\r\n        var provider = providerData.instance;\r\n        if (!provider) {\r\n            return;\r\n        }\r\n        Services.setCurrentNode(view, index);\r\n        if (lifecycles & 1048576 /* AfterContentInit */ &&\r\n            shouldCallLifecycleInitHook(view, 512 /* InitState_CallingAfterContentInit */, initIndex)) {\r\n            provider.ngAfterContentInit();\r\n        }\r\n        if (lifecycles & 2097152 /* AfterContentChecked */) {\r\n            provider.ngAfterContentChecked();\r\n        }\r\n        if (lifecycles & 4194304 /* AfterViewInit */ &&\r\n            shouldCallLifecycleInitHook(view, 768 /* InitState_CallingAfterViewInit */, initIndex)) {\r\n            provider.ngAfterViewInit();\r\n        }\r\n        if (lifecycles & 8388608 /* AfterViewChecked */) {\r\n            provider.ngAfterViewChecked();\r\n        }\r\n        if (lifecycles & 131072 /* OnDestroy */) {\r\n            provider.ngOnDestroy();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var ComponentFactoryResolver$1 = /** @class */ (function (_super) {\r\n        __extends(ComponentFactoryResolver, _super);\r\n        /**\r\n         * @param ngModule The NgModuleRef to which all resolved factories are bound.\r\n         */\r\n        function ComponentFactoryResolver(ngModule) {\r\n            var _this = _super.call(this) || this;\r\n            _this.ngModule = ngModule;\r\n            return _this;\r\n        }\r\n        ComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {\r\n            ngDevMode && assertComponentType(component);\r\n            var componentDef = getComponentDef(component);\r\n            return new ComponentFactory$1(componentDef, this.ngModule);\r\n        };\r\n        return ComponentFactoryResolver;\r\n    }(ComponentFactoryResolver));\r\n    function toRefArray(map) {\r\n        var array = [];\r\n        for (var nonMinified in map) {\r\n            if (map.hasOwnProperty(nonMinified)) {\r\n                var minified = map[nonMinified];\r\n                array.push({ propName: minified, templateName: nonMinified });\r\n            }\r\n        }\r\n        return array;\r\n    }\r\n    /**\r\n     * A change detection scheduler token for {@link RootContext}. This token is the default value used\r\n     * for the default `RootContext` found in the {@link ROOT_CONTEXT} token.\r\n     */\r\n    var SCHEDULER = new InjectionToken('SCHEDULER_TOKEN', {\r\n        providedIn: 'root',\r\n        factory: function () { return defaultScheduler; },\r\n    });\r\n    function createChainedInjector(rootViewInjector, moduleInjector) {\r\n        return {\r\n            get: function (token, notFoundValue, flags) {\r\n                var value = rootViewInjector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);\r\n                if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||\r\n                    notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {\r\n                    // Return the value from the root element injector when\r\n                    // - it provides it\r\n                    //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\r\n                    // - the module injector should not be checked\r\n                    //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\r\n                    return value;\r\n                }\r\n                return moduleInjector.get(token, notFoundValue, flags);\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * Render3 implementation of {@link viewEngine_ComponentFactory}.\r\n     */\r\n    var ComponentFactory$1 = /** @class */ (function (_super) {\r\n        __extends(ComponentFactory, _super);\r\n        /**\r\n         * @param componentDef The component definition.\r\n         * @param ngModule The NgModuleRef to which the factory is bound.\r\n         */\r\n        function ComponentFactory(componentDef, ngModule) {\r\n            var _this = _super.call(this) || this;\r\n            _this.componentDef = componentDef;\r\n            _this.ngModule = ngModule;\r\n            _this.componentType = componentDef.type;\r\n            // default to 'div' in case this component has an attribute selector\r\n            _this.selector = componentDef.selectors[0][0] || 'div';\r\n            _this.ngContentSelectors =\r\n                componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];\r\n            _this.isBoundToModule = !!ngModule;\r\n            return _this;\r\n        }\r\n        Object.defineProperty(ComponentFactory.prototype, \"inputs\", {\r\n            get: function () {\r\n                return toRefArray(this.componentDef.inputs);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(ComponentFactory.prototype, \"outputs\", {\r\n            get: function () {\r\n                return toRefArray(this.componentDef.outputs);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        ComponentFactory.prototype.create = function (injector, projectableNodes, rootSelectorOrNode, ngModule) {\r\n            ngModule = ngModule || this.ngModule;\r\n            var rootViewInjector = ngModule ? createChainedInjector(injector, ngModule.injector) : injector;\r\n            var rendererFactory = rootViewInjector.get(RendererFactory2, domRendererFactory3);\r\n            var sanitizer = rootViewInjector.get(Sanitizer, null);\r\n            // Ensure that the namespace for the root node is correct,\r\n            // otherwise the browser might not render out the element properly.\r\n            namespaceHTMLInternal();\r\n            var hostRNode = rootSelectorOrNode ?\r\n                locateHostElement(rendererFactory, rootSelectorOrNode) :\r\n                elementCreate(this.selector, rendererFactory.createRenderer(null, this.componentDef));\r\n            var rootFlags = this.componentDef.onPush ? 64 /* Dirty */ | 512 /* IsRoot */ :\r\n                16 /* CheckAlways */ | 512 /* IsRoot */;\r\n            // Check whether this Component needs to be isolated from other components, i.e. whether it\r\n            // should be placed into its own (empty) root context or existing root context should be used.\r\n            // Note: this is internal-only convention and might change in the future, so it should not be\r\n            // relied upon externally.\r\n            var isIsolated = typeof rootSelectorOrNode === 'string' &&\r\n                /^#root-ng-internal-isolated-\\d+/.test(rootSelectorOrNode);\r\n            var rootContext = createRootContext();\r\n            var renderer = rendererFactory.createRenderer(hostRNode, this.componentDef);\r\n            if (rootSelectorOrNode && hostRNode) {\r\n                ngDevMode && ngDevMode.rendererSetAttribute++;\r\n                isProceduralRenderer(renderer) ?\r\n                    renderer.setAttribute(hostRNode, 'ng-version', VERSION.full) :\r\n                    hostRNode.setAttribute('ng-version', VERSION.full);\r\n            }\r\n            // Create the root view. Uses empty TView and ContentTemplate.\r\n            var rootLView = createLView(null, createTView(-1, null, 1, 0, null, null, null, null), rootContext, rootFlags, null, null, rendererFactory, renderer, sanitizer, rootViewInjector);\r\n            // rootView is the parent when bootstrapping\r\n            var oldLView = enterView(rootLView, null);\r\n            var component;\r\n            var tElementNode;\r\n            // Will become true if the `try` block executes with no errors.\r\n            var safeToRunHooks = false;\r\n            try {\r\n                var componentView = createRootComponentView(hostRNode, this.componentDef, rootLView, rendererFactory, renderer);\r\n                tElementNode = getTNode(0, rootLView);\r\n                if (projectableNodes) {\r\n                    // projectable nodes can be passed as array of arrays or an array of iterables (ngUpgrade\r\n                    // case). Here we do normalize passed data structure to be an array of arrays to avoid\r\n                    // complex checks down the line.\r\n                    tElementNode.projection =\r\n                        projectableNodes.map(function (nodesforSlot) { return Array.from(nodesforSlot); });\r\n                }\r\n                // TODO: should LifecycleHooksFeature and other host features be generated by the compiler and\r\n                // executed here?\r\n                // Angular 5 reference: https://stackblitz.com/edit/lifecycle-hooks-vcref\r\n                component = createRootComponent(componentView, this.componentDef, rootLView, rootContext, [LifecycleHooksFeature]);\r\n                addToViewTree(rootLView, componentView);\r\n                refreshDescendantViews(rootLView);\r\n                safeToRunHooks = true;\r\n            }\r\n            finally {\r\n                leaveView(oldLView, safeToRunHooks);\r\n            }\r\n            var componentRef = new ComponentRef$1(this.componentType, component, createElementRef(ElementRef, tElementNode, rootLView), rootLView, tElementNode);\r\n            if (!rootSelectorOrNode || isIsolated) {\r\n                // The host element of the internal or isolated root view is attached to the component's host\r\n                // view node.\r\n                componentRef.hostView._tViewNode.child = tElementNode;\r\n            }\r\n            return componentRef;\r\n        };\r\n        return ComponentFactory;\r\n    }(ComponentFactory));\r\n    var componentFactoryResolver = new ComponentFactoryResolver$1();\r\n    /**\r\n     * Creates a ComponentFactoryResolver and stores it on the injector. Or, if the\r\n     * ComponentFactoryResolver\r\n     * already exists, retrieves the existing ComponentFactoryResolver.\r\n     *\r\n     * @returns The ComponentFactoryResolver instance to use\r\n     */\r\n    function injectComponentFactoryResolver() {\r\n        return componentFactoryResolver;\r\n    }\r\n    /**\r\n     * Represents an instance of a Component created via a {@link ComponentFactory}.\r\n     *\r\n     * `ComponentRef` provides access to the Component Instance as well other objects related to this\r\n     * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}\r\n     * method.\r\n     *\r\n     */\r\n    var ComponentRef$1 = /** @class */ (function (_super) {\r\n        __extends(ComponentRef, _super);\r\n        function ComponentRef(componentType, instance, location, _rootLView, _tNode) {\r\n            var _this = _super.call(this) || this;\r\n            _this.location = location;\r\n            _this._rootLView = _rootLView;\r\n            _this._tNode = _tNode;\r\n            _this.destroyCbs = [];\r\n            _this.instance = instance;\r\n            _this.hostView = _this.changeDetectorRef = new RootViewRef(_rootLView);\r\n            _this.hostView._tViewNode = assignTViewNodeToLView(_rootLView[TVIEW], null, -1, _rootLView);\r\n            _this.componentType = componentType;\r\n            return _this;\r\n        }\r\n        Object.defineProperty(ComponentRef.prototype, \"injector\", {\r\n            get: function () { return new NodeInjector(this._tNode, this._rootLView); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        ComponentRef.prototype.destroy = function () {\r\n            if (this.destroyCbs) {\r\n                this.destroyCbs.forEach(function (fn) { return fn(); });\r\n                this.destroyCbs = null;\r\n                !this.hostView.destroyed && this.hostView.destroy();\r\n            }\r\n        };\r\n        ComponentRef.prototype.onDestroy = function (callback) {\r\n            if (this.destroyCbs) {\r\n                this.destroyCbs.push(callback);\r\n            }\r\n        };\r\n        return ComponentRef;\r\n    }(ComponentRef));\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * NOTE: changes to the `ngI18nClosureMode` name must be synced with `compiler-cli/src/tooling.ts`.\r\n     */\r\n    if (typeof ngI18nClosureMode === 'undefined') {\r\n        // These property accesses can be ignored because ngI18nClosureMode will be set to false\r\n        // when optimizing code and the whole if statement will be dropped.\r\n        // Make sure to refer to ngI18nClosureMode as ['ngI18nClosureMode'] for closure.\r\n        // NOTE: we need to have it in IIFE so that the tree-shaker is happy.\r\n        (function () {\r\n            // tslint:disable-next-line:no-toplevel-property-access\r\n            _global['ngI18nClosureMode'] =\r\n                // TODO(FW-1250): validate that this actually, you know, works.\r\n                // tslint:disable-next-line:no-toplevel-property-access\r\n                typeof goog !== 'undefined' && typeof goog.getMsg === 'function';\r\n        })();\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * This const is used to store the locale data registered with `registerLocaleData`\r\n     */\r\n    var LOCALE_DATA = {};\r\n    (function (LocaleDataIndex) {\r\n        LocaleDataIndex[LocaleDataIndex[\"LocaleId\"] = 0] = \"LocaleId\";\r\n        LocaleDataIndex[LocaleDataIndex[\"DayPeriodsFormat\"] = 1] = \"DayPeriodsFormat\";\r\n        LocaleDataIndex[LocaleDataIndex[\"DayPeriodsStandalone\"] = 2] = \"DayPeriodsStandalone\";\r\n        LocaleDataIndex[LocaleDataIndex[\"DaysFormat\"] = 3] = \"DaysFormat\";\r\n        LocaleDataIndex[LocaleDataIndex[\"DaysStandalone\"] = 4] = \"DaysStandalone\";\r\n        LocaleDataIndex[LocaleDataIndex[\"MonthsFormat\"] = 5] = \"MonthsFormat\";\r\n        LocaleDataIndex[LocaleDataIndex[\"MonthsStandalone\"] = 6] = \"MonthsStandalone\";\r\n        LocaleDataIndex[LocaleDataIndex[\"Eras\"] = 7] = \"Eras\";\r\n        LocaleDataIndex[LocaleDataIndex[\"FirstDayOfWeek\"] = 8] = \"FirstDayOfWeek\";\r\n        LocaleDataIndex[LocaleDataIndex[\"WeekendRange\"] = 9] = \"WeekendRange\";\r\n        LocaleDataIndex[LocaleDataIndex[\"DateFormat\"] = 10] = \"DateFormat\";\r\n        LocaleDataIndex[LocaleDataIndex[\"TimeFormat\"] = 11] = \"TimeFormat\";\r\n        LocaleDataIndex[LocaleDataIndex[\"DateTimeFormat\"] = 12] = \"DateTimeFormat\";\r\n        LocaleDataIndex[LocaleDataIndex[\"NumberSymbols\"] = 13] = \"NumberSymbols\";\r\n        LocaleDataIndex[LocaleDataIndex[\"NumberFormats\"] = 14] = \"NumberFormats\";\r\n        LocaleDataIndex[LocaleDataIndex[\"CurrencySymbol\"] = 15] = \"CurrencySymbol\";\r\n        LocaleDataIndex[LocaleDataIndex[\"CurrencyName\"] = 16] = \"CurrencyName\";\r\n        LocaleDataIndex[LocaleDataIndex[\"Currencies\"] = 17] = \"Currencies\";\r\n        LocaleDataIndex[LocaleDataIndex[\"PluralCase\"] = 18] = \"PluralCase\";\r\n        LocaleDataIndex[LocaleDataIndex[\"ExtraData\"] = 19] = \"ExtraData\";\r\n    })(exports.ɵLocaleDataIndex || (exports.ɵLocaleDataIndex = {}));\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    // THIS CODE IS GENERATED - DO NOT MODIFY\r\n    // See angular/tools/gulp-tasks/cldr/extract.js\r\n    var u = undefined;\r\n    function plural(n) {\r\n        var i = Math.floor(Math.abs(n)), v = n.toString().replace(/^[^.]*\\.?/, '').length;\r\n        if (i === 1 && v === 0)\r\n            return 1;\r\n        return 5;\r\n    }\r\n    var localeEn = [\r\n        'en', [['a', 'p'], ['AM', 'PM'], u], [['AM', 'PM'], u, u],\r\n        [\r\n            ['S', 'M', 'T', 'W', 'T', 'F', 'S'], ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\r\n            ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\r\n            ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']\r\n        ],\r\n        u,\r\n        [\r\n            ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],\r\n            ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\r\n            [\r\n                'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',\r\n                'October', 'November', 'December'\r\n            ]\r\n        ],\r\n        u, [['B', 'A'], ['BC', 'AD'], ['Before Christ', 'Anno Domini']], 0, [6, 0],\r\n        ['M/d/yy', 'MMM d, y', 'MMMM d, y', 'EEEE, MMMM d, y'],\r\n        ['h:mm a', 'h:mm:ss a', 'h:mm:ss a z', 'h:mm:ss a zzzz'], ['{1}, {0}', u, '{1} \\'at\\' {0}', u],\r\n        ['.', ',', ';', '%', '+', '-', 'E', '×', '‰', '∞', 'NaN', ':'],\r\n        ['#,##0.###', '#,##0%', '¤#,##0.00', '#E0'], '$', 'US Dollar', {}, plural\r\n    ];\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Retrieves the plural function used by ICU expressions to determine the plural case to use\r\n     * for a given locale.\r\n     * @param locale A locale code for the locale format rules to use.\r\n     * @returns The plural function for the locale.\r\n     * @see `NgPlural`\r\n     * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\r\n     */\r\n    function getLocalePluralCase(locale) {\r\n        var data = findLocaleData(locale);\r\n        return data[exports.ɵLocaleDataIndex.PluralCase];\r\n    }\r\n    /**\r\n     * Finds the locale data for a given locale.\r\n     *\r\n     * @param locale The locale code.\r\n     * @returns The locale data.\r\n     * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\r\n     */\r\n    function findLocaleData(locale) {\r\n        var normalizedLocale = locale.toLowerCase().replace(/_/g, '-');\r\n        var match = LOCALE_DATA[normalizedLocale];\r\n        if (match) {\r\n            return match;\r\n        }\r\n        // let's try to find a parent locale\r\n        var parentLocale = normalizedLocale.split('-')[0];\r\n        match = LOCALE_DATA[parentLocale];\r\n        if (match) {\r\n            return match;\r\n        }\r\n        if (parentLocale === 'en') {\r\n            return localeEn;\r\n        }\r\n        throw new Error(\"Missing locale data for the locale \\\"\" + locale + \"\\\".\");\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Returns the plural case based on the locale\r\n     */\r\n    function getPluralCase(value, locale) {\r\n        var plural = getLocalePluralCase(locale)(value);\r\n        switch (plural) {\r\n            case 0:\r\n                return 'zero';\r\n            case 1:\r\n                return 'one';\r\n            case 2:\r\n                return 'two';\r\n            case 3:\r\n                return 'few';\r\n            case 4:\r\n                return 'many';\r\n            default:\r\n                return 'other';\r\n        }\r\n    }\r\n    /**\r\n     * The locale id that the application is using by default (for translations and ICU expressions).\r\n     */\r\n    var DEFAULT_LOCALE_ID = 'en-US';\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var MARKER = \"\\uFFFD\";\r\n    var ICU_BLOCK_REGEXP = /^\\s*(�\\d+:?\\d*�)\\s*,\\s*(select|plural)\\s*,/;\r\n    var SUBTEMPLATE_REGEXP = /�\\/?\\*(\\d+:\\d+)�/gi;\r\n    var PH_REGEXP = /�(\\/?[#*!]\\d+):?\\d*�/gi;\r\n    var BINDING_REGEXP = /�(\\d+):?\\d*�/gi;\r\n    var ICU_REGEXP = /({\\s*�\\d+:?\\d*�\\s*,\\s*\\S{6}\\s*,[\\s\\S]*})/gi;\r\n    // i18nPostprocess consts\r\n    var ROOT_TEMPLATE_ID = 0;\r\n    var PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]/;\r\n    var PP_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]|(�\\/?\\*\\d+:\\d+�)/g;\r\n    var PP_ICU_VARS_REGEXP = /({\\s*)(VAR_(PLURAL|SELECT)(_\\d+)?)(\\s*,)/g;\r\n    var PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;\r\n    var PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\\d+)?)�/g;\r\n    var PP_CLOSE_TEMPLATE_REGEXP = /\\/\\*/;\r\n    var PP_TEMPLATE_ID_REGEXP = /\\d+\\:(\\d+)/;\r\n    /**\r\n     * Breaks pattern into strings and top level {...} blocks.\r\n     * Can be used to break a message into text and ICU expressions, or to break an ICU expression into\r\n     * keys and cases.\r\n     * Original code from closure library, modified for Angular.\r\n     *\r\n     * @param pattern (sub)Pattern to be broken.\r\n     *\r\n     */\r\n    function extractParts(pattern) {\r\n        if (!pattern) {\r\n            return [];\r\n        }\r\n        var prevPos = 0;\r\n        var braceStack = [];\r\n        var results = [];\r\n        var braces = /[{}]/g;\r\n        // lastIndex doesn't get set to 0 so we have to.\r\n        braces.lastIndex = 0;\r\n        var match;\r\n        while (match = braces.exec(pattern)) {\r\n            var pos = match.index;\r\n            if (match[0] == '}') {\r\n                braceStack.pop();\r\n                if (braceStack.length == 0) {\r\n                    // End of the block.\r\n                    var block = pattern.substring(prevPos, pos);\r\n                    if (ICU_BLOCK_REGEXP.test(block)) {\r\n                        results.push(parseICUBlock(block));\r\n                    }\r\n                    else {\r\n                        results.push(block);\r\n                    }\r\n                    prevPos = pos + 1;\r\n                }\r\n            }\r\n            else {\r\n                if (braceStack.length == 0) {\r\n                    var substring_1 = pattern.substring(prevPos, pos);\r\n                    results.push(substring_1);\r\n                    prevPos = pos + 1;\r\n                }\r\n                braceStack.push('{');\r\n            }\r\n        }\r\n        var substring = pattern.substring(prevPos);\r\n        results.push(substring);\r\n        return results;\r\n    }\r\n    /**\r\n     * Parses text containing an ICU expression and produces a JSON object for it.\r\n     * Original code from closure library, modified for Angular.\r\n     *\r\n     * @param pattern Text containing an ICU expression that needs to be parsed.\r\n     *\r\n     */\r\n    function parseICUBlock(pattern) {\r\n        var cases = [];\r\n        var values = [];\r\n        var icuType = 1 /* plural */;\r\n        var mainBinding = 0;\r\n        pattern = pattern.replace(ICU_BLOCK_REGEXP, function (str, binding, type) {\r\n            if (type === 'select') {\r\n                icuType = 0 /* select */;\r\n            }\r\n            else {\r\n                icuType = 1 /* plural */;\r\n            }\r\n            mainBinding = parseInt(binding.substr(1), 10);\r\n            return '';\r\n        });\r\n        var parts = extractParts(pattern);\r\n        // Looking for (key block)+ sequence. One of the keys has to be \"other\".\r\n        for (var pos = 0; pos < parts.length;) {\r\n            var key = parts[pos++].trim();\r\n            if (icuType === 1 /* plural */) {\r\n                // Key can be \"=x\", we just want \"x\"\r\n                key = key.replace(/\\s*(?:=)?(\\w+)\\s*/, '$1');\r\n            }\r\n            if (key.length) {\r\n                cases.push(key);\r\n            }\r\n            var blocks = extractParts(parts[pos++]);\r\n            if (cases.length > values.length) {\r\n                values.push(blocks);\r\n            }\r\n        }\r\n        assertGreaterThan(cases.indexOf('other'), -1, 'Missing key \"other\" in ICU statement.');\r\n        // TODO(ocombe): support ICU expressions in attributes, see #21615\r\n        return { type: icuType, mainBinding: mainBinding, cases: cases, values: values };\r\n    }\r\n    /**\r\n     * Removes everything inside the sub-templates of a message.\r\n     */\r\n    function removeInnerTemplateTranslation(message) {\r\n        var match;\r\n        var res = '';\r\n        var index = 0;\r\n        var inTemplate = false;\r\n        var tagMatched;\r\n        while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {\r\n            if (!inTemplate) {\r\n                res += message.substring(index, match.index + match[0].length);\r\n                tagMatched = match[1];\r\n                inTemplate = true;\r\n            }\r\n            else {\r\n                if (match[0] === MARKER + \"/*\" + tagMatched + MARKER) {\r\n                    index = match.index;\r\n                    inTemplate = false;\r\n                }\r\n            }\r\n        }\r\n        ngDevMode &&\r\n            assertEqual(inTemplate, false, \"Tag mismatch: unable to find the end of the sub-template in the translation \\\"\" + message + \"\\\"\");\r\n        res += message.substr(index);\r\n        return res;\r\n    }\r\n    /**\r\n     * Extracts a part of a message and removes the rest.\r\n     *\r\n     * This method is used for extracting a part of the message associated with a template. A translated\r\n     * message can span multiple templates.\r\n     *\r\n     * Example:\r\n     * ```\r\n     * <div i18n>Translate <span *ngIf>me</span>!</div>\r\n     * ```\r\n     *\r\n     * @param message The message to crop\r\n     * @param subTemplateIndex Index of the sub-template to extract. If undefined it returns the\r\n     * external template and removes all sub-templates.\r\n     */\r\n    function getTranslationForTemplate(message, subTemplateIndex) {\r\n        if (typeof subTemplateIndex !== 'number') {\r\n            // We want the root template message, ignore all sub-templates\r\n            return removeInnerTemplateTranslation(message);\r\n        }\r\n        else {\r\n            // We want a specific sub-template\r\n            var start = message.indexOf(\":\" + subTemplateIndex + MARKER) + 2 + subTemplateIndex.toString().length;\r\n            var end = message.search(new RegExp(MARKER + \"\\\\/\\\\*\\\\d+:\" + subTemplateIndex + MARKER));\r\n            return removeInnerTemplateTranslation(message.substring(start, end));\r\n        }\r\n    }\r\n    /**\r\n     * Generate the OpCodes to update the bindings of a string.\r\n     *\r\n     * @param str The string containing the bindings.\r\n     * @param destinationNode Index of the destination node which will receive the binding.\r\n     * @param attrName Name of the attribute, if the string belongs to an attribute.\r\n     * @param sanitizeFn Sanitization function used to sanitize the string after update, if necessary.\r\n     */\r\n    function generateBindingUpdateOpCodes(str, destinationNode, attrName, sanitizeFn) {\r\n        if (sanitizeFn === void 0) { sanitizeFn = null; }\r\n        var updateOpCodes = [null, null]; // Alloc space for mask and size\r\n        var textParts = str.split(BINDING_REGEXP);\r\n        var mask = 0;\r\n        for (var j = 0; j < textParts.length; j++) {\r\n            var textValue = textParts[j];\r\n            if (j & 1) {\r\n                // Odd indexes are bindings\r\n                var bindingIndex = parseInt(textValue, 10);\r\n                updateOpCodes.push(-1 - bindingIndex);\r\n                mask = mask | toMaskBit(bindingIndex);\r\n            }\r\n            else if (textValue !== '') {\r\n                // Even indexes are text\r\n                updateOpCodes.push(textValue);\r\n            }\r\n        }\r\n        updateOpCodes.push(destinationNode << 2 /* SHIFT_REF */ |\r\n            (attrName ? 1 /* Attr */ : 0 /* Text */));\r\n        if (attrName) {\r\n            updateOpCodes.push(attrName, sanitizeFn);\r\n        }\r\n        updateOpCodes[0] = mask;\r\n        updateOpCodes[1] = updateOpCodes.length - 2;\r\n        return updateOpCodes;\r\n    }\r\n    function getBindingMask(icuExpression, mask) {\r\n        if (mask === void 0) { mask = 0; }\r\n        mask = mask | toMaskBit(icuExpression.mainBinding);\r\n        var match;\r\n        for (var i = 0; i < icuExpression.values.length; i++) {\r\n            var valueArr = icuExpression.values[i];\r\n            for (var j = 0; j < valueArr.length; j++) {\r\n                var value = valueArr[j];\r\n                if (typeof value === 'string') {\r\n                    while (match = BINDING_REGEXP.exec(value)) {\r\n                        mask = mask | toMaskBit(parseInt(match[1], 10));\r\n                    }\r\n                }\r\n                else {\r\n                    mask = getBindingMask(value, mask);\r\n                }\r\n            }\r\n        }\r\n        return mask;\r\n    }\r\n    var i18nIndexStack = [];\r\n    var i18nIndexStackPointer = -1;\r\n    /**\r\n     * Convert binding index to mask bit.\r\n     *\r\n     * Each index represents a single bit on the bit-mask. Because bit-mask only has 32 bits, we make\r\n     * the 32nd bit share all masks for all bindings higher than 32. Since it is extremely rare to have\r\n     * more than 32 bindings this will be hit very rarely. The downside of hitting this corner case is\r\n     * that we will execute binding code more often than necessary. (penalty of performance)\r\n     */\r\n    function toMaskBit(bindingIndex) {\r\n        return 1 << Math.min(bindingIndex, 31);\r\n    }\r\n    var parentIndexStack = [];\r\n    /**\r\n     * Marks a block of text as translatable.\r\n     *\r\n     * The instructions `i18nStart` and `i18nEnd` mark the translation block in the template.\r\n     * The translation `message` is the value which is locale specific. The translation string may\r\n     * contain placeholders which associate inner elements and sub-templates within the translation.\r\n     *\r\n     * The translation `message` placeholders are:\r\n     * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\r\n     *   interpolated into. The placeholder `index` points to the expression binding index. An optional\r\n     *   `block` that matches the sub-template in which it was declared.\r\n     * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\r\n     *   and end of DOM element that were embedded in the original translation block. The placeholder\r\n     *   `index` points to the element index in the template instructions set. An optional `block` that\r\n     *   matches the sub-template in which it was declared.\r\n     * - `�!{index}(:{block})�`/`�/!{index}(:{block})�`: *Projection Placeholder*:  Marks the\r\n     *   beginning and end of <ng-content> that was embedded in the original translation block.\r\n     *   The placeholder `index` points to the element index in the template instructions set.\r\n     *   An optional `block` that matches the sub-template in which it was declared.\r\n     * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\r\n     *   split up and translated separately in each angular template function. The `index` points to the\r\n     *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\r\n     *\r\n     * @param index A unique index of the translation in the static block.\r\n     * @param message The translation message.\r\n     * @param subTemplateIndex Optional sub-template index in the `message`.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵi18nStart(index, message, subTemplateIndex) {\r\n        var tView = getLView()[TVIEW];\r\n        ngDevMode && assertDefined(tView, \"tView should be defined\");\r\n        i18nIndexStack[++i18nIndexStackPointer] = index;\r\n        // We need to delay projections until `i18nEnd`\r\n        setDelayProjection(true);\r\n        if (tView.firstTemplatePass && tView.data[index + HEADER_OFFSET] === null) {\r\n            i18nStartFirstPass(tView, index, message, subTemplateIndex);\r\n        }\r\n    }\r\n    // Count for the number of vars that will be allocated for each i18n block.\r\n    // It is global because this is used in multiple functions that include loops and recursive calls.\r\n    // This is reset to 0 when `i18nStartFirstPass` is called.\r\n    var i18nVarsCount;\r\n    /**\r\n     * See `i18nStart` above.\r\n     */\r\n    function i18nStartFirstPass(tView, index, message, subTemplateIndex) {\r\n        var viewData = getLView();\r\n        var startIndex = tView.blueprint.length - HEADER_OFFSET;\r\n        i18nVarsCount = 0;\r\n        var previousOrParentTNode = getPreviousOrParentTNode();\r\n        var parentTNode = getIsParent() ? getPreviousOrParentTNode() :\r\n            previousOrParentTNode && previousOrParentTNode.parent;\r\n        var parentIndex = parentTNode && parentTNode !== viewData[T_HOST] ? parentTNode.index - HEADER_OFFSET : index;\r\n        var parentIndexPointer = 0;\r\n        parentIndexStack[parentIndexPointer] = parentIndex;\r\n        var createOpCodes = [];\r\n        // If the previous node wasn't the direct parent then we have a translation without top level\r\n        // element and we need to keep a reference of the previous element if there is one\r\n        if (index > 0 && previousOrParentTNode !== parentTNode) {\r\n            // Create an OpCode to select the previous TNode\r\n            createOpCodes.push(previousOrParentTNode.index << 3 /* SHIFT_REF */ | 0 /* Select */);\r\n        }\r\n        var updateOpCodes = [];\r\n        var icuExpressions = [];\r\n        var templateTranslation = getTranslationForTemplate(message, subTemplateIndex);\r\n        var msgParts = replaceNgsp(templateTranslation).split(PH_REGEXP);\r\n        for (var i = 0; i < msgParts.length; i++) {\r\n            var value = msgParts[i];\r\n            if (i & 1) {\r\n                // Odd indexes are placeholders (elements and sub-templates)\r\n                if (value.charAt(0) === '/') {\r\n                    // It is a closing tag\r\n                    if (value.charAt(1) === \"#\" /* ELEMENT */) {\r\n                        var phIndex = parseInt(value.substr(2), 10);\r\n                        parentIndex = parentIndexStack[--parentIndexPointer];\r\n                        createOpCodes.push(phIndex << 3 /* SHIFT_REF */ | 5 /* ElementEnd */);\r\n                    }\r\n                }\r\n                else {\r\n                    var phIndex = parseInt(value.substr(1), 10);\r\n                    // The value represents a placeholder that we move to the designated index\r\n                    createOpCodes.push(phIndex << 3 /* SHIFT_REF */ | 0 /* Select */, parentIndex << 17 /* SHIFT_PARENT */ | 1 /* AppendChild */);\r\n                    if (value.charAt(0) === \"#\" /* ELEMENT */) {\r\n                        parentIndexStack[++parentIndexPointer] = parentIndex = phIndex;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Even indexes are text (including bindings & ICU expressions)\r\n                var parts = extractParts(value);\r\n                for (var j = 0; j < parts.length; j++) {\r\n                    if (j & 1) {\r\n                        // Odd indexes are ICU expressions\r\n                        // Create the comment node that will anchor the ICU expression\r\n                        var icuNodeIndex = startIndex + i18nVarsCount++;\r\n                        createOpCodes.push(COMMENT_MARKER, ngDevMode ? \"ICU \" + icuNodeIndex : '', icuNodeIndex, parentIndex << 17 /* SHIFT_PARENT */ | 1 /* AppendChild */);\r\n                        // Update codes for the ICU expression\r\n                        var icuExpression = parts[j];\r\n                        var mask = getBindingMask(icuExpression);\r\n                        icuStart(icuExpressions, icuExpression, icuNodeIndex, icuNodeIndex);\r\n                        // Since this is recursive, the last TIcu that was pushed is the one we want\r\n                        var tIcuIndex = icuExpressions.length - 1;\r\n                        updateOpCodes.push(toMaskBit(icuExpression.mainBinding), // mask of the main binding\r\n                        3, // skip 3 opCodes if not changed\r\n                        -1 - icuExpression.mainBinding, icuNodeIndex << 2 /* SHIFT_REF */ | 2 /* IcuSwitch */, tIcuIndex, mask, // mask of all the bindings of this ICU expression\r\n                        2, // skip 2 opCodes if not changed\r\n                        icuNodeIndex << 2 /* SHIFT_REF */ | 3 /* IcuUpdate */, tIcuIndex);\r\n                    }\r\n                    else if (parts[j] !== '') {\r\n                        var text = parts[j];\r\n                        // Even indexes are text (including bindings)\r\n                        var hasBinding = text.match(BINDING_REGEXP);\r\n                        // Create text nodes\r\n                        var textNodeIndex = startIndex + i18nVarsCount++;\r\n                        createOpCodes.push(\r\n                        // If there is a binding, the value will be set during update\r\n                        hasBinding ? '' : text, textNodeIndex, parentIndex << 17 /* SHIFT_PARENT */ | 1 /* AppendChild */);\r\n                        if (hasBinding) {\r\n                            addAllToArray(generateBindingUpdateOpCodes(text, textNodeIndex), updateOpCodes);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (i18nVarsCount > 0) {\r\n            allocExpando(viewData, i18nVarsCount);\r\n        }\r\n        ngDevMode &&\r\n            attachI18nOpCodesDebug(createOpCodes, updateOpCodes, icuExpressions.length ? icuExpressions : null, viewData);\r\n        // NOTE: local var needed to properly assert the type of `TI18n`.\r\n        var tI18n = {\r\n            vars: i18nVarsCount,\r\n            create: createOpCodes,\r\n            update: updateOpCodes,\r\n            icus: icuExpressions.length ? icuExpressions : null,\r\n        };\r\n        tView.data[index + HEADER_OFFSET] = tI18n;\r\n    }\r\n    function appendI18nNode(tNode, parentTNode, previousTNode, viewData) {\r\n        ngDevMode && ngDevMode.rendererMoveNode++;\r\n        var nextNode = tNode.next;\r\n        if (!previousTNode) {\r\n            previousTNode = parentTNode;\r\n        }\r\n        // Re-organize node tree to put this node in the correct position.\r\n        if (previousTNode === parentTNode && tNode !== parentTNode.child) {\r\n            tNode.next = parentTNode.child;\r\n            parentTNode.child = tNode;\r\n        }\r\n        else if (previousTNode !== parentTNode && tNode !== previousTNode.next) {\r\n            tNode.next = previousTNode.next;\r\n            previousTNode.next = tNode;\r\n        }\r\n        else {\r\n            tNode.next = null;\r\n        }\r\n        if (parentTNode !== viewData[T_HOST]) {\r\n            tNode.parent = parentTNode;\r\n        }\r\n        // If tNode was moved around, we might need to fix a broken link.\r\n        var cursor = tNode.next;\r\n        while (cursor) {\r\n            if (cursor.next === tNode) {\r\n                cursor.next = nextNode;\r\n            }\r\n            cursor = cursor.next;\r\n        }\r\n        // If the placeholder to append is a projection, we need to move the projected nodes instead\r\n        if (tNode.type === 1 /* Projection */) {\r\n            var tProjectionNode = tNode;\r\n            appendProjectedNodes(viewData, tProjectionNode, tProjectionNode.projection, findComponentView(viewData));\r\n            return tNode;\r\n        }\r\n        appendChild(getNativeByTNode(tNode, viewData), tNode, viewData);\r\n        var slotValue = viewData[tNode.index];\r\n        if (tNode.type !== 0 /* Container */ && isLContainer(slotValue)) {\r\n            // Nodes that inject ViewContainerRef also have a comment node that should be moved\r\n            appendChild(slotValue[NATIVE], tNode, viewData);\r\n        }\r\n        return tNode;\r\n    }\r\n    /**\r\n     * Handles message string post-processing for internationalization.\r\n     *\r\n     * Handles message string post-processing by transforming it from intermediate\r\n     * format (that might contain some markers that we need to replace) to the final\r\n     * form, consumable by i18nStart instruction. Post processing steps include:\r\n     *\r\n     * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\r\n     * 2. Replace all ICU vars (like \"VAR_PLURAL\")\r\n     * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\r\n     * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\r\n     *    in case multiple ICUs have the same placeholder name\r\n     *\r\n     * @param message Raw translation string for post processing\r\n     * @param replacements Set of replacements that should be applied\r\n     *\r\n     * @returns Transformed string that can be consumed by i18nStart instruction\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵi18nPostprocess(message, replacements) {\r\n        if (replacements === void 0) { replacements = {}; }\r\n        /**\r\n         * Step 1: resolve all multi-value placeholders like [�#5�|�*1:1��#2:1�|�#4:1�]\r\n         *\r\n         * Note: due to the way we process nested templates (BFS), multi-value placeholders are typically\r\n         * grouped by templates, for example: [�#5�|�#6�|�#1:1�|�#3:2�] where �#5� and �#6� belong to root\r\n         * template, �#1:1� belong to nested template with index 1 and �#1:2� - nested template with index\r\n         * 3. However in real templates the order might be different: i.e. �#1:1� and/or �#3:2� may go in\r\n         * front of �#6�. The post processing step restores the right order by keeping track of the\r\n         * template id stack and looks for placeholders that belong to the currently active template.\r\n         */\r\n        var result = message;\r\n        if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {\r\n            var matches_1 = {};\r\n            var templateIdsStack_1 = [ROOT_TEMPLATE_ID];\r\n            result = result.replace(PP_PLACEHOLDERS_REGEXP, function (m, phs, tmpl) {\r\n                var content = phs || tmpl;\r\n                var placeholders = matches_1[content] || [];\r\n                if (!placeholders.length) {\r\n                    content.split('|').forEach(function (placeholder) {\r\n                        var match = placeholder.match(PP_TEMPLATE_ID_REGEXP);\r\n                        var templateId = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;\r\n                        var isCloseTemplateTag = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);\r\n                        placeholders.push([templateId, isCloseTemplateTag, placeholder]);\r\n                    });\r\n                    matches_1[content] = placeholders;\r\n                }\r\n                if (!placeholders.length) {\r\n                    throw new Error(\"i18n postprocess: unmatched placeholder - \" + content);\r\n                }\r\n                var currentTemplateId = templateIdsStack_1[templateIdsStack_1.length - 1];\r\n                var idx = 0;\r\n                // find placeholder index that matches current template id\r\n                for (var i = 0; i < placeholders.length; i++) {\r\n                    if (placeholders[i][0] === currentTemplateId) {\r\n                        idx = i;\r\n                        break;\r\n                    }\r\n                }\r\n                // update template id stack based on the current tag extracted\r\n                var _a = __read(placeholders[idx], 3), templateId = _a[0], isCloseTemplateTag = _a[1], placeholder = _a[2];\r\n                if (isCloseTemplateTag) {\r\n                    templateIdsStack_1.pop();\r\n                }\r\n                else if (currentTemplateId !== templateId) {\r\n                    templateIdsStack_1.push(templateId);\r\n                }\r\n                // remove processed tag from the list\r\n                placeholders.splice(idx, 1);\r\n                return placeholder;\r\n            });\r\n        }\r\n        // return current result if no replacements specified\r\n        if (!Object.keys(replacements).length) {\r\n            return result;\r\n        }\r\n        /**\r\n         * Step 2: replace all ICU vars (like \"VAR_PLURAL\")\r\n         */\r\n        result = result.replace(PP_ICU_VARS_REGEXP, function (match, start, key, _type, _idx, end) {\r\n            return replacements.hasOwnProperty(key) ? \"\" + start + replacements[key] + end : match;\r\n        });\r\n        /**\r\n         * Step 3: replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\r\n         */\r\n        result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, function (match, key) {\r\n            return replacements.hasOwnProperty(key) ? replacements[key] : match;\r\n        });\r\n        /**\r\n         * Step 4: replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�) in case\r\n         * multiple ICUs have the same placeholder name\r\n         */\r\n        result = result.replace(PP_ICUS_REGEXP, function (match, key) {\r\n            if (replacements.hasOwnProperty(key)) {\r\n                var list = replacements[key];\r\n                if (!list.length) {\r\n                    throw new Error(\"i18n postprocess: unmatched ICU - \" + match + \" with key: \" + key);\r\n                }\r\n                return list.shift();\r\n            }\r\n            return match;\r\n        });\r\n        return result;\r\n    }\r\n    /**\r\n     * Translates a translation block marked by `i18nStart` and `i18nEnd`. It inserts the text/ICU nodes\r\n     * into the render tree, moves the placeholder nodes and removes the deleted nodes.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵi18nEnd() {\r\n        var tView = getLView()[TVIEW];\r\n        ngDevMode && assertDefined(tView, \"tView should be defined\");\r\n        i18nEndFirstPass(tView);\r\n        // Stop delaying projections\r\n        setDelayProjection(false);\r\n    }\r\n    /**\r\n     * See `i18nEnd` above.\r\n     */\r\n    function i18nEndFirstPass(tView) {\r\n        var viewData = getLView();\r\n        ngDevMode && assertEqual(viewData[BINDING_INDEX], viewData[TVIEW].bindingStartIndex, 'i18nEnd should be called before any binding');\r\n        var rootIndex = i18nIndexStack[i18nIndexStackPointer--];\r\n        var tI18n = tView.data[rootIndex + HEADER_OFFSET];\r\n        ngDevMode && assertDefined(tI18n, \"You should call i18nStart before i18nEnd\");\r\n        // Find the last node that was added before `i18nEnd`\r\n        var lastCreatedNode = getPreviousOrParentTNode();\r\n        // Read the instructions to insert/move/remove DOM elements\r\n        var visitedNodes = readCreateOpCodes(rootIndex, tI18n.create, tI18n.icus, viewData);\r\n        // Remove deleted nodes\r\n        for (var i = rootIndex + 1; i <= lastCreatedNode.index - HEADER_OFFSET; i++) {\r\n            if (visitedNodes.indexOf(i) === -1) {\r\n                removeNode(i, viewData);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Creates and stores the dynamic TNode, and unhooks it from the tree for now.\r\n     */\r\n    function createDynamicNodeAtIndex(lView, index, type, native, name) {\r\n        var previousOrParentTNode = getPreviousOrParentTNode();\r\n        ngDevMode && assertDataInRange(lView, index + HEADER_OFFSET);\r\n        lView[index + HEADER_OFFSET] = native;\r\n        var tNode = getOrCreateTNode(lView[TVIEW], lView[T_HOST], index, type, name, null);\r\n        // We are creating a dynamic node, the previous tNode might not be pointing at this node.\r\n        // We will link ourselves into the tree later with `appendI18nNode`.\r\n        if (previousOrParentTNode.next === tNode) {\r\n            previousOrParentTNode.next = null;\r\n        }\r\n        return tNode;\r\n    }\r\n    function readCreateOpCodes(index, createOpCodes, icus, viewData) {\r\n        var renderer = getLView()[RENDERER];\r\n        var currentTNode = null;\r\n        var previousTNode = null;\r\n        var visitedNodes = [];\r\n        for (var i = 0; i < createOpCodes.length; i++) {\r\n            var opCode = createOpCodes[i];\r\n            if (typeof opCode == 'string') {\r\n                var textRNode = createTextNode(opCode, renderer);\r\n                var textNodeIndex = createOpCodes[++i];\r\n                ngDevMode && ngDevMode.rendererCreateTextNode++;\r\n                previousTNode = currentTNode;\r\n                currentTNode =\r\n                    createDynamicNodeAtIndex(viewData, textNodeIndex, 3 /* Element */, textRNode, null);\r\n                visitedNodes.push(textNodeIndex);\r\n                setIsNotParent();\r\n            }\r\n            else if (typeof opCode == 'number') {\r\n                switch (opCode & 7 /* MASK_OPCODE */) {\r\n                    case 1 /* AppendChild */:\r\n                        var destinationNodeIndex = opCode >>> 17 /* SHIFT_PARENT */;\r\n                        var destinationTNode = void 0;\r\n                        if (destinationNodeIndex === index) {\r\n                            // If the destination node is `i18nStart`, we don't have a\r\n                            // top-level node and we should use the host node instead\r\n                            destinationTNode = viewData[T_HOST];\r\n                        }\r\n                        else {\r\n                            destinationTNode = getTNode(destinationNodeIndex, viewData);\r\n                        }\r\n                        ngDevMode &&\r\n                            assertDefined(currentTNode, \"You need to create or select a node before you can insert it into the DOM\");\r\n                        previousTNode = appendI18nNode(currentTNode, destinationTNode, previousTNode, viewData);\r\n                        break;\r\n                    case 0 /* Select */:\r\n                        var nodeIndex = opCode >>> 3 /* SHIFT_REF */;\r\n                        visitedNodes.push(nodeIndex);\r\n                        previousTNode = currentTNode;\r\n                        currentTNode = getTNode(nodeIndex, viewData);\r\n                        if (currentTNode) {\r\n                            setPreviousOrParentTNode(currentTNode, currentTNode.type === 3 /* Element */);\r\n                        }\r\n                        break;\r\n                    case 5 /* ElementEnd */:\r\n                        var elementIndex = opCode >>> 3 /* SHIFT_REF */;\r\n                        previousTNode = currentTNode = getTNode(elementIndex, viewData);\r\n                        setPreviousOrParentTNode(currentTNode, false);\r\n                        break;\r\n                    case 4 /* Attr */:\r\n                        var elementNodeIndex = opCode >>> 3 /* SHIFT_REF */;\r\n                        var attrName = createOpCodes[++i];\r\n                        var attrValue = createOpCodes[++i];\r\n                        // This code is used for ICU expressions only, since we don't support\r\n                        // directives/components in ICUs, we don't need to worry about inputs here\r\n                        elementAttributeInternal(elementNodeIndex, attrName, attrValue, viewData);\r\n                        break;\r\n                    default:\r\n                        throw new Error(\"Unable to determine the type of mutate operation for \\\"\" + opCode + \"\\\"\");\r\n                }\r\n            }\r\n            else {\r\n                switch (opCode) {\r\n                    case COMMENT_MARKER:\r\n                        var commentValue = createOpCodes[++i];\r\n                        var commentNodeIndex = createOpCodes[++i];\r\n                        ngDevMode && assertEqual(typeof commentValue, 'string', \"Expected \\\"\" + commentValue + \"\\\" to be a comment node value\");\r\n                        var commentRNode = renderer.createComment(commentValue);\r\n                        ngDevMode && ngDevMode.rendererCreateComment++;\r\n                        previousTNode = currentTNode;\r\n                        currentTNode = createDynamicNodeAtIndex(viewData, commentNodeIndex, 5 /* IcuContainer */, commentRNode, null);\r\n                        visitedNodes.push(commentNodeIndex);\r\n                        attachPatchData(commentRNode, viewData);\r\n                        currentTNode.activeCaseIndex = null;\r\n                        // We will add the case nodes later, during the update phase\r\n                        setIsNotParent();\r\n                        break;\r\n                    case ELEMENT_MARKER:\r\n                        var tagNameValue = createOpCodes[++i];\r\n                        var elementNodeIndex = createOpCodes[++i];\r\n                        ngDevMode && assertEqual(typeof tagNameValue, 'string', \"Expected \\\"\" + tagNameValue + \"\\\" to be an element node tag name\");\r\n                        var elementRNode = renderer.createElement(tagNameValue);\r\n                        ngDevMode && ngDevMode.rendererCreateElement++;\r\n                        previousTNode = currentTNode;\r\n                        currentTNode = createDynamicNodeAtIndex(viewData, elementNodeIndex, 3 /* Element */, elementRNode, tagNameValue);\r\n                        visitedNodes.push(elementNodeIndex);\r\n                        break;\r\n                    default:\r\n                        throw new Error(\"Unable to determine the type of mutate operation for \\\"\" + opCode + \"\\\"\");\r\n                }\r\n            }\r\n        }\r\n        setIsNotParent();\r\n        return visitedNodes;\r\n    }\r\n    function readUpdateOpCodes(updateOpCodes, icus, bindingsStartIndex, changeMask, viewData, bypassCheckBit) {\r\n        if (bypassCheckBit === void 0) { bypassCheckBit = false; }\r\n        var caseCreated = false;\r\n        for (var i = 0; i < updateOpCodes.length; i++) {\r\n            // bit code to check if we should apply the next update\r\n            var checkBit = updateOpCodes[i];\r\n            // Number of opCodes to skip until next set of update codes\r\n            var skipCodes = updateOpCodes[++i];\r\n            if (bypassCheckBit || (checkBit & changeMask)) {\r\n                // The value has been updated since last checked\r\n                var value = '';\r\n                for (var j = i + 1; j <= (i + skipCodes); j++) {\r\n                    var opCode = updateOpCodes[j];\r\n                    if (typeof opCode == 'string') {\r\n                        value += opCode;\r\n                    }\r\n                    else if (typeof opCode == 'number') {\r\n                        if (opCode < 0) {\r\n                            // It's a binding index whose value is negative\r\n                            value += renderStringify(viewData[bindingsStartIndex - opCode]);\r\n                        }\r\n                        else {\r\n                            var nodeIndex = opCode >>> 2 /* SHIFT_REF */;\r\n                            var tIcuIndex = void 0;\r\n                            var tIcu = void 0;\r\n                            var icuTNode = void 0;\r\n                            switch (opCode & 3 /* MASK_OPCODE */) {\r\n                                case 1 /* Attr */:\r\n                                    var propName = updateOpCodes[++j];\r\n                                    var sanitizeFn = updateOpCodes[++j];\r\n                                    elementPropertyInternal(nodeIndex, propName, value, sanitizeFn);\r\n                                    break;\r\n                                case 0 /* Text */:\r\n                                    textBindingInternal(viewData, nodeIndex, value);\r\n                                    break;\r\n                                case 2 /* IcuSwitch */:\r\n                                    tIcuIndex = updateOpCodes[++j];\r\n                                    tIcu = icus[tIcuIndex];\r\n                                    icuTNode = getTNode(nodeIndex, viewData);\r\n                                    // If there is an active case, delete the old nodes\r\n                                    if (icuTNode.activeCaseIndex !== null) {\r\n                                        var removeCodes = tIcu.remove[icuTNode.activeCaseIndex];\r\n                                        for (var k = 0; k < removeCodes.length; k++) {\r\n                                            var removeOpCode = removeCodes[k];\r\n                                            switch (removeOpCode & 7 /* MASK_OPCODE */) {\r\n                                                case 3 /* Remove */:\r\n                                                    var nodeIndex_1 = removeOpCode >>> 3 /* SHIFT_REF */;\r\n                                                    removeNode(nodeIndex_1, viewData);\r\n                                                    break;\r\n                                                case 6 /* RemoveNestedIcu */:\r\n                                                    var nestedIcuNodeIndex = removeCodes[k + 1] >>> 3 /* SHIFT_REF */;\r\n                                                    var nestedIcuTNode = getTNode(nestedIcuNodeIndex, viewData);\r\n                                                    var activeIndex = nestedIcuTNode.activeCaseIndex;\r\n                                                    if (activeIndex !== null) {\r\n                                                        var nestedIcuTIndex = removeOpCode >>> 3 /* SHIFT_REF */;\r\n                                                        var nestedTIcu = icus[nestedIcuTIndex];\r\n                                                        addAllToArray(nestedTIcu.remove[activeIndex], removeCodes);\r\n                                                    }\r\n                                                    break;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    // Update the active caseIndex\r\n                                    var caseIndex = getCaseIndex(tIcu, value);\r\n                                    icuTNode.activeCaseIndex = caseIndex !== -1 ? caseIndex : null;\r\n                                    // Add the nodes for the new case\r\n                                    readCreateOpCodes(-1, tIcu.create[caseIndex], icus, viewData);\r\n                                    caseCreated = true;\r\n                                    break;\r\n                                case 3 /* IcuUpdate */:\r\n                                    tIcuIndex = updateOpCodes[++j];\r\n                                    tIcu = icus[tIcuIndex];\r\n                                    icuTNode = getTNode(nodeIndex, viewData);\r\n                                    readUpdateOpCodes(tIcu.update[icuTNode.activeCaseIndex], icus, bindingsStartIndex, changeMask, viewData, caseCreated);\r\n                                    break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            i += skipCodes;\r\n        }\r\n    }\r\n    function removeNode(index, viewData) {\r\n        var removedPhTNode = getTNode(index, viewData);\r\n        var removedPhRNode = getNativeByIndex(index, viewData);\r\n        if (removedPhRNode) {\r\n            nativeRemoveNode(viewData[RENDERER], removedPhRNode);\r\n        }\r\n        var slotValue = ɵɵload(index);\r\n        if (isLContainer(slotValue)) {\r\n            var lContainer = slotValue;\r\n            if (removedPhTNode.type !== 0 /* Container */) {\r\n                nativeRemoveNode(viewData[RENDERER], lContainer[NATIVE]);\r\n            }\r\n        }\r\n        // Define this node as detached so that we don't risk projecting it\r\n        removedPhTNode.flags |= 32 /* isDetached */;\r\n        ngDevMode && ngDevMode.rendererRemoveNode++;\r\n    }\r\n    /**\r\n     *\r\n     * Use this instruction to create a translation block that doesn't contain any placeholder.\r\n     * It calls both {@link i18nStart} and {@link i18nEnd} in one instruction.\r\n     *\r\n     * The translation `message` is the value which is locale specific. The translation string may\r\n     * contain placeholders which associate inner elements and sub-templates within the translation.\r\n     *\r\n     * The translation `message` placeholders are:\r\n     * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\r\n     *   interpolated into. The placeholder `index` points to the expression binding index. An optional\r\n     *   `block` that matches the sub-template in which it was declared.\r\n     * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\r\n     *   and end of DOM element that were embedded in the original translation block. The placeholder\r\n     *   `index` points to the element index in the template instructions set. An optional `block` that\r\n     *   matches the sub-template in which it was declared.\r\n     * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\r\n     *   split up and translated separately in each angular template function. The `index` points to the\r\n     *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\r\n     *\r\n     * @param index A unique index of the translation in the static block.\r\n     * @param message The translation message.\r\n     * @param subTemplateIndex Optional sub-template index in the `message`.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵi18n(index, message, subTemplateIndex) {\r\n        ɵɵi18nStart(index, message, subTemplateIndex);\r\n        ɵɵi18nEnd();\r\n    }\r\n    /**\r\n     * Marks a list of attributes as translatable.\r\n     *\r\n     * @param index A unique index in the static block\r\n     * @param values\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵi18nAttributes(index, values) {\r\n        var tView = getLView()[TVIEW];\r\n        ngDevMode && assertDefined(tView, \"tView should be defined\");\r\n        i18nAttributesFirstPass(tView, index, values);\r\n    }\r\n    /**\r\n     * See `i18nAttributes` above.\r\n     */\r\n    function i18nAttributesFirstPass(tView, index, values) {\r\n        var previousElement = getPreviousOrParentTNode();\r\n        var previousElementIndex = previousElement.index - HEADER_OFFSET;\r\n        var updateOpCodes = [];\r\n        for (var i = 0; i < values.length; i += 2) {\r\n            var attrName = values[i];\r\n            var message = values[i + 1];\r\n            var parts = message.split(ICU_REGEXP);\r\n            for (var j = 0; j < parts.length; j++) {\r\n                var value = parts[j];\r\n                if (j & 1) {\r\n                    // Odd indexes are ICU expressions\r\n                    // TODO(ocombe): support ICU expressions in attributes\r\n                    throw new Error('ICU expressions are not yet supported in attributes');\r\n                }\r\n                else if (value !== '') {\r\n                    // Even indexes are text (including bindings)\r\n                    var hasBinding = !!value.match(BINDING_REGEXP);\r\n                    if (hasBinding) {\r\n                        if (tView.firstTemplatePass && tView.data[index + HEADER_OFFSET] === null) {\r\n                            addAllToArray(generateBindingUpdateOpCodes(value, previousElementIndex, attrName), updateOpCodes);\r\n                        }\r\n                    }\r\n                    else {\r\n                        var lView = getLView();\r\n                        elementAttributeInternal(previousElementIndex, attrName, value, lView);\r\n                        // Check if that attribute is a directive input\r\n                        var tNode = getTNode(previousElementIndex, lView);\r\n                        var dataValue = tNode.inputs && tNode.inputs[attrName];\r\n                        if (dataValue) {\r\n                            setInputsForProperty(lView, dataValue, value);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (tView.firstTemplatePass && tView.data[index + HEADER_OFFSET] === null) {\r\n            tView.data[index + HEADER_OFFSET] = updateOpCodes;\r\n        }\r\n    }\r\n    var changeMask = 0;\r\n    var shiftsCounter = 0;\r\n    /**\r\n     * Stores the values of the bindings during each update cycle in order to determine if we need to\r\n     * update the translated nodes.\r\n     *\r\n     * @param value The binding's value\r\n     * @returns This function returns itself so that it may be chained\r\n     * (e.g. `i18nExp(ctx.name)(ctx.title)`)\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵi18nExp(value) {\r\n        var lView = getLView();\r\n        var expression = bind(lView, value);\r\n        if (expression !== NO_CHANGE) {\r\n            changeMask = changeMask | (1 << shiftsCounter);\r\n        }\r\n        shiftsCounter++;\r\n        return ɵɵi18nExp;\r\n    }\r\n    /**\r\n     * Updates a translation block or an i18n attribute when the bindings have changed.\r\n     *\r\n     * @param index Index of either {@link i18nStart} (translation block) or {@link i18nAttributes}\r\n     * (i18n attribute) on which it should update the content.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵi18nApply(index) {\r\n        if (shiftsCounter) {\r\n            var lView = getLView();\r\n            var tView = lView[TVIEW];\r\n            ngDevMode && assertDefined(tView, \"tView should be defined\");\r\n            var tI18n = tView.data[index + HEADER_OFFSET];\r\n            var updateOpCodes = void 0;\r\n            var icus = null;\r\n            if (Array.isArray(tI18n)) {\r\n                updateOpCodes = tI18n;\r\n            }\r\n            else {\r\n                updateOpCodes = tI18n.update;\r\n                icus = tI18n.icus;\r\n            }\r\n            var bindingsStartIndex = lView[BINDING_INDEX] - shiftsCounter - 1;\r\n            readUpdateOpCodes(updateOpCodes, icus, bindingsStartIndex, changeMask, lView);\r\n            // Reset changeMask & maskBit to default for the next update cycle\r\n            changeMask = 0;\r\n            shiftsCounter = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Returns the index of the current case of an ICU expression depending on the main binding value\r\n     *\r\n     * @param icuExpression\r\n     * @param bindingValue The value of the main binding used by this ICU expression\r\n     */\r\n    function getCaseIndex(icuExpression, bindingValue) {\r\n        var index = icuExpression.cases.indexOf(bindingValue);\r\n        if (index === -1) {\r\n            switch (icuExpression.type) {\r\n                case 1 /* plural */: {\r\n                    var resolvedCase = getPluralCase(bindingValue, getLocaleId());\r\n                    index = icuExpression.cases.indexOf(resolvedCase);\r\n                    if (index === -1 && resolvedCase !== 'other') {\r\n                        index = icuExpression.cases.indexOf('other');\r\n                    }\r\n                    break;\r\n                }\r\n                case 0 /* select */: {\r\n                    index = icuExpression.cases.indexOf('other');\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return index;\r\n    }\r\n    /**\r\n     * Generate the OpCodes for ICU expressions.\r\n     *\r\n     * @param tIcus\r\n     * @param icuExpression\r\n     * @param startIndex\r\n     * @param expandoStartIndex\r\n     */\r\n    function icuStart(tIcus, icuExpression, startIndex, expandoStartIndex) {\r\n        var createCodes = [];\r\n        var removeCodes = [];\r\n        var updateCodes = [];\r\n        var vars = [];\r\n        var childIcus = [];\r\n        for (var i = 0; i < icuExpression.values.length; i++) {\r\n            // Each value is an array of strings & other ICU expressions\r\n            var valueArr = icuExpression.values[i];\r\n            var nestedIcus = [];\r\n            for (var j = 0; j < valueArr.length; j++) {\r\n                var value = valueArr[j];\r\n                if (typeof value !== 'string') {\r\n                    // It is an nested ICU expression\r\n                    var icuIndex = nestedIcus.push(value) - 1;\r\n                    // Replace nested ICU expression by a comment node\r\n                    valueArr[j] = \"<!--\\uFFFD\" + icuIndex + \"\\uFFFD-->\";\r\n                }\r\n            }\r\n            var icuCase = parseIcuCase(valueArr.join(''), startIndex, nestedIcus, tIcus, expandoStartIndex);\r\n            createCodes.push(icuCase.create);\r\n            removeCodes.push(icuCase.remove);\r\n            updateCodes.push(icuCase.update);\r\n            vars.push(icuCase.vars);\r\n            childIcus.push(icuCase.childIcus);\r\n        }\r\n        var tIcu = {\r\n            type: icuExpression.type,\r\n            vars: vars,\r\n            childIcus: childIcus,\r\n            cases: icuExpression.cases,\r\n            create: createCodes,\r\n            remove: removeCodes,\r\n            update: updateCodes\r\n        };\r\n        tIcus.push(tIcu);\r\n        // Adding the maximum possible of vars needed (based on the cases with the most vars)\r\n        i18nVarsCount += Math.max.apply(Math, __spread(vars));\r\n    }\r\n    /**\r\n     * Transforms a string template into an HTML template and a list of instructions used to update\r\n     * attributes or nodes that contain bindings.\r\n     *\r\n     * @param unsafeHtml The string to parse\r\n     * @param parentIndex\r\n     * @param nestedIcus\r\n     * @param tIcus\r\n     * @param expandoStartIndex\r\n     */\r\n    function parseIcuCase(unsafeHtml, parentIndex, nestedIcus, tIcus, expandoStartIndex) {\r\n        var inertBodyHelper = new InertBodyHelper(document);\r\n        var inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\r\n        if (!inertBodyElement) {\r\n            throw new Error('Unable to generate inert body element');\r\n        }\r\n        var wrapper = getTemplateContent(inertBodyElement) || inertBodyElement;\r\n        var opCodes = { vars: 0, childIcus: [], create: [], remove: [], update: [] };\r\n        parseNodes(wrapper.firstChild, opCodes, parentIndex, nestedIcus, tIcus, expandoStartIndex);\r\n        return opCodes;\r\n    }\r\n    var NESTED_ICU = /�(\\d+)�/;\r\n    /**\r\n     * Parses a node, its children and its siblings, and generates the mutate & update OpCodes.\r\n     *\r\n     * @param currentNode The first node to parse\r\n     * @param icuCase The data for the ICU expression case that contains those nodes\r\n     * @param parentIndex Index of the current node's parent\r\n     * @param nestedIcus Data for the nested ICU expressions that this case contains\r\n     * @param tIcus Data for all ICU expressions of the current message\r\n     * @param expandoStartIndex Expando start index for the current ICU expression\r\n     */\r\n    function parseNodes(currentNode, icuCase, parentIndex, nestedIcus, tIcus, expandoStartIndex) {\r\n        if (currentNode) {\r\n            var nestedIcusToCreate = [];\r\n            while (currentNode) {\r\n                var nextNode = currentNode.nextSibling;\r\n                var newIndex = expandoStartIndex + ++icuCase.vars;\r\n                switch (currentNode.nodeType) {\r\n                    case Node.ELEMENT_NODE:\r\n                        var element = currentNode;\r\n                        var tagName = element.tagName.toLowerCase();\r\n                        if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\r\n                            // This isn't a valid element, we won't create an element for it\r\n                            icuCase.vars--;\r\n                        }\r\n                        else {\r\n                            icuCase.create.push(ELEMENT_MARKER, tagName, newIndex, parentIndex << 17 /* SHIFT_PARENT */ | 1 /* AppendChild */);\r\n                            var elAttrs = element.attributes;\r\n                            for (var i = 0; i < elAttrs.length; i++) {\r\n                                var attr = elAttrs.item(i);\r\n                                var lowerAttrName = attr.name.toLowerCase();\r\n                                var hasBinding_1 = !!attr.value.match(BINDING_REGEXP);\r\n                                // we assume the input string is safe, unless it's using a binding\r\n                                if (hasBinding_1) {\r\n                                    if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {\r\n                                        if (URI_ATTRS[lowerAttrName]) {\r\n                                            addAllToArray(generateBindingUpdateOpCodes(attr.value, newIndex, attr.name, _sanitizeUrl), icuCase.update);\r\n                                        }\r\n                                        else if (SRCSET_ATTRS[lowerAttrName]) {\r\n                                            addAllToArray(generateBindingUpdateOpCodes(attr.value, newIndex, attr.name, sanitizeSrcset), icuCase.update);\r\n                                        }\r\n                                        else {\r\n                                            addAllToArray(generateBindingUpdateOpCodes(attr.value, newIndex, attr.name), icuCase.update);\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        ngDevMode &&\r\n                                            console.warn(\"WARNING: ignoring unsafe attribute value \" + lowerAttrName + \" on element \" + tagName + \" (see http://g.co/ng/security#xss)\");\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    icuCase.create.push(newIndex << 3 /* SHIFT_REF */ | 4 /* Attr */, attr.name, attr.value);\r\n                                }\r\n                            }\r\n                            // Parse the children of this node (if any)\r\n                            parseNodes(currentNode.firstChild, icuCase, newIndex, nestedIcus, tIcus, expandoStartIndex);\r\n                            // Remove the parent node after the children\r\n                            icuCase.remove.push(newIndex << 3 /* SHIFT_REF */ | 3 /* Remove */);\r\n                        }\r\n                        break;\r\n                    case Node.TEXT_NODE:\r\n                        var value = currentNode.textContent || '';\r\n                        var hasBinding = value.match(BINDING_REGEXP);\r\n                        icuCase.create.push(hasBinding ? '' : value, newIndex, parentIndex << 17 /* SHIFT_PARENT */ | 1 /* AppendChild */);\r\n                        icuCase.remove.push(newIndex << 3 /* SHIFT_REF */ | 3 /* Remove */);\r\n                        if (hasBinding) {\r\n                            addAllToArray(generateBindingUpdateOpCodes(value, newIndex), icuCase.update);\r\n                        }\r\n                        break;\r\n                    case Node.COMMENT_NODE:\r\n                        // Check if the comment node is a placeholder for a nested ICU\r\n                        var match = NESTED_ICU.exec(currentNode.textContent || '');\r\n                        if (match) {\r\n                            var nestedIcuIndex = parseInt(match[1], 10);\r\n                            var newLocal = ngDevMode ? \"nested ICU \" + nestedIcuIndex : '';\r\n                            // Create the comment node that will anchor the ICU expression\r\n                            icuCase.create.push(COMMENT_MARKER, newLocal, newIndex, parentIndex << 17 /* SHIFT_PARENT */ | 1 /* AppendChild */);\r\n                            var nestedIcu = nestedIcus[nestedIcuIndex];\r\n                            nestedIcusToCreate.push([nestedIcu, newIndex]);\r\n                        }\r\n                        else {\r\n                            // We do not handle any other type of comment\r\n                            icuCase.vars--;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        // We do not handle any other type of element\r\n                        icuCase.vars--;\r\n                }\r\n                currentNode = nextNode;\r\n            }\r\n            for (var i = 0; i < nestedIcusToCreate.length; i++) {\r\n                var nestedIcu = nestedIcusToCreate[i][0];\r\n                var nestedIcuNodeIndex = nestedIcusToCreate[i][1];\r\n                icuStart(tIcus, nestedIcu, nestedIcuNodeIndex, expandoStartIndex + icuCase.vars);\r\n                // Since this is recursive, the last TIcu that was pushed is the one we want\r\n                var nestTIcuIndex = tIcus.length - 1;\r\n                icuCase.vars += Math.max.apply(Math, __spread(tIcus[nestTIcuIndex].vars));\r\n                icuCase.childIcus.push(nestTIcuIndex);\r\n                var mask = getBindingMask(nestedIcu);\r\n                icuCase.update.push(toMaskBit(nestedIcu.mainBinding), // mask of the main binding\r\n                3, // skip 3 opCodes if not changed\r\n                -1 - nestedIcu.mainBinding, nestedIcuNodeIndex << 2 /* SHIFT_REF */ | 2 /* IcuSwitch */, nestTIcuIndex, mask, // mask of all the bindings of this ICU expression\r\n                2, // skip 2 opCodes if not changed\r\n                nestedIcuNodeIndex << 2 /* SHIFT_REF */ | 3 /* IcuUpdate */, nestTIcuIndex);\r\n                icuCase.remove.push(nestTIcuIndex << 3 /* SHIFT_REF */ | 6 /* RemoveNestedIcu */, nestedIcuNodeIndex << 3 /* SHIFT_REF */ | 3 /* Remove */);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\r\n     * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\r\n     * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\r\n     * and later on replaced by a space. We are re-implementing the same idea here, since translations\r\n     * might contain this special character.\r\n     */\r\n    var NGSP_UNICODE_REGEXP = /\\uE500/g;\r\n    function replaceNgsp(value) {\r\n        return value.replace(NGSP_UNICODE_REGEXP, ' ');\r\n    }\r\n    var TRANSLATIONS = {};\r\n    /**\r\n     * Set the configuration for `i18nLocalize`.\r\n     *\r\n     * @deprecated this method is temporary & should not be used as it will be removed soon\r\n     */\r\n    function i18nConfigureLocalize(options) {\r\n        if (options === void 0) { options = {\r\n            translations: {}\r\n        }; }\r\n        TRANSLATIONS = options.translations;\r\n    }\r\n    var LOCALIZE_PH_REGEXP = /\\{\\$(.*?)\\}/g;\r\n    /**\r\n     * A goog.getMsg-like function for users that do not use Closure.\r\n     *\r\n     * This method is required as a *temporary* measure to prevent i18n tests from being blocked while\r\n     * running outside of Closure Compiler. This method will not be needed once runtime translation\r\n     * service support is introduced.\r\n     *\r\n     * @codeGenApi\r\n     * @deprecated this method is temporary & should not be used as it will be removed soon\r\n     */\r\n    function ɵɵi18nLocalize(input, placeholders) {\r\n        if (typeof TRANSLATIONS[input] !== 'undefined') { // to account for empty string\r\n            input = TRANSLATIONS[input];\r\n        }\r\n        if (placeholders !== undefined && Object.keys(placeholders).length) {\r\n            return input.replace(LOCALIZE_PH_REGEXP, function (_, key) { return placeholders[key] || ''; });\r\n        }\r\n        return input;\r\n    }\r\n    /**\r\n     * The locale id that the application is currently using (for translations and ICU expressions).\r\n     * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\r\n     * but is now defined as a global value.\r\n     */\r\n    var LOCALE_ID = DEFAULT_LOCALE_ID;\r\n    /**\r\n     * Sets the locale id that will be used for translations and ICU expressions.\r\n     * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\r\n     * but is now defined as a global value.\r\n     *\r\n     * @param localeId\r\n     */\r\n    function setLocaleId(localeId) {\r\n        assertDefined(localeId, \"Expected localeId to be defined\");\r\n        if (typeof localeId === 'string') {\r\n            LOCALE_ID = localeId.toLowerCase().replace(/_/g, '-');\r\n        }\r\n    }\r\n    /**\r\n     * Gets the locale id that will be used for translations and ICU expressions.\r\n     * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\r\n     * but is now defined as a global value.\r\n     */\r\n    function getLocaleId() {\r\n        return LOCALE_ID;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Map of module-id to the corresponding NgModule.\r\n     * - In pre Ivy we track NgModuleFactory,\r\n     * - In post Ivy we track the NgModuleType\r\n     */\r\n    var modules = new Map();\r\n    /**\r\n     * Registers a loaded module. Should only be called from generated NgModuleFactory code.\r\n     * @publicApi\r\n     */\r\n    function registerModuleFactory(id, factory) {\r\n        var existing = modules.get(id);\r\n        assertSameOrNotExisting(id, existing && existing.moduleType, factory.moduleType);\r\n        modules.set(id, factory);\r\n    }\r\n    function assertSameOrNotExisting(id, type, incoming) {\r\n        if (type && type !== incoming) {\r\n            throw new Error(\"Duplicate module registered for \" + id + \" - \" + stringify(type) + \" vs \" + stringify(type.name));\r\n        }\r\n    }\r\n    function registerNgModuleType(ngModuleType) {\r\n        if (ngModuleType.ngModuleDef.id !== null) {\r\n            var id = ngModuleType.ngModuleDef.id;\r\n            var existing = modules.get(id);\r\n            assertSameOrNotExisting(id, existing, ngModuleType);\r\n            modules.set(id, ngModuleType);\r\n        }\r\n        var imports = ngModuleType.ngModuleDef.imports;\r\n        if (imports instanceof Function) {\r\n            imports = imports();\r\n        }\r\n        if (imports) {\r\n            imports.forEach(function (i) { return registerNgModuleType(i); });\r\n        }\r\n    }\r\n    function clearModulesForTest() {\r\n        modules.clear();\r\n    }\r\n    function getRegisteredNgModuleType(id) {\r\n        return modules.get(id);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var COMPONENT_FACTORY_RESOLVER = {\r\n        provide: ComponentFactoryResolver,\r\n        useClass: ComponentFactoryResolver$1,\r\n        deps: [NgModuleRef],\r\n    };\r\n    var NgModuleRef$1 = /** @class */ (function (_super) {\r\n        __extends(NgModuleRef$1, _super);\r\n        function NgModuleRef$1(ngModuleType, _parent) {\r\n            var _this = _super.call(this) || this;\r\n            _this._parent = _parent;\r\n            // tslint:disable-next-line:require-internal-with-underscore\r\n            _this._bootstrapComponents = [];\r\n            _this.injector = _this;\r\n            _this.destroyCbs = [];\r\n            var ngModuleDef = getNgModuleDef(ngModuleType);\r\n            ngDevMode && assertDefined(ngModuleDef, \"NgModule '\" + stringify(ngModuleType) + \"' is not a subtype of 'NgModuleType'.\");\r\n            var ngLocaleIdDef = getNgLocaleIdDef(ngModuleType);\r\n            if (ngLocaleIdDef) {\r\n                setLocaleId(ngLocaleIdDef);\r\n            }\r\n            _this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap);\r\n            var additionalProviders = [\r\n                {\r\n                    provide: NgModuleRef,\r\n                    useValue: _this,\r\n                },\r\n                COMPONENT_FACTORY_RESOLVER\r\n            ];\r\n            _this._r3Injector = createInjector(ngModuleType, _parent, additionalProviders, stringify(ngModuleType));\r\n            _this.instance = _this.get(ngModuleType);\r\n            return _this;\r\n        }\r\n        NgModuleRef$1.prototype.get = function (token, notFoundValue, injectFlags) {\r\n            if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }\r\n            if (injectFlags === void 0) { injectFlags = exports.InjectFlags.Default; }\r\n            if (token === Injector || token === NgModuleRef || token === INJECTOR) {\r\n                return this;\r\n            }\r\n            return this._r3Injector.get(token, notFoundValue, injectFlags);\r\n        };\r\n        Object.defineProperty(NgModuleRef$1.prototype, \"componentFactoryResolver\", {\r\n            get: function () {\r\n                return this.get(ComponentFactoryResolver);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        NgModuleRef$1.prototype.destroy = function () {\r\n            ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\r\n            var injector = this._r3Injector;\r\n            !injector.destroyed && injector.destroy();\r\n            this.destroyCbs.forEach(function (fn) { return fn(); });\r\n            this.destroyCbs = null;\r\n        };\r\n        NgModuleRef$1.prototype.onDestroy = function (callback) {\r\n            ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\r\n            this.destroyCbs.push(callback);\r\n        };\r\n        return NgModuleRef$1;\r\n    }(NgModuleRef));\r\n    var NgModuleFactory$1 = /** @class */ (function (_super) {\r\n        __extends(NgModuleFactory, _super);\r\n        function NgModuleFactory(moduleType) {\r\n            var _this = _super.call(this) || this;\r\n            _this.moduleType = moduleType;\r\n            var ngModuleDef = getNgModuleDef(moduleType);\r\n            if (ngModuleDef !== null) {\r\n                // Register the NgModule with Angular's module registry. The location (and hence timing) of\r\n                // this call is critical to ensure this works correctly (modules get registered when expected)\r\n                // without bloating bundles (modules are registered when otherwise not referenced).\r\n                //\r\n                // In View Engine, registration occurs in the .ngfactory.js file as a side effect. This has\r\n                // several practical consequences:\r\n                //\r\n                // - If an .ngfactory file is not imported from, the module won't be registered (and can be\r\n                //   tree shaken).\r\n                // - If an .ngfactory file is imported from, the module will be registered even if an instance\r\n                //   is not actually created (via `create` below).\r\n                // - Since an .ngfactory file in View Engine references the .ngfactory files of the NgModule's\r\n                //   imports,\r\n                //\r\n                // In Ivy, things are a bit different. .ngfactory files still exist for compatibility, but are\r\n                // not a required API to use - there are other ways to obtain an NgModuleFactory for a given\r\n                // NgModule. Thus, relying on a side effect in the .ngfactory file is not sufficient. Instead,\r\n                // the side effect of registration is added here, in the constructor of NgModuleFactory,\r\n                // ensuring no matter how a factory is created, the module is registered correctly.\r\n                //\r\n                // An alternative would be to include the registration side effect inline following the actual\r\n                // NgModule definition. This also has the correct timing, but breaks tree-shaking - modules\r\n                // will be registered and retained even if they're otherwise never referenced.\r\n                registerNgModuleType(moduleType);\r\n            }\r\n            return _this;\r\n        }\r\n        NgModuleFactory.prototype.create = function (parentInjector) {\r\n            return new NgModuleRef$1(this.moduleType, parentInjector);\r\n        };\r\n        return NgModuleFactory;\r\n    }(NgModuleFactory));\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Adds decorator, constructor, and property metadata to a given type via static metadata fields\r\n     * on the type.\r\n     *\r\n     * These metadata fields can later be read with Angular's `ReflectionCapabilities` API.\r\n     *\r\n     * Calls to `setClassMetadata` can be marked as pure, resulting in the metadata assignments being\r\n     * tree-shaken away during production builds.\r\n     */\r\n    function setClassMetadata(type, decorators, ctorParameters, propDecorators) {\r\n        return noSideEffects(function () {\r\n            var _a;\r\n            var clazz = type;\r\n            // We determine whether a class has its own metadata by taking the metadata from the parent\r\n            // constructor and checking whether it's the same as the subclass metadata below. We can't use\r\n            // `hasOwnProperty` here because it doesn't work correctly in IE10 for static fields that are\r\n            // defined by TS. See https://github.com/angular/angular/pull/28439#issuecomment-459349218.\r\n            var parentPrototype = clazz.prototype ? Object.getPrototypeOf(clazz.prototype) : null;\r\n            var parentConstructor = parentPrototype && parentPrototype.constructor;\r\n            if (decorators !== null) {\r\n                if (clazz.decorators !== undefined &&\r\n                    (!parentConstructor || parentConstructor.decorators !== clazz.decorators)) {\r\n                    (_a = clazz.decorators).push.apply(_a, __spread(decorators));\r\n                }\r\n                else {\r\n                    clazz.decorators = decorators;\r\n                }\r\n            }\r\n            if (ctorParameters !== null) {\r\n                // Rather than merging, clobber the existing parameters. If other projects exist which use\r\n                // tsickle-style annotations and reflect over them in the same way, this could cause issues,\r\n                // but that is vanishingly unlikely.\r\n                clazz.ctorParameters = ctorParameters;\r\n            }\r\n            if (propDecorators !== null) {\r\n                // The property decorator objects are merged as it is possible different fields have different\r\n                // decorator types. Decorators on individual fields are not merged, as it's also incredibly\r\n                // unlikely that a field will be decorated both with an Angular decorator and a non-Angular\r\n                // decorator that's also been downleveled.\r\n                if (clazz.propDecorators !== undefined &&\r\n                    (!parentConstructor || parentConstructor.propDecorators !== clazz.propDecorators)) {\r\n                    clazz.propDecorators = __assign({}, clazz.propDecorators, propDecorators);\r\n                }\r\n                else {\r\n                    clazz.propDecorators = propDecorators;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Bindings for pure functions are stored after regular bindings.\r\n     *\r\n     * |------consts------|---------vars---------|                 |----- hostVars (dir1) ------|\r\n     * ------------------------------------------------------------------------------------------\r\n     * | nodes/refs/pipes | bindings | fn slots  | injector | dir1 | host bindings | host slots |\r\n     * ------------------------------------------------------------------------------------------\r\n     *                    ^                      ^\r\n     *      TView.bindingStartIndex      TView.expandoStartIndex\r\n     *\r\n     * Pure function instructions are given an offset from the binding root. Adding the offset to the\r\n     * binding root gives the first index where the bindings are stored. In component views, the binding\r\n     * root is the bindingStartIndex. In host bindings, the binding root is the expandoStartIndex +\r\n     * any directive instances + any hostVars in directives evaluated before it.\r\n     *\r\n     * See VIEW_DATA.md for more information about host binding resolution.\r\n     */\r\n    /**\r\n     * If the value hasn't been saved, calls the pure function to store and return the\r\n     * value. If it has been saved, returns the saved value.\r\n     *\r\n     * @param slotOffset the offset from binding root to the reserved slot\r\n     * @param pureFn Function that returns a value\r\n     * @param thisArg Optional calling context of pureFn\r\n     * @returns value\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpureFunction0(slotOffset, pureFn, thisArg) {\r\n        // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\r\n        var bindingIndex = getBindingRoot() + slotOffset;\r\n        var lView = getLView();\r\n        return isCreationMode() ?\r\n            updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) :\r\n            getBinding(lView, bindingIndex);\r\n    }\r\n    /**\r\n     * If the value of the provided exp has changed, calls the pure function to return\r\n     * an updated value. Or if the value has not changed, returns cached value.\r\n     *\r\n     * @param slotOffset the offset from binding root to the reserved slot\r\n     * @param pureFn Function that returns an updated value\r\n     * @param exp Updated expression value\r\n     * @param thisArg Optional calling context of pureFn\r\n     * @returns Updated or cached value\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpureFunction1(slotOffset, pureFn, exp, thisArg) {\r\n        // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\r\n        var lView = getLView();\r\n        var bindingIndex = getBindingRoot() + slotOffset;\r\n        return bindingUpdated(lView, bindingIndex, exp) ?\r\n            updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) :\r\n            getBinding(lView, bindingIndex + 1);\r\n    }\r\n    /**\r\n     * If the value of any provided exp has changed, calls the pure function to return\r\n     * an updated value. Or if no values have changed, returns cached value.\r\n     *\r\n     * @param slotOffset the offset from binding root to the reserved slot\r\n     * @param pureFn\r\n     * @param exp1\r\n     * @param exp2\r\n     * @param thisArg Optional calling context of pureFn\r\n     * @returns Updated or cached value\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {\r\n        // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\r\n        var bindingIndex = getBindingRoot() + slotOffset;\r\n        var lView = getLView();\r\n        return bindingUpdated2(lView, bindingIndex, exp1, exp2) ?\r\n            updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) :\r\n            getBinding(lView, bindingIndex + 2);\r\n    }\r\n    /**\r\n     * If the value of any provided exp has changed, calls the pure function to return\r\n     * an updated value. Or if no values have changed, returns cached value.\r\n     *\r\n     * @param slotOffset the offset from binding root to the reserved slot\r\n     * @param pureFn\r\n     * @param exp1\r\n     * @param exp2\r\n     * @param exp3\r\n     * @param thisArg Optional calling context of pureFn\r\n     * @returns Updated or cached value\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {\r\n        // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\r\n        var bindingIndex = getBindingRoot() + slotOffset;\r\n        var lView = getLView();\r\n        return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ?\r\n            updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) :\r\n            getBinding(lView, bindingIndex + 3);\r\n    }\r\n    /**\r\n     * If the value of any provided exp has changed, calls the pure function to return\r\n     * an updated value. Or if no values have changed, returns cached value.\r\n     *\r\n     * @param slotOffset the offset from binding root to the reserved slot\r\n     * @param pureFn\r\n     * @param exp1\r\n     * @param exp2\r\n     * @param exp3\r\n     * @param exp4\r\n     * @param thisArg Optional calling context of pureFn\r\n     * @returns Updated or cached value\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {\r\n        // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\r\n        var bindingIndex = getBindingRoot() + slotOffset;\r\n        var lView = getLView();\r\n        return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ?\r\n            updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) :\r\n            getBinding(lView, bindingIndex + 4);\r\n    }\r\n    /**\r\n     * If the value of any provided exp has changed, calls the pure function to return\r\n     * an updated value. Or if no values have changed, returns cached value.\r\n     *\r\n     * @param slotOffset the offset from binding root to the reserved slot\r\n     * @param pureFn\r\n     * @param exp1\r\n     * @param exp2\r\n     * @param exp3\r\n     * @param exp4\r\n     * @param exp5\r\n     * @param thisArg Optional calling context of pureFn\r\n     * @returns Updated or cached value\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {\r\n        // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\r\n        var bindingIndex = getBindingRoot() + slotOffset;\r\n        var lView = getLView();\r\n        var different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\r\n        return bindingUpdated(lView, bindingIndex + 4, exp5) || different ?\r\n            updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) :\r\n                pureFn(exp1, exp2, exp3, exp4, exp5)) :\r\n            getBinding(lView, bindingIndex + 5);\r\n    }\r\n    /**\r\n     * If the value of any provided exp has changed, calls the pure function to return\r\n     * an updated value. Or if no values have changed, returns cached value.\r\n     *\r\n     * @param slotOffset the offset from binding root to the reserved slot\r\n     * @param pureFn\r\n     * @param exp1\r\n     * @param exp2\r\n     * @param exp3\r\n     * @param exp4\r\n     * @param exp5\r\n     * @param exp6\r\n     * @param thisArg Optional calling context of pureFn\r\n     * @returns Updated or cached value\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {\r\n        // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\r\n        var bindingIndex = getBindingRoot() + slotOffset;\r\n        var lView = getLView();\r\n        var different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\r\n        return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ?\r\n            updateBinding(lView, bindingIndex + 6, thisArg ?\r\n                pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) :\r\n                pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) :\r\n            getBinding(lView, bindingIndex + 6);\r\n    }\r\n    /**\r\n     * If the value of any provided exp has changed, calls the pure function to return\r\n     * an updated value. Or if no values have changed, returns cached value.\r\n     *\r\n     * @param slotOffset the offset from binding root to the reserved slot\r\n     * @param pureFn\r\n     * @param exp1\r\n     * @param exp2\r\n     * @param exp3\r\n     * @param exp4\r\n     * @param exp5\r\n     * @param exp6\r\n     * @param exp7\r\n     * @param thisArg Optional calling context of pureFn\r\n     * @returns Updated or cached value\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {\r\n        // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\r\n        var bindingIndex = getBindingRoot() + slotOffset;\r\n        var lView = getLView();\r\n        var different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\r\n        return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ?\r\n            updateBinding(lView, bindingIndex + 7, thisArg ?\r\n                pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) :\r\n                pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) :\r\n            getBinding(lView, bindingIndex + 7);\r\n    }\r\n    /**\r\n     * If the value of any provided exp has changed, calls the pure function to return\r\n     * an updated value. Or if no values have changed, returns cached value.\r\n     *\r\n     * @param slotOffset the offset from binding root to the reserved slot\r\n     * @param pureFn\r\n     * @param exp1\r\n     * @param exp2\r\n     * @param exp3\r\n     * @param exp4\r\n     * @param exp5\r\n     * @param exp6\r\n     * @param exp7\r\n     * @param exp8\r\n     * @param thisArg Optional calling context of pureFn\r\n     * @returns Updated or cached value\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {\r\n        // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\r\n        var bindingIndex = getBindingRoot() + slotOffset;\r\n        var lView = getLView();\r\n        var different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\r\n        return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ?\r\n            updateBinding(lView, bindingIndex + 8, thisArg ?\r\n                pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) :\r\n                pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) :\r\n            getBinding(lView, bindingIndex + 8);\r\n    }\r\n    /**\r\n     * pureFunction instruction that can support any number of bindings.\r\n     *\r\n     * If the value of any provided exp has changed, calls the pure function to return\r\n     * an updated value. Or if no values have changed, returns cached value.\r\n     *\r\n     * @param slotOffset the offset from binding root to the reserved slot\r\n     * @param pureFn A pure function that takes binding values and builds an object or array\r\n     * containing those values.\r\n     * @param exps An array of binding values\r\n     * @param thisArg Optional calling context of pureFn\r\n     * @returns Updated or cached value\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpureFunctionV(slotOffset, pureFn, exps, thisArg) {\r\n        // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\r\n        var bindingIndex = getBindingRoot() + slotOffset;\r\n        var different = false;\r\n        var lView = getLView();\r\n        for (var i = 0; i < exps.length; i++) {\r\n            bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);\r\n        }\r\n        return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) :\r\n            getBinding(lView, bindingIndex);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Create a pipe.\r\n     *\r\n     * @param index Pipe index where the pipe will be stored.\r\n     * @param pipeName The name of the pipe\r\n     * @returns T the instance of the pipe.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpipe(index, pipeName) {\r\n        var tView = getLView()[TVIEW];\r\n        var pipeDef;\r\n        var adjustedIndex = index + HEADER_OFFSET;\r\n        if (tView.firstTemplatePass) {\r\n            pipeDef = getPipeDef$1(pipeName, tView.pipeRegistry);\r\n            tView.data[adjustedIndex] = pipeDef;\r\n            if (pipeDef.onDestroy) {\r\n                (tView.destroyHooks || (tView.destroyHooks = [])).push(adjustedIndex, pipeDef.onDestroy);\r\n            }\r\n        }\r\n        else {\r\n            pipeDef = tView.data[adjustedIndex];\r\n        }\r\n        var pipeInstance = pipeDef.factory();\r\n        store(index, pipeInstance);\r\n        return pipeInstance;\r\n    }\r\n    /**\r\n     * Searches the pipe registry for a pipe with the given name. If one is found,\r\n     * returns the pipe. Otherwise, an error is thrown because the pipe cannot be resolved.\r\n     *\r\n     * @param name Name of pipe to resolve\r\n     * @param registry Full list of available pipes\r\n     * @returns Matching PipeDef\r\n     *\r\n     * @publicApi\r\n     */\r\n    function getPipeDef$1(name, registry) {\r\n        if (registry) {\r\n            for (var i = registry.length - 1; i >= 0; i--) {\r\n                var pipeDef = registry[i];\r\n                if (name === pipeDef.name) {\r\n                    return pipeDef;\r\n                }\r\n            }\r\n        }\r\n        throw new Error(\"The pipe '\" + name + \"' could not be found!\");\r\n    }\r\n    /**\r\n     * Invokes a pipe with 1 arguments.\r\n     *\r\n     * This instruction acts as a guard to {@link PipeTransform#transform} invoking\r\n     * the pipe only when an input to the pipe changes.\r\n     *\r\n     * @param index Pipe index where the pipe was stored on creation.\r\n     * @param slotOffset the offset in the reserved slot space\r\n     * @param v1 1st argument to {@link PipeTransform#transform}.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpipeBind1(index, slotOffset, v1) {\r\n        var pipeInstance = ɵɵload(index);\r\n        return unwrapValue$1(isPure(index) ? ɵɵpureFunction1(slotOffset, pipeInstance.transform, v1, pipeInstance) :\r\n            pipeInstance.transform(v1));\r\n    }\r\n    /**\r\n     * Invokes a pipe with 2 arguments.\r\n     *\r\n     * This instruction acts as a guard to {@link PipeTransform#transform} invoking\r\n     * the pipe only when an input to the pipe changes.\r\n     *\r\n     * @param index Pipe index where the pipe was stored on creation.\r\n     * @param slotOffset the offset in the reserved slot space\r\n     * @param v1 1st argument to {@link PipeTransform#transform}.\r\n     * @param v2 2nd argument to {@link PipeTransform#transform}.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpipeBind2(index, slotOffset, v1, v2) {\r\n        var pipeInstance = ɵɵload(index);\r\n        return unwrapValue$1(isPure(index) ? ɵɵpureFunction2(slotOffset, pipeInstance.transform, v1, v2, pipeInstance) :\r\n            pipeInstance.transform(v1, v2));\r\n    }\r\n    /**\r\n     * Invokes a pipe with 3 arguments.\r\n     *\r\n     * This instruction acts as a guard to {@link PipeTransform#transform} invoking\r\n     * the pipe only when an input to the pipe changes.\r\n     *\r\n     * @param index Pipe index where the pipe was stored on creation.\r\n     * @param slotOffset the offset in the reserved slot space\r\n     * @param v1 1st argument to {@link PipeTransform#transform}.\r\n     * @param v2 2nd argument to {@link PipeTransform#transform}.\r\n     * @param v3 4rd argument to {@link PipeTransform#transform}.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpipeBind3(index, slotOffset, v1, v2, v3) {\r\n        var pipeInstance = ɵɵload(index);\r\n        return unwrapValue$1(isPure(index) ?\r\n            ɵɵpureFunction3(slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) :\r\n            pipeInstance.transform(v1, v2, v3));\r\n    }\r\n    /**\r\n     * Invokes a pipe with 4 arguments.\r\n     *\r\n     * This instruction acts as a guard to {@link PipeTransform#transform} invoking\r\n     * the pipe only when an input to the pipe changes.\r\n     *\r\n     * @param index Pipe index where the pipe was stored on creation.\r\n     * @param slotOffset the offset in the reserved slot space\r\n     * @param v1 1st argument to {@link PipeTransform#transform}.\r\n     * @param v2 2nd argument to {@link PipeTransform#transform}.\r\n     * @param v3 3rd argument to {@link PipeTransform#transform}.\r\n     * @param v4 4th argument to {@link PipeTransform#transform}.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpipeBind4(index, slotOffset, v1, v2, v3, v4) {\r\n        var pipeInstance = ɵɵload(index);\r\n        return unwrapValue$1(isPure(index) ?\r\n            ɵɵpureFunction4(slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) :\r\n            pipeInstance.transform(v1, v2, v3, v4));\r\n    }\r\n    /**\r\n     * Invokes a pipe with variable number of arguments.\r\n     *\r\n     * This instruction acts as a guard to {@link PipeTransform#transform} invoking\r\n     * the pipe only when an input to the pipe changes.\r\n     *\r\n     * @param index Pipe index where the pipe was stored on creation.\r\n     * @param slotOffset the offset in the reserved slot space\r\n     * @param values Array of arguments to pass to {@link PipeTransform#transform} method.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵpipeBindV(index, slotOffset, values) {\r\n        var pipeInstance = ɵɵload(index);\r\n        return unwrapValue$1(isPure(index) ? ɵɵpureFunctionV(slotOffset, pipeInstance.transform, values, pipeInstance) :\r\n            pipeInstance.transform.apply(pipeInstance, values));\r\n    }\r\n    function isPure(index) {\r\n        return getLView()[TVIEW].data[index + HEADER_OFFSET].pure;\r\n    }\r\n    /**\r\n     * Unwrap the output of a pipe transformation.\r\n     * In order to trick change detection into considering that the new value is always different from\r\n     * the old one, the old value is overwritten by NO_CHANGE.\r\n     *\r\n     * @param newValue the pipe transformation output.\r\n     */\r\n    function unwrapValue$1(newValue) {\r\n        if (WrappedValue.isWrapped(newValue)) {\r\n            newValue = WrappedValue.unwrap(newValue);\r\n            var lView = getLView();\r\n            // The NO_CHANGE value needs to be written at the index where the impacted binding value is\r\n            // stored\r\n            var bindingToInvalidateIdx = lView[BINDING_INDEX];\r\n            lView[bindingToInvalidateIdx] = NO_CHANGE;\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Use in components with the `@Output` directive to emit custom events\r\n     * synchronously or asynchronously, and register handlers for those events\r\n     * by subscribing to an instance.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * Extends\r\n     * [RxJS `Subject`](https://rxjs.dev/api/index/class/Subject)\r\n     * for Angular by adding the `emit()` method.\r\n     *\r\n     * In the following example, a component defines two output properties\r\n     * that create event emitters. When the title is clicked, the emitter\r\n     * emits an open or close event to toggle the current visibility state.\r\n     *\r\n     * ```html\r\n     * @Component({\r\n     *   selector: 'zippy',\r\n     *   template: `\r\n     *   <div class=\"zippy\">\r\n     *     <div (click)=\"toggle()\">Toggle</div>\r\n     *     <div [hidden]=\"!visible\">\r\n     *       <ng-content></ng-content>\r\n     *     </div>\r\n     *  </div>`})\r\n     * export class Zippy {\r\n     *   visible: boolean = true;\r\n     *   @Output() open: EventEmitter<any> = new EventEmitter();\r\n     *   @Output() close: EventEmitter<any> = new EventEmitter();\r\n     *\r\n     *   toggle() {\r\n     *     this.visible = !this.visible;\r\n     *     if (this.visible) {\r\n     *       this.open.emit(null);\r\n     *     } else {\r\n     *       this.close.emit(null);\r\n     *     }\r\n     *   }\r\n     * }\r\n     * ```\r\n     *\r\n     * Access the event object with the `$event` argument passed to the output event\r\n     * handler:\r\n     *\r\n     * ```html\r\n     * <zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"></zippy>\r\n     * ```\r\n     *\r\n     * @see [Observables in Angular](guide/observables-in-angular)\r\n     * @publicApi\r\n     */\r\n    var EventEmitter = /** @class */ (function (_super) {\r\n        __extends(EventEmitter, _super);\r\n        /**\r\n         * Creates an instance of this class that can\r\n         * deliver events synchronously or asynchronously.\r\n         *\r\n         * @param isAsync When true, deliver events asynchronously.\r\n         *\r\n         */\r\n        function EventEmitter(isAsync) {\r\n            if (isAsync === void 0) { isAsync = false; }\r\n            var _this = _super.call(this) || this;\r\n            _this.__isAsync = isAsync;\r\n            return _this;\r\n        }\r\n        /**\r\n         * Emits an event containing a given value.\r\n         * @param value The value to emit.\r\n         */\r\n        EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };\r\n        /**\r\n         * Registers handlers for events emitted by this instance.\r\n         * @param generatorOrNext When supplied, a custom handler for emitted events.\r\n         * @param error When supplied, a custom handler for an error notification\r\n         * from this emitter.\r\n         * @param complete When supplied, a custom handler for a completion\r\n         * notification from this emitter.\r\n         */\r\n        EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {\r\n            var schedulerFn;\r\n            var errorFn = function (err) { return null; };\r\n            var completeFn = function () { return null; };\r\n            if (generatorOrNext && typeof generatorOrNext === 'object') {\r\n                schedulerFn = this.__isAsync ? function (value) {\r\n                    setTimeout(function () { return generatorOrNext.next(value); });\r\n                } : function (value) { generatorOrNext.next(value); };\r\n                if (generatorOrNext.error) {\r\n                    errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :\r\n                        function (err) { generatorOrNext.error(err); };\r\n                }\r\n                if (generatorOrNext.complete) {\r\n                    completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :\r\n                        function () { generatorOrNext.complete(); };\r\n                }\r\n            }\r\n            else {\r\n                schedulerFn = this.__isAsync ? function (value) { setTimeout(function () { return generatorOrNext(value); }); } :\r\n                    function (value) { generatorOrNext(value); };\r\n                if (error) {\r\n                    errorFn =\r\n                        this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };\r\n                }\r\n                if (complete) {\r\n                    completeFn =\r\n                        this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };\r\n                }\r\n            }\r\n            var sink = _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);\r\n            if (generatorOrNext instanceof rxjs.Subscription) {\r\n                generatorOrNext.add(sink);\r\n            }\r\n            return sink;\r\n        };\r\n        return EventEmitter;\r\n    }(rxjs.Subject));\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function symbolIterator() {\r\n        return this._results[getSymbolIterator()]();\r\n    }\r\n    /**\r\n     * An unmodifiable list of items that Angular keeps up to date when the state\r\n     * of the application changes.\r\n     *\r\n     * The type of object that {@link ViewChildren}, {@link ContentChildren}, and {@link QueryList}\r\n     * provide.\r\n     *\r\n     * Implements an iterable interface, therefore it can be used in both ES6\r\n     * javascript `for (var i of items)` loops as well as in Angular templates with\r\n     * `*ngFor=\"let i of myList\"`.\r\n     *\r\n     * Changes can be observed by subscribing to the changes `Observable`.\r\n     *\r\n     * NOTE: In the future this class will implement an `Observable` interface.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     * ```typescript\r\n     * @Component({...})\r\n     * class Container {\r\n     *   @ViewChildren(Item) items:QueryList<Item>;\r\n     * }\r\n     * ```\r\n     *\r\n     * @publicApi\r\n     */\r\n    var QueryList = /** @class */ (function () {\r\n        function QueryList() {\r\n            this.dirty = true;\r\n            this._results = [];\r\n            this.changes = new EventEmitter();\r\n            this.length = 0;\r\n            // This function should be declared on the prototype, but doing so there will cause the class\r\n            // declaration to have side-effects and become not tree-shakable. For this reason we do it in\r\n            // the constructor.\r\n            // [getSymbolIterator()](): Iterator<T> { ... }\r\n            var symbol = getSymbolIterator();\r\n            var proto = QueryList.prototype;\r\n            if (!proto[symbol])\r\n                proto[symbol] = symbolIterator;\r\n        }\r\n        /**\r\n         * See\r\n         * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\r\n         */\r\n        QueryList.prototype.map = function (fn) { return this._results.map(fn); };\r\n        /**\r\n         * See\r\n         * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\r\n         */\r\n        QueryList.prototype.filter = function (fn) {\r\n            return this._results.filter(fn);\r\n        };\r\n        /**\r\n         * See\r\n         * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\r\n         */\r\n        QueryList.prototype.find = function (fn) {\r\n            return this._results.find(fn);\r\n        };\r\n        /**\r\n         * See\r\n         * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\r\n         */\r\n        QueryList.prototype.reduce = function (fn, init) {\r\n            return this._results.reduce(fn, init);\r\n        };\r\n        /**\r\n         * See\r\n         * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\r\n         */\r\n        QueryList.prototype.forEach = function (fn) { this._results.forEach(fn); };\r\n        /**\r\n         * See\r\n         * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\r\n         */\r\n        QueryList.prototype.some = function (fn) {\r\n            return this._results.some(fn);\r\n        };\r\n        /**\r\n         * Returns a copy of the internal results list as an Array.\r\n         */\r\n        QueryList.prototype.toArray = function () { return this._results.slice(); };\r\n        QueryList.prototype.toString = function () { return this._results.toString(); };\r\n        /**\r\n         * Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that\r\n         * on change detection, it will not notify of changes to the queries, unless a new change\r\n         * occurs.\r\n         *\r\n         * @param resultsTree The query results to store\r\n         */\r\n        QueryList.prototype.reset = function (resultsTree) {\r\n            this._results = flatten(resultsTree);\r\n            this.dirty = false;\r\n            this.length = this._results.length;\r\n            this.last = this._results[this.length - 1];\r\n            this.first = this._results[0];\r\n        };\r\n        /**\r\n         * Triggers a change event by emitting on the `changes` {@link EventEmitter}.\r\n         */\r\n        QueryList.prototype.notifyOnChanges = function () { this.changes.emit(this); };\r\n        /** internal */\r\n        QueryList.prototype.setDirty = function () { this.dirty = true; };\r\n        /** internal */\r\n        QueryList.prototype.destroy = function () {\r\n            this.changes.complete();\r\n            this.changes.unsubscribe();\r\n        };\r\n        return QueryList;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    // Note: This hack is necessary so we don't erroneously get a circular dependency\r\n    // failure based on types.\r\n    var unusedValueExportToPlacateAjd$7 = 1;\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    // Note: This hack is necessary so we don't erroneously get a circular dependency\r\n    // failure based on types.\r\n    var unusedValueExportToPlacateAjd$8 = 1;\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var unusedValueToPlacateAjd$2 = unusedValueExportToPlacateAjd$7 + unusedValueExportToPlacateAjd$2 + unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd$8;\r\n    var LQuery_ = /** @class */ (function () {\r\n        function LQuery_(queryList) {\r\n            this.queryList = queryList;\r\n            this.matches = null;\r\n        }\r\n        LQuery_.prototype.clone = function () { return new LQuery_(this.queryList); };\r\n        LQuery_.prototype.setDirty = function () { this.queryList.setDirty(); };\r\n        return LQuery_;\r\n    }());\r\n    var LQueries_ = /** @class */ (function () {\r\n        function LQueries_(queries) {\r\n            if (queries === void 0) { queries = []; }\r\n            this.queries = queries;\r\n        }\r\n        LQueries_.prototype.createEmbeddedView = function (tView) {\r\n            var tQueries = tView.queries;\r\n            if (tQueries !== null) {\r\n                var noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;\r\n                var viewLQueries = new Array(noOfInheritedQueries);\r\n                // An embedded view has queries propagated from a declaration view at the beginning of the\r\n                // TQueries collection and up until a first content query declared in the embedded view. Only\r\n                // propagated LQueries are created at this point (LQuery corresponding to declared content\r\n                // queries will be instantiated from the content query instructions for each directive).\r\n                for (var i = 0; i < noOfInheritedQueries; i++) {\r\n                    var tQuery = tQueries.getByIndex(i);\r\n                    var parentLQuery = this.queries[tQuery.indexInDeclarationView];\r\n                    viewLQueries[i] = parentLQuery.clone();\r\n                }\r\n                return new LQueries_(viewLQueries);\r\n            }\r\n            return null;\r\n        };\r\n        LQueries_.prototype.insertView = function (tView) { this.dirtyQueriesWithMatches(tView); };\r\n        LQueries_.prototype.detachView = function (tView) { this.dirtyQueriesWithMatches(tView); };\r\n        LQueries_.prototype.dirtyQueriesWithMatches = function (tView) {\r\n            for (var i = 0; i < this.queries.length; i++) {\r\n                if (getTQuery(tView, i).matches !== null) {\r\n                    this.queries[i].setDirty();\r\n                }\r\n            }\r\n        };\r\n        return LQueries_;\r\n    }());\r\n    var TQueryMetadata_ = /** @class */ (function () {\r\n        function TQueryMetadata_(predicate, descendants, isStatic, read) {\r\n            if (read === void 0) { read = null; }\r\n            this.predicate = predicate;\r\n            this.descendants = descendants;\r\n            this.isStatic = isStatic;\r\n            this.read = read;\r\n        }\r\n        return TQueryMetadata_;\r\n    }());\r\n    var TQueries_ = /** @class */ (function () {\r\n        function TQueries_(queries) {\r\n            if (queries === void 0) { queries = []; }\r\n            this.queries = queries;\r\n        }\r\n        TQueries_.prototype.elementStart = function (tView, tNode) {\r\n            var e_1, _a;\r\n            ngDevMode && assertFirstTemplatePass(tView, 'Queries should collect results on the first template pass only');\r\n            try {\r\n                for (var _b = __values(this.queries), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var query = _c.value;\r\n                    query.elementStart(tView, tNode);\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n        };\r\n        TQueries_.prototype.elementEnd = function (tNode) {\r\n            var e_2, _a;\r\n            try {\r\n                for (var _b = __values(this.queries), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var query = _c.value;\r\n                    query.elementEnd(tNode);\r\n                }\r\n            }\r\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_2) throw e_2.error; }\r\n            }\r\n        };\r\n        TQueries_.prototype.embeddedTView = function (tNode) {\r\n            var queriesForTemplateRef = null;\r\n            for (var i = 0; i < this.length; i++) {\r\n                var childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;\r\n                var tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);\r\n                if (tqueryClone) {\r\n                    tqueryClone.indexInDeclarationView = i;\r\n                    if (queriesForTemplateRef !== null) {\r\n                        queriesForTemplateRef.push(tqueryClone);\r\n                    }\r\n                    else {\r\n                        queriesForTemplateRef = [tqueryClone];\r\n                    }\r\n                }\r\n            }\r\n            return queriesForTemplateRef !== null ? new TQueries_(queriesForTemplateRef) : null;\r\n        };\r\n        TQueries_.prototype.template = function (tView, tNode) {\r\n            var e_3, _a;\r\n            ngDevMode && assertFirstTemplatePass(tView, 'Queries should collect results on the first template pass only');\r\n            try {\r\n                for (var _b = __values(this.queries), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var query = _c.value;\r\n                    query.template(tView, tNode);\r\n                }\r\n            }\r\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_3) throw e_3.error; }\r\n            }\r\n        };\r\n        TQueries_.prototype.getByIndex = function (index) {\r\n            ngDevMode && assertDataInRange(this.queries, index);\r\n            return this.queries[index];\r\n        };\r\n        Object.defineProperty(TQueries_.prototype, \"length\", {\r\n            get: function () { return this.queries.length; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        TQueries_.prototype.track = function (tquery) { this.queries.push(tquery); };\r\n        return TQueries_;\r\n    }());\r\n    var TQuery_ = /** @class */ (function () {\r\n        function TQuery_(metadata, nodeIndex) {\r\n            if (nodeIndex === void 0) { nodeIndex = -1; }\r\n            this.metadata = metadata;\r\n            this.matches = null;\r\n            this.indexInDeclarationView = -1;\r\n            this.crossesNgTemplate = false;\r\n            /**\r\n             * A flag indicating if a given query still applies to nodes it is crossing. We use this flag\r\n             * (alongside with _declarationNodeIndex) to know when to stop applying content queries to\r\n             * elements in a template.\r\n             */\r\n            this._appliesToNextNode = true;\r\n            this._declarationNodeIndex = nodeIndex;\r\n        }\r\n        TQuery_.prototype.elementStart = function (tView, tNode) {\r\n            if (this.isApplyingToNode(tNode)) {\r\n                this.matchTNode(tView, tNode);\r\n            }\r\n        };\r\n        TQuery_.prototype.elementEnd = function (tNode) {\r\n            if (this._declarationNodeIndex === tNode.index) {\r\n                this._appliesToNextNode = false;\r\n            }\r\n        };\r\n        TQuery_.prototype.template = function (tView, tNode) { this.elementStart(tView, tNode); };\r\n        TQuery_.prototype.embeddedTView = function (tNode, childQueryIndex) {\r\n            if (this.isApplyingToNode(tNode)) {\r\n                this.crossesNgTemplate = true;\r\n                // A marker indicating a `<ng-template>` element (a placeholder for query results from\r\n                // embedded views created based on this `<ng-template>`).\r\n                this.addMatch(-tNode.index, childQueryIndex);\r\n                return new TQuery_(this.metadata);\r\n            }\r\n            return null;\r\n        };\r\n        TQuery_.prototype.isApplyingToNode = function (tNode) {\r\n            if (this._appliesToNextNode && this.metadata.descendants === false) {\r\n                return this._declarationNodeIndex === (tNode.parent ? tNode.parent.index : -1);\r\n            }\r\n            return this._appliesToNextNode;\r\n        };\r\n        TQuery_.prototype.matchTNode = function (tView, tNode) {\r\n            if (Array.isArray(this.metadata.predicate)) {\r\n                var localNames = this.metadata.predicate;\r\n                for (var i = 0; i < localNames.length; i++) {\r\n                    this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, localNames[i]));\r\n                }\r\n            }\r\n            else {\r\n                var typePredicate = this.metadata.predicate;\r\n                if (typePredicate === TemplateRef) {\r\n                    if (tNode.type === 0 /* Container */) {\r\n                        this.matchTNodeWithReadOption(tView, tNode, -1);\r\n                    }\r\n                }\r\n                else {\r\n                    this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, typePredicate, false, false));\r\n                }\r\n            }\r\n        };\r\n        TQuery_.prototype.matchTNodeWithReadOption = function (tView, tNode, nodeMatchIdx) {\r\n            if (nodeMatchIdx !== null) {\r\n                var read = this.metadata.read;\r\n                if (read !== null) {\r\n                    if (read === ElementRef || read === ViewContainerRef ||\r\n                        read === TemplateRef && tNode.type === 0 /* Container */) {\r\n                        this.addMatch(tNode.index, -2);\r\n                    }\r\n                    else {\r\n                        var directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);\r\n                        if (directiveOrProviderIdx !== null) {\r\n                            this.addMatch(tNode.index, directiveOrProviderIdx);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    this.addMatch(tNode.index, nodeMatchIdx);\r\n                }\r\n            }\r\n        };\r\n        TQuery_.prototype.addMatch = function (tNodeIdx, matchIdx) {\r\n            if (this.matches === null) {\r\n                this.matches = [tNodeIdx, matchIdx];\r\n            }\r\n            else {\r\n                this.matches.push(tNodeIdx, matchIdx);\r\n            }\r\n        };\r\n        return TQuery_;\r\n    }());\r\n    /**\r\n     * Iterates over local names for a given node and returns directive index\r\n     * (or -1 if a local name points to an element).\r\n     *\r\n     * @param tNode static data of a node to check\r\n     * @param selector selector to match\r\n     * @returns directive index, -1 or null if a selector didn't match any of the local names\r\n     */\r\n    function getIdxOfMatchingSelector(tNode, selector) {\r\n        var localNames = tNode.localNames;\r\n        if (localNames !== null) {\r\n            for (var i = 0; i < localNames.length; i += 2) {\r\n                if (localNames[i] === selector) {\r\n                    return localNames[i + 1];\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    function createResultByTNodeType(tNode, currentView) {\r\n        if (tNode.type === 3 /* Element */ || tNode.type === 4 /* ElementContainer */) {\r\n            return createElementRef(ElementRef, tNode, currentView);\r\n        }\r\n        else if (tNode.type === 0 /* Container */) {\r\n            return createTemplateRef(TemplateRef, ElementRef, tNode, currentView);\r\n        }\r\n        return null;\r\n    }\r\n    function createResultForNode(lView, tNode, matchingIdx, read) {\r\n        if (matchingIdx === -1) {\r\n            // if read token and / or strategy is not specified, detect it using appropriate tNode type\r\n            return createResultByTNodeType(tNode, lView);\r\n        }\r\n        else if (matchingIdx === -2) {\r\n            // read a special token from a node injector\r\n            return createSpecialToken(lView, tNode, read);\r\n        }\r\n        else {\r\n            // read a token\r\n            return getNodeInjectable(lView[TVIEW].data, lView, matchingIdx, tNode);\r\n        }\r\n    }\r\n    function createSpecialToken(lView, tNode, read) {\r\n        if (read === ElementRef) {\r\n            return createElementRef(ElementRef, tNode, lView);\r\n        }\r\n        else if (read === TemplateRef) {\r\n            return createTemplateRef(TemplateRef, ElementRef, tNode, lView);\r\n        }\r\n        else if (read === ViewContainerRef) {\r\n            ngDevMode && assertNodeOfPossibleTypes(tNode, 3 /* Element */, 0 /* Container */, 4 /* ElementContainer */);\r\n            return createContainerRef(ViewContainerRef, ElementRef, tNode, lView);\r\n        }\r\n        else {\r\n            ngDevMode &&\r\n                throwError(\"Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got \" + stringify(read) + \".\");\r\n        }\r\n    }\r\n    /**\r\n     * A helper function that creates query results for a given view. This function is meant to do the\r\n     * processing once and only once for a given view instance (a set of results for a given view\r\n     * doesn't change).\r\n     */\r\n    function materializeViewResults(lView, tQuery, queryIndex) {\r\n        var lQuery = lView[QUERIES].queries[queryIndex];\r\n        if (lQuery.matches === null) {\r\n            var tViewData = lView[TVIEW].data;\r\n            var tQueryMatches = tQuery.matches;\r\n            var result = new Array(tQueryMatches.length / 2);\r\n            for (var i = 0; i < tQueryMatches.length; i += 2) {\r\n                var matchedNodeIdx = tQueryMatches[i];\r\n                if (matchedNodeIdx < 0) {\r\n                    // we at the <ng-template> marker which might have results in views created based on this\r\n                    // <ng-template> - those results will be in separate views though, so here we just leave\r\n                    // null as a placeholder\r\n                    result[i / 2] = null;\r\n                }\r\n                else {\r\n                    ngDevMode && assertDataInRange(tViewData, matchedNodeIdx);\r\n                    var tNode = tViewData[matchedNodeIdx];\r\n                    result[i / 2] =\r\n                        createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read);\r\n                }\r\n            }\r\n            lQuery.matches = result;\r\n        }\r\n        return lQuery.matches;\r\n    }\r\n    /**\r\n     * A helper function that collects (already materialized) query results from a tree of views,\r\n     * starting with a provided LView.\r\n     */\r\n    function collectQueryResults(lView, queryIndex, result) {\r\n        var e_4, _a;\r\n        var tQuery = lView[TVIEW].queries.getByIndex(queryIndex);\r\n        var tQueryMatches = tQuery.matches;\r\n        if (tQueryMatches !== null) {\r\n            var lViewResults = materializeViewResults(lView, tQuery, queryIndex);\r\n            for (var i = 0; i < tQueryMatches.length; i += 2) {\r\n                var tNodeIdx = tQueryMatches[i];\r\n                if (tNodeIdx > 0) {\r\n                    var viewResult = lViewResults[i / 2];\r\n                    ngDevMode && assertDefined(viewResult, 'materialized query result should be defined');\r\n                    result.push(viewResult);\r\n                }\r\n                else {\r\n                    var childQueryIndex = tQueryMatches[i + 1];\r\n                    var declarationLContainer = lView[-tNodeIdx];\r\n                    ngDevMode && assertLContainer(declarationLContainer);\r\n                    // collect matches for views inserted in this container\r\n                    for (var i_1 = CONTAINER_HEADER_OFFSET; i_1 < declarationLContainer.length; i_1++) {\r\n                        var embeddedLView = declarationLContainer[i_1];\r\n                        if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {\r\n                            collectQueryResults(embeddedLView, childQueryIndex, result);\r\n                        }\r\n                    }\r\n                    // collect matches for views created from this declaration container and inserted into\r\n                    // different containers\r\n                    if (declarationLContainer[MOVED_VIEWS] !== null) {\r\n                        try {\r\n                            for (var _b = (e_4 = void 0, __values(declarationLContainer[MOVED_VIEWS])), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                                var embeddedLView = _c.value;\r\n                                collectQueryResults(embeddedLView, childQueryIndex, result);\r\n                            }\r\n                        }\r\n                        catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n                        finally {\r\n                            try {\r\n                                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                            }\r\n                            finally { if (e_4) throw e_4.error; }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Refreshes a query by combining matches from all active views and removing matches from deleted\r\n     * views.\r\n     *\r\n     * @returns `true` if a query got dirty during change detection or if this is a static query\r\n     * resolving in creation mode, `false` otherwise.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵqueryRefresh(queryList) {\r\n        var lView = getLView();\r\n        var queryIndex = getCurrentQueryIndex();\r\n        setCurrentQueryIndex(queryIndex + 1);\r\n        var tQuery = getTQuery(lView[TVIEW], queryIndex);\r\n        if (queryList.dirty && (isCreationMode() === tQuery.metadata.isStatic)) {\r\n            if (tQuery.matches === null) {\r\n                queryList.reset([]);\r\n            }\r\n            else {\r\n                var result = tQuery.crossesNgTemplate ? collectQueryResults(lView, queryIndex, []) :\r\n                    materializeViewResults(lView, tQuery, queryIndex);\r\n                queryList.reset(result);\r\n                queryList.notifyOnChanges();\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Creates new QueryList for a static view query.\r\n     *\r\n     * @param predicate The type for which the query will search\r\n     * @param descend Whether or not to descend into children\r\n     * @param read What to save in the query\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵstaticViewQuery(predicate, descend, read) {\r\n        viewQueryInternal(getLView(), predicate, descend, read, true);\r\n    }\r\n    /**\r\n     * Creates new QueryList, stores the reference in LView and returns QueryList.\r\n     *\r\n     * @param predicate The type for which the query will search\r\n     * @param descend Whether or not to descend into children\r\n     * @param read What to save in the query\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵviewQuery(predicate, descend, read) {\r\n        viewQueryInternal(getLView(), predicate, descend, read, false);\r\n    }\r\n    function viewQueryInternal(lView, predicate, descend, read, isStatic) {\r\n        var tView = lView[TVIEW];\r\n        if (tView.firstTemplatePass) {\r\n            createTQuery(tView, new TQueryMetadata_(predicate, descend, isStatic, read), -1);\r\n            if (isStatic) {\r\n                tView.staticViewQueries = true;\r\n            }\r\n        }\r\n        createLQuery(lView);\r\n    }\r\n    /**\r\n     * Loads a QueryList corresponding to the current view query.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵloadViewQuery() {\r\n        return loadQueryInternal(getLView(), getCurrentQueryIndex());\r\n    }\r\n    /**\r\n     * Registers a QueryList, associated with a content query, for later refresh (part of a view\r\n     * refresh).\r\n     *\r\n     * @param directiveIndex Current directive index\r\n     * @param predicate The type for which the query will search\r\n     * @param descend Whether or not to descend into children\r\n     * @param read What to save in the query\r\n     * @returns QueryList<T>\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵcontentQuery(directiveIndex, predicate, descend, read) {\r\n        contentQueryInternal(getLView(), predicate, descend, read, false, getPreviousOrParentTNode(), directiveIndex);\r\n    }\r\n    /**\r\n     * Registers a QueryList, associated with a static content query, for later refresh\r\n     * (part of a view refresh).\r\n     *\r\n     * @param directiveIndex Current directive index\r\n     * @param predicate The type for which the query will search\r\n     * @param descend Whether or not to descend into children\r\n     * @param read What to save in the query\r\n     * @returns QueryList<T>\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵstaticContentQuery(directiveIndex, predicate, descend, read) {\r\n        contentQueryInternal(getLView(), predicate, descend, read, true, getPreviousOrParentTNode(), directiveIndex);\r\n    }\r\n    function contentQueryInternal(lView, predicate, descend, read, isStatic, tNode, directiveIndex) {\r\n        var tView = lView[TVIEW];\r\n        if (tView.firstTemplatePass) {\r\n            createTQuery(tView, new TQueryMetadata_(predicate, descend, isStatic, read), tNode.index);\r\n            saveContentQueryAndDirectiveIndex(tView, directiveIndex);\r\n            if (isStatic) {\r\n                tView.staticContentQueries = true;\r\n            }\r\n        }\r\n        createLQuery(lView);\r\n    }\r\n    /**\r\n     * Loads a QueryList corresponding to the current content query.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵloadContentQuery() {\r\n        return loadQueryInternal(getLView(), getCurrentQueryIndex());\r\n    }\r\n    function loadQueryInternal(lView, queryIndex) {\r\n        ngDevMode &&\r\n            assertDefined(lView[QUERIES], 'LQueries should be defined when trying to load a query');\r\n        ngDevMode && assertDataInRange(lView[QUERIES].queries, queryIndex);\r\n        return lView[QUERIES].queries[queryIndex].queryList;\r\n    }\r\n    function createLQuery(lView) {\r\n        var queryList = new QueryList();\r\n        storeCleanupWithContext(lView, queryList, queryList.destroy);\r\n        if (lView[QUERIES] === null)\r\n            lView[QUERIES] = new LQueries_();\r\n        lView[QUERIES].queries.push(new LQuery_(queryList));\r\n    }\r\n    function createTQuery(tView, metadata, nodeIndex) {\r\n        if (tView.queries === null)\r\n            tView.queries = new TQueries_();\r\n        tView.queries.track(new TQuery_(metadata, nodeIndex));\r\n    }\r\n    function saveContentQueryAndDirectiveIndex(tView, directiveIndex) {\r\n        var tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);\r\n        var lastSavedDirectiveIndex = tView.contentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;\r\n        if (directiveIndex !== lastSavedDirectiveIndex) {\r\n            tViewContentQueries.push(tView.queries.length - 1, directiveIndex);\r\n        }\r\n    }\r\n    function getTQuery(tView, index) {\r\n        ngDevMode && assertDefined(tView.queries, 'TQueries must be defined to retrieve a TQuery');\r\n        return tView.queries.getByIndex(index);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Retrieves `TemplateRef` instance from `Injector` when a local reference is placed on the\r\n     * `<ng-template>` element.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵtemplateRefExtractor(tNode, currentView) {\r\n        return createTemplateRef(TemplateRef, ElementRef, tNode, currentView);\r\n    }\r\n    /**\r\n     * Returns the appropriate `ChangeDetectorRef` for a pipe.\r\n     *\r\n     * @codeGenApi\r\n     */\r\n    function ɵɵinjectPipeChangeDetectorRef(flags) {\r\n        if (flags === void 0) { flags = exports.InjectFlags.Default; }\r\n        var value = injectChangeDetectorRef(true);\r\n        if (value == null && !(flags & exports.InjectFlags.Optional)) {\r\n            throw new Error(\"No provider for ChangeDetectorRef!\");\r\n        }\r\n        else {\r\n            return value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var ɵ0$e = function () { return ({\r\n        'ɵɵattribute': ɵɵattribute,\r\n        'ɵɵattributeInterpolate1': ɵɵattributeInterpolate1,\r\n        'ɵɵattributeInterpolate2': ɵɵattributeInterpolate2,\r\n        'ɵɵattributeInterpolate3': ɵɵattributeInterpolate3,\r\n        'ɵɵattributeInterpolate4': ɵɵattributeInterpolate4,\r\n        'ɵɵattributeInterpolate5': ɵɵattributeInterpolate5,\r\n        'ɵɵattributeInterpolate6': ɵɵattributeInterpolate6,\r\n        'ɵɵattributeInterpolate7': ɵɵattributeInterpolate7,\r\n        'ɵɵattributeInterpolate8': ɵɵattributeInterpolate8,\r\n        'ɵɵattributeInterpolateV': ɵɵattributeInterpolateV,\r\n        'ɵɵdefineBase': ɵɵdefineBase,\r\n        'ɵɵdefineComponent': ɵɵdefineComponent,\r\n        'ɵɵdefineDirective': ɵɵdefineDirective,\r\n        'ɵɵdefineInjectable': ɵɵdefineInjectable,\r\n        'ɵɵdefineInjector': ɵɵdefineInjector,\r\n        'ɵɵdefineNgModule': ɵɵdefineNgModule,\r\n        'ɵɵdefinePipe': ɵɵdefinePipe,\r\n        'ɵɵdirectiveInject': ɵɵdirectiveInject,\r\n        'ɵɵgetFactoryOf': ɵɵgetFactoryOf,\r\n        'ɵɵgetInheritedFactory': ɵɵgetInheritedFactory,\r\n        'ɵɵinject': ɵɵinject,\r\n        'ɵɵinjectAttribute': ɵɵinjectAttribute,\r\n        'ɵɵinjectPipeChangeDetectorRef': ɵɵinjectPipeChangeDetectorRef,\r\n        'ɵɵtemplateRefExtractor': ɵɵtemplateRefExtractor,\r\n        'ɵɵNgOnChangesFeature': ɵɵNgOnChangesFeature,\r\n        'ɵɵProvidersFeature': ɵɵProvidersFeature,\r\n        'ɵɵInheritDefinitionFeature': ɵɵInheritDefinitionFeature,\r\n        'ɵɵcontainer': ɵɵcontainer,\r\n        'ɵɵnextContext': ɵɵnextContext,\r\n        'ɵɵcontainerRefreshStart': ɵɵcontainerRefreshStart,\r\n        'ɵɵcontainerRefreshEnd': ɵɵcontainerRefreshEnd,\r\n        'ɵɵnamespaceHTML': ɵɵnamespaceHTML,\r\n        'ɵɵnamespaceMathML': ɵɵnamespaceMathML,\r\n        'ɵɵnamespaceSVG': ɵɵnamespaceSVG,\r\n        'ɵɵenableBindings': ɵɵenableBindings,\r\n        'ɵɵdisableBindings': ɵɵdisableBindings,\r\n        'ɵɵallocHostVars': ɵɵallocHostVars,\r\n        'ɵɵelementStart': ɵɵelementStart,\r\n        'ɵɵelementEnd': ɵɵelementEnd,\r\n        'ɵɵelement': ɵɵelement,\r\n        'ɵɵelementContainerStart': ɵɵelementContainerStart,\r\n        'ɵɵelementContainerEnd': ɵɵelementContainerEnd,\r\n        'ɵɵelementContainer': ɵɵelementContainer,\r\n        'ɵɵpureFunction0': ɵɵpureFunction0,\r\n        'ɵɵpureFunction1': ɵɵpureFunction1,\r\n        'ɵɵpureFunction2': ɵɵpureFunction2,\r\n        'ɵɵpureFunction3': ɵɵpureFunction3,\r\n        'ɵɵpureFunction4': ɵɵpureFunction4,\r\n        'ɵɵpureFunction5': ɵɵpureFunction5,\r\n        'ɵɵpureFunction6': ɵɵpureFunction6,\r\n        'ɵɵpureFunction7': ɵɵpureFunction7,\r\n        'ɵɵpureFunction8': ɵɵpureFunction8,\r\n        'ɵɵpureFunctionV': ɵɵpureFunctionV,\r\n        'ɵɵgetCurrentView': ɵɵgetCurrentView,\r\n        'ɵɵrestoreView': ɵɵrestoreView,\r\n        'ɵɵlistener': ɵɵlistener,\r\n        'ɵɵload': ɵɵload,\r\n        'ɵɵprojection': ɵɵprojection,\r\n        'ɵɵupdateSyntheticHostBinding': ɵɵupdateSyntheticHostBinding,\r\n        'ɵɵcomponentHostSyntheticListener': ɵɵcomponentHostSyntheticListener,\r\n        'ɵɵpipeBind1': ɵɵpipeBind1,\r\n        'ɵɵpipeBind2': ɵɵpipeBind2,\r\n        'ɵɵpipeBind3': ɵɵpipeBind3,\r\n        'ɵɵpipeBind4': ɵɵpipeBind4,\r\n        'ɵɵpipeBindV': ɵɵpipeBindV,\r\n        'ɵɵprojectionDef': ɵɵprojectionDef,\r\n        'ɵɵhostProperty': ɵɵhostProperty,\r\n        'ɵɵproperty': ɵɵproperty,\r\n        'ɵɵpropertyInterpolate': ɵɵpropertyInterpolate,\r\n        'ɵɵpropertyInterpolate1': ɵɵpropertyInterpolate1,\r\n        'ɵɵpropertyInterpolate2': ɵɵpropertyInterpolate2,\r\n        'ɵɵpropertyInterpolate3': ɵɵpropertyInterpolate3,\r\n        'ɵɵpropertyInterpolate4': ɵɵpropertyInterpolate4,\r\n        'ɵɵpropertyInterpolate5': ɵɵpropertyInterpolate5,\r\n        'ɵɵpropertyInterpolate6': ɵɵpropertyInterpolate6,\r\n        'ɵɵpropertyInterpolate7': ɵɵpropertyInterpolate7,\r\n        'ɵɵpropertyInterpolate8': ɵɵpropertyInterpolate8,\r\n        'ɵɵpropertyInterpolateV': ɵɵpropertyInterpolateV,\r\n        'ɵɵpipe': ɵɵpipe,\r\n        'ɵɵqueryRefresh': ɵɵqueryRefresh,\r\n        'ɵɵviewQuery': ɵɵviewQuery,\r\n        'ɵɵstaticViewQuery': ɵɵstaticViewQuery,\r\n        'ɵɵstaticContentQuery': ɵɵstaticContentQuery,\r\n        'ɵɵloadViewQuery': ɵɵloadViewQuery,\r\n        'ɵɵcontentQuery': ɵɵcontentQuery,\r\n        'ɵɵloadContentQuery': ɵɵloadContentQuery,\r\n        'ɵɵreference': ɵɵreference,\r\n        'ɵɵelementHostAttrs': ɵɵelementHostAttrs,\r\n        'ɵɵclassMap': ɵɵclassMap,\r\n        'ɵɵclassMapInterpolate1': ɵɵclassMapInterpolate1,\r\n        'ɵɵclassMapInterpolate2': ɵɵclassMapInterpolate2,\r\n        'ɵɵclassMapInterpolate3': ɵɵclassMapInterpolate3,\r\n        'ɵɵclassMapInterpolate4': ɵɵclassMapInterpolate4,\r\n        'ɵɵclassMapInterpolate5': ɵɵclassMapInterpolate5,\r\n        'ɵɵclassMapInterpolate6': ɵɵclassMapInterpolate6,\r\n        'ɵɵclassMapInterpolate7': ɵɵclassMapInterpolate7,\r\n        'ɵɵclassMapInterpolate8': ɵɵclassMapInterpolate8,\r\n        'ɵɵclassMapInterpolateV': ɵɵclassMapInterpolateV,\r\n        'ɵɵstyling': ɵɵstyling,\r\n        'ɵɵstyleMap': ɵɵstyleMap,\r\n        'ɵɵstyleProp': ɵɵstyleProp,\r\n        'ɵɵstylePropInterpolate1': ɵɵstylePropInterpolate1,\r\n        'ɵɵstylePropInterpolate2': ɵɵstylePropInterpolate2,\r\n        'ɵɵstylePropInterpolate3': ɵɵstylePropInterpolate3,\r\n        'ɵɵstylePropInterpolate4': ɵɵstylePropInterpolate4,\r\n        'ɵɵstylePropInterpolate5': ɵɵstylePropInterpolate5,\r\n        'ɵɵstylePropInterpolate6': ɵɵstylePropInterpolate6,\r\n        'ɵɵstylePropInterpolate7': ɵɵstylePropInterpolate7,\r\n        'ɵɵstylePropInterpolate8': ɵɵstylePropInterpolate8,\r\n        'ɵɵstylePropInterpolateV': ɵɵstylePropInterpolateV,\r\n        'ɵɵstyleSanitizer': ɵɵstyleSanitizer,\r\n        'ɵɵstylingApply': ɵɵstylingApply,\r\n        'ɵɵclassProp': ɵɵclassProp,\r\n        'ɵɵselect': ɵɵselect,\r\n        'ɵɵtemplate': ɵɵtemplate,\r\n        'ɵɵtext': ɵɵtext,\r\n        'ɵɵtextBinding': ɵɵtextBinding,\r\n        'ɵɵtextInterpolate': ɵɵtextInterpolate,\r\n        'ɵɵtextInterpolate1': ɵɵtextInterpolate1,\r\n        'ɵɵtextInterpolate2': ɵɵtextInterpolate2,\r\n        'ɵɵtextInterpolate3': ɵɵtextInterpolate3,\r\n        'ɵɵtextInterpolate4': ɵɵtextInterpolate4,\r\n        'ɵɵtextInterpolate5': ɵɵtextInterpolate5,\r\n        'ɵɵtextInterpolate6': ɵɵtextInterpolate6,\r\n        'ɵɵtextInterpolate7': ɵɵtextInterpolate7,\r\n        'ɵɵtextInterpolate8': ɵɵtextInterpolate8,\r\n        'ɵɵtextInterpolateV': ɵɵtextInterpolateV,\r\n        'ɵɵembeddedViewStart': ɵɵembeddedViewStart,\r\n        'ɵɵembeddedViewEnd': ɵɵembeddedViewEnd,\r\n        'ɵɵi18n': ɵɵi18n,\r\n        'ɵɵi18nAttributes': ɵɵi18nAttributes,\r\n        'ɵɵi18nExp': ɵɵi18nExp,\r\n        'ɵɵi18nStart': ɵɵi18nStart,\r\n        'ɵɵi18nEnd': ɵɵi18nEnd,\r\n        'ɵɵi18nApply': ɵɵi18nApply,\r\n        'ɵɵi18nPostprocess': ɵɵi18nPostprocess,\r\n        'ɵɵi18nLocalize': ɵɵi18nLocalize,\r\n        'ɵɵresolveWindow': ɵɵresolveWindow,\r\n        'ɵɵresolveDocument': ɵɵresolveDocument,\r\n        'ɵɵresolveBody': ɵɵresolveBody,\r\n        'ɵɵsetComponentScope': ɵɵsetComponentScope,\r\n        'ɵɵsetNgModuleScope': ɵɵsetNgModuleScope,\r\n        'ɵɵsanitizeHtml': ɵɵsanitizeHtml,\r\n        'ɵɵsanitizeStyle': ɵɵsanitizeStyle,\r\n        'ɵɵdefaultStyleSanitizer': ɵɵdefaultStyleSanitizer,\r\n        'ɵɵsanitizeResourceUrl': ɵɵsanitizeResourceUrl,\r\n        'ɵɵsanitizeScript': ɵɵsanitizeScript,\r\n        'ɵɵsanitizeUrl': ɵɵsanitizeUrl,\r\n        'ɵɵsanitizeUrlOrResourceUrl': ɵɵsanitizeUrlOrResourceUrl,\r\n    }); };\r\n    /**\r\n     * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\r\n     *\r\n     * This should be kept up to date with the public exports of @angular/core.\r\n     */\r\n    var angularCoreEnv = (ɵ0$e)();\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var EMPTY_ARRAY$4 = [];\r\n    var moduleQueue = [];\r\n    /**\r\n     * Enqueues moduleDef to be checked later to see if scope can be set on its\r\n     * component declarations.\r\n     */\r\n    function enqueueModuleForDelayedScoping(moduleType, ngModule) {\r\n        moduleQueue.push({ moduleType: moduleType, ngModule: ngModule });\r\n    }\r\n    var flushingModuleQueue = false;\r\n    /**\r\n     * Loops over queued module definitions, if a given module definition has all of its\r\n     * declarations resolved, it dequeues that module definition and sets the scope on\r\n     * its declarations.\r\n     */\r\n    function flushModuleScopingQueueAsMuchAsPossible() {\r\n        if (!flushingModuleQueue) {\r\n            flushingModuleQueue = true;\r\n            try {\r\n                for (var i = moduleQueue.length - 1; i >= 0; i--) {\r\n                    var _a = moduleQueue[i], moduleType = _a.moduleType, ngModule = _a.ngModule;\r\n                    if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {\r\n                        // dequeue\r\n                        moduleQueue.splice(i, 1);\r\n                        setScopeOnDeclaredComponents(moduleType, ngModule);\r\n                    }\r\n                }\r\n            }\r\n            finally {\r\n                flushingModuleQueue = false;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns truthy if a declaration has resolved. If the declaration happens to be\r\n     * an array of declarations, it will recurse to check each declaration in that array\r\n     * (which may also be arrays).\r\n     */\r\n    function isResolvedDeclaration(declaration) {\r\n        if (Array.isArray(declaration)) {\r\n            return declaration.every(isResolvedDeclaration);\r\n        }\r\n        return !!resolveForwardRef(declaration);\r\n    }\r\n    /**\r\n     * Compiles a module in JIT mode.\r\n     *\r\n     * This function automatically gets called when a class has a `@NgModule` decorator.\r\n     */\r\n    function compileNgModule(moduleType, ngModule) {\r\n        if (ngModule === void 0) { ngModule = {}; }\r\n        compileNgModuleDefs(moduleType, ngModule);\r\n        // Because we don't know if all declarations have resolved yet at the moment the\r\n        // NgModule decorator is executing, we're enqueueing the setting of module scope\r\n        // on its declarations to be run at a later time when all declarations for the module,\r\n        // including forward refs, have resolved.\r\n        enqueueModuleForDelayedScoping(moduleType, ngModule);\r\n    }\r\n    /**\r\n     * Compiles and adds the `ngModuleDef` and `ngInjectorDef` properties to the module class.\r\n     *\r\n     * It's possible to compile a module via this API which will allow duplicate declarations in its\r\n     * root.\r\n     */\r\n    function compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot) {\r\n        if (allowDuplicateDeclarationsInRoot === void 0) { allowDuplicateDeclarationsInRoot = false; }\r\n        ngDevMode && assertDefined(moduleType, 'Required value moduleType');\r\n        ngDevMode && assertDefined(ngModule, 'Required value ngModule');\r\n        var declarations = flatten(ngModule.declarations || EMPTY_ARRAY$4);\r\n        var ngModuleDef = null;\r\n        Object.defineProperty(moduleType, NG_MODULE_DEF, {\r\n            configurable: true,\r\n            get: function () {\r\n                if (ngModuleDef === null) {\r\n                    if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {\r\n                        // We need to assert this immediately, because allowing it to continue will cause it to\r\n                        // go into an infinite loop before we've reached the point where we throw all the errors.\r\n                        throw new Error(\"'\" + stringifyForError(moduleType) + \"' module can't import itself\");\r\n                    }\r\n                    ngModuleDef = getCompilerFacade().compileNgModule(angularCoreEnv, \"ng:///\" + moduleType.name + \"/ngModuleDef.js\", {\r\n                        type: moduleType,\r\n                        bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY$4).map(resolveForwardRef),\r\n                        declarations: declarations.map(resolveForwardRef),\r\n                        imports: flatten(ngModule.imports || EMPTY_ARRAY$4)\r\n                            .map(resolveForwardRef)\r\n                            .map(expandModuleWithProviders),\r\n                        exports: flatten(ngModule.exports || EMPTY_ARRAY$4)\r\n                            .map(resolveForwardRef)\r\n                            .map(expandModuleWithProviders),\r\n                        emitInline: true,\r\n                        schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,\r\n                        id: ngModule.id || null,\r\n                    });\r\n                }\r\n                return ngModuleDef;\r\n            }\r\n        });\r\n        var ngInjectorDef = null;\r\n        Object.defineProperty(moduleType, NG_INJECTOR_DEF, {\r\n            get: function () {\r\n                if (ngInjectorDef === null) {\r\n                    ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);\r\n                    var meta = {\r\n                        name: moduleType.name,\r\n                        type: moduleType,\r\n                        deps: reflectDependencies(moduleType),\r\n                        providers: ngModule.providers || EMPTY_ARRAY$4,\r\n                        imports: [\r\n                            (ngModule.imports || EMPTY_ARRAY$4).map(resolveForwardRef),\r\n                            (ngModule.exports || EMPTY_ARRAY$4).map(resolveForwardRef),\r\n                        ],\r\n                    };\r\n                    ngInjectorDef = getCompilerFacade().compileInjector(angularCoreEnv, \"ng:///\" + moduleType.name + \"/ngInjectorDef.js\", meta);\r\n                }\r\n                return ngInjectorDef;\r\n            },\r\n            // Make the property configurable in dev mode to allow overriding in tests\r\n            configurable: !!ngDevMode,\r\n        });\r\n    }\r\n    function verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {\r\n        if (verifiedNgModule.get(moduleType))\r\n            return;\r\n        verifiedNgModule.set(moduleType, true);\r\n        moduleType = resolveForwardRef(moduleType);\r\n        var ngModuleDef;\r\n        if (importingModule) {\r\n            ngModuleDef = getNgModuleDef(moduleType);\r\n            if (!ngModuleDef) {\r\n                throw new Error(\"Unexpected value '\" + moduleType.name + \"' imported by the module '\" + importingModule.name + \"'. Please add an @NgModule annotation.\");\r\n            }\r\n        }\r\n        else {\r\n            ngModuleDef = getNgModuleDef(moduleType, true);\r\n        }\r\n        var errors = [];\r\n        var declarations = maybeUnwrapFn(ngModuleDef.declarations);\r\n        var imports = maybeUnwrapFn(ngModuleDef.imports);\r\n        flatten(imports).map(unwrapModuleWithProvidersImports).forEach(function (mod) {\r\n            verifySemanticsOfNgModuleImport(mod, moduleType);\r\n            verifySemanticsOfNgModuleDef(mod, false, moduleType);\r\n        });\r\n        var exports = maybeUnwrapFn(ngModuleDef.exports);\r\n        declarations.forEach(verifyDeclarationsHaveDefinitions);\r\n        var combinedDeclarations = __spread(declarations.map(resolveForwardRef), flatten(imports.map(computeCombinedExports)).map(resolveForwardRef));\r\n        exports.forEach(verifyExportsAreDeclaredOrReExported);\r\n        declarations.forEach(function (decl) { return verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot); });\r\n        declarations.forEach(verifyComponentEntryComponentsIsPartOfNgModule);\r\n        var ngModule = getAnnotation(moduleType, 'NgModule');\r\n        if (ngModule) {\r\n            ngModule.imports &&\r\n                flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach(function (mod) {\r\n                    verifySemanticsOfNgModuleImport(mod, moduleType);\r\n                    verifySemanticsOfNgModuleDef(mod, false, moduleType);\r\n                });\r\n            ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);\r\n            ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);\r\n            ngModule.entryComponents &&\r\n                deepForEach(ngModule.entryComponents, verifyComponentIsPartOfNgModule);\r\n        }\r\n        // Throw Error if any errors were detected.\r\n        if (errors.length) {\r\n            throw new Error(errors.join('\\n'));\r\n        }\r\n        ////////////////////////////////////////////////////////////////////////////////////////////////\r\n        function verifyDeclarationsHaveDefinitions(type) {\r\n            type = resolveForwardRef(type);\r\n            var def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);\r\n            if (!def) {\r\n                errors.push(\"Unexpected value '\" + stringifyForError(type) + \"' declared by the module '\" + stringifyForError(moduleType) + \"'. Please add a @Pipe/@Directive/@Component annotation.\");\r\n            }\r\n        }\r\n        function verifyExportsAreDeclaredOrReExported(type) {\r\n            type = resolveForwardRef(type);\r\n            var kind = getComponentDef(type) && 'component' || getDirectiveDef(type) && 'directive' ||\r\n                getPipeDef(type) && 'pipe';\r\n            if (kind) {\r\n                // only checked if we are declared as Component, Directive, or Pipe\r\n                // Modules don't need to be declared or imported.\r\n                if (combinedDeclarations.lastIndexOf(type) === -1) {\r\n                    // We are exporting something which we don't explicitly declare or import.\r\n                    errors.push(\"Can't export \" + kind + \" \" + stringifyForError(type) + \" from \" + stringifyForError(moduleType) + \" as it was neither declared nor imported!\");\r\n                }\r\n            }\r\n        }\r\n        function verifyDeclarationIsUnique(type, suppressErrors) {\r\n            type = resolveForwardRef(type);\r\n            var existingModule = ownerNgModule.get(type);\r\n            if (existingModule && existingModule !== moduleType) {\r\n                if (!suppressErrors) {\r\n                    var modules = [existingModule, moduleType].map(stringifyForError).sort();\r\n                    errors.push(\"Type \" + stringifyForError(type) + \" is part of the declarations of 2 modules: \" + modules[0] + \" and \" + modules[1] + \"! \" +\r\n                        (\"Please consider moving \" + stringifyForError(type) + \" to a higher module that imports \" + modules[0] + \" and \" + modules[1] + \". \") +\r\n                        (\"You can also create a new NgModule that exports and includes \" + stringifyForError(type) + \" then import that NgModule in \" + modules[0] + \" and \" + modules[1] + \".\"));\r\n                }\r\n            }\r\n            else {\r\n                // Mark type as having owner.\r\n                ownerNgModule.set(type, moduleType);\r\n            }\r\n        }\r\n        function verifyComponentIsPartOfNgModule(type) {\r\n            type = resolveForwardRef(type);\r\n            var existingModule = ownerNgModule.get(type);\r\n            if (!existingModule) {\r\n                errors.push(\"Component \" + stringifyForError(type) + \" is not part of any NgModule or the module has not been imported into your module.\");\r\n            }\r\n        }\r\n        function verifyCorrectBootstrapType(type) {\r\n            type = resolveForwardRef(type);\r\n            if (!getComponentDef(type)) {\r\n                errors.push(stringifyForError(type) + \" cannot be used as an entry component.\");\r\n            }\r\n        }\r\n        function verifyComponentEntryComponentsIsPartOfNgModule(type) {\r\n            type = resolveForwardRef(type);\r\n            if (getComponentDef(type)) {\r\n                // We know we are component\r\n                var component = getAnnotation(type, 'Component');\r\n                if (component && component.entryComponents) {\r\n                    deepForEach(component.entryComponents, verifyComponentIsPartOfNgModule);\r\n                }\r\n            }\r\n        }\r\n        function verifySemanticsOfNgModuleImport(type, importingModule) {\r\n            type = resolveForwardRef(type);\r\n            if (getComponentDef(type) || getDirectiveDef(type)) {\r\n                throw new Error(\"Unexpected directive '\" + type.name + \"' imported by the module '\" + importingModule.name + \"'. Please add an @NgModule annotation.\");\r\n            }\r\n            if (getPipeDef(type)) {\r\n                throw new Error(\"Unexpected pipe '\" + type.name + \"' imported by the module '\" + importingModule.name + \"'. Please add an @NgModule annotation.\");\r\n            }\r\n        }\r\n    }\r\n    function unwrapModuleWithProvidersImports(typeOrWithProviders) {\r\n        typeOrWithProviders = resolveForwardRef(typeOrWithProviders);\r\n        return typeOrWithProviders.ngModule || typeOrWithProviders;\r\n    }\r\n    function getAnnotation(type, name) {\r\n        var annotation = null;\r\n        collect(type.__annotations__);\r\n        collect(type.decorators);\r\n        return annotation;\r\n        function collect(annotations) {\r\n            if (annotations) {\r\n                annotations.forEach(readAnnotation);\r\n            }\r\n        }\r\n        function readAnnotation(decorator) {\r\n            if (!annotation) {\r\n                var proto = Object.getPrototypeOf(decorator);\r\n                if (proto.ngMetadataName == name) {\r\n                    annotation = decorator;\r\n                }\r\n                else if (decorator.type) {\r\n                    var proto_1 = Object.getPrototypeOf(decorator.type);\r\n                    if (proto_1.ngMetadataName == name) {\r\n                        annotation = decorator.args[0];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Keep track of compiled components. This is needed because in tests we often want to compile the\r\n     * same component with more than one NgModule. This would cause an error unless we reset which\r\n     * NgModule the component belongs to. We keep the list of compiled components here so that the\r\n     * TestBed can reset it later.\r\n     */\r\n    var ownerNgModule = new Map();\r\n    var verifiedNgModule = new Map();\r\n    function resetCompiledComponents() {\r\n        ownerNgModule = new Map();\r\n        verifiedNgModule = new Map();\r\n        moduleQueue.length = 0;\r\n    }\r\n    /**\r\n     * Computes the combined declarations of explicit declarations, as well as declarations inherited by\r\n     * traversing the exports of imported modules.\r\n     * @param type\r\n     */\r\n    function computeCombinedExports(type) {\r\n        type = resolveForwardRef(type);\r\n        var ngModuleDef = getNgModuleDef(type, true);\r\n        return __spread(flatten(maybeUnwrapFn(ngModuleDef.exports).map(function (type) {\r\n            var ngModuleDef = getNgModuleDef(type);\r\n            if (ngModuleDef) {\r\n                verifySemanticsOfNgModuleDef(type, false);\r\n                return computeCombinedExports(type);\r\n            }\r\n            else {\r\n                return type;\r\n            }\r\n        })));\r\n    }\r\n    /**\r\n     * Some declared components may be compiled asynchronously, and thus may not have their\r\n     * ngComponentDef set yet. If this is the case, then a reference to the module is written into\r\n     * the `ngSelectorScope` property of the declared type.\r\n     */\r\n    function setScopeOnDeclaredComponents(moduleType, ngModule) {\r\n        var declarations = flatten(ngModule.declarations || EMPTY_ARRAY$4);\r\n        var transitiveScopes = transitiveScopesFor(moduleType);\r\n        declarations.forEach(function (declaration) {\r\n            if (declaration.hasOwnProperty(NG_COMPONENT_DEF)) {\r\n                // An `ngComponentDef` field exists - go ahead and patch the component directly.\r\n                var component = declaration;\r\n                var componentDef = getComponentDef(component);\r\n                patchComponentDefWithScope(componentDef, transitiveScopes);\r\n            }\r\n            else if (!declaration.hasOwnProperty(NG_DIRECTIVE_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {\r\n                // Set `ngSelectorScope` for future reference when the component compilation finishes.\r\n                declaration.ngSelectorScope = moduleType;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Patch the definition of a component with directives and pipes from the compilation scope of\r\n     * a given module.\r\n     */\r\n    function patchComponentDefWithScope(componentDef, transitiveScopes) {\r\n        componentDef.directiveDefs = function () {\r\n            return Array.from(transitiveScopes.compilation.directives)\r\n                .map(function (dir) { return dir.hasOwnProperty(NG_COMPONENT_DEF) ? getComponentDef(dir) :\r\n                getDirectiveDef(dir); })\r\n                .filter(function (def) { return !!def; });\r\n        };\r\n        componentDef.pipeDefs = function () {\r\n            return Array.from(transitiveScopes.compilation.pipes).map(function (pipe) { return getPipeDef(pipe); });\r\n        };\r\n        componentDef.schemas = transitiveScopes.schemas;\r\n        // Since we avoid Components/Directives/Pipes recompiling in case there are no overrides, we\r\n        // may face a problem where previously compiled defs available to a given Component/Directive\r\n        // are cached in TView and may become stale (in case any of these defs gets recompiled). In\r\n        // order to avoid this problem, we force fresh TView to be created.\r\n        componentDef.tView = null;\r\n    }\r\n    /**\r\n     * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.\r\n     *\r\n     * This operation is memoized and the result is cached on the module's definition. It can be called\r\n     * on modules with components that have not fully compiled yet, but the result should not be used\r\n     * until they have.\r\n     */\r\n    function transitiveScopesFor(moduleType, processNgModuleFn) {\r\n        if (!isNgModule(moduleType)) {\r\n            throw new Error(moduleType.name + \" does not have an ngModuleDef\");\r\n        }\r\n        var def = getNgModuleDef(moduleType);\r\n        if (def.transitiveCompileScopes !== null) {\r\n            return def.transitiveCompileScopes;\r\n        }\r\n        var scopes = {\r\n            schemas: def.schemas || null,\r\n            compilation: {\r\n                directives: new Set(),\r\n                pipes: new Set(),\r\n            },\r\n            exported: {\r\n                directives: new Set(),\r\n                pipes: new Set(),\r\n            },\r\n        };\r\n        maybeUnwrapFn(def.declarations).forEach(function (declared) {\r\n            var declaredWithDefs = declared;\r\n            if (getPipeDef(declaredWithDefs)) {\r\n                scopes.compilation.pipes.add(declared);\r\n            }\r\n            else {\r\n                // Either declared has an ngComponentDef or ngDirectiveDef, or it's a component which hasn't\r\n                // had its template compiled yet. In either case, it gets added to the compilation's\r\n                // directives.\r\n                scopes.compilation.directives.add(declared);\r\n            }\r\n        });\r\n        maybeUnwrapFn(def.imports).forEach(function (imported) {\r\n            var importedType = imported;\r\n            if (!isNgModule(importedType)) {\r\n                throw new Error(\"Importing \" + importedType.name + \" which does not have an ngModuleDef\");\r\n            }\r\n            if (processNgModuleFn) {\r\n                processNgModuleFn(importedType);\r\n            }\r\n            // When this module imports another, the imported module's exported directives and pipes are\r\n            // added to the compilation scope of this module.\r\n            var importedScope = transitiveScopesFor(importedType, processNgModuleFn);\r\n            importedScope.exported.directives.forEach(function (entry) { return scopes.compilation.directives.add(entry); });\r\n            importedScope.exported.pipes.forEach(function (entry) { return scopes.compilation.pipes.add(entry); });\r\n        });\r\n        maybeUnwrapFn(def.exports).forEach(function (exported) {\r\n            var exportedType = exported;\r\n            // Either the type is a module, a pipe, or a component/directive (which may not have an\r\n            // ngComponentDef as it might be compiled asynchronously).\r\n            if (isNgModule(exportedType)) {\r\n                // When this module exports another, the exported module's exported directives and pipes are\r\n                // added to both the compilation and exported scopes of this module.\r\n                var exportedScope = transitiveScopesFor(exportedType, processNgModuleFn);\r\n                exportedScope.exported.directives.forEach(function (entry) {\r\n                    scopes.compilation.directives.add(entry);\r\n                    scopes.exported.directives.add(entry);\r\n                });\r\n                exportedScope.exported.pipes.forEach(function (entry) {\r\n                    scopes.compilation.pipes.add(entry);\r\n                    scopes.exported.pipes.add(entry);\r\n                });\r\n            }\r\n            else if (getPipeDef(exportedType)) {\r\n                scopes.exported.pipes.add(exportedType);\r\n            }\r\n            else {\r\n                scopes.exported.directives.add(exportedType);\r\n            }\r\n        });\r\n        def.transitiveCompileScopes = scopes;\r\n        return scopes;\r\n    }\r\n    function expandModuleWithProviders(value) {\r\n        if (isModuleWithProviders(value)) {\r\n            return value.ngModule;\r\n        }\r\n        return value;\r\n    }\r\n    function isModuleWithProviders(value) {\r\n        return value.ngModule !== undefined;\r\n    }\r\n    function isNgModule(value) {\r\n        return !!getNgModuleDef(value);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Compile an Angular component according to its decorator metadata, and patch the resulting\r\n     * ngComponentDef onto the component type.\r\n     *\r\n     * Compilation may be asynchronous (due to the need to resolve URLs for the component template or\r\n     * other resources, for example). In the event that compilation is not immediate, `compileComponent`\r\n     * will enqueue resource resolution into a global queue and will fail to return the `ngComponentDef`\r\n     * until the global queue has been resolved with a call to `resolveComponentResources`.\r\n     */\r\n    function compileComponent(type, metadata) {\r\n        var ngComponentDef = null;\r\n        // Metadata may have resources which need to be resolved.\r\n        maybeQueueResolutionOfComponentResources(type, metadata);\r\n        Object.defineProperty(type, NG_COMPONENT_DEF, {\r\n            get: function () {\r\n                var compiler = getCompilerFacade();\r\n                if (ngComponentDef === null) {\r\n                    if (componentNeedsResolution(metadata)) {\r\n                        var error = [\"Component '\" + type.name + \"' is not resolved:\"];\r\n                        if (metadata.templateUrl) {\r\n                            error.push(\" - templateUrl: \" + metadata.templateUrl);\r\n                        }\r\n                        if (metadata.styleUrls && metadata.styleUrls.length) {\r\n                            error.push(\" - styleUrls: \" + JSON.stringify(metadata.styleUrls));\r\n                        }\r\n                        error.push(\"Did you run and wait for 'resolveComponentResources()'?\");\r\n                        throw new Error(error.join('\\n'));\r\n                    }\r\n                    var templateUrl = metadata.templateUrl || \"ng:///\" + type.name + \"/template.html\";\r\n                    var meta = __assign({}, directiveMetadata(type, metadata), { typeSourceSpan: compiler.createParseSourceSpan('Component', type.name, templateUrl), template: metadata.template || '', preserveWhitespaces: metadata.preserveWhitespaces || false, styles: metadata.styles || EMPTY_ARRAY, animations: metadata.animations, directives: [], changeDetection: metadata.changeDetection, pipes: new Map(), encapsulation: metadata.encapsulation || exports.ViewEncapsulation.Emulated, interpolation: metadata.interpolation, viewProviders: metadata.viewProviders || null });\r\n                    if (meta.usesInheritance) {\r\n                        addBaseDefToUndecoratedParents(type);\r\n                    }\r\n                    ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta);\r\n                    // When NgModule decorator executed, we enqueued the module definition such that\r\n                    // it would only dequeue and add itself as module scope to all of its declarations,\r\n                    // but only if  if all of its declarations had resolved. This call runs the check\r\n                    // to see if any modules that are in the queue can be dequeued and add scope to\r\n                    // their declarations.\r\n                    flushModuleScopingQueueAsMuchAsPossible();\r\n                    // If component compilation is async, then the @NgModule annotation which declares the\r\n                    // component may execute and set an ngSelectorScope property on the component type. This\r\n                    // allows the component to patch itself with directiveDefs from the module after it\r\n                    // finishes compiling.\r\n                    if (hasSelectorScope(type)) {\r\n                        var scopes = transitiveScopesFor(type.ngSelectorScope);\r\n                        patchComponentDefWithScope(ngComponentDef, scopes);\r\n                    }\r\n                }\r\n                return ngComponentDef;\r\n            },\r\n            // Make the property configurable in dev mode to allow overriding in tests\r\n            configurable: !!ngDevMode,\r\n        });\r\n        // Add ngInjectableDef so components are reachable through the module injector by default\r\n        // This is mostly to support injecting components in tests. In real application code,\r\n        // components should be retrieved through the node injector, so this isn't a problem.\r\n        compileInjectable(type);\r\n    }\r\n    function hasSelectorScope(component) {\r\n        return component.ngSelectorScope !== undefined;\r\n    }\r\n    /**\r\n     * Compile an Angular directive according to its decorator metadata, and patch the resulting\r\n     * ngDirectiveDef onto the component type.\r\n     *\r\n     * In the event that compilation is not immediate, `compileDirective` will return a `Promise` which\r\n     * will resolve when compilation completes and the directive becomes usable.\r\n     */\r\n    function compileDirective(type, directive) {\r\n        var ngDirectiveDef = null;\r\n        Object.defineProperty(type, NG_DIRECTIVE_DEF, {\r\n            get: function () {\r\n                if (ngDirectiveDef === null) {\r\n                    var name_1 = type && type.name;\r\n                    var sourceMapUrl = \"ng:///\" + name_1 + \"/ngDirectiveDef.js\";\r\n                    var compiler = getCompilerFacade();\r\n                    var facade = directiveMetadata(type, directive);\r\n                    facade.typeSourceSpan = compiler.createParseSourceSpan('Directive', name_1, sourceMapUrl);\r\n                    if (facade.usesInheritance) {\r\n                        addBaseDefToUndecoratedParents(type);\r\n                    }\r\n                    ngDirectiveDef = compiler.compileDirective(angularCoreEnv, sourceMapUrl, facade);\r\n                }\r\n                return ngDirectiveDef;\r\n            },\r\n            // Make the property configurable in dev mode to allow overriding in tests\r\n            configurable: !!ngDevMode,\r\n        });\r\n        // Add ngInjectableDef so directives are reachable through the module injector by default\r\n        // This is mostly to support injecting directives in tests. In real application code,\r\n        // directives should be retrieved through the node injector, so this isn't a problem.\r\n        compileInjectable(type);\r\n    }\r\n    function extendsDirectlyFromObject(type) {\r\n        return Object.getPrototypeOf(type.prototype) === Object.prototype;\r\n    }\r\n    /**\r\n     * Extract the `R3DirectiveMetadata` for a particular directive (either a `Directive` or a\r\n     * `Component`).\r\n     */\r\n    function directiveMetadata(type, metadata) {\r\n        // Reflect inputs and outputs.\r\n        var propMetadata = getReflect().ownPropMetadata(type);\r\n        return {\r\n            name: type.name,\r\n            type: type,\r\n            typeArgumentCount: 0,\r\n            selector: metadata.selector,\r\n            deps: reflectDependencies(type),\r\n            host: metadata.host || EMPTY_OBJ,\r\n            propMetadata: propMetadata,\r\n            inputs: metadata.inputs || EMPTY_ARRAY,\r\n            outputs: metadata.outputs || EMPTY_ARRAY,\r\n            queries: extractQueriesMetadata(type, propMetadata, isContentQuery),\r\n            lifecycle: { usesOnChanges: type.prototype.hasOwnProperty('ngOnChanges') },\r\n            typeSourceSpan: null,\r\n            usesInheritance: !extendsDirectlyFromObject(type),\r\n            exportAs: extractExportAs(metadata.exportAs),\r\n            providers: metadata.providers || null,\r\n            viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery),\r\n        };\r\n    }\r\n    /**\r\n     * Adds an `ngBaseDef` to all parent classes of a type that don't have an Angular decorator.\r\n     */\r\n    function addBaseDefToUndecoratedParents(type) {\r\n        var objPrototype = Object.prototype;\r\n        var parent = Object.getPrototypeOf(type);\r\n        // Go up the prototype until we hit `Object`.\r\n        while (parent && parent !== objPrototype) {\r\n            // Since inheritance works if the class was annotated already, we only need to add\r\n            // the base def if there are no annotations and the base def hasn't been created already.\r\n            if (!getDirectiveDef(parent) && !getComponentDef(parent) && !getBaseDef(parent)) {\r\n                var facade = extractBaseDefMetadata(parent);\r\n                facade && compileBase(parent, facade);\r\n            }\r\n            parent = Object.getPrototypeOf(parent);\r\n        }\r\n    }\r\n    /** Compiles the base metadata into a base definition. */\r\n    function compileBase(type, facade) {\r\n        var ngBaseDef = null;\r\n        Object.defineProperty(type, NG_BASE_DEF, {\r\n            get: function () {\r\n                if (ngBaseDef === null) {\r\n                    var name_2 = type && type.name;\r\n                    var sourceMapUrl = \"ng://\" + name_2 + \"/ngBaseDef.js\";\r\n                    var compiler = getCompilerFacade();\r\n                    ngBaseDef = compiler.compileBase(angularCoreEnv, sourceMapUrl, facade);\r\n                }\r\n                return ngBaseDef;\r\n            },\r\n            // Make the property configurable in dev mode to allow overriding in tests\r\n            configurable: !!ngDevMode,\r\n        });\r\n    }\r\n    /** Extracts the metadata necessary to construct an `ngBaseDef` from a class. */\r\n    function extractBaseDefMetadata(type) {\r\n        var propMetadata = getReflect().ownPropMetadata(type);\r\n        var viewQueries = extractQueriesMetadata(type, propMetadata, isViewQuery);\r\n        var queries = extractQueriesMetadata(type, propMetadata, isContentQuery);\r\n        var inputs;\r\n        var outputs;\r\n        // We only need to know whether there are any HostListener or HostBinding\r\n        // decorators present, the parsing logic is in the compiler already.\r\n        var hasHostDecorators = false;\r\n        var _loop_1 = function (field) {\r\n            propMetadata[field].forEach(function (ann) {\r\n                var metadataName = ann.ngMetadataName;\r\n                if (metadataName === 'Input') {\r\n                    inputs = inputs || {};\r\n                    inputs[field] = ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;\r\n                }\r\n                else if (metadataName === 'Output') {\r\n                    outputs = outputs || {};\r\n                    outputs[field] = ann.bindingPropertyName || field;\r\n                }\r\n                else if (metadataName === 'HostBinding' || metadataName === 'HostListener') {\r\n                    hasHostDecorators = true;\r\n                }\r\n            });\r\n        };\r\n        for (var field in propMetadata) {\r\n            _loop_1(field);\r\n        }\r\n        // Only generate the base def if there's any info inside it.\r\n        if (inputs || outputs || viewQueries.length || queries.length || hasHostDecorators) {\r\n            return { name: type.name, type: type, inputs: inputs, outputs: outputs, viewQueries: viewQueries, queries: queries, propMetadata: propMetadata };\r\n        }\r\n        return null;\r\n    }\r\n    function convertToR3QueryPredicate(selector) {\r\n        return typeof selector === 'string' ? splitByComma(selector) : resolveForwardRef(selector);\r\n    }\r\n    function convertToR3QueryMetadata(propertyName, ann) {\r\n        return {\r\n            propertyName: propertyName,\r\n            predicate: convertToR3QueryPredicate(ann.selector),\r\n            descendants: ann.descendants,\r\n            first: ann.first,\r\n            read: ann.read ? ann.read : null,\r\n            static: !!ann.static\r\n        };\r\n    }\r\n    function extractQueriesMetadata(type, propMetadata, isQueryAnn) {\r\n        var queriesMeta = [];\r\n        var _loop_2 = function (field) {\r\n            if (propMetadata.hasOwnProperty(field)) {\r\n                var annotations_1 = propMetadata[field];\r\n                annotations_1.forEach(function (ann) {\r\n                    if (isQueryAnn(ann)) {\r\n                        if (!ann.selector) {\r\n                            throw new Error(\"Can't construct a query for the property \\\"\" + field + \"\\\" of \" +\r\n                                (\"\\\"\" + stringifyForError(type) + \"\\\" since the query selector wasn't defined.\"));\r\n                        }\r\n                        if (annotations_1.some(isInputAnn)) {\r\n                            throw new Error(\"Cannot combine @Input decorators with query decorators\");\r\n                        }\r\n                        queriesMeta.push(convertToR3QueryMetadata(field, ann));\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        for (var field in propMetadata) {\r\n            _loop_2(field);\r\n        }\r\n        return queriesMeta;\r\n    }\r\n    function extractExportAs(exportAs) {\r\n        if (exportAs === undefined) {\r\n            return null;\r\n        }\r\n        return exportAs.split(',').map(function (part) { return part.trim(); });\r\n    }\r\n    function isContentQuery(value) {\r\n        var name = value.ngMetadataName;\r\n        return name === 'ContentChild' || name === 'ContentChildren';\r\n    }\r\n    function isViewQuery(value) {\r\n        var name = value.ngMetadataName;\r\n        return name === 'ViewChild' || name === 'ViewChildren';\r\n    }\r\n    function isInputAnn(value) {\r\n        return value.ngMetadataName === 'Input';\r\n    }\r\n    function splitByComma(value) {\r\n        return value.split(',').map(function (piece) { return piece.trim(); });\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function compilePipe(type, meta) {\r\n        var ngPipeDef = null;\r\n        Object.defineProperty(type, NG_PIPE_DEF, {\r\n            get: function () {\r\n                if (ngPipeDef === null) {\r\n                    var typeName = type.name;\r\n                    ngPipeDef =\r\n                        getCompilerFacade().compilePipe(angularCoreEnv, \"ng:///\" + typeName + \"/ngPipeDef.js\", {\r\n                            type: type,\r\n                            typeArgumentCount: 0,\r\n                            name: typeName,\r\n                            deps: reflectDependencies(type),\r\n                            pipeName: meta.name,\r\n                            pure: meta.pure !== undefined ? meta.pure : true\r\n                        });\r\n                }\r\n                return ngPipeDef;\r\n            },\r\n            // Make the property configurable in dev mode to allow overriding in tests\r\n            configurable: !!ngDevMode,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var ɵ0$f = function (dir) {\r\n        if (dir === void 0) { dir = {}; }\r\n        return dir;\r\n    }, ɵ1$4 = function (type, meta) { return SWITCH_COMPILE_DIRECTIVE(type, meta); };\r\n    /**\r\n     * Type of the Directive metadata.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var Directive = makeDecorator('Directive', ɵ0$f, undefined, undefined, ɵ1$4);\r\n    var ɵ2$1 = function (c) {\r\n        if (c === void 0) { c = {}; }\r\n        return (__assign({ changeDetection: exports.ChangeDetectionStrategy.Default }, c));\r\n    }, ɵ3$1 = function (type, meta) { return SWITCH_COMPILE_COMPONENT(type, meta); };\r\n    /**\r\n     * Component decorator and metadata.\r\n     *\r\n     * @Annotation\r\n     * @publicApi\r\n     */\r\n    var Component = makeDecorator('Component', ɵ2$1, Directive, undefined, ɵ3$1);\r\n    var ɵ4 = function (p) { return (__assign({ pure: true }, p)); }, ɵ5 = function (type, meta) { return SWITCH_COMPILE_PIPE(type, meta); };\r\n    /**\r\n     * @Annotation\r\n     * @publicApi\r\n     */\r\n    var Pipe = makeDecorator('Pipe', ɵ4, undefined, undefined, ɵ5);\r\n    var ɵ6 = function (bindingPropertyName) { return ({ bindingPropertyName: bindingPropertyName }); };\r\n    /**\r\n     * @Annotation\r\n     * @publicApi\r\n     */\r\n    var Input = makePropDecorator('Input', ɵ6);\r\n    var ɵ7 = function (bindingPropertyName) { return ({ bindingPropertyName: bindingPropertyName }); };\r\n    /**\r\n     * @Annotation\r\n     * @publicApi\r\n     */\r\n    var Output = makePropDecorator('Output', ɵ7);\r\n    var ɵ8 = function (hostPropertyName) { return ({ hostPropertyName: hostPropertyName }); };\r\n    /**\r\n     * @Annotation\r\n     * @publicApi\r\n     */\r\n    var HostBinding = makePropDecorator('HostBinding', ɵ8);\r\n    var ɵ9 = function (eventName, args) { return ({ eventName: eventName, args: args }); };\r\n    /**\r\n     * Decorator that binds a DOM event to a host listener and supplies configuration metadata.\r\n     * Angular invokes the supplied handler method when the host element emits the specified event,\r\n     * and updates the bound element with the result.\r\n     *\r\n     * If the handler method returns false, applies `preventDefault` on the bound element.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * The following example declares a directive\r\n     * that attaches a click listener to a button and counts clicks.\r\n     *\r\n     * ```ts\r\n     * @Directive({selector: 'button[counting]'})\r\n     * class CountClicks {\r\n     *   numberOfClicks = 0;\r\n     *\r\n     *   @HostListener('click', ['$event.target'])\r\n     *   onClick(btn) {\r\n     *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);\r\n     *  }\r\n     * }\r\n     *\r\n     * @Component({\r\n     *   selector: 'app',\r\n     *   template: '<button counting>Increment</button>',\r\n     * })\r\n     * class App {}\r\n     * ```\r\n     *\r\n     * @Annotation\r\n     * @publicApi\r\n     */\r\n    var HostListener = makePropDecorator('HostListener', ɵ9);\r\n    var SWITCH_COMPILE_COMPONENT__POST_R3__ = compileComponent;\r\n    var SWITCH_COMPILE_DIRECTIVE__POST_R3__ = compileDirective;\r\n    var SWITCH_COMPILE_PIPE__POST_R3__ = compilePipe;\r\n    var SWITCH_COMPILE_COMPONENT__PRE_R3__ = noop;\r\n    var SWITCH_COMPILE_DIRECTIVE__PRE_R3__ = noop;\r\n    var SWITCH_COMPILE_PIPE__PRE_R3__ = noop;\r\n    var SWITCH_COMPILE_COMPONENT = SWITCH_COMPILE_COMPONENT__PRE_R3__;\r\n    var SWITCH_COMPILE_DIRECTIVE = SWITCH_COMPILE_DIRECTIVE__PRE_R3__;\r\n    var SWITCH_COMPILE_PIPE = SWITCH_COMPILE_PIPE__PRE_R3__;\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var ɵ0$g = function (ngModule) { return ngModule; }, ɵ1$5 = \r\n    /**\r\n     * Decorator that marks the following class as an NgModule, and supplies\r\n     * configuration metadata for it.\r\n     *\r\n     * * The `declarations` and `entryComponents` options configure the compiler\r\n     * with information about what belongs to the NgModule.\r\n     * * The `providers` options configures the NgModule's injector to provide\r\n     * dependencies the NgModule members.\r\n     * * The `imports` and `exports` options bring in members from other modules, and make\r\n     * this module's members available to others.\r\n     */\r\n    function (type, meta) { return SWITCH_COMPILE_NGMODULE(type, meta); };\r\n    /**\r\n     * @Annotation\r\n     * @publicApi\r\n     */\r\n    var NgModule = makeDecorator('NgModule', ɵ0$g, undefined, undefined, ɵ1$5);\r\n    function preR3NgModuleCompile(moduleType, metadata) {\r\n        var imports = (metadata && metadata.imports) || [];\r\n        if (metadata && metadata.exports) {\r\n            imports = __spread(imports, [metadata.exports]);\r\n        }\r\n        moduleType.ngInjectorDef = ɵɵdefineInjector({\r\n            factory: convertInjectableProviderToFactory(moduleType, { useClass: moduleType }),\r\n            providers: metadata && metadata.providers,\r\n            imports: imports,\r\n        });\r\n    }\r\n    var SWITCH_COMPILE_NGMODULE__POST_R3__ = compileNgModule;\r\n    var SWITCH_COMPILE_NGMODULE__PRE_R3__ = preR3NgModuleCompile;\r\n    var SWITCH_COMPILE_NGMODULE = SWITCH_COMPILE_NGMODULE__PRE_R3__;\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * A function that will be executed when an application is initialized.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var APP_INITIALIZER = new InjectionToken('Application Initializer');\r\n    /**\r\n     * A class that reflects the state of running {@link APP_INITIALIZER}s.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var ApplicationInitStatus = /** @class */ (function () {\r\n        function ApplicationInitStatus(appInits) {\r\n            var _this = this;\r\n            this.appInits = appInits;\r\n            this.initialized = false;\r\n            this.done = false;\r\n            this.donePromise = new Promise(function (res, rej) {\r\n                _this.resolve = res;\r\n                _this.reject = rej;\r\n            });\r\n        }\r\n        /** @internal */\r\n        ApplicationInitStatus.prototype.runInitializers = function () {\r\n            var _this = this;\r\n            if (this.initialized) {\r\n                return;\r\n            }\r\n            var asyncInitPromises = [];\r\n            var complete = function () {\r\n                _this.done = true;\r\n                _this.resolve();\r\n            };\r\n            if (this.appInits) {\r\n                for (var i = 0; i < this.appInits.length; i++) {\r\n                    var initResult = this.appInits[i]();\r\n                    if (isPromise(initResult)) {\r\n                        asyncInitPromises.push(initResult);\r\n                    }\r\n                }\r\n            }\r\n            Promise.all(asyncInitPromises).then(function () { complete(); }).catch(function (e) { _this.reject(e); });\r\n            if (asyncInitPromises.length === 0) {\r\n                complete();\r\n            }\r\n            this.initialized = true;\r\n        };\r\n        ApplicationInitStatus = __decorate([\r\n            Injectable(),\r\n            __param(0, Inject(APP_INITIALIZER)), __param(0, Optional()),\r\n            __metadata(\"design:paramtypes\", [Array])\r\n        ], ApplicationInitStatus);\r\n        return ApplicationInitStatus;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * A DI Token representing a unique string id assigned to the application by Angular and used\r\n     * primarily for prefixing application attributes and CSS styles when\r\n     * {@link ViewEncapsulation#Emulated ViewEncapsulation.Emulated} is being used.\r\n     *\r\n     * If you need to avoid randomly generated value to be used as an application id, you can provide\r\n     * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}\r\n     * using this token.\r\n     * @publicApi\r\n     */\r\n    var APP_ID = new InjectionToken('AppId');\r\n    function _appIdRandomProviderFactory() {\r\n        return \"\" + _randomChar() + _randomChar() + _randomChar();\r\n    }\r\n    /**\r\n     * Providers that will generate a random APP_ID_TOKEN.\r\n     * @publicApi\r\n     */\r\n    var APP_ID_RANDOM_PROVIDER = {\r\n        provide: APP_ID,\r\n        useFactory: _appIdRandomProviderFactory,\r\n        deps: [],\r\n    };\r\n    function _randomChar() {\r\n        return String.fromCharCode(97 + Math.floor(Math.random() * 25));\r\n    }\r\n    /**\r\n     * A function that will be executed when a platform is initialized.\r\n     * @publicApi\r\n     */\r\n    var PLATFORM_INITIALIZER = new InjectionToken('Platform Initializer');\r\n    /**\r\n     * A token that indicates an opaque platform id.\r\n     * @publicApi\r\n     */\r\n    var PLATFORM_ID = new InjectionToken('Platform ID');\r\n    /**\r\n     * All callbacks provided via this token will be called for every component that is bootstrapped.\r\n     * Signature of the callback:\r\n     *\r\n     * `(componentRef: ComponentRef) => void`.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var APP_BOOTSTRAP_LISTENER = new InjectionToken('appBootstrapListener');\r\n    /**\r\n     * A token which indicates the root directory of the application\r\n     * @publicApi\r\n     */\r\n    var PACKAGE_ROOT_URL = new InjectionToken('Application Packages Root URL');\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var Console = /** @class */ (function () {\r\n        function Console() {\r\n        }\r\n        Console.prototype.log = function (message) {\r\n            // tslint:disable-next-line:no-console\r\n            console.log(message);\r\n        };\r\n        // Note: for reporting errors use `DOM.logError()` as it is platform specific\r\n        Console.prototype.warn = function (message) {\r\n            // tslint:disable-next-line:no-console\r\n            console.warn(message);\r\n        };\r\n        Console = __decorate([\r\n            Injectable()\r\n        ], Console);\r\n        return Console;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Provide this token to set the locale of your application.\r\n     * It is used for i18n extraction, by i18n pipes (DatePipe, I18nPluralPipe, CurrencyPipe,\r\n     * DecimalPipe and PercentPipe) and by ICU expressions.\r\n     *\r\n     * See the [i18n guide](guide/i18n#setting-up-locale) for more information.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * import { LOCALE_ID } from '@angular/core';\r\n     * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\r\n     * import { AppModule } from './app/app.module';\r\n     *\r\n     * platformBrowserDynamic().bootstrapModule(AppModule, {\r\n     *   providers: [{provide: LOCALE_ID, useValue: 'en-US' }]\r\n     * });\r\n     * ```\r\n     *\r\n     * @publicApi\r\n     */\r\n    var LOCALE_ID$1 = new InjectionToken('LocaleId');\r\n    /**\r\n     * Use this token at bootstrap to provide the content of your translation file (`xtb`,\r\n     * `xlf` or `xlf2`) when you want to translate your application in another language.\r\n     *\r\n     * See the [i18n guide](guide/i18n#merge) for more information.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * import { TRANSLATIONS } from '@angular/core';\r\n     * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\r\n     * import { AppModule } from './app/app.module';\r\n     *\r\n     * // content of your translation file\r\n     * const translations = '....';\r\n     *\r\n     * platformBrowserDynamic().bootstrapModule(AppModule, {\r\n     *   providers: [{provide: TRANSLATIONS, useValue: translations }]\r\n     * });\r\n     * ```\r\n     *\r\n     * @publicApi\r\n     */\r\n    var TRANSLATIONS$1 = new InjectionToken('Translations');\r\n    /**\r\n     * Provide this token at bootstrap to set the format of your {@link TRANSLATIONS}: `xtb`,\r\n     * `xlf` or `xlf2`.\r\n     *\r\n     * See the [i18n guide](guide/i18n#merge) for more information.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * import { TRANSLATIONS_FORMAT } from '@angular/core';\r\n     * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\r\n     * import { AppModule } from './app/app.module';\r\n     *\r\n     * platformBrowserDynamic().bootstrapModule(AppModule, {\r\n     *   providers: [{provide: TRANSLATIONS_FORMAT, useValue: 'xlf' }]\r\n     * });\r\n     * ```\r\n     *\r\n     * @publicApi\r\n     */\r\n    var TRANSLATIONS_FORMAT = new InjectionToken('TranslationsFormat');\r\n    (function (MissingTranslationStrategy) {\r\n        MissingTranslationStrategy[MissingTranslationStrategy[\"Error\"] = 0] = \"Error\";\r\n        MissingTranslationStrategy[MissingTranslationStrategy[\"Warning\"] = 1] = \"Warning\";\r\n        MissingTranslationStrategy[MissingTranslationStrategy[\"Ignore\"] = 2] = \"Ignore\";\r\n    })(exports.MissingTranslationStrategy || (exports.MissingTranslationStrategy = {}));\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var SWITCH_IVY_ENABLED__POST_R3__ = true;\r\n    var SWITCH_IVY_ENABLED__PRE_R3__ = false;\r\n    var ivyEnabled = SWITCH_IVY_ENABLED__PRE_R3__;\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Combination of NgModuleFactory and ComponentFactorys.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var ModuleWithComponentFactories = /** @class */ (function () {\r\n        function ModuleWithComponentFactories(ngModuleFactory, componentFactories) {\r\n            this.ngModuleFactory = ngModuleFactory;\r\n            this.componentFactories = componentFactories;\r\n        }\r\n        return ModuleWithComponentFactories;\r\n    }());\r\n    function _throwError() {\r\n        throw new Error(\"Runtime compiler is not loaded\");\r\n    }\r\n    var Compiler_compileModuleSync__PRE_R3__ = _throwError;\r\n    var Compiler_compileModuleSync__POST_R3__ = function (moduleType) {\r\n        return new NgModuleFactory$1(moduleType);\r\n    };\r\n    var Compiler_compileModuleSync = Compiler_compileModuleSync__PRE_R3__;\r\n    var Compiler_compileModuleAsync__PRE_R3__ = _throwError;\r\n    var Compiler_compileModuleAsync__POST_R3__ = function (moduleType) {\r\n        return Promise.resolve(Compiler_compileModuleSync__POST_R3__(moduleType));\r\n    };\r\n    var Compiler_compileModuleAsync = Compiler_compileModuleAsync__PRE_R3__;\r\n    var Compiler_compileModuleAndAllComponentsSync__PRE_R3__ = _throwError;\r\n    var Compiler_compileModuleAndAllComponentsSync__POST_R3__ = function (moduleType) {\r\n        var ngModuleFactory = Compiler_compileModuleSync__POST_R3__(moduleType);\r\n        var moduleDef = getNgModuleDef(moduleType);\r\n        var componentFactories = maybeUnwrapFn(moduleDef.declarations)\r\n            .reduce(function (factories, declaration) {\r\n            var componentDef = getComponentDef(declaration);\r\n            componentDef && factories.push(new ComponentFactory$1(componentDef));\r\n            return factories;\r\n        }, []);\r\n        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\r\n    };\r\n    var Compiler_compileModuleAndAllComponentsSync = Compiler_compileModuleAndAllComponentsSync__PRE_R3__;\r\n    var Compiler_compileModuleAndAllComponentsAsync__PRE_R3__ = _throwError;\r\n    var Compiler_compileModuleAndAllComponentsAsync__POST_R3__ = function (moduleType) {\r\n        return Promise.resolve(Compiler_compileModuleAndAllComponentsSync__POST_R3__(moduleType));\r\n    };\r\n    var Compiler_compileModuleAndAllComponentsAsync = Compiler_compileModuleAndAllComponentsAsync__PRE_R3__;\r\n    /**\r\n     * Low-level service for running the angular compiler during runtime\r\n     * to create {@link ComponentFactory}s, which\r\n     * can later be used to create and render a Component instance.\r\n     *\r\n     * Each `@NgModule` provides an own `Compiler` to its injector,\r\n     * that will use the directives/pipes of the ng module for compilation\r\n     * of components.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var Compiler = /** @class */ (function () {\r\n        function Compiler() {\r\n            /**\r\n             * Compiles the given NgModule and all of its components. All templates of the components listed\r\n             * in `entryComponents` have to be inlined.\r\n             */\r\n            this.compileModuleSync = Compiler_compileModuleSync;\r\n            /**\r\n             * Compiles the given NgModule and all of its components\r\n             */\r\n            this.compileModuleAsync = Compiler_compileModuleAsync;\r\n            /**\r\n             * Same as {@link #compileModuleSync} but also creates ComponentFactories for all components.\r\n             */\r\n            this.compileModuleAndAllComponentsSync = Compiler_compileModuleAndAllComponentsSync;\r\n            /**\r\n             * Same as {@link #compileModuleAsync} but also creates ComponentFactories for all components.\r\n             */\r\n            this.compileModuleAndAllComponentsAsync = Compiler_compileModuleAndAllComponentsAsync;\r\n        }\r\n        /**\r\n         * Clears all caches.\r\n         */\r\n        Compiler.prototype.clearCache = function () { };\r\n        /**\r\n         * Clears the cache for the given component/ngModule.\r\n         */\r\n        Compiler.prototype.clearCacheFor = function (type) { };\r\n        /**\r\n         * Returns the id for a given NgModule, if one is defined and known to the compiler.\r\n         */\r\n        Compiler.prototype.getModuleId = function (moduleType) { return undefined; };\r\n        Compiler = __decorate([\r\n            Injectable()\r\n        ], Compiler);\r\n        return Compiler;\r\n    }());\r\n    /**\r\n     * Token to provide CompilerOptions in the platform injector.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var COMPILER_OPTIONS = new InjectionToken('compilerOptions');\r\n    /**\r\n     * A factory for creating a Compiler\r\n     *\r\n     * @publicApi\r\n     */\r\n    var CompilerFactory = /** @class */ (function () {\r\n        function CompilerFactory() {\r\n        }\r\n        return CompilerFactory;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var trace;\r\n    var events;\r\n    function detectWTF() {\r\n        var wtf = _global /** TODO #9100 */['wtf'];\r\n        if (wtf) {\r\n            trace = wtf['trace'];\r\n            if (trace) {\r\n                events = trace['events'];\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    function createScope(signature, flags) {\r\n        if (flags === void 0) { flags = null; }\r\n        return events.createScope(signature, flags);\r\n    }\r\n    function leave(scope, returnValue) {\r\n        trace.leaveScope(scope, returnValue);\r\n        return returnValue;\r\n    }\r\n    function startTimeRange(rangeType, action) {\r\n        return trace.beginTimeRange(rangeType, action);\r\n    }\r\n    function endTimeRange(range) {\r\n        trace.endTimeRange(range);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * True if WTF is enabled.\r\n     */\r\n    var wtfEnabled = detectWTF();\r\n    function noopScope(arg0, arg1) {\r\n        return null;\r\n    }\r\n    /**\r\n     * Create trace scope.\r\n     *\r\n     * Scopes must be strictly nested and are analogous to stack frames, but\r\n     * do not have to follow the stack frames. Instead it is recommended that they follow logical\r\n     * nesting. You may want to use\r\n     * [Event\r\n     * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)\r\n     * as they are defined in WTF.\r\n     *\r\n     * Used to mark scope entry. The return value is used to leave the scope.\r\n     *\r\n     *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');\r\n     *\r\n     *     someMethod() {\r\n     *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI\r\n     *        // DO SOME WORK HERE\r\n     *        return wtfLeave(s, 123); // Return value 123\r\n     *     }\r\n     *\r\n     * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can\r\n     * negatively impact the performance of your application. For this reason we recommend that\r\n     * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and\r\n     * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to\r\n     * exception, will produce incorrect trace, but presence of exception signifies logic error which\r\n     * needs to be fixed before the app should be profiled. Add try-finally only when you expect that\r\n     * an exception is expected during normal execution while profiling.\r\n     *\r\n     * @publicApi\r\n     * @deprecated the Web Tracing Framework is no longer supported in Angular\r\n     */\r\n    var wtfCreateScope = wtfEnabled ? createScope : function (signature, flags) { return noopScope; };\r\n    /**\r\n     * Used to mark end of Scope.\r\n     *\r\n     * - `scope` to end.\r\n     * - `returnValue` (optional) to be passed to the WTF.\r\n     *\r\n     * Returns the `returnValue for easy chaining.\r\n     * @publicApi\r\n     * @deprecated the Web Tracing Framework is no longer supported in Angular\r\n     */\r\n    var wtfLeave = wtfEnabled ? leave : function (s, r) { return r; };\r\n    /**\r\n     * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.\r\n     * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been\r\n     * enabled.\r\n     *\r\n     *     someMethod() {\r\n     *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');\r\n     *        var future = new Future.delay(5).then((_) {\r\n     *          wtfEndTimeRange(s);\r\n     *        });\r\n     *     }\r\n     * @publicApi\r\n     * @deprecated the Web Tracing Framework is no longer supported in Angular\r\n     */\r\n    var wtfStartTimeRange = wtfEnabled ? startTimeRange : function (rangeType, action) { return null; };\r\n    /**\r\n     * Ends a async time range operation.\r\n     * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been\r\n     * enabled.\r\n     * @publicApi\r\n     * @deprecated the Web Tracing Framework is no longer supported in Angular\r\n     */\r\n    var wtfEndTimeRange = wtfEnabled ? endTimeRange : function (r) { return null; };\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var promise = (function () { return Promise.resolve(0); })();\r\n    function scheduleMicroTask(fn) {\r\n        if (typeof Zone === 'undefined') {\r\n            // use promise to schedule microTask instead of use Zone\r\n            promise.then(function () { fn && fn.apply(null, null); });\r\n        }\r\n        else {\r\n            Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * An injectable service for executing work inside or outside of the Angular zone.\r\n     *\r\n     * The most common use of this service is to optimize performance when starting a work consisting of\r\n     * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\r\n     * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks\r\n     * can reenter the Angular zone via {@link #run}.\r\n     *\r\n     * <!-- TODO: add/fix links to:\r\n     *   - docs explaining zones and the use of zones in Angular and change-detection\r\n     *   - link to runOutsideAngular/run (throughout this file!)\r\n     *   -->\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```\r\n     * import {Component, NgZone} from '@angular/core';\r\n     * import {NgIf} from '@angular/common';\r\n     *\r\n     * @Component({\r\n     *   selector: 'ng-zone-demo',\r\n     *   template: `\r\n     *     <h2>Demo: NgZone</h2>\r\n     *\r\n     *     <p>Progress: {{progress}}%</p>\r\n     *     <p *ngIf=\"progress >= 100\">Done processing {{label}} of Angular zone!</p>\r\n     *\r\n     *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\r\n     *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\r\n     *   `,\r\n     * })\r\n     * export class NgZoneDemo {\r\n     *   progress: number = 0;\r\n     *   label: string;\r\n     *\r\n     *   constructor(private _ngZone: NgZone) {}\r\n     *\r\n     *   // Loop inside the Angular zone\r\n     *   // so the UI DOES refresh after each setTimeout cycle\r\n     *   processWithinAngularZone() {\r\n     *     this.label = 'inside';\r\n     *     this.progress = 0;\r\n     *     this._increaseProgress(() => console.log('Inside Done!'));\r\n     *   }\r\n     *\r\n     *   // Loop outside of the Angular zone\r\n     *   // so the UI DOES NOT refresh after each setTimeout cycle\r\n     *   processOutsideOfAngularZone() {\r\n     *     this.label = 'outside';\r\n     *     this.progress = 0;\r\n     *     this._ngZone.runOutsideAngular(() => {\r\n     *       this._increaseProgress(() => {\r\n     *         // reenter the Angular zone and display done\r\n     *         this._ngZone.run(() => { console.log('Outside Done!'); });\r\n     *       });\r\n     *     });\r\n     *   }\r\n     *\r\n     *   _increaseProgress(doneCallback: () => void) {\r\n     *     this.progress += 1;\r\n     *     console.log(`Current progress: ${this.progress}%`);\r\n     *\r\n     *     if (this.progress < 100) {\r\n     *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);\r\n     *     } else {\r\n     *       doneCallback();\r\n     *     }\r\n     *   }\r\n     * }\r\n     * ```\r\n     *\r\n     * @publicApi\r\n     */\r\n    var NgZone = /** @class */ (function () {\r\n        function NgZone(_a) {\r\n            var _b = _a.enableLongStackTrace, enableLongStackTrace = _b === void 0 ? false : _b;\r\n            this.hasPendingMicrotasks = false;\r\n            this.hasPendingMacrotasks = false;\r\n            /**\r\n             * Whether there are no outstanding microtasks or macrotasks.\r\n             */\r\n            this.isStable = true;\r\n            /**\r\n             * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\r\n             */\r\n            this.onUnstable = new EventEmitter(false);\r\n            /**\r\n             * Notifies when there is no more microtasks enqueued in the current VM Turn.\r\n             * This is a hint for Angular to do change detection, which may enqueue more microtasks.\r\n             * For this reason this event can fire multiple times per VM Turn.\r\n             */\r\n            this.onMicrotaskEmpty = new EventEmitter(false);\r\n            /**\r\n             * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\r\n             * implies we are about to relinquish VM turn.\r\n             * This event gets called just once.\r\n             */\r\n            this.onStable = new EventEmitter(false);\r\n            /**\r\n             * Notifies that an error has been delivered.\r\n             */\r\n            this.onError = new EventEmitter(false);\r\n            if (typeof Zone == 'undefined') {\r\n                throw new Error(\"In this configuration Angular requires Zone.js\");\r\n            }\r\n            Zone.assertZonePatched();\r\n            var self = this;\r\n            self._nesting = 0;\r\n            self._outer = self._inner = Zone.current;\r\n            if (Zone['wtfZoneSpec']) {\r\n                self._inner = self._inner.fork(Zone['wtfZoneSpec']);\r\n            }\r\n            if (Zone['TaskTrackingZoneSpec']) {\r\n                self._inner = self._inner.fork(new Zone['TaskTrackingZoneSpec']);\r\n            }\r\n            if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {\r\n                self._inner = self._inner.fork(Zone['longStackTraceZoneSpec']);\r\n            }\r\n            forkInnerZoneWithAngularBehavior(self);\r\n        }\r\n        NgZone.isInAngularZone = function () { return Zone.current.get('isAngularZone') === true; };\r\n        NgZone.assertInAngularZone = function () {\r\n            if (!NgZone.isInAngularZone()) {\r\n                throw new Error('Expected to be in Angular Zone, but it is not!');\r\n            }\r\n        };\r\n        NgZone.assertNotInAngularZone = function () {\r\n            if (NgZone.isInAngularZone()) {\r\n                throw new Error('Expected to not be in Angular Zone, but it is!');\r\n            }\r\n        };\r\n        /**\r\n         * Executes the `fn` function synchronously within the Angular zone and returns value returned by\r\n         * the function.\r\n         *\r\n         * Running functions via `run` allows you to reenter Angular zone from a task that was executed\r\n         * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\r\n         *\r\n         * Any future tasks or microtasks scheduled from within this function will continue executing from\r\n         * within the Angular zone.\r\n         *\r\n         * If a synchronous error happens it will be rethrown and not reported via `onError`.\r\n         */\r\n        NgZone.prototype.run = function (fn, applyThis, applyArgs) {\r\n            return this._inner.run(fn, applyThis, applyArgs);\r\n        };\r\n        /**\r\n         * Executes the `fn` function synchronously within the Angular zone as a task and returns value\r\n         * returned by the function.\r\n         *\r\n         * Running functions via `run` allows you to reenter Angular zone from a task that was executed\r\n         * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\r\n         *\r\n         * Any future tasks or microtasks scheduled from within this function will continue executing from\r\n         * within the Angular zone.\r\n         *\r\n         * If a synchronous error happens it will be rethrown and not reported via `onError`.\r\n         */\r\n        NgZone.prototype.runTask = function (fn, applyThis, applyArgs, name) {\r\n            var zone = this._inner;\r\n            var task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop$1, noop$1);\r\n            try {\r\n                return zone.runTask(task, applyThis, applyArgs);\r\n            }\r\n            finally {\r\n                zone.cancelTask(task);\r\n            }\r\n        };\r\n        /**\r\n         * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not\r\n         * rethrown.\r\n         */\r\n        NgZone.prototype.runGuarded = function (fn, applyThis, applyArgs) {\r\n            return this._inner.runGuarded(fn, applyThis, applyArgs);\r\n        };\r\n        /**\r\n         * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\r\n         * the function.\r\n         *\r\n         * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do\r\n         * work that\r\n         * doesn't trigger Angular change-detection or is subject to Angular's error handling.\r\n         *\r\n         * Any future tasks or microtasks scheduled from within this function will continue executing from\r\n         * outside of the Angular zone.\r\n         *\r\n         * Use {@link #run} to reenter the Angular zone and do work that updates the application model.\r\n         */\r\n        NgZone.prototype.runOutsideAngular = function (fn) {\r\n            return this._outer.run(fn);\r\n        };\r\n        return NgZone;\r\n    }());\r\n    function noop$1() { }\r\n    var EMPTY_PAYLOAD = {};\r\n    function checkStable(zone) {\r\n        if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {\r\n            try {\r\n                zone._nesting++;\r\n                zone.onMicrotaskEmpty.emit(null);\r\n            }\r\n            finally {\r\n                zone._nesting--;\r\n                if (!zone.hasPendingMicrotasks) {\r\n                    try {\r\n                        zone.runOutsideAngular(function () { return zone.onStable.emit(null); });\r\n                    }\r\n                    finally {\r\n                        zone.isStable = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function forkInnerZoneWithAngularBehavior(zone) {\r\n        zone._inner = zone._inner.fork({\r\n            name: 'angular',\r\n            properties: { 'isAngularZone': true },\r\n            onInvokeTask: function (delegate, current, target, task, applyThis, applyArgs) {\r\n                try {\r\n                    onEnter(zone);\r\n                    return delegate.invokeTask(target, task, applyThis, applyArgs);\r\n                }\r\n                finally {\r\n                    onLeave(zone);\r\n                }\r\n            },\r\n            onInvoke: function (delegate, current, target, callback, applyThis, applyArgs, source) {\r\n                try {\r\n                    onEnter(zone);\r\n                    return delegate.invoke(target, callback, applyThis, applyArgs, source);\r\n                }\r\n                finally {\r\n                    onLeave(zone);\r\n                }\r\n            },\r\n            onHasTask: function (delegate, current, target, hasTaskState) {\r\n                delegate.hasTask(target, hasTaskState);\r\n                if (current === target) {\r\n                    // We are only interested in hasTask events which originate from our zone\r\n                    // (A child hasTask event is not interesting to us)\r\n                    if (hasTaskState.change == 'microTask') {\r\n                        zone.hasPendingMicrotasks = hasTaskState.microTask;\r\n                        checkStable(zone);\r\n                    }\r\n                    else if (hasTaskState.change == 'macroTask') {\r\n                        zone.hasPendingMacrotasks = hasTaskState.macroTask;\r\n                    }\r\n                }\r\n            },\r\n            onHandleError: function (delegate, current, target, error) {\r\n                delegate.handleError(target, error);\r\n                zone.runOutsideAngular(function () { return zone.onError.emit(error); });\r\n                return false;\r\n            }\r\n        });\r\n    }\r\n    function onEnter(zone) {\r\n        zone._nesting++;\r\n        if (zone.isStable) {\r\n            zone.isStable = false;\r\n            zone.onUnstable.emit(null);\r\n        }\r\n    }\r\n    function onLeave(zone) {\r\n        zone._nesting--;\r\n        checkStable(zone);\r\n    }\r\n    /**\r\n     * Provides a noop implementation of `NgZone` which does nothing. This zone requires explicit calls\r\n     * to framework to perform rendering.\r\n     */\r\n    var NoopNgZone = /** @class */ (function () {\r\n        function NoopNgZone() {\r\n            this.hasPendingMicrotasks = false;\r\n            this.hasPendingMacrotasks = false;\r\n            this.isStable = true;\r\n            this.onUnstable = new EventEmitter();\r\n            this.onMicrotaskEmpty = new EventEmitter();\r\n            this.onStable = new EventEmitter();\r\n            this.onError = new EventEmitter();\r\n        }\r\n        NoopNgZone.prototype.run = function (fn) { return fn(); };\r\n        NoopNgZone.prototype.runGuarded = function (fn) { return fn(); };\r\n        NoopNgZone.prototype.runOutsideAngular = function (fn) { return fn(); };\r\n        NoopNgZone.prototype.runTask = function (fn) { return fn(); };\r\n        return NoopNgZone;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * The Testability service provides testing hooks that can be accessed from\r\n     * the browser and by services such as Protractor. Each bootstrapped Angular\r\n     * application on the page will have an instance of Testability.\r\n     * @publicApi\r\n     */\r\n    var Testability = /** @class */ (function () {\r\n        function Testability(_ngZone) {\r\n            var _this = this;\r\n            this._ngZone = _ngZone;\r\n            this._pendingCount = 0;\r\n            this._isZoneStable = true;\r\n            /**\r\n             * Whether any work was done since the last 'whenStable' callback. This is\r\n             * useful to detect if this could have potentially destabilized another\r\n             * component while it is stabilizing.\r\n             * @internal\r\n             */\r\n            this._didWork = false;\r\n            this._callbacks = [];\r\n            this.taskTrackingZone = null;\r\n            this._watchAngularEvents();\r\n            _ngZone.run(function () {\r\n                _this.taskTrackingZone =\r\n                    typeof Zone == 'undefined' ? null : Zone.current.get('TaskTrackingZone');\r\n            });\r\n        }\r\n        Testability.prototype._watchAngularEvents = function () {\r\n            var _this = this;\r\n            this._ngZone.onUnstable.subscribe({\r\n                next: function () {\r\n                    _this._didWork = true;\r\n                    _this._isZoneStable = false;\r\n                }\r\n            });\r\n            this._ngZone.runOutsideAngular(function () {\r\n                _this._ngZone.onStable.subscribe({\r\n                    next: function () {\r\n                        NgZone.assertNotInAngularZone();\r\n                        scheduleMicroTask(function () {\r\n                            _this._isZoneStable = true;\r\n                            _this._runCallbacksIfReady();\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n        };\r\n        /**\r\n         * Increases the number of pending request\r\n         * @deprecated pending requests are now tracked with zones.\r\n         */\r\n        Testability.prototype.increasePendingRequestCount = function () {\r\n            this._pendingCount += 1;\r\n            this._didWork = true;\r\n            return this._pendingCount;\r\n        };\r\n        /**\r\n         * Decreases the number of pending request\r\n         * @deprecated pending requests are now tracked with zones\r\n         */\r\n        Testability.prototype.decreasePendingRequestCount = function () {\r\n            this._pendingCount -= 1;\r\n            if (this._pendingCount < 0) {\r\n                throw new Error('pending async requests below zero');\r\n            }\r\n            this._runCallbacksIfReady();\r\n            return this._pendingCount;\r\n        };\r\n        /**\r\n         * Whether an associated application is stable\r\n         */\r\n        Testability.prototype.isStable = function () {\r\n            return this._isZoneStable && this._pendingCount === 0 && !this._ngZone.hasPendingMacrotasks;\r\n        };\r\n        Testability.prototype._runCallbacksIfReady = function () {\r\n            var _this = this;\r\n            if (this.isStable()) {\r\n                // Schedules the call backs in a new frame so that it is always async.\r\n                scheduleMicroTask(function () {\r\n                    while (_this._callbacks.length !== 0) {\r\n                        var cb = _this._callbacks.pop();\r\n                        clearTimeout(cb.timeoutId);\r\n                        cb.doneCb(_this._didWork);\r\n                    }\r\n                    _this._didWork = false;\r\n                });\r\n            }\r\n            else {\r\n                // Still not stable, send updates.\r\n                var pending_1 = this.getPendingTasks();\r\n                this._callbacks = this._callbacks.filter(function (cb) {\r\n                    if (cb.updateCb && cb.updateCb(pending_1)) {\r\n                        clearTimeout(cb.timeoutId);\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                });\r\n                this._didWork = true;\r\n            }\r\n        };\r\n        Testability.prototype.getPendingTasks = function () {\r\n            if (!this.taskTrackingZone) {\r\n                return [];\r\n            }\r\n            // Copy the tasks data so that we don't leak tasks.\r\n            return this.taskTrackingZone.macroTasks.map(function (t) {\r\n                return {\r\n                    source: t.source,\r\n                    // From TaskTrackingZone:\r\n                    // https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40\r\n                    creationLocation: t.creationLocation,\r\n                    data: t.data\r\n                };\r\n            });\r\n        };\r\n        Testability.prototype.addCallback = function (cb, timeout, updateCb) {\r\n            var _this = this;\r\n            var timeoutId = -1;\r\n            if (timeout && timeout > 0) {\r\n                timeoutId = setTimeout(function () {\r\n                    _this._callbacks = _this._callbacks.filter(function (cb) { return cb.timeoutId !== timeoutId; });\r\n                    cb(_this._didWork, _this.getPendingTasks());\r\n                }, timeout);\r\n            }\r\n            this._callbacks.push({ doneCb: cb, timeoutId: timeoutId, updateCb: updateCb });\r\n        };\r\n        /**\r\n         * Wait for the application to be stable with a timeout. If the timeout is reached before that\r\n         * happens, the callback receives a list of the macro tasks that were pending, otherwise null.\r\n         *\r\n         * @param doneCb The callback to invoke when Angular is stable or the timeout expires\r\n         *    whichever comes first.\r\n         * @param timeout Optional. The maximum time to wait for Angular to become stable. If not\r\n         *    specified, whenStable() will wait forever.\r\n         * @param updateCb Optional. If specified, this callback will be invoked whenever the set of\r\n         *    pending macrotasks changes. If this callback returns true doneCb will not be invoked\r\n         *    and no further updates will be issued.\r\n         */\r\n        Testability.prototype.whenStable = function (doneCb, timeout, updateCb) {\r\n            if (updateCb && !this.taskTrackingZone) {\r\n                throw new Error('Task tracking zone is required when passing an update callback to ' +\r\n                    'whenStable(). Is \"zone.js/dist/task-tracking.js\" loaded?');\r\n            }\r\n            // These arguments are 'Function' above to keep the public API simple.\r\n            this.addCallback(doneCb, timeout, updateCb);\r\n            this._runCallbacksIfReady();\r\n        };\r\n        /**\r\n         * Get the number of pending requests\r\n         * @deprecated pending requests are now tracked with zones\r\n         */\r\n        Testability.prototype.getPendingRequestCount = function () { return this._pendingCount; };\r\n        /**\r\n         * Find providers by name\r\n         * @param using The root element to search from\r\n         * @param provider The name of binding variable\r\n         * @param exactMatch Whether using exactMatch\r\n         */\r\n        Testability.prototype.findProviders = function (using, provider, exactMatch) {\r\n            // TODO(juliemr): implement.\r\n            return [];\r\n        };\r\n        Testability = __decorate([\r\n            Injectable(),\r\n            __metadata(\"design:paramtypes\", [NgZone])\r\n        ], Testability);\r\n        return Testability;\r\n    }());\r\n    /**\r\n     * A global registry of {@link Testability} instances for specific elements.\r\n     * @publicApi\r\n     */\r\n    var TestabilityRegistry = /** @class */ (function () {\r\n        function TestabilityRegistry() {\r\n            /** @internal */\r\n            this._applications = new Map();\r\n            _testabilityGetter.addToWindow(this);\r\n        }\r\n        /**\r\n         * Registers an application with a testability hook so that it can be tracked\r\n         * @param token token of application, root element\r\n         * @param testability Testability hook\r\n         */\r\n        TestabilityRegistry.prototype.registerApplication = function (token, testability) {\r\n            this._applications.set(token, testability);\r\n        };\r\n        /**\r\n         * Unregisters an application.\r\n         * @param token token of application, root element\r\n         */\r\n        TestabilityRegistry.prototype.unregisterApplication = function (token) { this._applications.delete(token); };\r\n        /**\r\n         * Unregisters all applications\r\n         */\r\n        TestabilityRegistry.prototype.unregisterAllApplications = function () { this._applications.clear(); };\r\n        /**\r\n         * Get a testability hook associated with the application\r\n         * @param elem root element\r\n         */\r\n        TestabilityRegistry.prototype.getTestability = function (elem) { return this._applications.get(elem) || null; };\r\n        /**\r\n         * Get all registered testabilities\r\n         */\r\n        TestabilityRegistry.prototype.getAllTestabilities = function () { return Array.from(this._applications.values()); };\r\n        /**\r\n         * Get all registered applications(root elements)\r\n         */\r\n        TestabilityRegistry.prototype.getAllRootElements = function () { return Array.from(this._applications.keys()); };\r\n        /**\r\n         * Find testability of a node in the Tree\r\n         * @param elem node\r\n         * @param findInAncestors whether finding testability in ancestors if testability was not found in\r\n         * current node\r\n         */\r\n        TestabilityRegistry.prototype.findTestabilityInTree = function (elem, findInAncestors) {\r\n            if (findInAncestors === void 0) { findInAncestors = true; }\r\n            return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);\r\n        };\r\n        TestabilityRegistry = __decorate([\r\n            Injectable(),\r\n            __metadata(\"design:paramtypes\", [])\r\n        ], TestabilityRegistry);\r\n        return TestabilityRegistry;\r\n    }());\r\n    var _NoopGetTestability = /** @class */ (function () {\r\n        function _NoopGetTestability() {\r\n        }\r\n        _NoopGetTestability.prototype.addToWindow = function (registry) { };\r\n        _NoopGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {\r\n            return null;\r\n        };\r\n        return _NoopGetTestability;\r\n    }());\r\n    /**\r\n     * Set the {@link GetTestability} implementation used by the Angular testing framework.\r\n     * @publicApi\r\n     */\r\n    function setTestabilityGetter(getter) {\r\n        _testabilityGetter = getter;\r\n    }\r\n    var _testabilityGetter = new _NoopGetTestability();\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var _platform;\r\n    var compileNgModuleFactory = compileNgModuleFactory__PRE_R3__;\r\n    function compileNgModuleFactory__PRE_R3__(injector, options, moduleType) {\r\n        var compilerFactory = injector.get(CompilerFactory);\r\n        var compiler = compilerFactory.createCompiler([options]);\r\n        return compiler.compileModuleAsync(moduleType);\r\n    }\r\n    function compileNgModuleFactory__POST_R3__(injector, options, moduleType) {\r\n        ngDevMode && assertNgModuleType(moduleType);\r\n        var moduleFactory = new NgModuleFactory$1(moduleType);\r\n        if (isComponentResourceResolutionQueueEmpty()) {\r\n            return Promise.resolve(moduleFactory);\r\n        }\r\n        var compilerOptions = injector.get(COMPILER_OPTIONS, []).concat(options);\r\n        var compilerProviders = _mergeArrays(compilerOptions.map(function (o) { return o.providers; }));\r\n        // In case there are no compiler providers, we just return the module factory as\r\n        // there won't be any resource loader. This can happen with Ivy, because AOT compiled\r\n        // modules can be still passed through \"bootstrapModule\". In that case we shouldn't\r\n        // unnecessarily require the JIT compiler.\r\n        if (compilerProviders.length === 0) {\r\n            return Promise.resolve(moduleFactory);\r\n        }\r\n        var compiler = getCompilerFacade();\r\n        var compilerInjector = Injector.create({ providers: compilerProviders });\r\n        var resourceLoader = compilerInjector.get(compiler.ResourceLoader);\r\n        // The resource loader can also return a string while the \"resolveComponentResources\"\r\n        // always expects a promise. Therefore we need to wrap the returned value in a promise.\r\n        return resolveComponentResources(function (url) { return Promise.resolve(resourceLoader.get(url)); })\r\n            .then(function () { return moduleFactory; });\r\n    }\r\n    var isBoundToModule = isBoundToModule__PRE_R3__;\r\n    function isBoundToModule__PRE_R3__(cf) {\r\n        return cf instanceof ComponentFactoryBoundToModule;\r\n    }\r\n    function isBoundToModule__POST_R3__(cf) {\r\n        return cf.isBoundToModule;\r\n    }\r\n    var ALLOW_MULTIPLE_PLATFORMS = new InjectionToken('AllowMultipleToken');\r\n    /**\r\n     * A token for third-party components that can register themselves with NgProbe.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var NgProbeToken = /** @class */ (function () {\r\n        function NgProbeToken(name, token) {\r\n            this.name = name;\r\n            this.token = token;\r\n        }\r\n        return NgProbeToken;\r\n    }());\r\n    /**\r\n     * Creates a platform.\r\n     * Platforms have to be eagerly created via this function.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function createPlatform(injector) {\r\n        if (_platform && !_platform.destroyed &&\r\n            !_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {\r\n            throw new Error('There can be only one platform. Destroy the previous one to create a new one.');\r\n        }\r\n        _platform = injector.get(PlatformRef);\r\n        var inits = injector.get(PLATFORM_INITIALIZER, null);\r\n        if (inits)\r\n            inits.forEach(function (init) { return init(); });\r\n        return _platform;\r\n    }\r\n    /**\r\n     * Creates a factory for a platform\r\n     *\r\n     * @publicApi\r\n     */\r\n    function createPlatformFactory(parentPlatformFactory, name, providers) {\r\n        if (providers === void 0) { providers = []; }\r\n        var desc = \"Platform: \" + name;\r\n        var marker = new InjectionToken(desc);\r\n        return function (extraProviders) {\r\n            if (extraProviders === void 0) { extraProviders = []; }\r\n            var platform = getPlatform();\r\n            if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {\r\n                if (parentPlatformFactory) {\r\n                    parentPlatformFactory(providers.concat(extraProviders).concat({ provide: marker, useValue: true }));\r\n                }\r\n                else {\r\n                    var injectedProviders = providers.concat(extraProviders).concat({ provide: marker, useValue: true });\r\n                    createPlatform(Injector.create({ providers: injectedProviders, name: desc }));\r\n                }\r\n            }\r\n            return assertPlatform(marker);\r\n        };\r\n    }\r\n    /**\r\n     * Checks that there currently is a platform which contains the given token as a provider.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function assertPlatform(requiredToken) {\r\n        var platform = getPlatform();\r\n        if (!platform) {\r\n            throw new Error('No platform exists!');\r\n        }\r\n        if (!platform.injector.get(requiredToken, null)) {\r\n            throw new Error('A platform with a different configuration has been created. Please destroy it first.');\r\n        }\r\n        return platform;\r\n    }\r\n    /**\r\n     * Destroy the existing platform.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function destroyPlatform() {\r\n        if (_platform && !_platform.destroyed) {\r\n            _platform.destroy();\r\n        }\r\n    }\r\n    /**\r\n     * Returns the current platform.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function getPlatform() {\r\n        return _platform && !_platform.destroyed ? _platform : null;\r\n    }\r\n    /**\r\n     * The Angular platform is the entry point for Angular on a web page. Each page\r\n     * has exactly one platform, and services (such as reflection) which are common\r\n     * to every Angular application running on the page are bound in its scope.\r\n     *\r\n     * A page's platform is initialized implicitly when a platform is created via a platform factory\r\n     * (e.g. {@link platformBrowser}), or explicitly by calling the {@link createPlatform} function.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var PlatformRef = /** @class */ (function () {\r\n        /** @internal */\r\n        function PlatformRef(_injector) {\r\n            this._injector = _injector;\r\n            this._modules = [];\r\n            this._destroyListeners = [];\r\n            this._destroyed = false;\r\n        }\r\n        /**\r\n         * Creates an instance of an `@NgModule` for the given platform\r\n         * for offline compilation.\r\n         *\r\n         * @usageNotes\r\n         * ### Simple Example\r\n         *\r\n         * ```typescript\r\n         * my_module.ts:\r\n         *\r\n         * @NgModule({\r\n         *   imports: [BrowserModule]\r\n         * })\r\n         * class MyModule {}\r\n         *\r\n         * main.ts:\r\n         * import {MyModuleNgFactory} from './my_module.ngfactory';\r\n         * import {platformBrowser} from '@angular/platform-browser';\r\n         *\r\n         * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);\r\n         * ```\r\n         */\r\n        PlatformRef.prototype.bootstrapModuleFactory = function (moduleFactory, options) {\r\n            var _this = this;\r\n            // Note: We need to create the NgZone _before_ we instantiate the module,\r\n            // as instantiating the module creates some providers eagerly.\r\n            // So we create a mini parent injector that just contains the new NgZone and\r\n            // pass that as parent to the NgModuleFactory.\r\n            var ngZoneOption = options ? options.ngZone : undefined;\r\n            var ngZone = getNgZone(ngZoneOption);\r\n            var providers = [{ provide: NgZone, useValue: ngZone }];\r\n            // Attention: Don't use ApplicationRef.run here,\r\n            // as we want to be sure that all possible constructor calls are inside `ngZone.run`!\r\n            return ngZone.run(function () {\r\n                var ngZoneInjector = Injector.create({ providers: providers, parent: _this.injector, name: moduleFactory.moduleType.name });\r\n                var moduleRef = moduleFactory.create(ngZoneInjector);\r\n                var exceptionHandler = moduleRef.injector.get(ErrorHandler, null);\r\n                if (!exceptionHandler) {\r\n                    throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');\r\n                }\r\n                // If the `LOCALE_ID` provider is defined at bootstrap we set the value for runtime i18n (ivy)\r\n                if (ivyEnabled) {\r\n                    var localeId = moduleRef.injector.get(LOCALE_ID$1, DEFAULT_LOCALE_ID);\r\n                    setLocaleId(localeId || DEFAULT_LOCALE_ID);\r\n                }\r\n                moduleRef.onDestroy(function () { return remove(_this._modules, moduleRef); });\r\n                ngZone.runOutsideAngular(function () { return ngZone.onError.subscribe({ next: function (error) { exceptionHandler.handleError(error); } }); });\r\n                return _callAndReportToErrorHandler(exceptionHandler, ngZone, function () {\r\n                    var initStatus = moduleRef.injector.get(ApplicationInitStatus);\r\n                    initStatus.runInitializers();\r\n                    return initStatus.donePromise.then(function () {\r\n                        _this._moduleDoBootstrap(moduleRef);\r\n                        return moduleRef;\r\n                    });\r\n                });\r\n            });\r\n        };\r\n        /**\r\n         * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.\r\n         *\r\n         * @usageNotes\r\n         * ### Simple Example\r\n         *\r\n         * ```typescript\r\n         * @NgModule({\r\n         *   imports: [BrowserModule]\r\n         * })\r\n         * class MyModule {}\r\n         *\r\n         * let moduleRef = platformBrowser().bootstrapModule(MyModule);\r\n         * ```\r\n         *\r\n         */\r\n        PlatformRef.prototype.bootstrapModule = function (moduleType, compilerOptions) {\r\n            var _this = this;\r\n            if (compilerOptions === void 0) { compilerOptions = []; }\r\n            var options = optionsReducer({}, compilerOptions);\r\n            return compileNgModuleFactory(this.injector, options, moduleType)\r\n                .then(function (moduleFactory) { return _this.bootstrapModuleFactory(moduleFactory, options); });\r\n        };\r\n        PlatformRef.prototype._moduleDoBootstrap = function (moduleRef) {\r\n            var appRef = moduleRef.injector.get(ApplicationRef);\r\n            if (moduleRef._bootstrapComponents.length > 0) {\r\n                moduleRef._bootstrapComponents.forEach(function (f) { return appRef.bootstrap(f); });\r\n            }\r\n            else if (moduleRef.instance.ngDoBootstrap) {\r\n                moduleRef.instance.ngDoBootstrap(appRef);\r\n            }\r\n            else {\r\n                throw new Error(\"The module \" + stringify(moduleRef.instance.constructor) + \" was bootstrapped, but it does not declare \\\"@NgModule.bootstrap\\\" components nor a \\\"ngDoBootstrap\\\" method. \" +\r\n                    \"Please define one of these.\");\r\n            }\r\n            this._modules.push(moduleRef);\r\n        };\r\n        /**\r\n         * Register a listener to be called when the platform is disposed.\r\n         */\r\n        PlatformRef.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };\r\n        Object.defineProperty(PlatformRef.prototype, \"injector\", {\r\n            /**\r\n             * Retrieve the platform {@link Injector}, which is the parent injector for\r\n             * every Angular application on the page and provides singleton providers.\r\n             */\r\n            get: function () { return this._injector; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * Destroy the Angular platform and all Angular applications on the page.\r\n         */\r\n        PlatformRef.prototype.destroy = function () {\r\n            if (this._destroyed) {\r\n                throw new Error('The platform has already been destroyed!');\r\n            }\r\n            this._modules.slice().forEach(function (module) { return module.destroy(); });\r\n            this._destroyListeners.forEach(function (listener) { return listener(); });\r\n            this._destroyed = true;\r\n        };\r\n        Object.defineProperty(PlatformRef.prototype, \"destroyed\", {\r\n            get: function () { return this._destroyed; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        PlatformRef = __decorate([\r\n            Injectable(),\r\n            __metadata(\"design:paramtypes\", [Injector])\r\n        ], PlatformRef);\r\n        return PlatformRef;\r\n    }());\r\n    function getNgZone(ngZoneOption) {\r\n        var ngZone;\r\n        if (ngZoneOption === 'noop') {\r\n            ngZone = new NoopNgZone();\r\n        }\r\n        else {\r\n            ngZone = (ngZoneOption === 'zone.js' ? undefined : ngZoneOption) ||\r\n                new NgZone({ enableLongStackTrace: isDevMode() });\r\n        }\r\n        return ngZone;\r\n    }\r\n    function _callAndReportToErrorHandler(errorHandler, ngZone, callback) {\r\n        try {\r\n            var result = callback();\r\n            if (isPromise(result)) {\r\n                return result.catch(function (e) {\r\n                    ngZone.runOutsideAngular(function () { return errorHandler.handleError(e); });\r\n                    // rethrow as the exception handler might not do it\r\n                    throw e;\r\n                });\r\n            }\r\n            return result;\r\n        }\r\n        catch (e) {\r\n            ngZone.runOutsideAngular(function () { return errorHandler.handleError(e); });\r\n            // rethrow as the exception handler might not do it\r\n            throw e;\r\n        }\r\n    }\r\n    function optionsReducer(dst, objs) {\r\n        if (Array.isArray(objs)) {\r\n            dst = objs.reduce(optionsReducer, dst);\r\n        }\r\n        else {\r\n            dst = __assign({}, dst, objs);\r\n        }\r\n        return dst;\r\n    }\r\n    /**\r\n     * A reference to an Angular application running on a page.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * {@a is-stable-examples}\r\n     * ### isStable examples and caveats\r\n     *\r\n     * Note two important points about `isStable`, demonstrated in the examples below:\r\n     * - the application will never be stable if you start any kind\r\n     * of recurrent asynchronous task when the application starts\r\n     * (for example for a polling process, started with a `setInterval`, a `setTimeout`\r\n     * or using RxJS operators like `interval`);\r\n     * - the `isStable` Observable runs outside of the Angular zone.\r\n     *\r\n     * Let's imagine that you start a recurrent task\r\n     * (here incrementing a counter, using RxJS `interval`),\r\n     * and at the same time subscribe to `isStable`.\r\n     *\r\n     * ```\r\n     * constructor(appRef: ApplicationRef) {\r\n     *   appRef.isStable.pipe(\r\n     *      filter(stable => stable)\r\n     *   ).subscribe(() => console.log('App is stable now');\r\n     *   interval(1000).subscribe(counter => console.log(counter));\r\n     * }\r\n     * ```\r\n     * In this example, `isStable` will never emit `true`,\r\n     * and the trace \"App is stable now\" will never get logged.\r\n     *\r\n     * If you want to execute something when the app is stable,\r\n     * you have to wait for the application to be stable\r\n     * before starting your polling process.\r\n     *\r\n     * ```\r\n     * constructor(appRef: ApplicationRef) {\r\n     *   appRef.isStable.pipe(\r\n     *     first(stable => stable),\r\n     *     tap(stable => console.log('App is stable now')),\r\n     *     switchMap(() => interval(1000))\r\n     *   ).subscribe(counter => console.log(counter));\r\n     * }\r\n     * ```\r\n     * In this example, the trace \"App is stable now\" will be logged\r\n     * and then the counter starts incrementing every second.\r\n     *\r\n     * Note also that this Observable runs outside of the Angular zone,\r\n     * which means that the code in the subscription\r\n     * to this Observable will not trigger the change detection.\r\n     *\r\n     * Let's imagine that instead of logging the counter value,\r\n     * you update a field of your component\r\n     * and display it in its template.\r\n     *\r\n     * ```\r\n     * constructor(appRef: ApplicationRef) {\r\n     *   appRef.isStable.pipe(\r\n     *     first(stable => stable),\r\n     *     switchMap(() => interval(1000))\r\n     *   ).subscribe(counter => this.value = counter);\r\n     * }\r\n     * ```\r\n     * As the `isStable` Observable runs outside the zone,\r\n     * the `value` field will be updated properly,\r\n     * but the template will not be refreshed!\r\n     *\r\n     * You'll have to manually trigger the change detection to update the template.\r\n     *\r\n     * ```\r\n     * constructor(appRef: ApplicationRef, cd: ChangeDetectorRef) {\r\n     *   appRef.isStable.pipe(\r\n     *     first(stable => stable),\r\n     *     switchMap(() => interval(1000))\r\n     *   ).subscribe(counter => {\r\n     *     this.value = counter;\r\n     *     cd.detectChanges();\r\n     *   });\r\n     * }\r\n     * ```\r\n     *\r\n     * Or make the subscription callback run inside the zone.\r\n     *\r\n     * ```\r\n     * constructor(appRef: ApplicationRef, zone: NgZone) {\r\n     *   appRef.isStable.pipe(\r\n     *     first(stable => stable),\r\n     *     switchMap(() => interval(1000))\r\n     *   ).subscribe(counter => zone.run(() => this.value = counter));\r\n     * }\r\n     * ```\r\n     *\r\n     * @publicApi\r\n     */\r\n    var ApplicationRef = /** @class */ (function () {\r\n        /** @internal */\r\n        function ApplicationRef(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus) {\r\n            var _this = this;\r\n            this._zone = _zone;\r\n            this._console = _console;\r\n            this._injector = _injector;\r\n            this._exceptionHandler = _exceptionHandler;\r\n            this._componentFactoryResolver = _componentFactoryResolver;\r\n            this._initStatus = _initStatus;\r\n            this._bootstrapListeners = [];\r\n            this._views = [];\r\n            this._runningTick = false;\r\n            this._enforceNoNewChanges = false;\r\n            this._stable = true;\r\n            /**\r\n             * Get a list of component types registered to this application.\r\n             * This list is populated even before the component is created.\r\n             */\r\n            this.componentTypes = [];\r\n            /**\r\n             * Get a list of components registered to this application.\r\n             */\r\n            this.components = [];\r\n            this._enforceNoNewChanges = isDevMode();\r\n            this._zone.onMicrotaskEmpty.subscribe({ next: function () { _this._zone.run(function () { _this.tick(); }); } });\r\n            var isCurrentlyStable = new rxjs.Observable(function (observer) {\r\n                _this._stable = _this._zone.isStable && !_this._zone.hasPendingMacrotasks &&\r\n                    !_this._zone.hasPendingMicrotasks;\r\n                _this._zone.runOutsideAngular(function () {\r\n                    observer.next(_this._stable);\r\n                    observer.complete();\r\n                });\r\n            });\r\n            var isStable = new rxjs.Observable(function (observer) {\r\n                // Create the subscription to onStable outside the Angular Zone so that\r\n                // the callback is run outside the Angular Zone.\r\n                var stableSub;\r\n                _this._zone.runOutsideAngular(function () {\r\n                    stableSub = _this._zone.onStable.subscribe(function () {\r\n                        NgZone.assertNotInAngularZone();\r\n                        // Check whether there are no pending macro/micro tasks in the next tick\r\n                        // to allow for NgZone to update the state.\r\n                        scheduleMicroTask(function () {\r\n                            if (!_this._stable && !_this._zone.hasPendingMacrotasks &&\r\n                                !_this._zone.hasPendingMicrotasks) {\r\n                                _this._stable = true;\r\n                                observer.next(true);\r\n                            }\r\n                        });\r\n                    });\r\n                });\r\n                var unstableSub = _this._zone.onUnstable.subscribe(function () {\r\n                    NgZone.assertInAngularZone();\r\n                    if (_this._stable) {\r\n                        _this._stable = false;\r\n                        _this._zone.runOutsideAngular(function () { observer.next(false); });\r\n                    }\r\n                });\r\n                return function () {\r\n                    stableSub.unsubscribe();\r\n                    unstableSub.unsubscribe();\r\n                };\r\n            });\r\n            this.isStable =\r\n                rxjs.merge(isCurrentlyStable, isStable.pipe(operators.share()));\r\n        }\r\n        ApplicationRef_1 = ApplicationRef;\r\n        /**\r\n         * Bootstrap a new component at the root level of the application.\r\n         *\r\n         * @usageNotes\r\n         * ### Bootstrap process\r\n         *\r\n         * When bootstrapping a new root component into an application, Angular mounts the\r\n         * specified application component onto DOM elements identified by the componentType's\r\n         * selector and kicks off automatic change detection to finish initializing the component.\r\n         *\r\n         * Optionally, a component can be mounted onto a DOM element that does not match the\r\n         * componentType's selector.\r\n         *\r\n         * ### Example\r\n         * {@example core/ts/platform/platform.ts region='longform'}\r\n         */\r\n        ApplicationRef.prototype.bootstrap = function (componentOrFactory, rootSelectorOrNode) {\r\n            var _this = this;\r\n            if (!this._initStatus.done) {\r\n                throw new Error('Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');\r\n            }\r\n            var componentFactory;\r\n            if (componentOrFactory instanceof ComponentFactory) {\r\n                componentFactory = componentOrFactory;\r\n            }\r\n            else {\r\n                componentFactory =\r\n                    this._componentFactoryResolver.resolveComponentFactory(componentOrFactory);\r\n            }\r\n            this.componentTypes.push(componentFactory.componentType);\r\n            // Create a factory associated with the current module if it's not bound to some other\r\n            var ngModule = isBoundToModule(componentFactory) ? null : this._injector.get(NgModuleRef);\r\n            var selectorOrNode = rootSelectorOrNode || componentFactory.selector;\r\n            var compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);\r\n            compRef.onDestroy(function () { _this._unloadComponent(compRef); });\r\n            var testability = compRef.injector.get(Testability, null);\r\n            if (testability) {\r\n                compRef.injector.get(TestabilityRegistry)\r\n                    .registerApplication(compRef.location.nativeElement, testability);\r\n            }\r\n            this._loadComponent(compRef);\r\n            if (isDevMode()) {\r\n                this._console.log(\"Angular is running in the development mode. Call enableProdMode() to enable the production mode.\");\r\n            }\r\n            return compRef;\r\n        };\r\n        /**\r\n         * Invoke this method to explicitly process change detection and its side-effects.\r\n         *\r\n         * In development mode, `tick()` also performs a second change detection cycle to ensure that no\r\n         * further changes are detected. If additional changes are picked up during this second cycle,\r\n         * bindings in the app have side-effects that cannot be resolved in a single change detection\r\n         * pass.\r\n         * In this case, Angular throws an error, since an Angular application can only have one change\r\n         * detection pass during which all change detection must complete.\r\n         */\r\n        ApplicationRef.prototype.tick = function () {\r\n            var e_1, _a, e_2, _b;\r\n            var _this = this;\r\n            if (this._runningTick) {\r\n                throw new Error('ApplicationRef.tick is called recursively');\r\n            }\r\n            var scope = ApplicationRef_1._tickScope();\r\n            try {\r\n                this._runningTick = true;\r\n                try {\r\n                    for (var _c = __values(this._views), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                        var view = _d.value;\r\n                        view.detectChanges();\r\n                    }\r\n                }\r\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\r\n                    }\r\n                    finally { if (e_1) throw e_1.error; }\r\n                }\r\n                if (this._enforceNoNewChanges) {\r\n                    try {\r\n                        for (var _e = __values(this._views), _f = _e.next(); !_f.done; _f = _e.next()) {\r\n                            var view = _f.value;\r\n                            view.checkNoChanges();\r\n                        }\r\n                    }\r\n                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n                    finally {\r\n                        try {\r\n                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\r\n                        }\r\n                        finally { if (e_2) throw e_2.error; }\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n                // Attention: Don't rethrow as it could cancel subscriptions to Observables!\r\n                this._zone.runOutsideAngular(function () { return _this._exceptionHandler.handleError(e); });\r\n            }\r\n            finally {\r\n                this._runningTick = false;\r\n                wtfLeave(scope);\r\n            }\r\n        };\r\n        /**\r\n         * Attaches a view so that it will be dirty checked.\r\n         * The view will be automatically detached when it is destroyed.\r\n         * This will throw if the view is already attached to a ViewContainer.\r\n         */\r\n        ApplicationRef.prototype.attachView = function (viewRef) {\r\n            var view = viewRef;\r\n            this._views.push(view);\r\n            view.attachToAppRef(this);\r\n        };\r\n        /**\r\n         * Detaches a view from dirty checking again.\r\n         */\r\n        ApplicationRef.prototype.detachView = function (viewRef) {\r\n            var view = viewRef;\r\n            remove(this._views, view);\r\n            view.detachFromAppRef();\r\n        };\r\n        ApplicationRef.prototype._loadComponent = function (componentRef) {\r\n            this.attachView(componentRef.hostView);\r\n            this.tick();\r\n            this.components.push(componentRef);\r\n            // Get the listeners lazily to prevent DI cycles.\r\n            var listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners);\r\n            listeners.forEach(function (listener) { return listener(componentRef); });\r\n        };\r\n        ApplicationRef.prototype._unloadComponent = function (componentRef) {\r\n            this.detachView(componentRef.hostView);\r\n            remove(this.components, componentRef);\r\n        };\r\n        /** @internal */\r\n        ApplicationRef.prototype.ngOnDestroy = function () {\r\n            // TODO(alxhub): Dispose of the NgZone.\r\n            this._views.slice().forEach(function (view) { return view.destroy(); });\r\n        };\r\n        Object.defineProperty(ApplicationRef.prototype, \"viewCount\", {\r\n            /**\r\n             * Returns the number of attached views.\r\n             */\r\n            get: function () { return this._views.length; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        var ApplicationRef_1;\r\n        /** @internal */\r\n        ApplicationRef._tickScope = wtfCreateScope('ApplicationRef#tick()');\r\n        ApplicationRef = ApplicationRef_1 = __decorate([\r\n            Injectable(),\r\n            __metadata(\"design:paramtypes\", [NgZone, Console, Injector,\r\n                ErrorHandler,\r\n                ComponentFactoryResolver,\r\n                ApplicationInitStatus])\r\n        ], ApplicationRef);\r\n        return ApplicationRef;\r\n    }());\r\n    function remove(list, el) {\r\n        var index = list.indexOf(el);\r\n        if (index > -1) {\r\n            list.splice(index, 1);\r\n        }\r\n    }\r\n    function _mergeArrays(parts) {\r\n        var result = [];\r\n        parts.forEach(function (part) { return part && result.push.apply(result, __spread(part)); });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Used to load ng module factories.\r\n     *\r\n     * @publicApi\r\n     * @deprecated the `string` form of `loadChildren` is deprecated, and `NgModuleFactoryLoader` is\r\n     * part of its implementation. See `LoadChildren` for more details.\r\n     */\r\n    var NgModuleFactoryLoader = /** @class */ (function () {\r\n        function NgModuleFactoryLoader() {\r\n        }\r\n        return NgModuleFactoryLoader;\r\n    }());\r\n    function getModuleFactory__PRE_R3__(id) {\r\n        var factory = getRegisteredNgModuleType(id);\r\n        if (!factory)\r\n            throw noModuleError(id);\r\n        return factory;\r\n    }\r\n    function getModuleFactory__POST_R3__(id) {\r\n        var type = getRegisteredNgModuleType(id);\r\n        if (!type)\r\n            throw noModuleError(id);\r\n        return new NgModuleFactory$1(type);\r\n    }\r\n    /**\r\n     * Returns the NgModuleFactory with the given id, if it exists and has been loaded.\r\n     * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module\r\n     * cannot be found.\r\n     * @publicApi\r\n     */\r\n    var getModuleFactory = getModuleFactory__PRE_R3__;\r\n    function noModuleError(id) {\r\n        return new Error(\"No module with ID \" + id + \" loaded\");\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var _SEPARATOR = '#';\r\n    var FACTORY_CLASS_SUFFIX = 'NgFactory';\r\n    /**\r\n     * Configuration for SystemJsNgModuleLoader.\r\n     * token.\r\n     *\r\n     * @publicApi\r\n     * @deprecated the `string` form of `loadChildren` is deprecated, and `SystemJsNgModuleLoaderConfig`\r\n     * is part of its implementation. See `LoadChildren` for more details.\r\n     */\r\n    var SystemJsNgModuleLoaderConfig = /** @class */ (function () {\r\n        function SystemJsNgModuleLoaderConfig() {\r\n        }\r\n        return SystemJsNgModuleLoaderConfig;\r\n    }());\r\n    var DEFAULT_CONFIG = {\r\n        factoryPathPrefix: '',\r\n        factoryPathSuffix: '.ngfactory',\r\n    };\r\n    /**\r\n     * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory\r\n     * @publicApi\r\n     * @deprecated the `string` form of `loadChildren` is deprecated, and `SystemJsNgModuleLoader` is\r\n     * part of its implementation. See `LoadChildren` for more details.\r\n     */\r\n    var SystemJsNgModuleLoader = /** @class */ (function () {\r\n        function SystemJsNgModuleLoader(_compiler, config) {\r\n            this._compiler = _compiler;\r\n            this._config = config || DEFAULT_CONFIG;\r\n        }\r\n        SystemJsNgModuleLoader.prototype.load = function (path) {\r\n            var legacyOfflineMode = !ivyEnabled && this._compiler instanceof Compiler;\r\n            return legacyOfflineMode ? this.loadFactory(path) : this.loadAndCompile(path);\r\n        };\r\n        SystemJsNgModuleLoader.prototype.loadAndCompile = function (path) {\r\n            var _this = this;\r\n            var _a = __read(path.split(_SEPARATOR), 2), module = _a[0], exportName = _a[1];\r\n            if (exportName === undefined) {\r\n                exportName = 'default';\r\n            }\r\n            return System.import(module)\r\n                .then(function (module) { return module[exportName]; })\r\n                .then(function (type) { return checkNotEmpty(type, module, exportName); })\r\n                .then(function (type) { return _this._compiler.compileModuleAsync(type); });\r\n        };\r\n        SystemJsNgModuleLoader.prototype.loadFactory = function (path) {\r\n            var _a = __read(path.split(_SEPARATOR), 2), module = _a[0], exportName = _a[1];\r\n            var factoryClassSuffix = FACTORY_CLASS_SUFFIX;\r\n            if (exportName === undefined) {\r\n                exportName = 'default';\r\n                factoryClassSuffix = '';\r\n            }\r\n            return System.import(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix)\r\n                .then(function (module) { return module[exportName + factoryClassSuffix]; })\r\n                .then(function (factory) { return checkNotEmpty(factory, module, exportName); });\r\n        };\r\n        SystemJsNgModuleLoader = __decorate([\r\n            Injectable(),\r\n            __param(1, Optional()),\r\n            __metadata(\"design:paramtypes\", [Compiler, SystemJsNgModuleLoaderConfig])\r\n        ], SystemJsNgModuleLoader);\r\n        return SystemJsNgModuleLoader;\r\n    }());\r\n    function checkNotEmpty(value, modulePath, exportName) {\r\n        if (!value) {\r\n            throw new Error(\"Cannot find '\" + exportName + \"' in '\" + modulePath + \"'\");\r\n        }\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Represents an Angular [view](guide/glossary#view),\r\n     * specifically the [host view](guide/glossary#view-tree) that is defined by a component.\r\n     * Also serves as the base class\r\n     * that adds destroy methods for [embedded views](guide/glossary#view-tree).\r\n     *\r\n     * @see `EmbeddedViewRef`\r\n     *\r\n     * @publicApi\r\n     */\r\n    var ViewRef$1 = /** @class */ (function (_super) {\r\n        __extends(ViewRef, _super);\r\n        function ViewRef() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        return ViewRef;\r\n    }(ChangeDetectorRef));\r\n    /**\r\n     * Represents an Angular [view](guide/glossary#view) in a view container.\r\n     * An [embedded view](guide/glossary#view-tree) can be referenced from a component\r\n     * other than the hosting component whose template defines it, or it can be defined\r\n     * independently by a `TemplateRef`.\r\n     *\r\n     * Properties of elements in a view can change, but the structure (number and order) of elements in\r\n     * a view cannot. Change the structure of elements by inserting, moving, or\r\n     * removing nested views in a view container.\r\n     *\r\n     * @see `ViewContainerRef`\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * The following template breaks down into two separate `TemplateRef` instances,\r\n     * an outer one and an inner one.\r\n     *\r\n     * ```\r\n     * Count: {{items.length}}\r\n     * <ul>\r\n     *   <li *ngFor=\"let  item of items\">{{item}}</li>\r\n     * </ul>\r\n     * ```\r\n     *\r\n     * This is the outer `TemplateRef`:\r\n     *\r\n     * ```\r\n     * Count: {{items.length}}\r\n     * <ul>\r\n     *   <ng-template ngFor let-item [ngForOf]=\"items\"></ng-template>\r\n     * </ul>\r\n     * ```\r\n     *\r\n     * This is the inner `TemplateRef`:\r\n     *\r\n     * ```\r\n     *   <li>{{item}}</li>\r\n     * ```\r\n     *\r\n     * The outer and inner `TemplateRef` instances are assembled into views as follows:\r\n     *\r\n     * ```\r\n     * <!-- ViewRef: outer-0 -->\r\n     * Count: 2\r\n     * <ul>\r\n     *   <ng-template view-container-ref></ng-template>\r\n     *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->\r\n     *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->\r\n     * </ul>\r\n     * <!-- /ViewRef: outer-0 -->\r\n     * ```\r\n     * @publicApi\r\n     */\r\n    var EmbeddedViewRef = /** @class */ (function (_super) {\r\n        __extends(EmbeddedViewRef, _super);\r\n        function EmbeddedViewRef() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        return EmbeddedViewRef;\r\n    }(ViewRef$1));\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * @publicApi\r\n     */\r\n    var DebugEventListener = /** @class */ (function () {\r\n        function DebugEventListener(name, callback) {\r\n            this.name = name;\r\n            this.callback = callback;\r\n        }\r\n        return DebugEventListener;\r\n    }());\r\n    var DebugNode__PRE_R3__ = /** @class */ (function () {\r\n        function DebugNode__PRE_R3__(nativeNode, parent, _debugContext) {\r\n            this.listeners = [];\r\n            this.parent = null;\r\n            this._debugContext = _debugContext;\r\n            this.nativeNode = nativeNode;\r\n            if (parent && parent instanceof DebugElement__PRE_R3__) {\r\n                parent.addChild(this);\r\n            }\r\n        }\r\n        Object.defineProperty(DebugNode__PRE_R3__.prototype, \"injector\", {\r\n            get: function () { return this._debugContext.injector; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugNode__PRE_R3__.prototype, \"componentInstance\", {\r\n            get: function () { return this._debugContext.component; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugNode__PRE_R3__.prototype, \"context\", {\r\n            get: function () { return this._debugContext.context; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugNode__PRE_R3__.prototype, \"references\", {\r\n            get: function () { return this._debugContext.references; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugNode__PRE_R3__.prototype, \"providerTokens\", {\r\n            get: function () { return this._debugContext.providerTokens; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return DebugNode__PRE_R3__;\r\n    }());\r\n    var DebugElement__PRE_R3__ = /** @class */ (function (_super) {\r\n        __extends(DebugElement__PRE_R3__, _super);\r\n        function DebugElement__PRE_R3__(nativeNode, parent, _debugContext) {\r\n            var _this = _super.call(this, nativeNode, parent, _debugContext) || this;\r\n            _this.properties = {};\r\n            _this.attributes = {};\r\n            _this.classes = {};\r\n            _this.styles = {};\r\n            _this.childNodes = [];\r\n            _this.nativeElement = nativeNode;\r\n            return _this;\r\n        }\r\n        DebugElement__PRE_R3__.prototype.addChild = function (child) {\r\n            if (child) {\r\n                this.childNodes.push(child);\r\n                child.parent = this;\r\n            }\r\n        };\r\n        DebugElement__PRE_R3__.prototype.removeChild = function (child) {\r\n            var childIndex = this.childNodes.indexOf(child);\r\n            if (childIndex !== -1) {\r\n                child.parent = null;\r\n                this.childNodes.splice(childIndex, 1);\r\n            }\r\n        };\r\n        DebugElement__PRE_R3__.prototype.insertChildrenAfter = function (child, newChildren) {\r\n            var _a;\r\n            var _this = this;\r\n            var siblingIndex = this.childNodes.indexOf(child);\r\n            if (siblingIndex !== -1) {\r\n                (_a = this.childNodes).splice.apply(_a, __spread([siblingIndex + 1, 0], newChildren));\r\n                newChildren.forEach(function (c) {\r\n                    if (c.parent) {\r\n                        c.parent.removeChild(c);\r\n                    }\r\n                    child.parent = _this;\r\n                });\r\n            }\r\n        };\r\n        DebugElement__PRE_R3__.prototype.insertBefore = function (refChild, newChild) {\r\n            var refIndex = this.childNodes.indexOf(refChild);\r\n            if (refIndex === -1) {\r\n                this.addChild(newChild);\r\n            }\r\n            else {\r\n                if (newChild.parent) {\r\n                    newChild.parent.removeChild(newChild);\r\n                }\r\n                newChild.parent = this;\r\n                this.childNodes.splice(refIndex, 0, newChild);\r\n            }\r\n        };\r\n        DebugElement__PRE_R3__.prototype.query = function (predicate) {\r\n            var results = this.queryAll(predicate);\r\n            return results[0] || null;\r\n        };\r\n        DebugElement__PRE_R3__.prototype.queryAll = function (predicate) {\r\n            var matches = [];\r\n            _queryElementChildren(this, predicate, matches);\r\n            return matches;\r\n        };\r\n        DebugElement__PRE_R3__.prototype.queryAllNodes = function (predicate) {\r\n            var matches = [];\r\n            _queryNodeChildren(this, predicate, matches);\r\n            return matches;\r\n        };\r\n        Object.defineProperty(DebugElement__PRE_R3__.prototype, \"children\", {\r\n            get: function () {\r\n                return this\r\n                    .childNodes //\r\n                    .filter(function (node) { return node instanceof DebugElement__PRE_R3__; });\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        DebugElement__PRE_R3__.prototype.triggerEventHandler = function (eventName, eventObj) {\r\n            this.listeners.forEach(function (listener) {\r\n                if (listener.name == eventName) {\r\n                    listener.callback(eventObj);\r\n                }\r\n            });\r\n        };\r\n        return DebugElement__PRE_R3__;\r\n    }(DebugNode__PRE_R3__));\r\n    /**\r\n     * @publicApi\r\n     */\r\n    function asNativeElements(debugEls) {\r\n        return debugEls.map(function (el) { return el.nativeElement; });\r\n    }\r\n    function _queryElementChildren(element, predicate, matches) {\r\n        element.childNodes.forEach(function (node) {\r\n            if (node instanceof DebugElement__PRE_R3__) {\r\n                if (predicate(node)) {\r\n                    matches.push(node);\r\n                }\r\n                _queryElementChildren(node, predicate, matches);\r\n            }\r\n        });\r\n    }\r\n    function _queryNodeChildren(parentNode, predicate, matches) {\r\n        if (parentNode instanceof DebugElement__PRE_R3__) {\r\n            parentNode.childNodes.forEach(function (node) {\r\n                if (predicate(node)) {\r\n                    matches.push(node);\r\n                }\r\n                if (node instanceof DebugElement__PRE_R3__) {\r\n                    _queryNodeChildren(node, predicate, matches);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    var DebugNode__POST_R3__ = /** @class */ (function () {\r\n        function DebugNode__POST_R3__(nativeNode) {\r\n            this.nativeNode = nativeNode;\r\n        }\r\n        Object.defineProperty(DebugNode__POST_R3__.prototype, \"parent\", {\r\n            get: function () {\r\n                var parent = this.nativeNode.parentNode;\r\n                return parent ? new DebugElement__POST_R3__(parent) : null;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugNode__POST_R3__.prototype, \"injector\", {\r\n            get: function () { return getInjector(this.nativeNode); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugNode__POST_R3__.prototype, \"componentInstance\", {\r\n            get: function () {\r\n                var nativeElement = this.nativeNode;\r\n                return nativeElement &&\r\n                    (getComponent(nativeElement) || getViewComponent(nativeElement));\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugNode__POST_R3__.prototype, \"context\", {\r\n            get: function () {\r\n                return getComponent(this.nativeNode) || getContext$1(this.nativeNode);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugNode__POST_R3__.prototype, \"listeners\", {\r\n            get: function () {\r\n                return getListeners(this.nativeNode).filter(isBrowserEvents);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugNode__POST_R3__.prototype, \"references\", {\r\n            get: function () { return getLocalRefs(this.nativeNode); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugNode__POST_R3__.prototype, \"providerTokens\", {\r\n            get: function () { return getInjectionTokens(this.nativeNode); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return DebugNode__POST_R3__;\r\n    }());\r\n    var DebugElement__POST_R3__ = /** @class */ (function (_super) {\r\n        __extends(DebugElement__POST_R3__, _super);\r\n        function DebugElement__POST_R3__(nativeNode) {\r\n            var _this = this;\r\n            ngDevMode && assertDomNode(nativeNode);\r\n            _this = _super.call(this, nativeNode) || this;\r\n            return _this;\r\n        }\r\n        Object.defineProperty(DebugElement__POST_R3__.prototype, \"nativeElement\", {\r\n            get: function () {\r\n                return this.nativeNode.nodeType == Node.ELEMENT_NODE ? this.nativeNode : null;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugElement__POST_R3__.prototype, \"name\", {\r\n            get: function () { return this.nativeElement.nodeName; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugElement__POST_R3__.prototype, \"properties\", {\r\n            /**\r\n             *  Gets a map of property names to property values for an element.\r\n             *\r\n             *  This map includes:\r\n             *  - Regular property bindings (e.g. `[id]=\"id\"`)\r\n             *  - Host property bindings (e.g. `host: { '[id]': \"id\" }`)\r\n             *  - Interpolated property bindings (e.g. `id=\"{{ value }}\")\r\n             *\r\n             *  It does not include:\r\n             *  - input property bindings (e.g. `[myCustomInput]=\"value\"`)\r\n             *  - attribute bindings (e.g. `[attr.role]=\"menu\"`)\r\n             */\r\n            get: function () {\r\n                var context = loadLContext(this.nativeNode);\r\n                var lView = context.lView;\r\n                var tData = lView[TVIEW].data;\r\n                var tNode = tData[context.nodeIndex];\r\n                var properties = collectPropertyBindings(tNode, lView, tData);\r\n                var hostProperties = collectHostPropertyBindings(tNode, lView, tData);\r\n                var className = collectClassNames(this);\r\n                var output = __assign({}, properties, hostProperties);\r\n                if (className) {\r\n                    output['className'] = output['className'] ? output['className'] + (\" \" + className) : className;\r\n                }\r\n                return output;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugElement__POST_R3__.prototype, \"attributes\", {\r\n            get: function () {\r\n                var attributes = {};\r\n                var element = this.nativeElement;\r\n                if (!element) {\r\n                    return attributes;\r\n                }\r\n                var context = loadLContext(element);\r\n                var lView = context.lView;\r\n                var tNodeAttrs = lView[TVIEW].data[context.nodeIndex].attrs;\r\n                var lowercaseTNodeAttrs = [];\r\n                // For debug nodes we take the element's attribute directly from the DOM since it allows us\r\n                // to account for ones that weren't set via bindings (e.g. ViewEngine keeps track of the ones\r\n                // that are set through `Renderer2`). The problem is that the browser will lowercase all names,\r\n                // however since we have the attributes already on the TNode, we can preserve the case by going\r\n                // through them once, adding them to the `attributes` map and putting their lower-cased name\r\n                // into an array. Afterwards when we're going through the native DOM attributes, we can check\r\n                // whether we haven't run into an attribute already through the TNode.\r\n                if (tNodeAttrs) {\r\n                    var i = 0;\r\n                    while (i < tNodeAttrs.length) {\r\n                        var attrName = tNodeAttrs[i];\r\n                        // Stop as soon as we hit a marker. We only care about the regular attributes. Everything\r\n                        // else will be handled below when we read the final attributes off the DOM.\r\n                        if (typeof attrName !== 'string')\r\n                            break;\r\n                        var attrValue = tNodeAttrs[i + 1];\r\n                        attributes[attrName] = attrValue;\r\n                        lowercaseTNodeAttrs.push(attrName.toLowerCase());\r\n                        i += 2;\r\n                    }\r\n                }\r\n                var eAttrs = element.attributes;\r\n                for (var i = 0; i < eAttrs.length; i++) {\r\n                    var attr = eAttrs[i];\r\n                    // Make sure that we don't assign the same attribute both in its\r\n                    // case-sensitive form and the lower-cased one from the browser.\r\n                    if (lowercaseTNodeAttrs.indexOf(attr.name) === -1) {\r\n                        attributes[attr.name] = attr.value;\r\n                    }\r\n                }\r\n                return attributes;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugElement__POST_R3__.prototype, \"styles\", {\r\n            get: function () {\r\n                return _getStylingDebugInfo(this.nativeElement, false);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugElement__POST_R3__.prototype, \"classes\", {\r\n            get: function () {\r\n                return _getStylingDebugInfo(this.nativeElement, true);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugElement__POST_R3__.prototype, \"childNodes\", {\r\n            get: function () {\r\n                var childNodes = this.nativeNode.childNodes;\r\n                var children = [];\r\n                for (var i = 0; i < childNodes.length; i++) {\r\n                    var element = childNodes[i];\r\n                    children.push(getDebugNode__POST_R3__(element));\r\n                }\r\n                return children;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugElement__POST_R3__.prototype, \"children\", {\r\n            get: function () {\r\n                var nativeElement = this.nativeElement;\r\n                if (!nativeElement)\r\n                    return [];\r\n                var childNodes = nativeElement.children;\r\n                var children = [];\r\n                for (var i = 0; i < childNodes.length; i++) {\r\n                    var element = childNodes[i];\r\n                    children.push(getDebugNode__POST_R3__(element));\r\n                }\r\n                return children;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        DebugElement__POST_R3__.prototype.query = function (predicate) {\r\n            var results = this.queryAll(predicate);\r\n            return results[0] || null;\r\n        };\r\n        DebugElement__POST_R3__.prototype.queryAll = function (predicate) {\r\n            var matches = [];\r\n            _queryAllR3(this, predicate, matches, true);\r\n            return matches;\r\n        };\r\n        DebugElement__POST_R3__.prototype.queryAllNodes = function (predicate) {\r\n            var matches = [];\r\n            _queryAllR3(this, predicate, matches, false);\r\n            return matches;\r\n        };\r\n        DebugElement__POST_R3__.prototype.triggerEventHandler = function (eventName, eventObj) {\r\n            this.listeners.forEach(function (listener) {\r\n                if (listener.name === eventName) {\r\n                    listener.callback(eventObj);\r\n                }\r\n            });\r\n        };\r\n        return DebugElement__POST_R3__;\r\n    }(DebugNode__POST_R3__));\r\n    function _getStylingDebugInfo(element, isClassBased) {\r\n        if (element) {\r\n            var context = loadLContextFromNode(element);\r\n            var lView = context.lView;\r\n            var tData = lView[TVIEW].data;\r\n            var tNode = tData[context.nodeIndex];\r\n            if (isClassBased) {\r\n                return isStylingContext(tNode.classes) ?\r\n                    new NodeStylingDebug(tNode.classes, lView, true).values :\r\n                    stylingMapToStringMap(tNode.classes);\r\n            }\r\n            else {\r\n                return isStylingContext(tNode.styles) ?\r\n                    new NodeStylingDebug(tNode.styles, lView, false).values :\r\n                    stylingMapToStringMap(tNode.styles);\r\n            }\r\n        }\r\n        return {};\r\n    }\r\n    function _queryAllR3(parentElement, predicate, matches, elementsOnly) {\r\n        var context = loadLContext(parentElement.nativeNode);\r\n        var parentTNode = context.lView[TVIEW].data[context.nodeIndex];\r\n        _queryNodeChildrenR3(parentTNode, context.lView, predicate, matches, elementsOnly, parentElement.nativeNode);\r\n    }\r\n    /**\r\n     * Recursively match the current TNode against the predicate, and goes on with the next ones.\r\n     *\r\n     * @param tNode the current TNode\r\n     * @param lView the LView of this TNode\r\n     * @param predicate the predicate to match\r\n     * @param matches the list of positive matches\r\n     * @param elementsOnly whether only elements should be searched\r\n     * @param rootNativeNode the root native node on which predicate should not be matched\r\n     */\r\n    function _queryNodeChildrenR3(tNode, lView, predicate, matches, elementsOnly, rootNativeNode) {\r\n        var e_1, _a;\r\n        var nativeNode = getNativeByTNodeOrNull(tNode, lView);\r\n        // For each type of TNode, specific logic is executed.\r\n        if (tNode.type === 3 /* Element */ || tNode.type === 4 /* ElementContainer */) {\r\n            // Case 1: the TNode is an element\r\n            // The native node has to be checked.\r\n            _addQueryMatchR3(nativeNode, predicate, matches, elementsOnly, rootNativeNode);\r\n            if (isComponent(tNode)) {\r\n                // If the element is the host of a component, then all nodes in its view have to be processed.\r\n                // Note: the component's content (tNode.child) will be processed from the insertion points.\r\n                var componentView = getComponentViewByIndex(tNode.index, lView);\r\n                if (componentView && componentView[TVIEW].firstChild) {\r\n                    _queryNodeChildrenR3(componentView[TVIEW].firstChild, componentView, predicate, matches, elementsOnly, rootNativeNode);\r\n                }\r\n            }\r\n            else {\r\n                if (tNode.child) {\r\n                    // Otherwise, its children have to be processed.\r\n                    _queryNodeChildrenR3(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);\r\n                }\r\n                // We also have to query the DOM directly in order to catch elements inserted through\r\n                // Renderer2. Note that this is __not__ optimal, because we're walking similar trees multiple\r\n                // times. ViewEngine could do it more efficiently, because all the insertions go through\r\n                // Renderer2, however that's not the case in Ivy. This approach is being used because:\r\n                // 1. Matching the ViewEngine behavior would mean potentially introducing a depedency\r\n                //    from `Renderer2` to Ivy which could bring Ivy code into ViewEngine.\r\n                // 2. We would have to make `Renderer3` \"know\" about debug nodes.\r\n                // 3. It allows us to capture nodes that were inserted directly via the DOM.\r\n                nativeNode && _queryNativeNodeDescendants(nativeNode, predicate, matches, elementsOnly);\r\n            }\r\n            // In all cases, if a dynamic container exists for this node, each view inside it has to be\r\n            // processed.\r\n            var nodeOrContainer = lView[tNode.index];\r\n            if (isLContainer(nodeOrContainer)) {\r\n                _queryNodeChildrenInContainerR3(nodeOrContainer, predicate, matches, elementsOnly, rootNativeNode);\r\n            }\r\n        }\r\n        else if (tNode.type === 0 /* Container */) {\r\n            // Case 2: the TNode is a container\r\n            // The native node has to be checked.\r\n            var lContainer = lView[tNode.index];\r\n            _addQueryMatchR3(lContainer[NATIVE], predicate, matches, elementsOnly, rootNativeNode);\r\n            // Each view inside the container has to be processed.\r\n            _queryNodeChildrenInContainerR3(lContainer, predicate, matches, elementsOnly, rootNativeNode);\r\n        }\r\n        else if (tNode.type === 1 /* Projection */) {\r\n            // Case 3: the TNode is a projection insertion point (i.e. a <ng-content>).\r\n            // The nodes projected at this location all need to be processed.\r\n            var componentView = findComponentView(lView);\r\n            var componentHost = componentView[T_HOST];\r\n            var head = componentHost.projection[tNode.projection];\r\n            if (Array.isArray(head)) {\r\n                try {\r\n                    for (var head_1 = __values(head), head_1_1 = head_1.next(); !head_1_1.done; head_1_1 = head_1.next()) {\r\n                        var nativeNode_1 = head_1_1.value;\r\n                        _addQueryMatchR3(nativeNode_1, predicate, matches, elementsOnly, rootNativeNode);\r\n                    }\r\n                }\r\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (head_1_1 && !head_1_1.done && (_a = head_1.return)) _a.call(head_1);\r\n                    }\r\n                    finally { if (e_1) throw e_1.error; }\r\n                }\r\n            }\r\n            else if (head) {\r\n                var nextLView = componentView[PARENT];\r\n                var nextTNode = nextLView[TVIEW].data[head.index];\r\n                _queryNodeChildrenR3(nextTNode, nextLView, predicate, matches, elementsOnly, rootNativeNode);\r\n            }\r\n        }\r\n        else if (tNode.child) {\r\n            // Case 4: the TNode is a view.\r\n            _queryNodeChildrenR3(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);\r\n        }\r\n        // We don't want to go to the next sibling of the root node.\r\n        if (rootNativeNode !== nativeNode) {\r\n            // To determine the next node to be processed, we need to use the next or the projectionNext\r\n            // link, depending on whether the current node has been projected.\r\n            var nextTNode = (tNode.flags & 2 /* isProjected */) ? tNode.projectionNext : tNode.next;\r\n            if (nextTNode) {\r\n                _queryNodeChildrenR3(nextTNode, lView, predicate, matches, elementsOnly, rootNativeNode);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Process all TNodes in a given container.\r\n     *\r\n     * @param lContainer the container to be processed\r\n     * @param predicate the predicate to match\r\n     * @param matches the list of positive matches\r\n     * @param elementsOnly whether only elements should be searched\r\n     * @param rootNativeNode the root native node on which predicate should not be matched\r\n     */\r\n    function _queryNodeChildrenInContainerR3(lContainer, predicate, matches, elementsOnly, rootNativeNode) {\r\n        for (var i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\r\n            var childView = lContainer[i];\r\n            _queryNodeChildrenR3(childView[TVIEW].node, childView, predicate, matches, elementsOnly, rootNativeNode);\r\n        }\r\n    }\r\n    /**\r\n     * Match the current native node against the predicate.\r\n     *\r\n     * @param nativeNode the current native node\r\n     * @param predicate the predicate to match\r\n     * @param matches the list of positive matches\r\n     * @param elementsOnly whether only elements should be searched\r\n     * @param rootNativeNode the root native node on which predicate should not be matched\r\n     */\r\n    function _addQueryMatchR3(nativeNode, predicate, matches, elementsOnly, rootNativeNode) {\r\n        if (rootNativeNode !== nativeNode) {\r\n            var debugNode = getDebugNode(nativeNode);\r\n            if (!debugNode) {\r\n                return;\r\n            }\r\n            // Type of the \"predicate and \"matches\" array are set based on the value of\r\n            // the \"elementsOnly\" parameter. TypeScript is not able to properly infer these\r\n            // types with generics, so we manually cast the parameters accordingly.\r\n            if (elementsOnly && debugNode instanceof DebugElement__POST_R3__ && predicate(debugNode) &&\r\n                matches.indexOf(debugNode) === -1) {\r\n                matches.push(debugNode);\r\n            }\r\n            else if (!elementsOnly && predicate(debugNode) &&\r\n                matches.indexOf(debugNode) === -1) {\r\n                matches.push(debugNode);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Match all the descendants of a DOM node against a predicate.\r\n     *\r\n     * @param nativeNode the current native node\r\n     * @param predicate the predicate to match\r\n     * @param matches the list of positive matches\r\n     * @param elementsOnly whether only elements should be searched\r\n     */\r\n    function _queryNativeNodeDescendants(parentNode, predicate, matches, elementsOnly) {\r\n        var nodes = parentNode.childNodes;\r\n        var length = nodes.length;\r\n        for (var i = 0; i < length; i++) {\r\n            var node = nodes[i];\r\n            var debugNode = getDebugNode(node);\r\n            if (debugNode) {\r\n                if (elementsOnly && debugNode instanceof DebugElement__POST_R3__ && predicate(debugNode) &&\r\n                    matches.indexOf(debugNode) === -1) {\r\n                    matches.push(debugNode);\r\n                }\r\n                else if (!elementsOnly && predicate(debugNode) &&\r\n                    matches.indexOf(debugNode) === -1) {\r\n                    matches.push(debugNode);\r\n                }\r\n                _queryNativeNodeDescendants(node, predicate, matches, elementsOnly);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Iterates through the property bindings for a given node and generates\r\n     * a map of property names to values. This map only contains property bindings\r\n     * defined in templates, not in host bindings.\r\n     */\r\n    function collectPropertyBindings(tNode, lView, tData) {\r\n        var properties = {};\r\n        var bindingIndex = getFirstBindingIndex(tNode.propertyMetadataStartIndex, tData);\r\n        while (bindingIndex < tNode.propertyMetadataEndIndex) {\r\n            var value = void 0;\r\n            var propMetadata = tData[bindingIndex];\r\n            while (!isPropMetadataString(propMetadata)) {\r\n                // This is the first value for an interpolation. We need to build up\r\n                // the full interpolation by combining runtime values in LView with\r\n                // the static interstitial values stored in TData.\r\n                value = (value || '') + renderStringify(lView[bindingIndex]) + tData[bindingIndex];\r\n                propMetadata = tData[++bindingIndex];\r\n            }\r\n            value = value === undefined ? lView[bindingIndex] : value += lView[bindingIndex];\r\n            // Property metadata string has 3 parts: property name, prefix, and suffix\r\n            var metadataParts = propMetadata.split(INTERPOLATION_DELIMITER);\r\n            var propertyName = metadataParts[0];\r\n            // Attr bindings don't have property names and should be skipped\r\n            if (propertyName) {\r\n                // Wrap value with prefix and suffix (will be '' for normal bindings), if they're defined.\r\n                // Avoid wrapping for normal bindings so that the value doesn't get cast to a string.\r\n                properties[propertyName] = (metadataParts[1] && metadataParts[2]) ?\r\n                    metadataParts[1] + value + metadataParts[2] :\r\n                    value;\r\n            }\r\n            bindingIndex++;\r\n        }\r\n        return properties;\r\n    }\r\n    /**\r\n     * Retrieves the first binding index that holds values for this property\r\n     * binding.\r\n     *\r\n     * For normal bindings (e.g. `[id]=\"id\"`), the binding index is the\r\n     * same as the metadata index. For interpolations (e.g. `id=\"{{id}}-{{name}}\"`),\r\n     * there can be multiple binding values, so we might have to loop backwards\r\n     * from the metadata index until we find the first one.\r\n     *\r\n     * @param metadataIndex The index of the first property metadata string for\r\n     * this node.\r\n     * @param tData The data array for the current TView\r\n     * @returns The first binding index for this binding\r\n     */\r\n    function getFirstBindingIndex(metadataIndex, tData) {\r\n        var currentBindingIndex = metadataIndex - 1;\r\n        // If the slot before the metadata holds a string, we know that this\r\n        // metadata applies to an interpolation with at least 2 bindings, and\r\n        // we need to search further to access the first binding value.\r\n        var currentValue = tData[currentBindingIndex];\r\n        // We need to iterate until we hit either a:\r\n        // - TNode (it is an element slot marking the end of `consts` section), OR a\r\n        // - metadata string (slot is attribute metadata or a previous node's property metadata)\r\n        while (typeof currentValue === 'string' && !isPropMetadataString(currentValue)) {\r\n            currentValue = tData[--currentBindingIndex];\r\n        }\r\n        return currentBindingIndex + 1;\r\n    }\r\n    function collectHostPropertyBindings(tNode, lView, tData) {\r\n        var properties = {};\r\n        // Host binding values for a node are stored after directives on that node\r\n        var hostPropIndex = tNode.directiveEnd;\r\n        var propMetadata = tData[hostPropIndex];\r\n        // When we reach a value in TView.data that is not a string, we know we've\r\n        // hit the next node's providers and directives and should stop copying data.\r\n        while (typeof propMetadata === 'string') {\r\n            var propertyName = propMetadata.split(INTERPOLATION_DELIMITER)[0];\r\n            properties[propertyName] = lView[hostPropIndex];\r\n            propMetadata = tData[++hostPropIndex];\r\n        }\r\n        return properties;\r\n    }\r\n    function collectClassNames(debugElement) {\r\n        var e_2, _a;\r\n        var classes = debugElement.classes;\r\n        var output = '';\r\n        try {\r\n            for (var _b = __values(Object.keys(classes)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var className = _c.value;\r\n                if (classes[className]) {\r\n                    output = output ? output + (\" \" + className) : className;\r\n                }\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        return output;\r\n    }\r\n    // Need to keep the nodes in a global Map so that multiple angular apps are supported.\r\n    var _nativeNodeToDebugNode = new Map();\r\n    function getDebugNode__PRE_R3__(nativeNode) {\r\n        return _nativeNodeToDebugNode.get(nativeNode) || null;\r\n    }\r\n    var NG_DEBUG_PROPERTY = '__ng_debug__';\r\n    function getDebugNode__POST_R3__(nativeNode) {\r\n        if (nativeNode instanceof Node) {\r\n            if (!(nativeNode.hasOwnProperty(NG_DEBUG_PROPERTY))) {\r\n                nativeNode[NG_DEBUG_PROPERTY] = nativeNode.nodeType == Node.ELEMENT_NODE ?\r\n                    new DebugElement__POST_R3__(nativeNode) :\r\n                    new DebugNode__POST_R3__(nativeNode);\r\n            }\r\n            return nativeNode[NG_DEBUG_PROPERTY];\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * @publicApi\r\n     */\r\n    var getDebugNode = getDebugNode__PRE_R3__;\r\n    function getAllDebugNodes() {\r\n        return Array.from(_nativeNodeToDebugNode.values());\r\n    }\r\n    function indexDebugNode(node) {\r\n        _nativeNodeToDebugNode.set(node.nativeNode, node);\r\n    }\r\n    function removeDebugNodeFromIndex(node) {\r\n        _nativeNodeToDebugNode.delete(node.nativeNode);\r\n    }\r\n    /**\r\n     * @publicApi\r\n     */\r\n    var DebugNode = DebugNode__PRE_R3__;\r\n    /**\r\n     * @publicApi\r\n     */\r\n    var DebugElement = DebugElement__PRE_R3__;\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var _CORE_PLATFORM_PROVIDERS = [\r\n        // Set a default platform name for platforms that don't set it explicitly.\r\n        { provide: PLATFORM_ID, useValue: 'unknown' },\r\n        { provide: PlatformRef, deps: [Injector] },\r\n        { provide: TestabilityRegistry, deps: [] },\r\n        { provide: Console, deps: [] },\r\n    ];\r\n    /**\r\n     * This platform has to be included in any other platform\r\n     *\r\n     * @publicApi\r\n     */\r\n    var platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function _iterableDiffersFactory() {\r\n        return defaultIterableDiffers;\r\n    }\r\n    function _keyValueDiffersFactory() {\r\n        return defaultKeyValueDiffers;\r\n    }\r\n    function _localeFactory(locale) {\r\n        if (locale) {\r\n            if (ivyEnabled) {\r\n                setLocaleId(locale);\r\n            }\r\n            return locale;\r\n        }\r\n        // Use `goog.LOCALE` as default value for `LOCALE_ID` token for Closure Compiler.\r\n        // Note: default `goog.LOCALE` value is `en`, when Angular used `en-US`. In order to preserve\r\n        // backwards compatibility, we use Angular default value over Closure Compiler's one.\r\n        if (ngI18nClosureMode && typeof goog !== 'undefined' && goog.LOCALE !== 'en') {\r\n            if (ivyEnabled) {\r\n                setLocaleId(goog.LOCALE);\r\n            }\r\n            return goog.LOCALE;\r\n        }\r\n        return DEFAULT_LOCALE_ID;\r\n    }\r\n    /**\r\n     * A built-in [dependency injection token](guide/glossary#di-token)\r\n     * that is used to configure the root injector for bootstrapping.\r\n     */\r\n    var APPLICATION_MODULE_PROVIDERS = [\r\n        {\r\n            provide: ApplicationRef,\r\n            useClass: ApplicationRef,\r\n            deps: [NgZone, Console, Injector, ErrorHandler, ComponentFactoryResolver, ApplicationInitStatus]\r\n        },\r\n        { provide: SCHEDULER, deps: [NgZone], useFactory: zoneSchedulerFactory },\r\n        {\r\n            provide: ApplicationInitStatus,\r\n            useClass: ApplicationInitStatus,\r\n            deps: [[new Optional(), APP_INITIALIZER]]\r\n        },\r\n        { provide: Compiler, useClass: Compiler, deps: [] },\r\n        APP_ID_RANDOM_PROVIDER,\r\n        { provide: IterableDiffers, useFactory: _iterableDiffersFactory, deps: [] },\r\n        { provide: KeyValueDiffers, useFactory: _keyValueDiffersFactory, deps: [] },\r\n        {\r\n            provide: LOCALE_ID$1,\r\n            useFactory: _localeFactory,\r\n            deps: [[new Inject(LOCALE_ID$1), new Optional(), new SkipSelf()]]\r\n        },\r\n    ];\r\n    /**\r\n     * Schedule work at next available slot.\r\n     *\r\n     * In Ivy this is just `requestAnimationFrame`. For compatibility reasons when bootstrapped\r\n     * using `platformRef.bootstrap` we need to use `NgZone.onStable` as the scheduling mechanism.\r\n     * This overrides the scheduling mechanism in Ivy to `NgZone.onStable`.\r\n     *\r\n     * @param ngZone NgZone to use for scheduling.\r\n     */\r\n    function zoneSchedulerFactory(ngZone) {\r\n        var queue = [];\r\n        ngZone.onStable.subscribe(function () {\r\n            while (queue.length) {\r\n                queue.pop()();\r\n            }\r\n        });\r\n        return function (fn) { queue.push(fn); };\r\n    }\r\n    /**\r\n     * Configures the root injector for an app with\r\n     * providers of `@angular/core` dependencies that `ApplicationRef` needs\r\n     * to bootstrap components.\r\n     *\r\n     * Re-exported by `BrowserModule`, which is included automatically in the root\r\n     * `AppModule` when you create a new app with the CLI `new` command.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var ApplicationModule = /** @class */ (function () {\r\n        // Inject ApplicationRef to make it eager...\r\n        function ApplicationModule(appRef) {\r\n        }\r\n        ApplicationModule = __decorate([\r\n            NgModule({ providers: APPLICATION_MODULE_PROVIDERS }),\r\n            __metadata(\"design:paramtypes\", [ApplicationRef])\r\n        ], ApplicationModule);\r\n        return ApplicationModule;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function anchorDef(flags, matchedQueriesDsl, ngContentIndex, childCount, handleEvent, templateFactory) {\r\n        flags |= 1 /* TypeElement */;\r\n        var _a = splitMatchedQueriesDsl(matchedQueriesDsl), matchedQueries = _a.matchedQueries, references = _a.references, matchedQueryIds = _a.matchedQueryIds;\r\n        var template = templateFactory ? resolveDefinition(templateFactory) : null;\r\n        return {\r\n            // will bet set by the view definition\r\n            nodeIndex: -1,\r\n            parent: null,\r\n            renderParent: null,\r\n            bindingIndex: -1,\r\n            outputIndex: -1,\r\n            // regular values\r\n            flags: flags,\r\n            checkIndex: -1,\r\n            childFlags: 0,\r\n            directChildFlags: 0,\r\n            childMatchedQueries: 0, matchedQueries: matchedQueries, matchedQueryIds: matchedQueryIds, references: references, ngContentIndex: ngContentIndex, childCount: childCount,\r\n            bindings: [],\r\n            bindingFlags: 0,\r\n            outputs: [],\r\n            element: {\r\n                ns: null,\r\n                name: null,\r\n                attrs: null, template: template,\r\n                componentProvider: null,\r\n                componentView: null,\r\n                componentRendererType: null,\r\n                publicProviders: null,\r\n                allProviders: null,\r\n                handleEvent: handleEvent || NOOP\r\n            },\r\n            provider: null,\r\n            text: null,\r\n            query: null,\r\n            ngContent: null\r\n        };\r\n    }\r\n    function elementDef(checkIndex, flags, matchedQueriesDsl, ngContentIndex, childCount, namespaceAndName, fixedAttrs, bindings, outputs, handleEvent, componentView, componentRendererType) {\r\n        var _a;\r\n        if (fixedAttrs === void 0) { fixedAttrs = []; }\r\n        if (!handleEvent) {\r\n            handleEvent = NOOP;\r\n        }\r\n        var _b = splitMatchedQueriesDsl(matchedQueriesDsl), matchedQueries = _b.matchedQueries, references = _b.references, matchedQueryIds = _b.matchedQueryIds;\r\n        var ns = null;\r\n        var name = null;\r\n        if (namespaceAndName) {\r\n            _a = __read(splitNamespace(namespaceAndName), 2), ns = _a[0], name = _a[1];\r\n        }\r\n        bindings = bindings || [];\r\n        var bindingDefs = new Array(bindings.length);\r\n        for (var i = 0; i < bindings.length; i++) {\r\n            var _c = __read(bindings[i], 3), bindingFlags = _c[0], namespaceAndName_1 = _c[1], suffixOrSecurityContext = _c[2];\r\n            var _d = __read(splitNamespace(namespaceAndName_1), 2), ns_1 = _d[0], name_1 = _d[1];\r\n            var securityContext = undefined;\r\n            var suffix = undefined;\r\n            switch (bindingFlags & 15 /* Types */) {\r\n                case 4 /* TypeElementStyle */:\r\n                    suffix = suffixOrSecurityContext;\r\n                    break;\r\n                case 1 /* TypeElementAttribute */:\r\n                case 8 /* TypeProperty */:\r\n                    securityContext = suffixOrSecurityContext;\r\n                    break;\r\n            }\r\n            bindingDefs[i] =\r\n                { flags: bindingFlags, ns: ns_1, name: name_1, nonMinifiedName: name_1, securityContext: securityContext, suffix: suffix };\r\n        }\r\n        outputs = outputs || [];\r\n        var outputDefs = new Array(outputs.length);\r\n        for (var i = 0; i < outputs.length; i++) {\r\n            var _e = __read(outputs[i], 2), target = _e[0], eventName = _e[1];\r\n            outputDefs[i] = {\r\n                type: 0 /* ElementOutput */,\r\n                target: target, eventName: eventName,\r\n                propName: null\r\n            };\r\n        }\r\n        fixedAttrs = fixedAttrs || [];\r\n        var attrs = fixedAttrs.map(function (_a) {\r\n            var _b = __read(_a, 2), namespaceAndName = _b[0], value = _b[1];\r\n            var _c = __read(splitNamespace(namespaceAndName), 2), ns = _c[0], name = _c[1];\r\n            return [ns, name, value];\r\n        });\r\n        componentRendererType = resolveRendererType2(componentRendererType);\r\n        if (componentView) {\r\n            flags |= 33554432 /* ComponentView */;\r\n        }\r\n        flags |= 1 /* TypeElement */;\r\n        return {\r\n            // will bet set by the view definition\r\n            nodeIndex: -1,\r\n            parent: null,\r\n            renderParent: null,\r\n            bindingIndex: -1,\r\n            outputIndex: -1,\r\n            // regular values\r\n            checkIndex: checkIndex,\r\n            flags: flags,\r\n            childFlags: 0,\r\n            directChildFlags: 0,\r\n            childMatchedQueries: 0, matchedQueries: matchedQueries, matchedQueryIds: matchedQueryIds, references: references, ngContentIndex: ngContentIndex, childCount: childCount,\r\n            bindings: bindingDefs,\r\n            bindingFlags: calcBindingFlags(bindingDefs),\r\n            outputs: outputDefs,\r\n            element: {\r\n                ns: ns,\r\n                name: name,\r\n                attrs: attrs,\r\n                template: null,\r\n                // will bet set by the view definition\r\n                componentProvider: null,\r\n                componentView: componentView || null,\r\n                componentRendererType: componentRendererType,\r\n                publicProviders: null,\r\n                allProviders: null,\r\n                handleEvent: handleEvent || NOOP,\r\n            },\r\n            provider: null,\r\n            text: null,\r\n            query: null,\r\n            ngContent: null\r\n        };\r\n    }\r\n    function createElement(view, renderHost, def) {\r\n        var elDef = def.element;\r\n        var rootSelectorOrNode = view.root.selectorOrNode;\r\n        var renderer = view.renderer;\r\n        var el;\r\n        if (view.parent || !rootSelectorOrNode) {\r\n            if (elDef.name) {\r\n                el = renderer.createElement(elDef.name, elDef.ns);\r\n            }\r\n            else {\r\n                el = renderer.createComment('');\r\n            }\r\n            var parentEl = getParentRenderElement(view, renderHost, def);\r\n            if (parentEl) {\r\n                renderer.appendChild(parentEl, el);\r\n            }\r\n        }\r\n        else {\r\n            // when using native Shadow DOM, do not clear the root element contents to allow slot projection\r\n            var preserveContent = (!!elDef.componentRendererType &&\r\n                elDef.componentRendererType.encapsulation === exports.ViewEncapsulation.ShadowDom);\r\n            el = renderer.selectRootElement(rootSelectorOrNode, preserveContent);\r\n        }\r\n        if (elDef.attrs) {\r\n            for (var i = 0; i < elDef.attrs.length; i++) {\r\n                var _a = __read(elDef.attrs[i], 3), ns = _a[0], name_2 = _a[1], value = _a[2];\r\n                renderer.setAttribute(el, name_2, value, ns);\r\n            }\r\n        }\r\n        return el;\r\n    }\r\n    function listenToElementOutputs(view, compView, def, el) {\r\n        for (var i = 0; i < def.outputs.length; i++) {\r\n            var output = def.outputs[i];\r\n            var handleEventClosure = renderEventHandlerClosure(view, def.nodeIndex, elementEventFullName(output.target, output.eventName));\r\n            var listenTarget = output.target;\r\n            var listenerView = view;\r\n            if (output.target === 'component') {\r\n                listenTarget = null;\r\n                listenerView = compView;\r\n            }\r\n            var disposable = listenerView.renderer.listen(listenTarget || el, output.eventName, handleEventClosure);\r\n            view.disposables[def.outputIndex + i] = disposable;\r\n        }\r\n    }\r\n    function renderEventHandlerClosure(view, index, eventName) {\r\n        return function (event) { return dispatchEvent(view, index, eventName, event); };\r\n    }\r\n    function checkAndUpdateElementInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\r\n        var bindLen = def.bindings.length;\r\n        var changed = false;\r\n        if (bindLen > 0 && checkAndUpdateElementValue(view, def, 0, v0))\r\n            changed = true;\r\n        if (bindLen > 1 && checkAndUpdateElementValue(view, def, 1, v1))\r\n            changed = true;\r\n        if (bindLen > 2 && checkAndUpdateElementValue(view, def, 2, v2))\r\n            changed = true;\r\n        if (bindLen > 3 && checkAndUpdateElementValue(view, def, 3, v3))\r\n            changed = true;\r\n        if (bindLen > 4 && checkAndUpdateElementValue(view, def, 4, v4))\r\n            changed = true;\r\n        if (bindLen > 5 && checkAndUpdateElementValue(view, def, 5, v5))\r\n            changed = true;\r\n        if (bindLen > 6 && checkAndUpdateElementValue(view, def, 6, v6))\r\n            changed = true;\r\n        if (bindLen > 7 && checkAndUpdateElementValue(view, def, 7, v7))\r\n            changed = true;\r\n        if (bindLen > 8 && checkAndUpdateElementValue(view, def, 8, v8))\r\n            changed = true;\r\n        if (bindLen > 9 && checkAndUpdateElementValue(view, def, 9, v9))\r\n            changed = true;\r\n        return changed;\r\n    }\r\n    function checkAndUpdateElementDynamic(view, def, values) {\r\n        var changed = false;\r\n        for (var i = 0; i < values.length; i++) {\r\n            if (checkAndUpdateElementValue(view, def, i, values[i]))\r\n                changed = true;\r\n        }\r\n        return changed;\r\n    }\r\n    function checkAndUpdateElementValue(view, def, bindingIdx, value) {\r\n        if (!checkAndUpdateBinding(view, def, bindingIdx, value)) {\r\n            return false;\r\n        }\r\n        var binding = def.bindings[bindingIdx];\r\n        var elData = asElementData(view, def.nodeIndex);\r\n        var renderNode = elData.renderElement;\r\n        var name = binding.name;\r\n        switch (binding.flags & 15 /* Types */) {\r\n            case 1 /* TypeElementAttribute */:\r\n                setElementAttribute(view, binding, renderNode, binding.ns, name, value);\r\n                break;\r\n            case 2 /* TypeElementClass */:\r\n                setElementClass(view, renderNode, name, value);\r\n                break;\r\n            case 4 /* TypeElementStyle */:\r\n                setElementStyle(view, binding, renderNode, name, value);\r\n                break;\r\n            case 8 /* TypeProperty */:\r\n                var bindView = (def.flags & 33554432 /* ComponentView */ &&\r\n                    binding.flags & 32 /* SyntheticHostProperty */) ?\r\n                    elData.componentView :\r\n                    view;\r\n                setElementProperty(bindView, binding, renderNode, name, value);\r\n                break;\r\n        }\r\n        return true;\r\n    }\r\n    function setElementAttribute(view, binding, renderNode, ns, name, value) {\r\n        var securityContext = binding.securityContext;\r\n        var renderValue = securityContext ? view.root.sanitizer.sanitize(securityContext, value) : value;\r\n        renderValue = renderValue != null ? renderValue.toString() : null;\r\n        var renderer = view.renderer;\r\n        if (value != null) {\r\n            renderer.setAttribute(renderNode, name, renderValue, ns);\r\n        }\r\n        else {\r\n            renderer.removeAttribute(renderNode, name, ns);\r\n        }\r\n    }\r\n    function setElementClass(view, renderNode, name, value) {\r\n        var renderer = view.renderer;\r\n        if (value) {\r\n            renderer.addClass(renderNode, name);\r\n        }\r\n        else {\r\n            renderer.removeClass(renderNode, name);\r\n        }\r\n    }\r\n    function setElementStyle(view, binding, renderNode, name, value) {\r\n        var renderValue = view.root.sanitizer.sanitize(exports.SecurityContext.STYLE, value);\r\n        if (renderValue != null) {\r\n            renderValue = renderValue.toString();\r\n            var unit = binding.suffix;\r\n            if (unit != null) {\r\n                renderValue = renderValue + unit;\r\n            }\r\n        }\r\n        else {\r\n            renderValue = null;\r\n        }\r\n        var renderer = view.renderer;\r\n        if (renderValue != null) {\r\n            renderer.setStyle(renderNode, name, renderValue);\r\n        }\r\n        else {\r\n            renderer.removeStyle(renderNode, name);\r\n        }\r\n    }\r\n    function setElementProperty(view, binding, renderNode, name, value) {\r\n        var securityContext = binding.securityContext;\r\n        var renderValue = securityContext ? view.root.sanitizer.sanitize(securityContext, value) : value;\r\n        view.renderer.setProperty(renderNode, name, renderValue);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function queryDef(flags, id, bindings) {\r\n        var bindingDefs = [];\r\n        for (var propName in bindings) {\r\n            var bindingType = bindings[propName];\r\n            bindingDefs.push({ propName: propName, bindingType: bindingType });\r\n        }\r\n        return {\r\n            // will bet set by the view definition\r\n            nodeIndex: -1,\r\n            parent: null,\r\n            renderParent: null,\r\n            bindingIndex: -1,\r\n            outputIndex: -1,\r\n            // regular values\r\n            // TODO(vicb): check\r\n            checkIndex: -1, flags: flags,\r\n            childFlags: 0,\r\n            directChildFlags: 0,\r\n            childMatchedQueries: 0,\r\n            ngContentIndex: -1,\r\n            matchedQueries: {},\r\n            matchedQueryIds: 0,\r\n            references: {},\r\n            childCount: 0,\r\n            bindings: [],\r\n            bindingFlags: 0,\r\n            outputs: [],\r\n            element: null,\r\n            provider: null,\r\n            text: null,\r\n            query: { id: id, filterId: filterQueryId(id), bindings: bindingDefs },\r\n            ngContent: null\r\n        };\r\n    }\r\n    function createQuery() {\r\n        return new QueryList();\r\n    }\r\n    function dirtyParentQueries(view) {\r\n        var queryIds = view.def.nodeMatchedQueries;\r\n        while (view.parent && isEmbeddedView(view)) {\r\n            var tplDef = view.parentNodeDef;\r\n            view = view.parent;\r\n            // content queries\r\n            var end = tplDef.nodeIndex + tplDef.childCount;\r\n            for (var i = 0; i <= end; i++) {\r\n                var nodeDef = view.def.nodes[i];\r\n                if ((nodeDef.flags & 67108864 /* TypeContentQuery */) &&\r\n                    (nodeDef.flags & 536870912 /* DynamicQuery */) &&\r\n                    (nodeDef.query.filterId & queryIds) === nodeDef.query.filterId) {\r\n                    asQueryList(view, i).setDirty();\r\n                }\r\n                if ((nodeDef.flags & 1 /* TypeElement */ && i + nodeDef.childCount < tplDef.nodeIndex) ||\r\n                    !(nodeDef.childFlags & 67108864 /* TypeContentQuery */) ||\r\n                    !(nodeDef.childFlags & 536870912 /* DynamicQuery */)) {\r\n                    // skip elements that don't contain the template element or no query.\r\n                    i += nodeDef.childCount;\r\n                }\r\n            }\r\n        }\r\n        // view queries\r\n        if (view.def.nodeFlags & 134217728 /* TypeViewQuery */) {\r\n            for (var i = 0; i < view.def.nodes.length; i++) {\r\n                var nodeDef = view.def.nodes[i];\r\n                if ((nodeDef.flags & 134217728 /* TypeViewQuery */) && (nodeDef.flags & 536870912 /* DynamicQuery */)) {\r\n                    asQueryList(view, i).setDirty();\r\n                }\r\n                // only visit the root nodes\r\n                i += nodeDef.childCount;\r\n            }\r\n        }\r\n    }\r\n    function checkAndUpdateQuery(view, nodeDef) {\r\n        var queryList = asQueryList(view, nodeDef.nodeIndex);\r\n        if (!queryList.dirty) {\r\n            return;\r\n        }\r\n        var directiveInstance;\r\n        var newValues = undefined;\r\n        if (nodeDef.flags & 67108864 /* TypeContentQuery */) {\r\n            var elementDef = nodeDef.parent.parent;\r\n            newValues = calcQueryValues(view, elementDef.nodeIndex, elementDef.nodeIndex + elementDef.childCount, nodeDef.query, []);\r\n            directiveInstance = asProviderData(view, nodeDef.parent.nodeIndex).instance;\r\n        }\r\n        else if (nodeDef.flags & 134217728 /* TypeViewQuery */) {\r\n            newValues = calcQueryValues(view, 0, view.def.nodes.length - 1, nodeDef.query, []);\r\n            directiveInstance = view.component;\r\n        }\r\n        queryList.reset(newValues);\r\n        var bindings = nodeDef.query.bindings;\r\n        var notify = false;\r\n        for (var i = 0; i < bindings.length; i++) {\r\n            var binding = bindings[i];\r\n            var boundValue = void 0;\r\n            switch (binding.bindingType) {\r\n                case 0 /* First */:\r\n                    boundValue = queryList.first;\r\n                    break;\r\n                case 1 /* All */:\r\n                    boundValue = queryList;\r\n                    notify = true;\r\n                    break;\r\n            }\r\n            directiveInstance[binding.propName] = boundValue;\r\n        }\r\n        if (notify) {\r\n            queryList.notifyOnChanges();\r\n        }\r\n    }\r\n    function calcQueryValues(view, startIndex, endIndex, queryDef, values) {\r\n        for (var i = startIndex; i <= endIndex; i++) {\r\n            var nodeDef = view.def.nodes[i];\r\n            var valueType = nodeDef.matchedQueries[queryDef.id];\r\n            if (valueType != null) {\r\n                values.push(getQueryValue(view, nodeDef, valueType));\r\n            }\r\n            if (nodeDef.flags & 1 /* TypeElement */ && nodeDef.element.template &&\r\n                (nodeDef.element.template.nodeMatchedQueries & queryDef.filterId) ===\r\n                    queryDef.filterId) {\r\n                var elementData = asElementData(view, i);\r\n                // check embedded views that were attached at the place of their template,\r\n                // but process child nodes first if some match the query (see issue #16568)\r\n                if ((nodeDef.childMatchedQueries & queryDef.filterId) === queryDef.filterId) {\r\n                    calcQueryValues(view, i + 1, i + nodeDef.childCount, queryDef, values);\r\n                    i += nodeDef.childCount;\r\n                }\r\n                if (nodeDef.flags & 16777216 /* EmbeddedViews */) {\r\n                    var embeddedViews = elementData.viewContainer._embeddedViews;\r\n                    for (var k = 0; k < embeddedViews.length; k++) {\r\n                        var embeddedView = embeddedViews[k];\r\n                        var dvc = declaredViewContainer(embeddedView);\r\n                        if (dvc && dvc === elementData) {\r\n                            calcQueryValues(embeddedView, 0, embeddedView.def.nodes.length - 1, queryDef, values);\r\n                        }\r\n                    }\r\n                }\r\n                var projectedViews = elementData.template._projectedViews;\r\n                if (projectedViews) {\r\n                    for (var k = 0; k < projectedViews.length; k++) {\r\n                        var projectedView = projectedViews[k];\r\n                        calcQueryValues(projectedView, 0, projectedView.def.nodes.length - 1, queryDef, values);\r\n                    }\r\n                }\r\n            }\r\n            if ((nodeDef.childMatchedQueries & queryDef.filterId) !== queryDef.filterId) {\r\n                // if no child matches the query, skip the children.\r\n                i += nodeDef.childCount;\r\n            }\r\n        }\r\n        return values;\r\n    }\r\n    function getQueryValue(view, nodeDef, queryValueType) {\r\n        if (queryValueType != null) {\r\n            // a match\r\n            switch (queryValueType) {\r\n                case 1 /* RenderElement */:\r\n                    return asElementData(view, nodeDef.nodeIndex).renderElement;\r\n                case 0 /* ElementRef */:\r\n                    return new ElementRef(asElementData(view, nodeDef.nodeIndex).renderElement);\r\n                case 2 /* TemplateRef */:\r\n                    return asElementData(view, nodeDef.nodeIndex).template;\r\n                case 3 /* ViewContainerRef */:\r\n                    return asElementData(view, nodeDef.nodeIndex).viewContainer;\r\n                case 4 /* Provider */:\r\n                    return asProviderData(view, nodeDef.nodeIndex).instance;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function ngContentDef(ngContentIndex, index) {\r\n        return {\r\n            // will bet set by the view definition\r\n            nodeIndex: -1,\r\n            parent: null,\r\n            renderParent: null,\r\n            bindingIndex: -1,\r\n            outputIndex: -1,\r\n            // regular values\r\n            checkIndex: -1,\r\n            flags: 8 /* TypeNgContent */,\r\n            childFlags: 0,\r\n            directChildFlags: 0,\r\n            childMatchedQueries: 0,\r\n            matchedQueries: {},\r\n            matchedQueryIds: 0,\r\n            references: {}, ngContentIndex: ngContentIndex,\r\n            childCount: 0,\r\n            bindings: [],\r\n            bindingFlags: 0,\r\n            outputs: [],\r\n            element: null,\r\n            provider: null,\r\n            text: null,\r\n            query: null,\r\n            ngContent: { index: index }\r\n        };\r\n    }\r\n    function appendNgContent(view, renderHost, def) {\r\n        var parentEl = getParentRenderElement(view, renderHost, def);\r\n        if (!parentEl) {\r\n            // Nothing to do if there is no parent element.\r\n            return;\r\n        }\r\n        var ngContentIndex = def.ngContent.index;\r\n        visitProjectedRenderNodes(view, ngContentIndex, 1 /* AppendChild */, parentEl, null, undefined);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function purePipeDef(checkIndex, argCount) {\r\n        // argCount + 1 to include the pipe as first arg\r\n        return _pureExpressionDef(128 /* TypePurePipe */, checkIndex, new Array(argCount + 1));\r\n    }\r\n    function pureArrayDef(checkIndex, argCount) {\r\n        return _pureExpressionDef(32 /* TypePureArray */, checkIndex, new Array(argCount));\r\n    }\r\n    function pureObjectDef(checkIndex, propToIndex) {\r\n        var keys = Object.keys(propToIndex);\r\n        var nbKeys = keys.length;\r\n        var propertyNames = new Array(nbKeys);\r\n        for (var i = 0; i < nbKeys; i++) {\r\n            var key = keys[i];\r\n            var index = propToIndex[key];\r\n            propertyNames[index] = key;\r\n        }\r\n        return _pureExpressionDef(64 /* TypePureObject */, checkIndex, propertyNames);\r\n    }\r\n    function _pureExpressionDef(flags, checkIndex, propertyNames) {\r\n        var bindings = new Array(propertyNames.length);\r\n        for (var i = 0; i < propertyNames.length; i++) {\r\n            var prop = propertyNames[i];\r\n            bindings[i] = {\r\n                flags: 8 /* TypeProperty */,\r\n                name: prop,\r\n                ns: null,\r\n                nonMinifiedName: prop,\r\n                securityContext: null,\r\n                suffix: null\r\n            };\r\n        }\r\n        return {\r\n            // will bet set by the view definition\r\n            nodeIndex: -1,\r\n            parent: null,\r\n            renderParent: null,\r\n            bindingIndex: -1,\r\n            outputIndex: -1,\r\n            // regular values\r\n            checkIndex: checkIndex,\r\n            flags: flags,\r\n            childFlags: 0,\r\n            directChildFlags: 0,\r\n            childMatchedQueries: 0,\r\n            matchedQueries: {},\r\n            matchedQueryIds: 0,\r\n            references: {},\r\n            ngContentIndex: -1,\r\n            childCount: 0, bindings: bindings,\r\n            bindingFlags: calcBindingFlags(bindings),\r\n            outputs: [],\r\n            element: null,\r\n            provider: null,\r\n            text: null,\r\n            query: null,\r\n            ngContent: null\r\n        };\r\n    }\r\n    function createPureExpression(view, def) {\r\n        return { value: undefined };\r\n    }\r\n    function checkAndUpdatePureExpressionInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\r\n        var bindings = def.bindings;\r\n        var changed = false;\r\n        var bindLen = bindings.length;\r\n        if (bindLen > 0 && checkAndUpdateBinding(view, def, 0, v0))\r\n            changed = true;\r\n        if (bindLen > 1 && checkAndUpdateBinding(view, def, 1, v1))\r\n            changed = true;\r\n        if (bindLen > 2 && checkAndUpdateBinding(view, def, 2, v2))\r\n            changed = true;\r\n        if (bindLen > 3 && checkAndUpdateBinding(view, def, 3, v3))\r\n            changed = true;\r\n        if (bindLen > 4 && checkAndUpdateBinding(view, def, 4, v4))\r\n            changed = true;\r\n        if (bindLen > 5 && checkAndUpdateBinding(view, def, 5, v5))\r\n            changed = true;\r\n        if (bindLen > 6 && checkAndUpdateBinding(view, def, 6, v6))\r\n            changed = true;\r\n        if (bindLen > 7 && checkAndUpdateBinding(view, def, 7, v7))\r\n            changed = true;\r\n        if (bindLen > 8 && checkAndUpdateBinding(view, def, 8, v8))\r\n            changed = true;\r\n        if (bindLen > 9 && checkAndUpdateBinding(view, def, 9, v9))\r\n            changed = true;\r\n        if (changed) {\r\n            var data = asPureExpressionData(view, def.nodeIndex);\r\n            var value = void 0;\r\n            switch (def.flags & 201347067 /* Types */) {\r\n                case 32 /* TypePureArray */:\r\n                    value = new Array(bindings.length);\r\n                    if (bindLen > 0)\r\n                        value[0] = v0;\r\n                    if (bindLen > 1)\r\n                        value[1] = v1;\r\n                    if (bindLen > 2)\r\n                        value[2] = v2;\r\n                    if (bindLen > 3)\r\n                        value[3] = v3;\r\n                    if (bindLen > 4)\r\n                        value[4] = v4;\r\n                    if (bindLen > 5)\r\n                        value[5] = v5;\r\n                    if (bindLen > 6)\r\n                        value[6] = v6;\r\n                    if (bindLen > 7)\r\n                        value[7] = v7;\r\n                    if (bindLen > 8)\r\n                        value[8] = v8;\r\n                    if (bindLen > 9)\r\n                        value[9] = v9;\r\n                    break;\r\n                case 64 /* TypePureObject */:\r\n                    value = {};\r\n                    if (bindLen > 0)\r\n                        value[bindings[0].name] = v0;\r\n                    if (bindLen > 1)\r\n                        value[bindings[1].name] = v1;\r\n                    if (bindLen > 2)\r\n                        value[bindings[2].name] = v2;\r\n                    if (bindLen > 3)\r\n                        value[bindings[3].name] = v3;\r\n                    if (bindLen > 4)\r\n                        value[bindings[4].name] = v4;\r\n                    if (bindLen > 5)\r\n                        value[bindings[5].name] = v5;\r\n                    if (bindLen > 6)\r\n                        value[bindings[6].name] = v6;\r\n                    if (bindLen > 7)\r\n                        value[bindings[7].name] = v7;\r\n                    if (bindLen > 8)\r\n                        value[bindings[8].name] = v8;\r\n                    if (bindLen > 9)\r\n                        value[bindings[9].name] = v9;\r\n                    break;\r\n                case 128 /* TypePurePipe */:\r\n                    var pipe = v0;\r\n                    switch (bindLen) {\r\n                        case 1:\r\n                            value = pipe.transform(v0);\r\n                            break;\r\n                        case 2:\r\n                            value = pipe.transform(v1);\r\n                            break;\r\n                        case 3:\r\n                            value = pipe.transform(v1, v2);\r\n                            break;\r\n                        case 4:\r\n                            value = pipe.transform(v1, v2, v3);\r\n                            break;\r\n                        case 5:\r\n                            value = pipe.transform(v1, v2, v3, v4);\r\n                            break;\r\n                        case 6:\r\n                            value = pipe.transform(v1, v2, v3, v4, v5);\r\n                            break;\r\n                        case 7:\r\n                            value = pipe.transform(v1, v2, v3, v4, v5, v6);\r\n                            break;\r\n                        case 8:\r\n                            value = pipe.transform(v1, v2, v3, v4, v5, v6, v7);\r\n                            break;\r\n                        case 9:\r\n                            value = pipe.transform(v1, v2, v3, v4, v5, v6, v7, v8);\r\n                            break;\r\n                        case 10:\r\n                            value = pipe.transform(v1, v2, v3, v4, v5, v6, v7, v8, v9);\r\n                            break;\r\n                    }\r\n                    break;\r\n            }\r\n            data.value = value;\r\n        }\r\n        return changed;\r\n    }\r\n    function checkAndUpdatePureExpressionDynamic(view, def, values) {\r\n        var bindings = def.bindings;\r\n        var changed = false;\r\n        for (var i = 0; i < values.length; i++) {\r\n            // Note: We need to loop over all values, so that\r\n            // the old values are updates as well!\r\n            if (checkAndUpdateBinding(view, def, i, values[i])) {\r\n                changed = true;\r\n            }\r\n        }\r\n        if (changed) {\r\n            var data = asPureExpressionData(view, def.nodeIndex);\r\n            var value = void 0;\r\n            switch (def.flags & 201347067 /* Types */) {\r\n                case 32 /* TypePureArray */:\r\n                    value = values;\r\n                    break;\r\n                case 64 /* TypePureObject */:\r\n                    value = {};\r\n                    for (var i = 0; i < values.length; i++) {\r\n                        value[bindings[i].name] = values[i];\r\n                    }\r\n                    break;\r\n                case 128 /* TypePurePipe */:\r\n                    var pipe = values[0];\r\n                    var params = values.slice(1);\r\n                    value = pipe.transform.apply(pipe, __spread(params));\r\n                    break;\r\n            }\r\n            data.value = value;\r\n        }\r\n        return changed;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function textDef(checkIndex, ngContentIndex, staticText) {\r\n        var bindings = new Array(staticText.length - 1);\r\n        for (var i = 1; i < staticText.length; i++) {\r\n            bindings[i - 1] = {\r\n                flags: 8 /* TypeProperty */,\r\n                name: null,\r\n                ns: null,\r\n                nonMinifiedName: null,\r\n                securityContext: null,\r\n                suffix: staticText[i],\r\n            };\r\n        }\r\n        return {\r\n            // will bet set by the view definition\r\n            nodeIndex: -1,\r\n            parent: null,\r\n            renderParent: null,\r\n            bindingIndex: -1,\r\n            outputIndex: -1,\r\n            // regular values\r\n            checkIndex: checkIndex,\r\n            flags: 2 /* TypeText */,\r\n            childFlags: 0,\r\n            directChildFlags: 0,\r\n            childMatchedQueries: 0,\r\n            matchedQueries: {},\r\n            matchedQueryIds: 0,\r\n            references: {}, ngContentIndex: ngContentIndex,\r\n            childCount: 0, bindings: bindings,\r\n            bindingFlags: 8 /* TypeProperty */,\r\n            outputs: [],\r\n            element: null,\r\n            provider: null,\r\n            text: { prefix: staticText[0] },\r\n            query: null,\r\n            ngContent: null,\r\n        };\r\n    }\r\n    function createText(view, renderHost, def) {\r\n        var renderNode;\r\n        var renderer = view.renderer;\r\n        renderNode = renderer.createText(def.text.prefix);\r\n        var parentEl = getParentRenderElement(view, renderHost, def);\r\n        if (parentEl) {\r\n            renderer.appendChild(parentEl, renderNode);\r\n        }\r\n        return { renderText: renderNode };\r\n    }\r\n    function checkAndUpdateTextInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\r\n        var changed = false;\r\n        var bindings = def.bindings;\r\n        var bindLen = bindings.length;\r\n        if (bindLen > 0 && checkAndUpdateBinding(view, def, 0, v0))\r\n            changed = true;\r\n        if (bindLen > 1 && checkAndUpdateBinding(view, def, 1, v1))\r\n            changed = true;\r\n        if (bindLen > 2 && checkAndUpdateBinding(view, def, 2, v2))\r\n            changed = true;\r\n        if (bindLen > 3 && checkAndUpdateBinding(view, def, 3, v3))\r\n            changed = true;\r\n        if (bindLen > 4 && checkAndUpdateBinding(view, def, 4, v4))\r\n            changed = true;\r\n        if (bindLen > 5 && checkAndUpdateBinding(view, def, 5, v5))\r\n            changed = true;\r\n        if (bindLen > 6 && checkAndUpdateBinding(view, def, 6, v6))\r\n            changed = true;\r\n        if (bindLen > 7 && checkAndUpdateBinding(view, def, 7, v7))\r\n            changed = true;\r\n        if (bindLen > 8 && checkAndUpdateBinding(view, def, 8, v8))\r\n            changed = true;\r\n        if (bindLen > 9 && checkAndUpdateBinding(view, def, 9, v9))\r\n            changed = true;\r\n        if (changed) {\r\n            var value = def.text.prefix;\r\n            if (bindLen > 0)\r\n                value += _addInterpolationPart(v0, bindings[0]);\r\n            if (bindLen > 1)\r\n                value += _addInterpolationPart(v1, bindings[1]);\r\n            if (bindLen > 2)\r\n                value += _addInterpolationPart(v2, bindings[2]);\r\n            if (bindLen > 3)\r\n                value += _addInterpolationPart(v3, bindings[3]);\r\n            if (bindLen > 4)\r\n                value += _addInterpolationPart(v4, bindings[4]);\r\n            if (bindLen > 5)\r\n                value += _addInterpolationPart(v5, bindings[5]);\r\n            if (bindLen > 6)\r\n                value += _addInterpolationPart(v6, bindings[6]);\r\n            if (bindLen > 7)\r\n                value += _addInterpolationPart(v7, bindings[7]);\r\n            if (bindLen > 8)\r\n                value += _addInterpolationPart(v8, bindings[8]);\r\n            if (bindLen > 9)\r\n                value += _addInterpolationPart(v9, bindings[9]);\r\n            var renderNode = asTextData(view, def.nodeIndex).renderText;\r\n            view.renderer.setValue(renderNode, value);\r\n        }\r\n        return changed;\r\n    }\r\n    function checkAndUpdateTextDynamic(view, def, values) {\r\n        var bindings = def.bindings;\r\n        var changed = false;\r\n        for (var i = 0; i < values.length; i++) {\r\n            // Note: We need to loop over all values, so that\r\n            // the old values are updates as well!\r\n            if (checkAndUpdateBinding(view, def, i, values[i])) {\r\n                changed = true;\r\n            }\r\n        }\r\n        if (changed) {\r\n            var value = '';\r\n            for (var i = 0; i < values.length; i++) {\r\n                value = value + _addInterpolationPart(values[i], bindings[i]);\r\n            }\r\n            value = def.text.prefix + value;\r\n            var renderNode = asTextData(view, def.nodeIndex).renderText;\r\n            view.renderer.setValue(renderNode, value);\r\n        }\r\n        return changed;\r\n    }\r\n    function _addInterpolationPart(value, binding) {\r\n        var valueStr = value != null ? value.toString() : '';\r\n        return valueStr + binding.suffix;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function viewDef(flags, nodes, updateDirectives, updateRenderer) {\r\n        // clone nodes and set auto calculated values\r\n        var viewBindingCount = 0;\r\n        var viewDisposableCount = 0;\r\n        var viewNodeFlags = 0;\r\n        var viewRootNodeFlags = 0;\r\n        var viewMatchedQueries = 0;\r\n        var currentParent = null;\r\n        var currentRenderParent = null;\r\n        var currentElementHasPublicProviders = false;\r\n        var currentElementHasPrivateProviders = false;\r\n        var lastRenderRootNode = null;\r\n        for (var i = 0; i < nodes.length; i++) {\r\n            var node = nodes[i];\r\n            node.nodeIndex = i;\r\n            node.parent = currentParent;\r\n            node.bindingIndex = viewBindingCount;\r\n            node.outputIndex = viewDisposableCount;\r\n            node.renderParent = currentRenderParent;\r\n            viewNodeFlags |= node.flags;\r\n            viewMatchedQueries |= node.matchedQueryIds;\r\n            if (node.element) {\r\n                var elDef = node.element;\r\n                elDef.publicProviders =\r\n                    currentParent ? currentParent.element.publicProviders : Object.create(null);\r\n                elDef.allProviders = elDef.publicProviders;\r\n                // Note: We assume that all providers of an element are before any child element!\r\n                currentElementHasPublicProviders = false;\r\n                currentElementHasPrivateProviders = false;\r\n                if (node.element.template) {\r\n                    viewMatchedQueries |= node.element.template.nodeMatchedQueries;\r\n                }\r\n            }\r\n            validateNode(currentParent, node, nodes.length);\r\n            viewBindingCount += node.bindings.length;\r\n            viewDisposableCount += node.outputs.length;\r\n            if (!currentRenderParent && (node.flags & 3 /* CatRenderNode */)) {\r\n                lastRenderRootNode = node;\r\n            }\r\n            if (node.flags & 20224 /* CatProvider */) {\r\n                if (!currentElementHasPublicProviders) {\r\n                    currentElementHasPublicProviders = true;\r\n                    // Use prototypical inheritance to not get O(n^2) complexity...\r\n                    currentParent.element.publicProviders =\r\n                        Object.create(currentParent.element.publicProviders);\r\n                    currentParent.element.allProviders = currentParent.element.publicProviders;\r\n                }\r\n                var isPrivateService = (node.flags & 8192 /* PrivateProvider */) !== 0;\r\n                var isComponent = (node.flags & 32768 /* Component */) !== 0;\r\n                if (!isPrivateService || isComponent) {\r\n                    currentParent.element.publicProviders[tokenKey(node.provider.token)] = node;\r\n                }\r\n                else {\r\n                    if (!currentElementHasPrivateProviders) {\r\n                        currentElementHasPrivateProviders = true;\r\n                        // Use prototypical inheritance to not get O(n^2) complexity...\r\n                        currentParent.element.allProviders =\r\n                            Object.create(currentParent.element.publicProviders);\r\n                    }\r\n                    currentParent.element.allProviders[tokenKey(node.provider.token)] = node;\r\n                }\r\n                if (isComponent) {\r\n                    currentParent.element.componentProvider = node;\r\n                }\r\n            }\r\n            if (currentParent) {\r\n                currentParent.childFlags |= node.flags;\r\n                currentParent.directChildFlags |= node.flags;\r\n                currentParent.childMatchedQueries |= node.matchedQueryIds;\r\n                if (node.element && node.element.template) {\r\n                    currentParent.childMatchedQueries |= node.element.template.nodeMatchedQueries;\r\n                }\r\n            }\r\n            else {\r\n                viewRootNodeFlags |= node.flags;\r\n            }\r\n            if (node.childCount > 0) {\r\n                currentParent = node;\r\n                if (!isNgContainer(node)) {\r\n                    currentRenderParent = node;\r\n                }\r\n            }\r\n            else {\r\n                // When the current node has no children, check if it is the last children of its parent.\r\n                // When it is, propagate the flags up.\r\n                // The loop is required because an element could be the last transitive children of several\r\n                // elements. We loop to either the root or the highest opened element (= with remaining\r\n                // children)\r\n                while (currentParent && i === currentParent.nodeIndex + currentParent.childCount) {\r\n                    var newParent = currentParent.parent;\r\n                    if (newParent) {\r\n                        newParent.childFlags |= currentParent.childFlags;\r\n                        newParent.childMatchedQueries |= currentParent.childMatchedQueries;\r\n                    }\r\n                    currentParent = newParent;\r\n                    // We also need to update the render parent & account for ng-container\r\n                    if (currentParent && isNgContainer(currentParent)) {\r\n                        currentRenderParent = currentParent.renderParent;\r\n                    }\r\n                    else {\r\n                        currentRenderParent = currentParent;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var handleEvent = function (view, nodeIndex, eventName, event) {\r\n            return nodes[nodeIndex].element.handleEvent(view, eventName, event);\r\n        };\r\n        return {\r\n            // Will be filled later...\r\n            factory: null,\r\n            nodeFlags: viewNodeFlags,\r\n            rootNodeFlags: viewRootNodeFlags,\r\n            nodeMatchedQueries: viewMatchedQueries, flags: flags,\r\n            nodes: nodes,\r\n            updateDirectives: updateDirectives || NOOP,\r\n            updateRenderer: updateRenderer || NOOP, handleEvent: handleEvent,\r\n            bindingCount: viewBindingCount,\r\n            outputCount: viewDisposableCount, lastRenderRootNode: lastRenderRootNode\r\n        };\r\n    }\r\n    function isNgContainer(node) {\r\n        return (node.flags & 1 /* TypeElement */) !== 0 && node.element.name === null;\r\n    }\r\n    function validateNode(parent, node, nodeCount) {\r\n        var template = node.element && node.element.template;\r\n        if (template) {\r\n            if (!template.lastRenderRootNode) {\r\n                throw new Error(\"Illegal State: Embedded templates without nodes are not allowed!\");\r\n            }\r\n            if (template.lastRenderRootNode &&\r\n                template.lastRenderRootNode.flags & 16777216 /* EmbeddedViews */) {\r\n                throw new Error(\"Illegal State: Last root node of a template can't have embedded views, at index \" + node.nodeIndex + \"!\");\r\n            }\r\n        }\r\n        if (node.flags & 20224 /* CatProvider */) {\r\n            var parentFlags = parent ? parent.flags : 0;\r\n            if ((parentFlags & 1 /* TypeElement */) === 0) {\r\n                throw new Error(\"Illegal State: StaticProvider/Directive nodes need to be children of elements or anchors, at index \" + node.nodeIndex + \"!\");\r\n            }\r\n        }\r\n        if (node.query) {\r\n            if (node.flags & 67108864 /* TypeContentQuery */ &&\r\n                (!parent || (parent.flags & 16384 /* TypeDirective */) === 0)) {\r\n                throw new Error(\"Illegal State: Content Query nodes need to be children of directives, at index \" + node.nodeIndex + \"!\");\r\n            }\r\n            if (node.flags & 134217728 /* TypeViewQuery */ && parent) {\r\n                throw new Error(\"Illegal State: View Query nodes have to be top level nodes, at index \" + node.nodeIndex + \"!\");\r\n            }\r\n        }\r\n        if (node.childCount) {\r\n            var parentEnd = parent ? parent.nodeIndex + parent.childCount : nodeCount - 1;\r\n            if (node.nodeIndex <= parentEnd && node.nodeIndex + node.childCount > parentEnd) {\r\n                throw new Error(\"Illegal State: childCount of node leads outside of parent, at index \" + node.nodeIndex + \"!\");\r\n            }\r\n        }\r\n    }\r\n    function createEmbeddedView(parent, anchorDef, viewDef, context) {\r\n        // embedded views are seen as siblings to the anchor, so we need\r\n        // to get the parent of the anchor and use it as parentIndex.\r\n        var view = createView(parent.root, parent.renderer, parent, anchorDef, viewDef);\r\n        initView(view, parent.component, context);\r\n        createViewNodes(view);\r\n        return view;\r\n    }\r\n    function createRootView(root, def, context) {\r\n        var view = createView(root, root.renderer, null, null, def);\r\n        initView(view, context, context);\r\n        createViewNodes(view);\r\n        return view;\r\n    }\r\n    function createComponentView(parentView, nodeDef, viewDef, hostElement) {\r\n        var rendererType = nodeDef.element.componentRendererType;\r\n        var compRenderer;\r\n        if (!rendererType) {\r\n            compRenderer = parentView.root.renderer;\r\n        }\r\n        else {\r\n            compRenderer = parentView.root.rendererFactory.createRenderer(hostElement, rendererType);\r\n        }\r\n        return createView(parentView.root, compRenderer, parentView, nodeDef.element.componentProvider, viewDef);\r\n    }\r\n    function createView(root, renderer, parent, parentNodeDef, def) {\r\n        var nodes = new Array(def.nodes.length);\r\n        var disposables = def.outputCount ? new Array(def.outputCount) : null;\r\n        var view = {\r\n            def: def,\r\n            parent: parent,\r\n            viewContainerParent: null, parentNodeDef: parentNodeDef,\r\n            context: null,\r\n            component: null, nodes: nodes,\r\n            state: 13 /* CatInit */, root: root, renderer: renderer,\r\n            oldValues: new Array(def.bindingCount), disposables: disposables,\r\n            initIndex: -1\r\n        };\r\n        return view;\r\n    }\r\n    function initView(view, component, context) {\r\n        view.component = component;\r\n        view.context = context;\r\n    }\r\n    function createViewNodes(view) {\r\n        var renderHost;\r\n        if (isComponentView(view)) {\r\n            var hostDef = view.parentNodeDef;\r\n            renderHost = asElementData(view.parent, hostDef.parent.nodeIndex).renderElement;\r\n        }\r\n        var def = view.def;\r\n        var nodes = view.nodes;\r\n        for (var i = 0; i < def.nodes.length; i++) {\r\n            var nodeDef = def.nodes[i];\r\n            Services.setCurrentNode(view, i);\r\n            var nodeData = void 0;\r\n            switch (nodeDef.flags & 201347067 /* Types */) {\r\n                case 1 /* TypeElement */:\r\n                    var el = createElement(view, renderHost, nodeDef);\r\n                    var componentView = undefined;\r\n                    if (nodeDef.flags & 33554432 /* ComponentView */) {\r\n                        var compViewDef = resolveDefinition(nodeDef.element.componentView);\r\n                        componentView = Services.createComponentView(view, nodeDef, compViewDef, el);\r\n                    }\r\n                    listenToElementOutputs(view, componentView, nodeDef, el);\r\n                    nodeData = {\r\n                        renderElement: el,\r\n                        componentView: componentView,\r\n                        viewContainer: null,\r\n                        template: nodeDef.element.template ? createTemplateData(view, nodeDef) : undefined\r\n                    };\r\n                    if (nodeDef.flags & 16777216 /* EmbeddedViews */) {\r\n                        nodeData.viewContainer = createViewContainerData(view, nodeDef, nodeData);\r\n                    }\r\n                    break;\r\n                case 2 /* TypeText */:\r\n                    nodeData = createText(view, renderHost, nodeDef);\r\n                    break;\r\n                case 512 /* TypeClassProvider */:\r\n                case 1024 /* TypeFactoryProvider */:\r\n                case 2048 /* TypeUseExistingProvider */:\r\n                case 256 /* TypeValueProvider */: {\r\n                    nodeData = nodes[i];\r\n                    if (!nodeData && !(nodeDef.flags & 4096 /* LazyProvider */)) {\r\n                        var instance = createProviderInstance(view, nodeDef);\r\n                        nodeData = { instance: instance };\r\n                    }\r\n                    break;\r\n                }\r\n                case 16 /* TypePipe */: {\r\n                    var instance = createPipeInstance(view, nodeDef);\r\n                    nodeData = { instance: instance };\r\n                    break;\r\n                }\r\n                case 16384 /* TypeDirective */: {\r\n                    nodeData = nodes[i];\r\n                    if (!nodeData) {\r\n                        var instance = createDirectiveInstance(view, nodeDef);\r\n                        nodeData = { instance: instance };\r\n                    }\r\n                    if (nodeDef.flags & 32768 /* Component */) {\r\n                        var compView = asElementData(view, nodeDef.parent.nodeIndex).componentView;\r\n                        initView(compView, nodeData.instance, nodeData.instance);\r\n                    }\r\n                    break;\r\n                }\r\n                case 32 /* TypePureArray */:\r\n                case 64 /* TypePureObject */:\r\n                case 128 /* TypePurePipe */:\r\n                    nodeData = createPureExpression(view, nodeDef);\r\n                    break;\r\n                case 67108864 /* TypeContentQuery */:\r\n                case 134217728 /* TypeViewQuery */:\r\n                    nodeData = createQuery();\r\n                    break;\r\n                case 8 /* TypeNgContent */:\r\n                    appendNgContent(view, renderHost, nodeDef);\r\n                    // no runtime data needed for NgContent...\r\n                    nodeData = undefined;\r\n                    break;\r\n            }\r\n            nodes[i] = nodeData;\r\n        }\r\n        // Create the ViewData.nodes of component views after we created everything else,\r\n        // so that e.g. ng-content works\r\n        execComponentViewsAction(view, ViewAction.CreateViewNodes);\r\n        // fill static content and view queries\r\n        execQueriesAction(view, 67108864 /* TypeContentQuery */ | 134217728 /* TypeViewQuery */, 268435456 /* StaticQuery */, 0 /* CheckAndUpdate */);\r\n    }\r\n    function checkNoChangesView(view) {\r\n        markProjectedViewsForCheck(view);\r\n        Services.updateDirectives(view, 1 /* CheckNoChanges */);\r\n        execEmbeddedViewsAction(view, ViewAction.CheckNoChanges);\r\n        Services.updateRenderer(view, 1 /* CheckNoChanges */);\r\n        execComponentViewsAction(view, ViewAction.CheckNoChanges);\r\n        // Note: We don't check queries for changes as we didn't do this in v2.x.\r\n        // TODO(tbosch): investigate if we can enable the check again in v5.x with a nicer error message.\r\n        view.state &= ~(64 /* CheckProjectedViews */ | 32 /* CheckProjectedView */);\r\n    }\r\n    function checkAndUpdateView(view) {\r\n        if (view.state & 1 /* BeforeFirstCheck */) {\r\n            view.state &= ~1 /* BeforeFirstCheck */;\r\n            view.state |= 2 /* FirstCheck */;\r\n        }\r\n        else {\r\n            view.state &= ~2 /* FirstCheck */;\r\n        }\r\n        shiftInitState(view, 0 /* InitState_BeforeInit */, 256 /* InitState_CallingOnInit */);\r\n        markProjectedViewsForCheck(view);\r\n        Services.updateDirectives(view, 0 /* CheckAndUpdate */);\r\n        execEmbeddedViewsAction(view, ViewAction.CheckAndUpdate);\r\n        execQueriesAction(view, 67108864 /* TypeContentQuery */, 536870912 /* DynamicQuery */, 0 /* CheckAndUpdate */);\r\n        var callInit = shiftInitState(view, 256 /* InitState_CallingOnInit */, 512 /* InitState_CallingAfterContentInit */);\r\n        callLifecycleHooksChildrenFirst(view, 2097152 /* AfterContentChecked */ | (callInit ? 1048576 /* AfterContentInit */ : 0));\r\n        Services.updateRenderer(view, 0 /* CheckAndUpdate */);\r\n        execComponentViewsAction(view, ViewAction.CheckAndUpdate);\r\n        execQueriesAction(view, 134217728 /* TypeViewQuery */, 536870912 /* DynamicQuery */, 0 /* CheckAndUpdate */);\r\n        callInit = shiftInitState(view, 512 /* InitState_CallingAfterContentInit */, 768 /* InitState_CallingAfterViewInit */);\r\n        callLifecycleHooksChildrenFirst(view, 8388608 /* AfterViewChecked */ | (callInit ? 4194304 /* AfterViewInit */ : 0));\r\n        if (view.def.flags & 2 /* OnPush */) {\r\n            view.state &= ~8 /* ChecksEnabled */;\r\n        }\r\n        view.state &= ~(64 /* CheckProjectedViews */ | 32 /* CheckProjectedView */);\r\n        shiftInitState(view, 768 /* InitState_CallingAfterViewInit */, 1024 /* InitState_AfterInit */);\r\n    }\r\n    function checkAndUpdateNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\r\n        if (argStyle === 0 /* Inline */) {\r\n            return checkAndUpdateNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\r\n        }\r\n        else {\r\n            return checkAndUpdateNodeDynamic(view, nodeDef, v0);\r\n        }\r\n    }\r\n    function markProjectedViewsForCheck(view) {\r\n        var def = view.def;\r\n        if (!(def.nodeFlags & 4 /* ProjectedTemplate */)) {\r\n            return;\r\n        }\r\n        for (var i = 0; i < def.nodes.length; i++) {\r\n            var nodeDef = def.nodes[i];\r\n            if (nodeDef.flags & 4 /* ProjectedTemplate */) {\r\n                var projectedViews = asElementData(view, i).template._projectedViews;\r\n                if (projectedViews) {\r\n                    for (var i_1 = 0; i_1 < projectedViews.length; i_1++) {\r\n                        var projectedView = projectedViews[i_1];\r\n                        projectedView.state |= 32 /* CheckProjectedView */;\r\n                        markParentViewsForCheckProjectedViews(projectedView, view);\r\n                    }\r\n                }\r\n            }\r\n            else if ((nodeDef.childFlags & 4 /* ProjectedTemplate */) === 0) {\r\n                // a parent with leafs\r\n                // no child is a component,\r\n                // then skip the children\r\n                i += nodeDef.childCount;\r\n            }\r\n        }\r\n    }\r\n    function checkAndUpdateNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\r\n        switch (nodeDef.flags & 201347067 /* Types */) {\r\n            case 1 /* TypeElement */:\r\n                return checkAndUpdateElementInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\r\n            case 2 /* TypeText */:\r\n                return checkAndUpdateTextInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\r\n            case 16384 /* TypeDirective */:\r\n                return checkAndUpdateDirectiveInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\r\n            case 32 /* TypePureArray */:\r\n            case 64 /* TypePureObject */:\r\n            case 128 /* TypePurePipe */:\r\n                return checkAndUpdatePureExpressionInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\r\n            default:\r\n                throw 'unreachable';\r\n        }\r\n    }\r\n    function checkAndUpdateNodeDynamic(view, nodeDef, values) {\r\n        switch (nodeDef.flags & 201347067 /* Types */) {\r\n            case 1 /* TypeElement */:\r\n                return checkAndUpdateElementDynamic(view, nodeDef, values);\r\n            case 2 /* TypeText */:\r\n                return checkAndUpdateTextDynamic(view, nodeDef, values);\r\n            case 16384 /* TypeDirective */:\r\n                return checkAndUpdateDirectiveDynamic(view, nodeDef, values);\r\n            case 32 /* TypePureArray */:\r\n            case 64 /* TypePureObject */:\r\n            case 128 /* TypePurePipe */:\r\n                return checkAndUpdatePureExpressionDynamic(view, nodeDef, values);\r\n            default:\r\n                throw 'unreachable';\r\n        }\r\n    }\r\n    function checkNoChangesNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\r\n        if (argStyle === 0 /* Inline */) {\r\n            checkNoChangesNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\r\n        }\r\n        else {\r\n            checkNoChangesNodeDynamic(view, nodeDef, v0);\r\n        }\r\n        // Returning false is ok here as we would have thrown in case of a change.\r\n        return false;\r\n    }\r\n    function checkNoChangesNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\r\n        var bindLen = nodeDef.bindings.length;\r\n        if (bindLen > 0)\r\n            checkBindingNoChanges(view, nodeDef, 0, v0);\r\n        if (bindLen > 1)\r\n            checkBindingNoChanges(view, nodeDef, 1, v1);\r\n        if (bindLen > 2)\r\n            checkBindingNoChanges(view, nodeDef, 2, v2);\r\n        if (bindLen > 3)\r\n            checkBindingNoChanges(view, nodeDef, 3, v3);\r\n        if (bindLen > 4)\r\n            checkBindingNoChanges(view, nodeDef, 4, v4);\r\n        if (bindLen > 5)\r\n            checkBindingNoChanges(view, nodeDef, 5, v5);\r\n        if (bindLen > 6)\r\n            checkBindingNoChanges(view, nodeDef, 6, v6);\r\n        if (bindLen > 7)\r\n            checkBindingNoChanges(view, nodeDef, 7, v7);\r\n        if (bindLen > 8)\r\n            checkBindingNoChanges(view, nodeDef, 8, v8);\r\n        if (bindLen > 9)\r\n            checkBindingNoChanges(view, nodeDef, 9, v9);\r\n    }\r\n    function checkNoChangesNodeDynamic(view, nodeDef, values) {\r\n        for (var i = 0; i < values.length; i++) {\r\n            checkBindingNoChanges(view, nodeDef, i, values[i]);\r\n        }\r\n    }\r\n    /**\r\n     * Workaround https://github.com/angular/tsickle/issues/497\r\n     * @suppress {misplacedTypeAnnotation}\r\n     */\r\n    function checkNoChangesQuery(view, nodeDef) {\r\n        var queryList = asQueryList(view, nodeDef.nodeIndex);\r\n        if (queryList.dirty) {\r\n            throw expressionChangedAfterItHasBeenCheckedError(Services.createDebugContext(view, nodeDef.nodeIndex), \"Query \" + nodeDef.query.id + \" not dirty\", \"Query \" + nodeDef.query.id + \" dirty\", (view.state & 1 /* BeforeFirstCheck */) !== 0);\r\n        }\r\n    }\r\n    function destroyView(view) {\r\n        if (view.state & 128 /* Destroyed */) {\r\n            return;\r\n        }\r\n        execEmbeddedViewsAction(view, ViewAction.Destroy);\r\n        execComponentViewsAction(view, ViewAction.Destroy);\r\n        callLifecycleHooksChildrenFirst(view, 131072 /* OnDestroy */);\r\n        if (view.disposables) {\r\n            for (var i = 0; i < view.disposables.length; i++) {\r\n                view.disposables[i]();\r\n            }\r\n        }\r\n        detachProjectedView(view);\r\n        if (view.renderer.destroyNode) {\r\n            destroyViewNodes(view);\r\n        }\r\n        if (isComponentView(view)) {\r\n            view.renderer.destroy();\r\n        }\r\n        view.state |= 128 /* Destroyed */;\r\n    }\r\n    function destroyViewNodes(view) {\r\n        var len = view.def.nodes.length;\r\n        for (var i = 0; i < len; i++) {\r\n            var def = view.def.nodes[i];\r\n            if (def.flags & 1 /* TypeElement */) {\r\n                view.renderer.destroyNode(asElementData(view, i).renderElement);\r\n            }\r\n            else if (def.flags & 2 /* TypeText */) {\r\n                view.renderer.destroyNode(asTextData(view, i).renderText);\r\n            }\r\n            else if (def.flags & 67108864 /* TypeContentQuery */ || def.flags & 134217728 /* TypeViewQuery */) {\r\n                asQueryList(view, i).destroy();\r\n            }\r\n        }\r\n    }\r\n    var ViewAction;\r\n    (function (ViewAction) {\r\n        ViewAction[ViewAction[\"CreateViewNodes\"] = 0] = \"CreateViewNodes\";\r\n        ViewAction[ViewAction[\"CheckNoChanges\"] = 1] = \"CheckNoChanges\";\r\n        ViewAction[ViewAction[\"CheckNoChangesProjectedViews\"] = 2] = \"CheckNoChangesProjectedViews\";\r\n        ViewAction[ViewAction[\"CheckAndUpdate\"] = 3] = \"CheckAndUpdate\";\r\n        ViewAction[ViewAction[\"CheckAndUpdateProjectedViews\"] = 4] = \"CheckAndUpdateProjectedViews\";\r\n        ViewAction[ViewAction[\"Destroy\"] = 5] = \"Destroy\";\r\n    })(ViewAction || (ViewAction = {}));\r\n    function execComponentViewsAction(view, action) {\r\n        var def = view.def;\r\n        if (!(def.nodeFlags & 33554432 /* ComponentView */)) {\r\n            return;\r\n        }\r\n        for (var i = 0; i < def.nodes.length; i++) {\r\n            var nodeDef = def.nodes[i];\r\n            if (nodeDef.flags & 33554432 /* ComponentView */) {\r\n                // a leaf\r\n                callViewAction(asElementData(view, i).componentView, action);\r\n            }\r\n            else if ((nodeDef.childFlags & 33554432 /* ComponentView */) === 0) {\r\n                // a parent with leafs\r\n                // no child is a component,\r\n                // then skip the children\r\n                i += nodeDef.childCount;\r\n            }\r\n        }\r\n    }\r\n    function execEmbeddedViewsAction(view, action) {\r\n        var def = view.def;\r\n        if (!(def.nodeFlags & 16777216 /* EmbeddedViews */)) {\r\n            return;\r\n        }\r\n        for (var i = 0; i < def.nodes.length; i++) {\r\n            var nodeDef = def.nodes[i];\r\n            if (nodeDef.flags & 16777216 /* EmbeddedViews */) {\r\n                // a leaf\r\n                var embeddedViews = asElementData(view, i).viewContainer._embeddedViews;\r\n                for (var k = 0; k < embeddedViews.length; k++) {\r\n                    callViewAction(embeddedViews[k], action);\r\n                }\r\n            }\r\n            else if ((nodeDef.childFlags & 16777216 /* EmbeddedViews */) === 0) {\r\n                // a parent with leafs\r\n                // no child is a component,\r\n                // then skip the children\r\n                i += nodeDef.childCount;\r\n            }\r\n        }\r\n    }\r\n    function callViewAction(view, action) {\r\n        var viewState = view.state;\r\n        switch (action) {\r\n            case ViewAction.CheckNoChanges:\r\n                if ((viewState & 128 /* Destroyed */) === 0) {\r\n                    if ((viewState & 12 /* CatDetectChanges */) === 12 /* CatDetectChanges */) {\r\n                        checkNoChangesView(view);\r\n                    }\r\n                    else if (viewState & 64 /* CheckProjectedViews */) {\r\n                        execProjectedViewsAction(view, ViewAction.CheckNoChangesProjectedViews);\r\n                    }\r\n                }\r\n                break;\r\n            case ViewAction.CheckNoChangesProjectedViews:\r\n                if ((viewState & 128 /* Destroyed */) === 0) {\r\n                    if (viewState & 32 /* CheckProjectedView */) {\r\n                        checkNoChangesView(view);\r\n                    }\r\n                    else if (viewState & 64 /* CheckProjectedViews */) {\r\n                        execProjectedViewsAction(view, action);\r\n                    }\r\n                }\r\n                break;\r\n            case ViewAction.CheckAndUpdate:\r\n                if ((viewState & 128 /* Destroyed */) === 0) {\r\n                    if ((viewState & 12 /* CatDetectChanges */) === 12 /* CatDetectChanges */) {\r\n                        checkAndUpdateView(view);\r\n                    }\r\n                    else if (viewState & 64 /* CheckProjectedViews */) {\r\n                        execProjectedViewsAction(view, ViewAction.CheckAndUpdateProjectedViews);\r\n                    }\r\n                }\r\n                break;\r\n            case ViewAction.CheckAndUpdateProjectedViews:\r\n                if ((viewState & 128 /* Destroyed */) === 0) {\r\n                    if (viewState & 32 /* CheckProjectedView */) {\r\n                        checkAndUpdateView(view);\r\n                    }\r\n                    else if (viewState & 64 /* CheckProjectedViews */) {\r\n                        execProjectedViewsAction(view, action);\r\n                    }\r\n                }\r\n                break;\r\n            case ViewAction.Destroy:\r\n                // Note: destroyView recurses over all views,\r\n                // so we don't need to special case projected views here.\r\n                destroyView(view);\r\n                break;\r\n            case ViewAction.CreateViewNodes:\r\n                createViewNodes(view);\r\n                break;\r\n        }\r\n    }\r\n    function execProjectedViewsAction(view, action) {\r\n        execEmbeddedViewsAction(view, action);\r\n        execComponentViewsAction(view, action);\r\n    }\r\n    function execQueriesAction(view, queryFlags, staticDynamicQueryFlag, checkType) {\r\n        if (!(view.def.nodeFlags & queryFlags) || !(view.def.nodeFlags & staticDynamicQueryFlag)) {\r\n            return;\r\n        }\r\n        var nodeCount = view.def.nodes.length;\r\n        for (var i = 0; i < nodeCount; i++) {\r\n            var nodeDef = view.def.nodes[i];\r\n            if ((nodeDef.flags & queryFlags) && (nodeDef.flags & staticDynamicQueryFlag)) {\r\n                Services.setCurrentNode(view, nodeDef.nodeIndex);\r\n                switch (checkType) {\r\n                    case 0 /* CheckAndUpdate */:\r\n                        checkAndUpdateQuery(view, nodeDef);\r\n                        break;\r\n                    case 1 /* CheckNoChanges */:\r\n                        checkNoChangesQuery(view, nodeDef);\r\n                        break;\r\n                }\r\n            }\r\n            if (!(nodeDef.childFlags & queryFlags) || !(nodeDef.childFlags & staticDynamicQueryFlag)) {\r\n                // no child has a matching query\r\n                // then skip the children\r\n                i += nodeDef.childCount;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var initialized = false;\r\n    function initServicesIfNeeded() {\r\n        if (initialized) {\r\n            return;\r\n        }\r\n        initialized = true;\r\n        var services = isDevMode() ? createDebugServices() : createProdServices();\r\n        Services.setCurrentNode = services.setCurrentNode;\r\n        Services.createRootView = services.createRootView;\r\n        Services.createEmbeddedView = services.createEmbeddedView;\r\n        Services.createComponentView = services.createComponentView;\r\n        Services.createNgModuleRef = services.createNgModuleRef;\r\n        Services.overrideProvider = services.overrideProvider;\r\n        Services.overrideComponentView = services.overrideComponentView;\r\n        Services.clearOverrides = services.clearOverrides;\r\n        Services.checkAndUpdateView = services.checkAndUpdateView;\r\n        Services.checkNoChangesView = services.checkNoChangesView;\r\n        Services.destroyView = services.destroyView;\r\n        Services.resolveDep = resolveDep;\r\n        Services.createDebugContext = services.createDebugContext;\r\n        Services.handleEvent = services.handleEvent;\r\n        Services.updateDirectives = services.updateDirectives;\r\n        Services.updateRenderer = services.updateRenderer;\r\n        Services.dirtyParentQueries = dirtyParentQueries;\r\n    }\r\n    function createProdServices() {\r\n        return {\r\n            setCurrentNode: function () { },\r\n            createRootView: createProdRootView,\r\n            createEmbeddedView: createEmbeddedView,\r\n            createComponentView: createComponentView,\r\n            createNgModuleRef: createNgModuleRef,\r\n            overrideProvider: NOOP,\r\n            overrideComponentView: NOOP,\r\n            clearOverrides: NOOP,\r\n            checkAndUpdateView: checkAndUpdateView,\r\n            checkNoChangesView: checkNoChangesView,\r\n            destroyView: destroyView,\r\n            createDebugContext: function (view, nodeIndex) { return new DebugContext_(view, nodeIndex); },\r\n            handleEvent: function (view, nodeIndex, eventName, event) {\r\n                return view.def.handleEvent(view, nodeIndex, eventName, event);\r\n            },\r\n            updateDirectives: function (view, checkType) { return view.def.updateDirectives(checkType === 0 /* CheckAndUpdate */ ? prodCheckAndUpdateNode :\r\n                prodCheckNoChangesNode, view); },\r\n            updateRenderer: function (view, checkType) { return view.def.updateRenderer(checkType === 0 /* CheckAndUpdate */ ? prodCheckAndUpdateNode :\r\n                prodCheckNoChangesNode, view); },\r\n        };\r\n    }\r\n    function createDebugServices() {\r\n        return {\r\n            setCurrentNode: debugSetCurrentNode,\r\n            createRootView: debugCreateRootView,\r\n            createEmbeddedView: debugCreateEmbeddedView,\r\n            createComponentView: debugCreateComponentView,\r\n            createNgModuleRef: debugCreateNgModuleRef,\r\n            overrideProvider: debugOverrideProvider,\r\n            overrideComponentView: debugOverrideComponentView,\r\n            clearOverrides: debugClearOverrides,\r\n            checkAndUpdateView: debugCheckAndUpdateView,\r\n            checkNoChangesView: debugCheckNoChangesView,\r\n            destroyView: debugDestroyView,\r\n            createDebugContext: function (view, nodeIndex) { return new DebugContext_(view, nodeIndex); },\r\n            handleEvent: debugHandleEvent,\r\n            updateDirectives: debugUpdateDirectives,\r\n            updateRenderer: debugUpdateRenderer,\r\n        };\r\n    }\r\n    function createProdRootView(elInjector, projectableNodes, rootSelectorOrNode, def, ngModule, context) {\r\n        var rendererFactory = ngModule.injector.get(RendererFactory2);\r\n        return createRootView(createRootData(elInjector, ngModule, rendererFactory, projectableNodes, rootSelectorOrNode), def, context);\r\n    }\r\n    function debugCreateRootView(elInjector, projectableNodes, rootSelectorOrNode, def, ngModule, context) {\r\n        var rendererFactory = ngModule.injector.get(RendererFactory2);\r\n        var root = createRootData(elInjector, ngModule, new DebugRendererFactory2(rendererFactory), projectableNodes, rootSelectorOrNode);\r\n        var defWithOverride = applyProviderOverridesToView(def);\r\n        return callWithDebugContext(DebugAction.create, createRootView, null, [root, defWithOverride, context]);\r\n    }\r\n    function createRootData(elInjector, ngModule, rendererFactory, projectableNodes, rootSelectorOrNode) {\r\n        var sanitizer = ngModule.injector.get(Sanitizer);\r\n        var errorHandler = ngModule.injector.get(ErrorHandler);\r\n        var renderer = rendererFactory.createRenderer(null, null);\r\n        return {\r\n            ngModule: ngModule,\r\n            injector: elInjector, projectableNodes: projectableNodes,\r\n            selectorOrNode: rootSelectorOrNode, sanitizer: sanitizer, rendererFactory: rendererFactory, renderer: renderer, errorHandler: errorHandler\r\n        };\r\n    }\r\n    function debugCreateEmbeddedView(parentView, anchorDef, viewDef, context) {\r\n        var defWithOverride = applyProviderOverridesToView(viewDef);\r\n        return callWithDebugContext(DebugAction.create, createEmbeddedView, null, [parentView, anchorDef, defWithOverride, context]);\r\n    }\r\n    function debugCreateComponentView(parentView, nodeDef, viewDef, hostElement) {\r\n        var overrideComponentView = viewDefOverrides.get(nodeDef.element.componentProvider.provider.token);\r\n        if (overrideComponentView) {\r\n            viewDef = overrideComponentView;\r\n        }\r\n        else {\r\n            viewDef = applyProviderOverridesToView(viewDef);\r\n        }\r\n        return callWithDebugContext(DebugAction.create, createComponentView, null, [parentView, nodeDef, viewDef, hostElement]);\r\n    }\r\n    function debugCreateNgModuleRef(moduleType, parentInjector, bootstrapComponents, def) {\r\n        var defWithOverride = applyProviderOverridesToNgModule(def);\r\n        return createNgModuleRef(moduleType, parentInjector, bootstrapComponents, defWithOverride);\r\n    }\r\n    var providerOverrides = new Map();\r\n    var providerOverridesWithScope = new Map();\r\n    var viewDefOverrides = new Map();\r\n    function debugOverrideProvider(override) {\r\n        providerOverrides.set(override.token, override);\r\n        var injectableDef;\r\n        if (typeof override.token === 'function' && (injectableDef = getInjectableDef(override.token)) &&\r\n            typeof injectableDef.providedIn === 'function') {\r\n            providerOverridesWithScope.set(override.token, override);\r\n        }\r\n    }\r\n    function debugOverrideComponentView(comp, compFactory) {\r\n        var hostViewDef = resolveDefinition(getComponentViewDefinitionFactory(compFactory));\r\n        var compViewDef = resolveDefinition(hostViewDef.nodes[0].element.componentView);\r\n        viewDefOverrides.set(comp, compViewDef);\r\n    }\r\n    function debugClearOverrides() {\r\n        providerOverrides.clear();\r\n        providerOverridesWithScope.clear();\r\n        viewDefOverrides.clear();\r\n    }\r\n    // Notes about the algorithm:\r\n    // 1) Locate the providers of an element and check if one of them was overwritten\r\n    // 2) Change the providers of that element\r\n    //\r\n    // We only create new datastructures if we need to, to keep perf impact\r\n    // reasonable.\r\n    function applyProviderOverridesToView(def) {\r\n        if (providerOverrides.size === 0) {\r\n            return def;\r\n        }\r\n        var elementIndicesWithOverwrittenProviders = findElementIndicesWithOverwrittenProviders(def);\r\n        if (elementIndicesWithOverwrittenProviders.length === 0) {\r\n            return def;\r\n        }\r\n        // clone the whole view definition,\r\n        // as it maintains references between the nodes that are hard to update.\r\n        def = def.factory(function () { return NOOP; });\r\n        for (var i = 0; i < elementIndicesWithOverwrittenProviders.length; i++) {\r\n            applyProviderOverridesToElement(def, elementIndicesWithOverwrittenProviders[i]);\r\n        }\r\n        return def;\r\n        function findElementIndicesWithOverwrittenProviders(def) {\r\n            var elIndicesWithOverwrittenProviders = [];\r\n            var lastElementDef = null;\r\n            for (var i = 0; i < def.nodes.length; i++) {\r\n                var nodeDef = def.nodes[i];\r\n                if (nodeDef.flags & 1 /* TypeElement */) {\r\n                    lastElementDef = nodeDef;\r\n                }\r\n                if (lastElementDef && nodeDef.flags & 3840 /* CatProviderNoDirective */ &&\r\n                    providerOverrides.has(nodeDef.provider.token)) {\r\n                    elIndicesWithOverwrittenProviders.push(lastElementDef.nodeIndex);\r\n                    lastElementDef = null;\r\n                }\r\n            }\r\n            return elIndicesWithOverwrittenProviders;\r\n        }\r\n        function applyProviderOverridesToElement(viewDef, elIndex) {\r\n            for (var i = elIndex + 1; i < viewDef.nodes.length; i++) {\r\n                var nodeDef = viewDef.nodes[i];\r\n                if (nodeDef.flags & 1 /* TypeElement */) {\r\n                    // stop at the next element\r\n                    return;\r\n                }\r\n                if (nodeDef.flags & 3840 /* CatProviderNoDirective */) {\r\n                    var provider = nodeDef.provider;\r\n                    var override = providerOverrides.get(provider.token);\r\n                    if (override) {\r\n                        nodeDef.flags = (nodeDef.flags & ~3840 /* CatProviderNoDirective */) | override.flags;\r\n                        provider.deps = splitDepsDsl(override.deps);\r\n                        provider.value = override.value;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Notes about the algorithm:\r\n    // We only create new datastructures if we need to, to keep perf impact\r\n    // reasonable.\r\n    function applyProviderOverridesToNgModule(def) {\r\n        var _a = calcHasOverrides(def), hasOverrides = _a.hasOverrides, hasDeprecatedOverrides = _a.hasDeprecatedOverrides;\r\n        if (!hasOverrides) {\r\n            return def;\r\n        }\r\n        // clone the whole view definition,\r\n        // as it maintains references between the nodes that are hard to update.\r\n        def = def.factory(function () { return NOOP; });\r\n        applyProviderOverrides(def);\r\n        return def;\r\n        function calcHasOverrides(def) {\r\n            var hasOverrides = false;\r\n            var hasDeprecatedOverrides = false;\r\n            if (providerOverrides.size === 0) {\r\n                return { hasOverrides: hasOverrides, hasDeprecatedOverrides: hasDeprecatedOverrides };\r\n            }\r\n            def.providers.forEach(function (node) {\r\n                var override = providerOverrides.get(node.token);\r\n                if ((node.flags & 3840 /* CatProviderNoDirective */) && override) {\r\n                    hasOverrides = true;\r\n                    hasDeprecatedOverrides = hasDeprecatedOverrides || override.deprecatedBehavior;\r\n                }\r\n            });\r\n            def.modules.forEach(function (module) {\r\n                providerOverridesWithScope.forEach(function (override, token) {\r\n                    if (getInjectableDef(token).providedIn === module) {\r\n                        hasOverrides = true;\r\n                        hasDeprecatedOverrides = hasDeprecatedOverrides || override.deprecatedBehavior;\r\n                    }\r\n                });\r\n            });\r\n            return { hasOverrides: hasOverrides, hasDeprecatedOverrides: hasDeprecatedOverrides };\r\n        }\r\n        function applyProviderOverrides(def) {\r\n            for (var i = 0; i < def.providers.length; i++) {\r\n                var provider = def.providers[i];\r\n                if (hasDeprecatedOverrides) {\r\n                    // We had a bug where me made\r\n                    // all providers lazy. Keep this logic behind a flag\r\n                    // for migrating existing users.\r\n                    provider.flags |= 4096 /* LazyProvider */;\r\n                }\r\n                var override = providerOverrides.get(provider.token);\r\n                if (override) {\r\n                    provider.flags = (provider.flags & ~3840 /* CatProviderNoDirective */) | override.flags;\r\n                    provider.deps = splitDepsDsl(override.deps);\r\n                    provider.value = override.value;\r\n                }\r\n            }\r\n            if (providerOverridesWithScope.size > 0) {\r\n                var moduleSet_1 = new Set(def.modules);\r\n                providerOverridesWithScope.forEach(function (override, token) {\r\n                    if (moduleSet_1.has(getInjectableDef(token).providedIn)) {\r\n                        var provider = {\r\n                            token: token,\r\n                            flags: override.flags | (hasDeprecatedOverrides ? 4096 /* LazyProvider */ : 0 /* None */),\r\n                            deps: splitDepsDsl(override.deps),\r\n                            value: override.value,\r\n                            index: def.providers.length,\r\n                        };\r\n                        def.providers.push(provider);\r\n                        def.providersByKey[tokenKey(token)] = provider;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n    function prodCheckAndUpdateNode(view, checkIndex, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\r\n        var nodeDef = view.def.nodes[checkIndex];\r\n        checkAndUpdateNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\r\n        return (nodeDef.flags & 224 /* CatPureExpression */) ?\r\n            asPureExpressionData(view, checkIndex).value :\r\n            undefined;\r\n    }\r\n    function prodCheckNoChangesNode(view, checkIndex, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\r\n        var nodeDef = view.def.nodes[checkIndex];\r\n        checkNoChangesNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\r\n        return (nodeDef.flags & 224 /* CatPureExpression */) ?\r\n            asPureExpressionData(view, checkIndex).value :\r\n            undefined;\r\n    }\r\n    function debugCheckAndUpdateView(view) {\r\n        return callWithDebugContext(DebugAction.detectChanges, checkAndUpdateView, null, [view]);\r\n    }\r\n    function debugCheckNoChangesView(view) {\r\n        return callWithDebugContext(DebugAction.checkNoChanges, checkNoChangesView, null, [view]);\r\n    }\r\n    function debugDestroyView(view) {\r\n        return callWithDebugContext(DebugAction.destroy, destroyView, null, [view]);\r\n    }\r\n    var DebugAction;\r\n    (function (DebugAction) {\r\n        DebugAction[DebugAction[\"create\"] = 0] = \"create\";\r\n        DebugAction[DebugAction[\"detectChanges\"] = 1] = \"detectChanges\";\r\n        DebugAction[DebugAction[\"checkNoChanges\"] = 2] = \"checkNoChanges\";\r\n        DebugAction[DebugAction[\"destroy\"] = 3] = \"destroy\";\r\n        DebugAction[DebugAction[\"handleEvent\"] = 4] = \"handleEvent\";\r\n    })(DebugAction || (DebugAction = {}));\r\n    var _currentAction;\r\n    var _currentView;\r\n    var _currentNodeIndex;\r\n    function debugSetCurrentNode(view, nodeIndex) {\r\n        _currentView = view;\r\n        _currentNodeIndex = nodeIndex;\r\n    }\r\n    function debugHandleEvent(view, nodeIndex, eventName, event) {\r\n        debugSetCurrentNode(view, nodeIndex);\r\n        return callWithDebugContext(DebugAction.handleEvent, view.def.handleEvent, null, [view, nodeIndex, eventName, event]);\r\n    }\r\n    function debugUpdateDirectives(view, checkType) {\r\n        if (view.state & 128 /* Destroyed */) {\r\n            throw viewDestroyedError(DebugAction[_currentAction]);\r\n        }\r\n        debugSetCurrentNode(view, nextDirectiveWithBinding(view, 0));\r\n        return view.def.updateDirectives(debugCheckDirectivesFn, view);\r\n        function debugCheckDirectivesFn(view, nodeIndex, argStyle) {\r\n            var values = [];\r\n            for (var _i = 3; _i < arguments.length; _i++) {\r\n                values[_i - 3] = arguments[_i];\r\n            }\r\n            var nodeDef = view.def.nodes[nodeIndex];\r\n            if (checkType === 0 /* CheckAndUpdate */) {\r\n                debugCheckAndUpdateNode(view, nodeDef, argStyle, values);\r\n            }\r\n            else {\r\n                debugCheckNoChangesNode(view, nodeDef, argStyle, values);\r\n            }\r\n            if (nodeDef.flags & 16384 /* TypeDirective */) {\r\n                debugSetCurrentNode(view, nextDirectiveWithBinding(view, nodeIndex));\r\n            }\r\n            return (nodeDef.flags & 224 /* CatPureExpression */) ?\r\n                asPureExpressionData(view, nodeDef.nodeIndex).value :\r\n                undefined;\r\n        }\r\n    }\r\n    function debugUpdateRenderer(view, checkType) {\r\n        if (view.state & 128 /* Destroyed */) {\r\n            throw viewDestroyedError(DebugAction[_currentAction]);\r\n        }\r\n        debugSetCurrentNode(view, nextRenderNodeWithBinding(view, 0));\r\n        return view.def.updateRenderer(debugCheckRenderNodeFn, view);\r\n        function debugCheckRenderNodeFn(view, nodeIndex, argStyle) {\r\n            var values = [];\r\n            for (var _i = 3; _i < arguments.length; _i++) {\r\n                values[_i - 3] = arguments[_i];\r\n            }\r\n            var nodeDef = view.def.nodes[nodeIndex];\r\n            if (checkType === 0 /* CheckAndUpdate */) {\r\n                debugCheckAndUpdateNode(view, nodeDef, argStyle, values);\r\n            }\r\n            else {\r\n                debugCheckNoChangesNode(view, nodeDef, argStyle, values);\r\n            }\r\n            if (nodeDef.flags & 3 /* CatRenderNode */) {\r\n                debugSetCurrentNode(view, nextRenderNodeWithBinding(view, nodeIndex));\r\n            }\r\n            return (nodeDef.flags & 224 /* CatPureExpression */) ?\r\n                asPureExpressionData(view, nodeDef.nodeIndex).value :\r\n                undefined;\r\n        }\r\n    }\r\n    function debugCheckAndUpdateNode(view, nodeDef, argStyle, givenValues) {\r\n        var changed = checkAndUpdateNode.apply(void 0, __spread([view, nodeDef, argStyle], givenValues));\r\n        if (changed) {\r\n            var values = argStyle === 1 /* Dynamic */ ? givenValues[0] : givenValues;\r\n            if (nodeDef.flags & 16384 /* TypeDirective */) {\r\n                var bindingValues = {};\r\n                for (var i = 0; i < nodeDef.bindings.length; i++) {\r\n                    var binding = nodeDef.bindings[i];\r\n                    var value = values[i];\r\n                    if (binding.flags & 8 /* TypeProperty */) {\r\n                        bindingValues[normalizeDebugBindingName(binding.nonMinifiedName)] =\r\n                            normalizeDebugBindingValue(value);\r\n                    }\r\n                }\r\n                var elDef = nodeDef.parent;\r\n                var el = asElementData(view, elDef.nodeIndex).renderElement;\r\n                if (!elDef.element.name) {\r\n                    // a comment.\r\n                    view.renderer.setValue(el, \"bindings=\" + JSON.stringify(bindingValues, null, 2));\r\n                }\r\n                else {\r\n                    // a regular element.\r\n                    for (var attr in bindingValues) {\r\n                        var value = bindingValues[attr];\r\n                        if (value != null) {\r\n                            view.renderer.setAttribute(el, attr, value);\r\n                        }\r\n                        else {\r\n                            view.renderer.removeAttribute(el, attr);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function debugCheckNoChangesNode(view, nodeDef, argStyle, values) {\r\n        checkNoChangesNode.apply(void 0, __spread([view, nodeDef, argStyle], values));\r\n    }\r\n    function nextDirectiveWithBinding(view, nodeIndex) {\r\n        for (var i = nodeIndex; i < view.def.nodes.length; i++) {\r\n            var nodeDef = view.def.nodes[i];\r\n            if (nodeDef.flags & 16384 /* TypeDirective */ && nodeDef.bindings && nodeDef.bindings.length) {\r\n                return i;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    function nextRenderNodeWithBinding(view, nodeIndex) {\r\n        for (var i = nodeIndex; i < view.def.nodes.length; i++) {\r\n            var nodeDef = view.def.nodes[i];\r\n            if ((nodeDef.flags & 3 /* CatRenderNode */) && nodeDef.bindings && nodeDef.bindings.length) {\r\n                return i;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    var DebugContext_ = /** @class */ (function () {\r\n        function DebugContext_(view, nodeIndex) {\r\n            this.view = view;\r\n            this.nodeIndex = nodeIndex;\r\n            if (nodeIndex == null) {\r\n                this.nodeIndex = nodeIndex = 0;\r\n            }\r\n            this.nodeDef = view.def.nodes[nodeIndex];\r\n            var elDef = this.nodeDef;\r\n            var elView = view;\r\n            while (elDef && (elDef.flags & 1 /* TypeElement */) === 0) {\r\n                elDef = elDef.parent;\r\n            }\r\n            if (!elDef) {\r\n                while (!elDef && elView) {\r\n                    elDef = viewParentEl(elView);\r\n                    elView = elView.parent;\r\n                }\r\n            }\r\n            this.elDef = elDef;\r\n            this.elView = elView;\r\n        }\r\n        Object.defineProperty(DebugContext_.prototype, \"elOrCompView\", {\r\n            get: function () {\r\n                // Has to be done lazily as we use the DebugContext also during creation of elements...\r\n                return asElementData(this.elView, this.elDef.nodeIndex).componentView || this.view;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugContext_.prototype, \"injector\", {\r\n            get: function () { return createInjector$1(this.elView, this.elDef); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugContext_.prototype, \"component\", {\r\n            get: function () { return this.elOrCompView.component; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugContext_.prototype, \"context\", {\r\n            get: function () { return this.elOrCompView.context; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugContext_.prototype, \"providerTokens\", {\r\n            get: function () {\r\n                var tokens = [];\r\n                if (this.elDef) {\r\n                    for (var i = this.elDef.nodeIndex + 1; i <= this.elDef.nodeIndex + this.elDef.childCount; i++) {\r\n                        var childDef = this.elView.def.nodes[i];\r\n                        if (childDef.flags & 20224 /* CatProvider */) {\r\n                            tokens.push(childDef.provider.token);\r\n                        }\r\n                        i += childDef.childCount;\r\n                    }\r\n                }\r\n                return tokens;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugContext_.prototype, \"references\", {\r\n            get: function () {\r\n                var references = {};\r\n                if (this.elDef) {\r\n                    collectReferences(this.elView, this.elDef, references);\r\n                    for (var i = this.elDef.nodeIndex + 1; i <= this.elDef.nodeIndex + this.elDef.childCount; i++) {\r\n                        var childDef = this.elView.def.nodes[i];\r\n                        if (childDef.flags & 20224 /* CatProvider */) {\r\n                            collectReferences(this.elView, childDef, references);\r\n                        }\r\n                        i += childDef.childCount;\r\n                    }\r\n                }\r\n                return references;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugContext_.prototype, \"componentRenderElement\", {\r\n            get: function () {\r\n                var elData = findHostElement(this.elOrCompView);\r\n                return elData ? elData.renderElement : undefined;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DebugContext_.prototype, \"renderNode\", {\r\n            get: function () {\r\n                return this.nodeDef.flags & 2 /* TypeText */ ? renderNode(this.view, this.nodeDef) :\r\n                    renderNode(this.elView, this.elDef);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        DebugContext_.prototype.logError = function (console) {\r\n            var values = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                values[_i - 1] = arguments[_i];\r\n            }\r\n            var logViewDef;\r\n            var logNodeIndex;\r\n            if (this.nodeDef.flags & 2 /* TypeText */) {\r\n                logViewDef = this.view.def;\r\n                logNodeIndex = this.nodeDef.nodeIndex;\r\n            }\r\n            else {\r\n                logViewDef = this.elView.def;\r\n                logNodeIndex = this.elDef.nodeIndex;\r\n            }\r\n            // Note: we only generate a log function for text and element nodes\r\n            // to make the generated code as small as possible.\r\n            var renderNodeIndex = getRenderNodeIndex(logViewDef, logNodeIndex);\r\n            var currRenderNodeIndex = -1;\r\n            var nodeLogger = function () {\r\n                var _a;\r\n                currRenderNodeIndex++;\r\n                if (currRenderNodeIndex === renderNodeIndex) {\r\n                    return (_a = console.error).bind.apply(_a, __spread([console], values));\r\n                }\r\n                else {\r\n                    return NOOP;\r\n                }\r\n            };\r\n            logViewDef.factory(nodeLogger);\r\n            if (currRenderNodeIndex < renderNodeIndex) {\r\n                console.error('Illegal state: the ViewDefinitionFactory did not call the logger!');\r\n                console.error.apply(console, __spread(values));\r\n            }\r\n        };\r\n        return DebugContext_;\r\n    }());\r\n    function getRenderNodeIndex(viewDef, nodeIndex) {\r\n        var renderNodeIndex = -1;\r\n        for (var i = 0; i <= nodeIndex; i++) {\r\n            var nodeDef = viewDef.nodes[i];\r\n            if (nodeDef.flags & 3 /* CatRenderNode */) {\r\n                renderNodeIndex++;\r\n            }\r\n        }\r\n        return renderNodeIndex;\r\n    }\r\n    function findHostElement(view) {\r\n        while (view && !isComponentView(view)) {\r\n            view = view.parent;\r\n        }\r\n        if (view.parent) {\r\n            return asElementData(view.parent, viewParentEl(view).nodeIndex);\r\n        }\r\n        return null;\r\n    }\r\n    function collectReferences(view, nodeDef, references) {\r\n        for (var refName in nodeDef.references) {\r\n            references[refName] = getQueryValue(view, nodeDef, nodeDef.references[refName]);\r\n        }\r\n    }\r\n    function callWithDebugContext(action, fn, self, args) {\r\n        var oldAction = _currentAction;\r\n        var oldView = _currentView;\r\n        var oldNodeIndex = _currentNodeIndex;\r\n        try {\r\n            _currentAction = action;\r\n            var result = fn.apply(self, args);\r\n            _currentView = oldView;\r\n            _currentNodeIndex = oldNodeIndex;\r\n            _currentAction = oldAction;\r\n            return result;\r\n        }\r\n        catch (e) {\r\n            if (isViewDebugError(e) || !_currentView) {\r\n                throw e;\r\n            }\r\n            throw viewWrappedDebugError(e, getCurrentDebugContext());\r\n        }\r\n    }\r\n    function getCurrentDebugContext() {\r\n        return _currentView ? new DebugContext_(_currentView, _currentNodeIndex) : null;\r\n    }\r\n    var DebugRendererFactory2 = /** @class */ (function () {\r\n        function DebugRendererFactory2(delegate) {\r\n            this.delegate = delegate;\r\n        }\r\n        DebugRendererFactory2.prototype.createRenderer = function (element, renderData) {\r\n            return new DebugRenderer2(this.delegate.createRenderer(element, renderData));\r\n        };\r\n        DebugRendererFactory2.prototype.begin = function () {\r\n            if (this.delegate.begin) {\r\n                this.delegate.begin();\r\n            }\r\n        };\r\n        DebugRendererFactory2.prototype.end = function () {\r\n            if (this.delegate.end) {\r\n                this.delegate.end();\r\n            }\r\n        };\r\n        DebugRendererFactory2.prototype.whenRenderingDone = function () {\r\n            if (this.delegate.whenRenderingDone) {\r\n                return this.delegate.whenRenderingDone();\r\n            }\r\n            return Promise.resolve(null);\r\n        };\r\n        return DebugRendererFactory2;\r\n    }());\r\n    var DebugRenderer2 = /** @class */ (function () {\r\n        function DebugRenderer2(delegate) {\r\n            this.delegate = delegate;\r\n            /**\r\n             * Factory function used to create a `DebugContext` when a node is created.\r\n             *\r\n             * The `DebugContext` allows to retrieve information about the nodes that are useful in tests.\r\n             *\r\n             * The factory is configurable so that the `DebugRenderer2` could instantiate either a View Engine\r\n             * or a Render context.\r\n             */\r\n            this.debugContextFactory = getCurrentDebugContext;\r\n            this.data = this.delegate.data;\r\n        }\r\n        DebugRenderer2.prototype.createDebugContext = function (nativeElement) { return this.debugContextFactory(nativeElement); };\r\n        DebugRenderer2.prototype.destroyNode = function (node) {\r\n            var debugNode = getDebugNode(node);\r\n            removeDebugNodeFromIndex(debugNode);\r\n            if (debugNode instanceof DebugNode__PRE_R3__) {\r\n                debugNode.listeners.length = 0;\r\n            }\r\n            if (this.delegate.destroyNode) {\r\n                this.delegate.destroyNode(node);\r\n            }\r\n        };\r\n        DebugRenderer2.prototype.destroy = function () { this.delegate.destroy(); };\r\n        DebugRenderer2.prototype.createElement = function (name, namespace) {\r\n            var el = this.delegate.createElement(name, namespace);\r\n            var debugCtx = this.createDebugContext(el);\r\n            if (debugCtx) {\r\n                var debugEl = new DebugElement__PRE_R3__(el, null, debugCtx);\r\n                debugEl.name = name;\r\n                indexDebugNode(debugEl);\r\n            }\r\n            return el;\r\n        };\r\n        DebugRenderer2.prototype.createComment = function (value) {\r\n            var comment = this.delegate.createComment(value);\r\n            var debugCtx = this.createDebugContext(comment);\r\n            if (debugCtx) {\r\n                indexDebugNode(new DebugNode__PRE_R3__(comment, null, debugCtx));\r\n            }\r\n            return comment;\r\n        };\r\n        DebugRenderer2.prototype.createText = function (value) {\r\n            var text = this.delegate.createText(value);\r\n            var debugCtx = this.createDebugContext(text);\r\n            if (debugCtx) {\r\n                indexDebugNode(new DebugNode__PRE_R3__(text, null, debugCtx));\r\n            }\r\n            return text;\r\n        };\r\n        DebugRenderer2.prototype.appendChild = function (parent, newChild) {\r\n            var debugEl = getDebugNode(parent);\r\n            var debugChildEl = getDebugNode(newChild);\r\n            if (debugEl && debugChildEl && debugEl instanceof DebugElement__PRE_R3__) {\r\n                debugEl.addChild(debugChildEl);\r\n            }\r\n            this.delegate.appendChild(parent, newChild);\r\n        };\r\n        DebugRenderer2.prototype.insertBefore = function (parent, newChild, refChild) {\r\n            var debugEl = getDebugNode(parent);\r\n            var debugChildEl = getDebugNode(newChild);\r\n            var debugRefEl = getDebugNode(refChild);\r\n            if (debugEl && debugChildEl && debugEl instanceof DebugElement__PRE_R3__) {\r\n                debugEl.insertBefore(debugRefEl, debugChildEl);\r\n            }\r\n            this.delegate.insertBefore(parent, newChild, refChild);\r\n        };\r\n        DebugRenderer2.prototype.removeChild = function (parent, oldChild) {\r\n            var debugEl = getDebugNode(parent);\r\n            var debugChildEl = getDebugNode(oldChild);\r\n            if (debugEl && debugChildEl && debugEl instanceof DebugElement__PRE_R3__) {\r\n                debugEl.removeChild(debugChildEl);\r\n            }\r\n            this.delegate.removeChild(parent, oldChild);\r\n        };\r\n        DebugRenderer2.prototype.selectRootElement = function (selectorOrNode, preserveContent) {\r\n            var el = this.delegate.selectRootElement(selectorOrNode, preserveContent);\r\n            var debugCtx = getCurrentDebugContext();\r\n            if (debugCtx) {\r\n                indexDebugNode(new DebugElement__PRE_R3__(el, null, debugCtx));\r\n            }\r\n            return el;\r\n        };\r\n        DebugRenderer2.prototype.setAttribute = function (el, name, value, namespace) {\r\n            var debugEl = getDebugNode(el);\r\n            if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {\r\n                var fullName = namespace ? namespace + ':' + name : name;\r\n                debugEl.attributes[fullName] = value;\r\n            }\r\n            this.delegate.setAttribute(el, name, value, namespace);\r\n        };\r\n        DebugRenderer2.prototype.removeAttribute = function (el, name, namespace) {\r\n            var debugEl = getDebugNode(el);\r\n            if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {\r\n                var fullName = namespace ? namespace + ':' + name : name;\r\n                debugEl.attributes[fullName] = null;\r\n            }\r\n            this.delegate.removeAttribute(el, name, namespace);\r\n        };\r\n        DebugRenderer2.prototype.addClass = function (el, name) {\r\n            var debugEl = getDebugNode(el);\r\n            if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {\r\n                debugEl.classes[name] = true;\r\n            }\r\n            this.delegate.addClass(el, name);\r\n        };\r\n        DebugRenderer2.prototype.removeClass = function (el, name) {\r\n            var debugEl = getDebugNode(el);\r\n            if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {\r\n                debugEl.classes[name] = false;\r\n            }\r\n            this.delegate.removeClass(el, name);\r\n        };\r\n        DebugRenderer2.prototype.setStyle = function (el, style, value, flags) {\r\n            var debugEl = getDebugNode(el);\r\n            if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {\r\n                debugEl.styles[style] = value;\r\n            }\r\n            this.delegate.setStyle(el, style, value, flags);\r\n        };\r\n        DebugRenderer2.prototype.removeStyle = function (el, style, flags) {\r\n            var debugEl = getDebugNode(el);\r\n            if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {\r\n                debugEl.styles[style] = null;\r\n            }\r\n            this.delegate.removeStyle(el, style, flags);\r\n        };\r\n        DebugRenderer2.prototype.setProperty = function (el, name, value) {\r\n            var debugEl = getDebugNode(el);\r\n            if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {\r\n                debugEl.properties[name] = value;\r\n            }\r\n            this.delegate.setProperty(el, name, value);\r\n        };\r\n        DebugRenderer2.prototype.listen = function (target, eventName, callback) {\r\n            if (typeof target !== 'string') {\r\n                var debugEl = getDebugNode(target);\r\n                if (debugEl) {\r\n                    debugEl.listeners.push(new DebugEventListener(eventName, callback));\r\n                }\r\n            }\r\n            return this.delegate.listen(target, eventName, callback);\r\n        };\r\n        DebugRenderer2.prototype.parentNode = function (node) { return this.delegate.parentNode(node); };\r\n        DebugRenderer2.prototype.nextSibling = function (node) { return this.delegate.nextSibling(node); };\r\n        DebugRenderer2.prototype.setValue = function (node, value) { return this.delegate.setValue(node, value); };\r\n        return DebugRenderer2;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function overrideProvider(override) {\r\n        initServicesIfNeeded();\r\n        return Services.overrideProvider(override);\r\n    }\r\n    function overrideComponentView(comp, componentFactory) {\r\n        initServicesIfNeeded();\r\n        return Services.overrideComponentView(comp, componentFactory);\r\n    }\r\n    function clearOverrides() {\r\n        initServicesIfNeeded();\r\n        return Services.clearOverrides();\r\n    }\r\n    // Attention: this function is called as top level function.\r\n    // Putting any logic in here will destroy closure tree shaking!\r\n    function createNgModuleFactory(ngModuleType, bootstrapComponents, defFactory) {\r\n        return new NgModuleFactory_(ngModuleType, bootstrapComponents, defFactory);\r\n    }\r\n    function cloneNgModuleDefinition(def) {\r\n        var providers = Array.from(def.providers);\r\n        var modules = Array.from(def.modules);\r\n        var providersByKey = {};\r\n        for (var key in def.providersByKey) {\r\n            providersByKey[key] = def.providersByKey[key];\r\n        }\r\n        return {\r\n            factory: def.factory,\r\n            isRoot: def.isRoot, providers: providers, modules: modules, providersByKey: providersByKey,\r\n        };\r\n    }\r\n    var NgModuleFactory_ = /** @class */ (function (_super) {\r\n        __extends(NgModuleFactory_, _super);\r\n        function NgModuleFactory_(moduleType, _bootstrapComponents, _ngModuleDefFactory) {\r\n            var _this = \r\n            // Attention: this ctor is called as top level function.\r\n            // Putting any logic in here will destroy closure tree shaking!\r\n            _super.call(this) || this;\r\n            _this.moduleType = moduleType;\r\n            _this._bootstrapComponents = _bootstrapComponents;\r\n            _this._ngModuleDefFactory = _ngModuleDefFactory;\r\n            return _this;\r\n        }\r\n        NgModuleFactory_.prototype.create = function (parentInjector) {\r\n            initServicesIfNeeded();\r\n            // Clone the NgModuleDefinition so that any tree shakeable provider definition\r\n            // added to this instance of the NgModuleRef doesn't affect the cached copy.\r\n            // See https://github.com/angular/angular/issues/25018.\r\n            var def = cloneNgModuleDefinition(resolveDefinition(this._ngModuleDefFactory));\r\n            return Services.createNgModuleRef(this.moduleType, parentInjector || Injector.NULL, this._bootstrapComponents, def);\r\n        };\r\n        return NgModuleFactory_;\r\n    }(NgModuleFactory));\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    // clang-format on\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    // This file only reexports content of the `src` folder. Keep it that way.\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n\r\n    /**\r\n     * Generated bundle index. Do not edit.\r\n     */\r\n\r\n    exports.ɵangular_packages_core_core_q = APPLICATION_MODULE_PROVIDERS;\r\n    exports.ɵangular_packages_core_core_n = _iterableDiffersFactory;\r\n    exports.ɵangular_packages_core_core_o = _keyValueDiffersFactory;\r\n    exports.ɵangular_packages_core_core_p = _localeFactory;\r\n    exports.ɵangular_packages_core_core_r = zoneSchedulerFactory;\r\n    exports.ɵangular_packages_core_core_f = _appIdRandomProviderFactory;\r\n    exports.ɵangular_packages_core_core_l = DefaultIterableDifferFactory;\r\n    exports.ɵangular_packages_core_core_m = DefaultKeyValueDifferFactory;\r\n    exports.ɵangular_packages_core_core_k = DebugElement__PRE_R3__;\r\n    exports.ɵangular_packages_core_core_j = DebugNode__PRE_R3__;\r\n    exports.ɵangular_packages_core_core_b = NullInjector;\r\n    exports.ɵangular_packages_core_core_a = injectInjectorOnly;\r\n    exports.ɵangular_packages_core_core_c = ReflectiveInjector_;\r\n    exports.ɵangular_packages_core_core_d = ReflectiveDependency;\r\n    exports.ɵangular_packages_core_core_e = resolveReflectiveProviders;\r\n    exports.ɵangular_packages_core_core_i = getModuleFactory__PRE_R3__;\r\n    exports.ɵangular_packages_core_core_s = wtfEnabled;\r\n    exports.ɵangular_packages_core_core_u = createScope;\r\n    exports.ɵangular_packages_core_core_t = detectWTF;\r\n    exports.ɵangular_packages_core_core_x = endTimeRange;\r\n    exports.ɵangular_packages_core_core_v = leave;\r\n    exports.ɵangular_packages_core_core_w = startTimeRange;\r\n    exports.ɵangular_packages_core_core_ba = SCHEDULER;\r\n    exports.ɵangular_packages_core_core_bb = injectAttributeImpl;\r\n    exports.ɵangular_packages_core_core_bc = getLView;\r\n    exports.ɵangular_packages_core_core_bd = getPreviousOrParentTNode;\r\n    exports.ɵangular_packages_core_core_be = nextContextImpl;\r\n    exports.ɵangular_packages_core_core_bm = getRootContext;\r\n    exports.ɵangular_packages_core_core_bl = loadInternal;\r\n    exports.ɵangular_packages_core_core_g = createElementRef;\r\n    exports.ɵangular_packages_core_core_h = createTemplateRef;\r\n    exports.ɵangular_packages_core_core_bg = getUrlSanitizer;\r\n    exports.ɵangular_packages_core_core_bk = noSideEffects;\r\n    exports.ɵangular_packages_core_core_bh = makeParamDecorator;\r\n    exports.ɵangular_packages_core_core_bi = makePropDecorator;\r\n    exports.ɵangular_packages_core_core_bn = getClosureSafeProperty;\r\n    exports.ɵangular_packages_core_core_y = _def;\r\n    exports.ɵangular_packages_core_core_z = DebugContext;\r\n    exports.createPlatform = createPlatform;\r\n    exports.assertPlatform = assertPlatform;\r\n    exports.destroyPlatform = destroyPlatform;\r\n    exports.getPlatform = getPlatform;\r\n    exports.PlatformRef = PlatformRef;\r\n    exports.ApplicationRef = ApplicationRef;\r\n    exports.createPlatformFactory = createPlatformFactory;\r\n    exports.NgProbeToken = NgProbeToken;\r\n    exports.enableProdMode = enableProdMode;\r\n    exports.isDevMode = isDevMode;\r\n    exports.APP_ID = APP_ID;\r\n    exports.PACKAGE_ROOT_URL = PACKAGE_ROOT_URL;\r\n    exports.PLATFORM_INITIALIZER = PLATFORM_INITIALIZER;\r\n    exports.PLATFORM_ID = PLATFORM_ID;\r\n    exports.APP_BOOTSTRAP_LISTENER = APP_BOOTSTRAP_LISTENER;\r\n    exports.APP_INITIALIZER = APP_INITIALIZER;\r\n    exports.ApplicationInitStatus = ApplicationInitStatus;\r\n    exports.DebugElement = DebugElement;\r\n    exports.DebugEventListener = DebugEventListener;\r\n    exports.DebugNode = DebugNode;\r\n    exports.asNativeElements = asNativeElements;\r\n    exports.getDebugNode = getDebugNode;\r\n    exports.Testability = Testability;\r\n    exports.TestabilityRegistry = TestabilityRegistry;\r\n    exports.setTestabilityGetter = setTestabilityGetter;\r\n    exports.TRANSLATIONS = TRANSLATIONS$1;\r\n    exports.TRANSLATIONS_FORMAT = TRANSLATIONS_FORMAT;\r\n    exports.LOCALE_ID = LOCALE_ID$1;\r\n    exports.ApplicationModule = ApplicationModule;\r\n    exports.wtfCreateScope = wtfCreateScope;\r\n    exports.wtfLeave = wtfLeave;\r\n    exports.wtfStartTimeRange = wtfStartTimeRange;\r\n    exports.wtfEndTimeRange = wtfEndTimeRange;\r\n    exports.Type = Type;\r\n    exports.EventEmitter = EventEmitter;\r\n    exports.ErrorHandler = ErrorHandler;\r\n    exports.Sanitizer = Sanitizer;\r\n    exports.Attribute = Attribute;\r\n    exports.ANALYZE_FOR_ENTRY_COMPONENTS = ANALYZE_FOR_ENTRY_COMPONENTS;\r\n    exports.ContentChild = ContentChild;\r\n    exports.ContentChildren = ContentChildren;\r\n    exports.Query = Query;\r\n    exports.ViewChild = ViewChild;\r\n    exports.ViewChildren = ViewChildren;\r\n    exports.Component = Component;\r\n    exports.Directive = Directive;\r\n    exports.HostBinding = HostBinding;\r\n    exports.HostListener = HostListener;\r\n    exports.Input = Input;\r\n    exports.Output = Output;\r\n    exports.Pipe = Pipe;\r\n    exports.NgModule = NgModule;\r\n    exports.CUSTOM_ELEMENTS_SCHEMA = CUSTOM_ELEMENTS_SCHEMA;\r\n    exports.NO_ERRORS_SCHEMA = NO_ERRORS_SCHEMA;\r\n    exports.Version = Version;\r\n    exports.VERSION = VERSION;\r\n    exports.ɵɵdefineInjectable = ɵɵdefineInjectable;\r\n    exports.defineInjectable = defineInjectable;\r\n    exports.ɵɵdefineInjector = ɵɵdefineInjector;\r\n    exports.forwardRef = forwardRef;\r\n    exports.resolveForwardRef = resolveForwardRef;\r\n    exports.Injectable = Injectable;\r\n    exports.Injector = Injector;\r\n    exports.ɵɵinject = ɵɵinject;\r\n    exports.inject = inject;\r\n    exports.INJECTOR = INJECTOR;\r\n    exports.ReflectiveInjector = ReflectiveInjector;\r\n    exports.ResolvedReflectiveFactory = ResolvedReflectiveFactory;\r\n    exports.ReflectiveKey = ReflectiveKey;\r\n    exports.InjectionToken = InjectionToken;\r\n    exports.Inject = Inject;\r\n    exports.Optional = Optional;\r\n    exports.Self = Self;\r\n    exports.SkipSelf = SkipSelf;\r\n    exports.Host = Host;\r\n    exports.ɵ0 = ɵ0;\r\n    exports.ɵ1 = ɵ1;\r\n    exports.NgZone = NgZone;\r\n    exports.ɵNoopNgZone = NoopNgZone;\r\n    exports.RenderComponentType = RenderComponentType;\r\n    exports.Renderer = Renderer;\r\n    exports.Renderer2 = Renderer2;\r\n    exports.RendererFactory2 = RendererFactory2;\r\n    exports.RootRenderer = RootRenderer;\r\n    exports.COMPILER_OPTIONS = COMPILER_OPTIONS;\r\n    exports.Compiler = Compiler;\r\n    exports.CompilerFactory = CompilerFactory;\r\n    exports.ModuleWithComponentFactories = ModuleWithComponentFactories;\r\n    exports.ComponentFactory = ComponentFactory;\r\n    exports.ɵComponentFactory = ComponentFactory;\r\n    exports.ComponentRef = ComponentRef;\r\n    exports.ComponentFactoryResolver = ComponentFactoryResolver;\r\n    exports.ElementRef = ElementRef;\r\n    exports.NgModuleFactory = NgModuleFactory;\r\n    exports.NgModuleRef = NgModuleRef;\r\n    exports.NgModuleFactoryLoader = NgModuleFactoryLoader;\r\n    exports.getModuleFactory = getModuleFactory;\r\n    exports.QueryList = QueryList;\r\n    exports.SystemJsNgModuleLoader = SystemJsNgModuleLoader;\r\n    exports.SystemJsNgModuleLoaderConfig = SystemJsNgModuleLoaderConfig;\r\n    exports.TemplateRef = TemplateRef;\r\n    exports.ViewContainerRef = ViewContainerRef;\r\n    exports.EmbeddedViewRef = EmbeddedViewRef;\r\n    exports.ViewRef = ViewRef$1;\r\n    exports.ChangeDetectorRef = ChangeDetectorRef;\r\n    exports.DefaultIterableDiffer = DefaultIterableDiffer;\r\n    exports.IterableDiffers = IterableDiffers;\r\n    exports.KeyValueDiffers = KeyValueDiffers;\r\n    exports.SimpleChange = SimpleChange;\r\n    exports.WrappedValue = WrappedValue;\r\n    exports.platformCore = platformCore;\r\n    exports.ɵALLOW_MULTIPLE_PLATFORMS = ALLOW_MULTIPLE_PLATFORMS;\r\n    exports.ɵAPP_ID_RANDOM_PROVIDER = APP_ID_RANDOM_PROVIDER;\r\n    exports.ɵdefaultIterableDiffers = defaultIterableDiffers;\r\n    exports.ɵdefaultKeyValueDiffers = defaultKeyValueDiffers;\r\n    exports.ɵdevModeEqual = devModeEqual$1;\r\n    exports.ɵisListLikeIterable = isListLikeIterable$1;\r\n    exports.ɵisDefaultChangeDetectionStrategy = isDefaultChangeDetectionStrategy;\r\n    exports.ɵConsole = Console;\r\n    exports.ɵsetCurrentInjector = setCurrentInjector;\r\n    exports.ɵgetInjectableDef = getInjectableDef;\r\n    exports.ɵAPP_ROOT = APP_ROOT;\r\n    exports.ɵDEFAULT_LOCALE_ID = DEFAULT_LOCALE_ID;\r\n    exports.ɵivyEnabled = ivyEnabled;\r\n    exports.ɵCodegenComponentFactoryResolver = CodegenComponentFactoryResolver;\r\n    exports.ɵclearResolutionOfComponentResourcesQueue = clearResolutionOfComponentResourcesQueue;\r\n    exports.ɵresolveComponentResources = resolveComponentResources;\r\n    exports.ɵReflectionCapabilities = ReflectionCapabilities;\r\n    exports.ɵRenderDebugInfo = RenderDebugInfo;\r\n    exports.ɵ_sanitizeHtml = _sanitizeHtml;\r\n    exports.ɵ_sanitizeStyle = _sanitizeStyle;\r\n    exports.ɵ_sanitizeUrl = _sanitizeUrl;\r\n    exports.ɵglobal = _global;\r\n    exports.ɵlooseIdentical = looseIdentical;\r\n    exports.ɵstringify = stringify;\r\n    exports.ɵmakeDecorator = makeDecorator;\r\n    exports.ɵisObservable = isObservable;\r\n    exports.ɵisPromise = isPromise;\r\n    exports.ɵclearOverrides = clearOverrides;\r\n    exports.ɵinitServicesIfNeeded = initServicesIfNeeded;\r\n    exports.ɵoverrideComponentView = overrideComponentView;\r\n    exports.ɵoverrideProvider = overrideProvider;\r\n    exports.ɵNOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR;\r\n    exports.ɵgetLocalePluralCase = getLocalePluralCase;\r\n    exports.ɵfindLocaleData = findLocaleData;\r\n    exports.ɵLOCALE_DATA = LOCALE_DATA;\r\n    exports.ɵɵattribute = ɵɵattribute;\r\n    exports.ɵɵattributeInterpolate1 = ɵɵattributeInterpolate1;\r\n    exports.ɵɵattributeInterpolate2 = ɵɵattributeInterpolate2;\r\n    exports.ɵɵattributeInterpolate3 = ɵɵattributeInterpolate3;\r\n    exports.ɵɵattributeInterpolate4 = ɵɵattributeInterpolate4;\r\n    exports.ɵɵattributeInterpolate5 = ɵɵattributeInterpolate5;\r\n    exports.ɵɵattributeInterpolate6 = ɵɵattributeInterpolate6;\r\n    exports.ɵɵattributeInterpolate7 = ɵɵattributeInterpolate7;\r\n    exports.ɵɵattributeInterpolate8 = ɵɵattributeInterpolate8;\r\n    exports.ɵɵattributeInterpolateV = ɵɵattributeInterpolateV;\r\n    exports.ɵɵdefineBase = ɵɵdefineBase;\r\n    exports.ɵɵdefineComponent = ɵɵdefineComponent;\r\n    exports.ɵɵdefineDirective = ɵɵdefineDirective;\r\n    exports.ɵɵdefinePipe = ɵɵdefinePipe;\r\n    exports.ɵɵdefineNgModule = ɵɵdefineNgModule;\r\n    exports.ɵdetectChanges = detectChanges;\r\n    exports.ɵrenderComponent = renderComponent;\r\n    exports.ɵRender3ComponentFactory = ComponentFactory$1;\r\n    exports.ɵRender3ComponentRef = ComponentRef$1;\r\n    exports.ɵɵdirectiveInject = ɵɵdirectiveInject;\r\n    exports.ɵɵinjectAttribute = ɵɵinjectAttribute;\r\n    exports.ɵɵinjectPipeChangeDetectorRef = ɵɵinjectPipeChangeDetectorRef;\r\n    exports.ɵɵgetFactoryOf = ɵɵgetFactoryOf;\r\n    exports.ɵɵgetInheritedFactory = ɵɵgetInheritedFactory;\r\n    exports.ɵɵsetComponentScope = ɵɵsetComponentScope;\r\n    exports.ɵɵsetNgModuleScope = ɵɵsetNgModuleScope;\r\n    exports.ɵɵtemplateRefExtractor = ɵɵtemplateRefExtractor;\r\n    exports.ɵɵProvidersFeature = ɵɵProvidersFeature;\r\n    exports.ɵɵInheritDefinitionFeature = ɵɵInheritDefinitionFeature;\r\n    exports.ɵɵNgOnChangesFeature = ɵɵNgOnChangesFeature;\r\n    exports.ɵLifecycleHooksFeature = LifecycleHooksFeature;\r\n    exports.ɵRender3NgModuleRef = NgModuleRef$1;\r\n    exports.ɵmarkDirty = markDirty;\r\n    exports.ɵNgModuleFactory = NgModuleFactory$1;\r\n    exports.ɵNO_CHANGE = NO_CHANGE;\r\n    exports.ɵɵcontainer = ɵɵcontainer;\r\n    exports.ɵɵnextContext = ɵɵnextContext;\r\n    exports.ɵɵelementStart = ɵɵelementStart;\r\n    exports.ɵɵnamespaceHTML = ɵɵnamespaceHTML;\r\n    exports.ɵɵnamespaceMathML = ɵɵnamespaceMathML;\r\n    exports.ɵɵnamespaceSVG = ɵɵnamespaceSVG;\r\n    exports.ɵɵelement = ɵɵelement;\r\n    exports.ɵɵlistener = ɵɵlistener;\r\n    exports.ɵɵtext = ɵɵtext;\r\n    exports.ɵɵtextInterpolate = ɵɵtextInterpolate;\r\n    exports.ɵɵtextInterpolate1 = ɵɵtextInterpolate1;\r\n    exports.ɵɵtextInterpolate2 = ɵɵtextInterpolate2;\r\n    exports.ɵɵtextInterpolate3 = ɵɵtextInterpolate3;\r\n    exports.ɵɵtextInterpolate4 = ɵɵtextInterpolate4;\r\n    exports.ɵɵtextInterpolate5 = ɵɵtextInterpolate5;\r\n    exports.ɵɵtextInterpolate6 = ɵɵtextInterpolate6;\r\n    exports.ɵɵtextInterpolate7 = ɵɵtextInterpolate7;\r\n    exports.ɵɵtextInterpolate8 = ɵɵtextInterpolate8;\r\n    exports.ɵɵtextInterpolateV = ɵɵtextInterpolateV;\r\n    exports.ɵɵembeddedViewStart = ɵɵembeddedViewStart;\r\n    exports.ɵɵprojection = ɵɵprojection;\r\n    exports.ɵɵpipeBind1 = ɵɵpipeBind1;\r\n    exports.ɵɵpipeBind2 = ɵɵpipeBind2;\r\n    exports.ɵɵpipeBind3 = ɵɵpipeBind3;\r\n    exports.ɵɵpipeBind4 = ɵɵpipeBind4;\r\n    exports.ɵɵpipeBindV = ɵɵpipeBindV;\r\n    exports.ɵɵpureFunction0 = ɵɵpureFunction0;\r\n    exports.ɵɵpureFunction1 = ɵɵpureFunction1;\r\n    exports.ɵɵpureFunction2 = ɵɵpureFunction2;\r\n    exports.ɵɵpureFunction3 = ɵɵpureFunction3;\r\n    exports.ɵɵpureFunction4 = ɵɵpureFunction4;\r\n    exports.ɵɵpureFunction5 = ɵɵpureFunction5;\r\n    exports.ɵɵpureFunction6 = ɵɵpureFunction6;\r\n    exports.ɵɵpureFunction7 = ɵɵpureFunction7;\r\n    exports.ɵɵpureFunction8 = ɵɵpureFunction8;\r\n    exports.ɵɵpureFunctionV = ɵɵpureFunctionV;\r\n    exports.ɵɵgetCurrentView = ɵɵgetCurrentView;\r\n    exports.ɵgetDirectives = getDirectives;\r\n    exports.ɵgetHostElement = getHostElement;\r\n    exports.ɵɵrestoreView = ɵɵrestoreView;\r\n    exports.ɵɵcontainerRefreshStart = ɵɵcontainerRefreshStart;\r\n    exports.ɵɵcontainerRefreshEnd = ɵɵcontainerRefreshEnd;\r\n    exports.ɵɵqueryRefresh = ɵɵqueryRefresh;\r\n    exports.ɵɵviewQuery = ɵɵviewQuery;\r\n    exports.ɵɵstaticViewQuery = ɵɵstaticViewQuery;\r\n    exports.ɵɵstaticContentQuery = ɵɵstaticContentQuery;\r\n    exports.ɵɵloadViewQuery = ɵɵloadViewQuery;\r\n    exports.ɵɵcontentQuery = ɵɵcontentQuery;\r\n    exports.ɵɵloadContentQuery = ɵɵloadContentQuery;\r\n    exports.ɵɵelementEnd = ɵɵelementEnd;\r\n    exports.ɵɵhostProperty = ɵɵhostProperty;\r\n    exports.ɵɵproperty = ɵɵproperty;\r\n    exports.ɵɵpropertyInterpolate = ɵɵpropertyInterpolate;\r\n    exports.ɵɵpropertyInterpolate1 = ɵɵpropertyInterpolate1;\r\n    exports.ɵɵpropertyInterpolate2 = ɵɵpropertyInterpolate2;\r\n    exports.ɵɵpropertyInterpolate3 = ɵɵpropertyInterpolate3;\r\n    exports.ɵɵpropertyInterpolate4 = ɵɵpropertyInterpolate4;\r\n    exports.ɵɵpropertyInterpolate5 = ɵɵpropertyInterpolate5;\r\n    exports.ɵɵpropertyInterpolate6 = ɵɵpropertyInterpolate6;\r\n    exports.ɵɵpropertyInterpolate7 = ɵɵpropertyInterpolate7;\r\n    exports.ɵɵpropertyInterpolate8 = ɵɵpropertyInterpolate8;\r\n    exports.ɵɵpropertyInterpolateV = ɵɵpropertyInterpolateV;\r\n    exports.ɵɵupdateSyntheticHostBinding = ɵɵupdateSyntheticHostBinding;\r\n    exports.ɵɵcomponentHostSyntheticListener = ɵɵcomponentHostSyntheticListener;\r\n    exports.ɵɵprojectionDef = ɵɵprojectionDef;\r\n    exports.ɵɵreference = ɵɵreference;\r\n    exports.ɵɵenableBindings = ɵɵenableBindings;\r\n    exports.ɵɵdisableBindings = ɵɵdisableBindings;\r\n    exports.ɵɵallocHostVars = ɵɵallocHostVars;\r\n    exports.ɵɵelementContainerStart = ɵɵelementContainerStart;\r\n    exports.ɵɵelementContainerEnd = ɵɵelementContainerEnd;\r\n    exports.ɵɵelementContainer = ɵɵelementContainer;\r\n    exports.ɵɵstyling = ɵɵstyling;\r\n    exports.ɵɵstyleMap = ɵɵstyleMap;\r\n    exports.ɵɵstyleSanitizer = ɵɵstyleSanitizer;\r\n    exports.ɵɵclassMap = ɵɵclassMap;\r\n    exports.ɵɵclassMapInterpolate1 = ɵɵclassMapInterpolate1;\r\n    exports.ɵɵclassMapInterpolate2 = ɵɵclassMapInterpolate2;\r\n    exports.ɵɵclassMapInterpolate3 = ɵɵclassMapInterpolate3;\r\n    exports.ɵɵclassMapInterpolate4 = ɵɵclassMapInterpolate4;\r\n    exports.ɵɵclassMapInterpolate5 = ɵɵclassMapInterpolate5;\r\n    exports.ɵɵclassMapInterpolate6 = ɵɵclassMapInterpolate6;\r\n    exports.ɵɵclassMapInterpolate7 = ɵɵclassMapInterpolate7;\r\n    exports.ɵɵclassMapInterpolate8 = ɵɵclassMapInterpolate8;\r\n    exports.ɵɵclassMapInterpolateV = ɵɵclassMapInterpolateV;\r\n    exports.ɵɵstyleProp = ɵɵstyleProp;\r\n    exports.ɵɵstylePropInterpolate1 = ɵɵstylePropInterpolate1;\r\n    exports.ɵɵstylePropInterpolate2 = ɵɵstylePropInterpolate2;\r\n    exports.ɵɵstylePropInterpolate3 = ɵɵstylePropInterpolate3;\r\n    exports.ɵɵstylePropInterpolate4 = ɵɵstylePropInterpolate4;\r\n    exports.ɵɵstylePropInterpolate5 = ɵɵstylePropInterpolate5;\r\n    exports.ɵɵstylePropInterpolate6 = ɵɵstylePropInterpolate6;\r\n    exports.ɵɵstylePropInterpolate7 = ɵɵstylePropInterpolate7;\r\n    exports.ɵɵstylePropInterpolate8 = ɵɵstylePropInterpolate8;\r\n    exports.ɵɵstylePropInterpolateV = ɵɵstylePropInterpolateV;\r\n    exports.ɵɵstylingApply = ɵɵstylingApply;\r\n    exports.ɵɵclassProp = ɵɵclassProp;\r\n    exports.ɵɵelementHostAttrs = ɵɵelementHostAttrs;\r\n    exports.ɵɵselect = ɵɵselect;\r\n    exports.ɵɵtextBinding = ɵɵtextBinding;\r\n    exports.ɵɵtemplate = ɵɵtemplate;\r\n    exports.ɵɵembeddedViewEnd = ɵɵembeddedViewEnd;\r\n    exports.ɵstore = store;\r\n    exports.ɵɵload = ɵɵload;\r\n    exports.ɵɵpipe = ɵɵpipe;\r\n    exports.ɵwhenRendered = whenRendered;\r\n    exports.ɵɵi18n = ɵɵi18n;\r\n    exports.ɵɵi18nAttributes = ɵɵi18nAttributes;\r\n    exports.ɵɵi18nExp = ɵɵi18nExp;\r\n    exports.ɵɵi18nStart = ɵɵi18nStart;\r\n    exports.ɵɵi18nEnd = ɵɵi18nEnd;\r\n    exports.ɵɵi18nApply = ɵɵi18nApply;\r\n    exports.ɵɵi18nPostprocess = ɵɵi18nPostprocess;\r\n    exports.ɵi18nConfigureLocalize = i18nConfigureLocalize;\r\n    exports.ɵɵi18nLocalize = ɵɵi18nLocalize;\r\n    exports.ɵsetLocaleId = setLocaleId;\r\n    exports.ɵsetClassMetadata = setClassMetadata;\r\n    exports.ɵɵresolveWindow = ɵɵresolveWindow;\r\n    exports.ɵɵresolveDocument = ɵɵresolveDocument;\r\n    exports.ɵɵresolveBody = ɵɵresolveBody;\r\n    exports.ɵcompileComponent = compileComponent;\r\n    exports.ɵcompileDirective = compileDirective;\r\n    exports.ɵcompileNgModule = compileNgModule;\r\n    exports.ɵcompileNgModuleDefs = compileNgModuleDefs;\r\n    exports.ɵpatchComponentDefWithScope = patchComponentDefWithScope;\r\n    exports.ɵresetCompiledComponents = resetCompiledComponents;\r\n    exports.ɵflushModuleScopingQueueAsMuchAsPossible = flushModuleScopingQueueAsMuchAsPossible;\r\n    exports.ɵtransitiveScopesFor = transitiveScopesFor;\r\n    exports.ɵcompilePipe = compilePipe;\r\n    exports.ɵɵsanitizeHtml = ɵɵsanitizeHtml;\r\n    exports.ɵɵsanitizeStyle = ɵɵsanitizeStyle;\r\n    exports.ɵɵdefaultStyleSanitizer = ɵɵdefaultStyleSanitizer;\r\n    exports.ɵɵsanitizeScript = ɵɵsanitizeScript;\r\n    exports.ɵɵsanitizeUrl = ɵɵsanitizeUrl;\r\n    exports.ɵɵsanitizeResourceUrl = ɵɵsanitizeResourceUrl;\r\n    exports.ɵɵsanitizeUrlOrResourceUrl = ɵɵsanitizeUrlOrResourceUrl;\r\n    exports.ɵbypassSanitizationTrustHtml = bypassSanitizationTrustHtml;\r\n    exports.ɵbypassSanitizationTrustStyle = bypassSanitizationTrustStyle;\r\n    exports.ɵbypassSanitizationTrustScript = bypassSanitizationTrustScript;\r\n    exports.ɵbypassSanitizationTrustUrl = bypassSanitizationTrustUrl;\r\n    exports.ɵbypassSanitizationTrustResourceUrl = bypassSanitizationTrustResourceUrl;\r\n    exports.ɵgetLContext = getLContext;\r\n    exports.ɵNG_ELEMENT_ID = NG_ELEMENT_ID;\r\n    exports.ɵNG_COMPONENT_DEF = NG_COMPONENT_DEF;\r\n    exports.ɵNG_DIRECTIVE_DEF = NG_DIRECTIVE_DEF;\r\n    exports.ɵNG_PIPE_DEF = NG_PIPE_DEF;\r\n    exports.ɵNG_MODULE_DEF = NG_MODULE_DEF;\r\n    exports.ɵNG_BASE_DEF = NG_BASE_DEF;\r\n    exports.ɵNG_INJECTABLE_DEF = NG_INJECTABLE_DEF;\r\n    exports.ɵNG_INJECTOR_DEF = NG_INJECTOR_DEF;\r\n    exports.ɵcompileNgModuleFactory__POST_R3__ = compileNgModuleFactory__POST_R3__;\r\n    exports.ɵisBoundToModule__POST_R3__ = isBoundToModule__POST_R3__;\r\n    exports.ɵSWITCH_COMPILE_COMPONENT__POST_R3__ = SWITCH_COMPILE_COMPONENT__POST_R3__;\r\n    exports.ɵSWITCH_COMPILE_DIRECTIVE__POST_R3__ = SWITCH_COMPILE_DIRECTIVE__POST_R3__;\r\n    exports.ɵSWITCH_COMPILE_PIPE__POST_R3__ = SWITCH_COMPILE_PIPE__POST_R3__;\r\n    exports.ɵSWITCH_COMPILE_NGMODULE__POST_R3__ = SWITCH_COMPILE_NGMODULE__POST_R3__;\r\n    exports.ɵgetDebugNode__POST_R3__ = getDebugNode__POST_R3__;\r\n    exports.ɵSWITCH_COMPILE_INJECTABLE__POST_R3__ = SWITCH_COMPILE_INJECTABLE__POST_R3__;\r\n    exports.ɵSWITCH_IVY_ENABLED__POST_R3__ = SWITCH_IVY_ENABLED__POST_R3__;\r\n    exports.ɵSWITCH_CHANGE_DETECTOR_REF_FACTORY__POST_R3__ = SWITCH_CHANGE_DETECTOR_REF_FACTORY__POST_R3__;\r\n    exports.ɵCompiler_compileModuleSync__POST_R3__ = Compiler_compileModuleSync__POST_R3__;\r\n    exports.ɵCompiler_compileModuleAsync__POST_R3__ = Compiler_compileModuleAsync__POST_R3__;\r\n    exports.ɵCompiler_compileModuleAndAllComponentsSync__POST_R3__ = Compiler_compileModuleAndAllComponentsSync__POST_R3__;\r\n    exports.ɵCompiler_compileModuleAndAllComponentsAsync__POST_R3__ = Compiler_compileModuleAndAllComponentsAsync__POST_R3__;\r\n    exports.ɵSWITCH_ELEMENT_REF_FACTORY__POST_R3__ = SWITCH_ELEMENT_REF_FACTORY__POST_R3__;\r\n    exports.ɵSWITCH_TEMPLATE_REF_FACTORY__POST_R3__ = SWITCH_TEMPLATE_REF_FACTORY__POST_R3__;\r\n    exports.ɵSWITCH_VIEW_CONTAINER_REF_FACTORY__POST_R3__ = SWITCH_VIEW_CONTAINER_REF_FACTORY__POST_R3__;\r\n    exports.ɵSWITCH_RENDERER2_FACTORY__POST_R3__ = SWITCH_RENDERER2_FACTORY__POST_R3__;\r\n    exports.ɵgetModuleFactory__POST_R3__ = getModuleFactory__POST_R3__;\r\n    exports.ɵregisterNgModuleType = registerNgModuleType;\r\n    exports.ɵpublishGlobalUtil = publishGlobalUtil;\r\n    exports.ɵpublishDefaultGlobalUtils = publishDefaultGlobalUtils;\r\n    exports.ɵcreateInjector = createInjector;\r\n    exports.ɵINJECTOR_IMPL__POST_R3__ = INJECTOR_IMPL__POST_R3__;\r\n    exports.ɵregisterModuleFactory = registerModuleFactory;\r\n    exports.ɵEMPTY_ARRAY = EMPTY_ARRAY$3;\r\n    exports.ɵEMPTY_MAP = EMPTY_MAP;\r\n    exports.ɵand = anchorDef;\r\n    exports.ɵccf = createComponentFactory;\r\n    exports.ɵcmf = createNgModuleFactory;\r\n    exports.ɵcrt = createRendererType2;\r\n    exports.ɵdid = directiveDef;\r\n    exports.ɵeld = elementDef;\r\n    exports.ɵgetComponentViewDefinitionFactory = getComponentViewDefinitionFactory;\r\n    exports.ɵinlineInterpolate = inlineInterpolate;\r\n    exports.ɵinterpolate = interpolate;\r\n    exports.ɵmod = moduleDef;\r\n    exports.ɵmpd = moduleProvideDef;\r\n    exports.ɵncd = ngContentDef;\r\n    exports.ɵnov = nodeValue;\r\n    exports.ɵpid = pipeDef;\r\n    exports.ɵprd = providerDef;\r\n    exports.ɵpad = pureArrayDef;\r\n    exports.ɵpod = pureObjectDef;\r\n    exports.ɵppd = purePipeDef;\r\n    exports.ɵqud = queryDef;\r\n    exports.ɵted = textDef;\r\n    exports.ɵunv = unwrapValue;\r\n    exports.ɵvid = viewDef;\r\n\r\n    Object.defineProperty(exports, '__esModule', { value: true });\r\n\r\n}));\r\n\r\n"]}