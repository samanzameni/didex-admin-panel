{"version":3,"sources":["d:/Angular Project/Didex/didex-admin-panel/node_modules/@angular/core/bundles/core-testing.umd.js"],"names":[],"mappings":"AAAA;;;;;;;mKAO0I;iJACT;;gDAExF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sGAwtE6D;;;;;8LAG1E","file":"core-testing.umd.js","sourcesContent":["/**\r\n * @license Angular v8.2.14\r\n * (c) 2010-2019 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\n(function (global, factory) {\r\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/compiler')) :\r\n    typeof define === 'function' && define.amd ? define('@angular/core/testing', ['exports', '@angular/core', '@angular/compiler'], factory) :\r\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.core = global.ng.core || {}, global.ng.core.testing = {}), global.ng.core, global.ng.compiler));\r\n}(this, function (exports, core, compiler) { 'use strict';\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var _global = (typeof window === 'undefined' ? global : window);\r\n    /**\r\n     * Wraps a test function in an asynchronous test zone. The test will automatically\r\n     * complete when all asynchronous calls within this zone are done. Can be used\r\n     * to wrap an {@link inject} call.\r\n     *\r\n     * Example:\r\n     *\r\n     * ```\r\n     * it('...', async(inject([AClass], (object) => {\r\n     *   object.doSomething.then(() => {\r\n     *     expect(...);\r\n     *   })\r\n     * });\r\n     * ```\r\n     *\r\n     *\r\n     */\r\n    function asyncFallback(fn) {\r\n        // If we're running using the Jasmine test framework, adapt to call the 'done'\r\n        // function when asynchronous activity is finished.\r\n        if (_global.jasmine) {\r\n            // Not using an arrow function to preserve context passed from call site\r\n            return function (done) {\r\n                if (!done) {\r\n                    // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\r\n                    // fake it here and assume sync.\r\n                    done = function () { };\r\n                    done.fail = function (e) { throw e; };\r\n                }\r\n                runInTestZone(fn, this, done, function (err) {\r\n                    if (typeof err === 'string') {\r\n                        return done.fail(new Error(err));\r\n                    }\r\n                    else {\r\n                        done.fail(err);\r\n                    }\r\n                });\r\n            };\r\n        }\r\n        // Otherwise, return a promise which will resolve when asynchronous activity\r\n        // is finished. This will be correctly consumed by the Mocha framework with\r\n        // it('...', async(myFn)); or can be used in a custom framework.\r\n        // Not using an arrow function to preserve context passed from call site\r\n        return function () {\r\n            var _this = this;\r\n            return new Promise(function (finishCallback, failCallback) {\r\n                runInTestZone(fn, _this, finishCallback, failCallback);\r\n            });\r\n        };\r\n    }\r\n    function runInTestZone(fn, context, finishCallback, failCallback) {\r\n        var currentZone = Zone.current;\r\n        var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\r\n        if (AsyncTestZoneSpec === undefined) {\r\n            throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\r\n                'Please make sure that your environment includes zone.js/dist/async-test.js');\r\n        }\r\n        var ProxyZoneSpec = Zone['ProxyZoneSpec'];\r\n        if (ProxyZoneSpec === undefined) {\r\n            throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\r\n                'Please make sure that your environment includes zone.js/dist/proxy.js');\r\n        }\r\n        var proxyZoneSpec = ProxyZoneSpec.get();\r\n        ProxyZoneSpec.assertPresent();\r\n        // We need to create the AsyncTestZoneSpec outside the ProxyZone.\r\n        // If we do it in ProxyZone then we will get to infinite recursion.\r\n        var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\r\n        var previousDelegate = proxyZoneSpec.getDelegate();\r\n        proxyZone.parent.run(function () {\r\n            var testZoneSpec = new AsyncTestZoneSpec(function () {\r\n                // Need to restore the original zone.\r\n                currentZone.run(function () {\r\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\r\n                        // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\r\n                        proxyZoneSpec.setDelegate(previousDelegate);\r\n                    }\r\n                    finishCallback();\r\n                });\r\n            }, function (error) {\r\n                // Need to restore the original zone.\r\n                currentZone.run(function () {\r\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\r\n                        // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\r\n                        proxyZoneSpec.setDelegate(previousDelegate);\r\n                    }\r\n                    failCallback(error);\r\n                });\r\n            }, 'test');\r\n            proxyZoneSpec.setDelegate(testZoneSpec);\r\n        });\r\n        return Zone.current.runGuarded(fn, context);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Wraps a test function in an asynchronous test zone. The test will automatically\r\n     * complete when all asynchronous calls within this zone are done. Can be used\r\n     * to wrap an {@link inject} call.\r\n     *\r\n     * Example:\r\n     *\r\n     * ```\r\n     * it('...', async(inject([AClass], (object) => {\r\n     *   object.doSomething.then(() => {\r\n     *     expect(...);\r\n     *   })\r\n     * });\r\n     * ```\r\n     *\r\n     * @publicApi\r\n     */\r\n    function async(fn) {\r\n        var _Zone = typeof Zone !== 'undefined' ? Zone : null;\r\n        if (!_Zone) {\r\n            return function () {\r\n                return Promise.reject('Zone is needed for the async() test helper but could not be found. ' +\r\n                    'Please make sure that your environment includes zone.js/dist/zone.js');\r\n            };\r\n        }\r\n        var asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\r\n        if (typeof asyncTest === 'function') {\r\n            return asyncTest(fn);\r\n        }\r\n        // not using new version of zone.js\r\n        // TODO @JiaLiPassion, remove this after all library updated to\r\n        // newest version of zone.js(0.8.25)\r\n        return asyncFallback(fn);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Fixture for debugging and testing a component.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var ComponentFixture = /** @class */ (function () {\r\n        function ComponentFixture(componentRef, ngZone, _autoDetect) {\r\n            var _this = this;\r\n            this.componentRef = componentRef;\r\n            this.ngZone = ngZone;\r\n            this._autoDetect = _autoDetect;\r\n            this._isStable = true;\r\n            this._isDestroyed = false;\r\n            this._resolve = null;\r\n            this._promise = null;\r\n            this._onUnstableSubscription = null;\r\n            this._onStableSubscription = null;\r\n            this._onMicrotaskEmptySubscription = null;\r\n            this._onErrorSubscription = null;\r\n            this.changeDetectorRef = componentRef.changeDetectorRef;\r\n            this.elementRef = componentRef.location;\r\n            this.debugElement = core.getDebugNode(this.elementRef.nativeElement);\r\n            this.componentInstance = componentRef.instance;\r\n            this.nativeElement = this.elementRef.nativeElement;\r\n            this.componentRef = componentRef;\r\n            this.ngZone = ngZone;\r\n            if (ngZone) {\r\n                // Create subscriptions outside the NgZone so that the callbacks run oustide\r\n                // of NgZone.\r\n                ngZone.runOutsideAngular(function () {\r\n                    _this._onUnstableSubscription =\r\n                        ngZone.onUnstable.subscribe({ next: function () { _this._isStable = false; } });\r\n                    _this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({\r\n                        next: function () {\r\n                            if (_this._autoDetect) {\r\n                                // Do a change detection run with checkNoChanges set to true to check\r\n                                // there are no changes on the second run.\r\n                                _this.detectChanges(true);\r\n                            }\r\n                        }\r\n                    });\r\n                    _this._onStableSubscription = ngZone.onStable.subscribe({\r\n                        next: function () {\r\n                            _this._isStable = true;\r\n                            // Check whether there is a pending whenStable() completer to resolve.\r\n                            if (_this._promise !== null) {\r\n                                // If so check whether there are no pending macrotasks before resolving.\r\n                                // Do this check in the next tick so that ngZone gets a chance to update the state of\r\n                                // pending macrotasks.\r\n                                scheduleMicroTask(function () {\r\n                                    if (!ngZone.hasPendingMacrotasks) {\r\n                                        if (_this._promise !== null) {\r\n                                            _this._resolve(true);\r\n                                            _this._resolve = null;\r\n                                            _this._promise = null;\r\n                                        }\r\n                                    }\r\n                                });\r\n                            }\r\n                        }\r\n                    });\r\n                    _this._onErrorSubscription =\r\n                        ngZone.onError.subscribe({ next: function (error) { throw error; } });\r\n                });\r\n            }\r\n        }\r\n        ComponentFixture.prototype._tick = function (checkNoChanges) {\r\n            this.changeDetectorRef.detectChanges();\r\n            if (checkNoChanges) {\r\n                this.checkNoChanges();\r\n            }\r\n        };\r\n        /**\r\n         * Trigger a change detection cycle for the component.\r\n         */\r\n        ComponentFixture.prototype.detectChanges = function (checkNoChanges) {\r\n            var _this = this;\r\n            if (checkNoChanges === void 0) { checkNoChanges = true; }\r\n            if (this.ngZone != null) {\r\n                // Run the change detection inside the NgZone so that any async tasks as part of the change\r\n                // detection are captured by the zone and can be waited for in isStable.\r\n                this.ngZone.run(function () { _this._tick(checkNoChanges); });\r\n            }\r\n            else {\r\n                // Running without zone. Just do the change detection.\r\n                this._tick(checkNoChanges);\r\n            }\r\n        };\r\n        /**\r\n         * Do a change detection run to make sure there were no changes.\r\n         */\r\n        ComponentFixture.prototype.checkNoChanges = function () { this.changeDetectorRef.checkNoChanges(); };\r\n        /**\r\n         * Set whether the fixture should autodetect changes.\r\n         *\r\n         * Also runs detectChanges once so that any existing change is detected.\r\n         */\r\n        ComponentFixture.prototype.autoDetectChanges = function (autoDetect) {\r\n            if (autoDetect === void 0) { autoDetect = true; }\r\n            if (this.ngZone == null) {\r\n                throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\r\n            }\r\n            this._autoDetect = autoDetect;\r\n            this.detectChanges();\r\n        };\r\n        /**\r\n         * Return whether the fixture is currently stable or has async tasks that have not been completed\r\n         * yet.\r\n         */\r\n        ComponentFixture.prototype.isStable = function () { return this._isStable && !this.ngZone.hasPendingMacrotasks; };\r\n        /**\r\n         * Get a promise that resolves when the fixture is stable.\r\n         *\r\n         * This can be used to resume testing after events have triggered asynchronous activity or\r\n         * asynchronous change detection.\r\n         */\r\n        ComponentFixture.prototype.whenStable = function () {\r\n            var _this = this;\r\n            if (this.isStable()) {\r\n                return Promise.resolve(false);\r\n            }\r\n            else if (this._promise !== null) {\r\n                return this._promise;\r\n            }\r\n            else {\r\n                this._promise = new Promise(function (res) { _this._resolve = res; });\r\n                return this._promise;\r\n            }\r\n        };\r\n        ComponentFixture.prototype._getRenderer = function () {\r\n            if (this._renderer === undefined) {\r\n                this._renderer = this.componentRef.injector.get(core.RendererFactory2, null);\r\n            }\r\n            return this._renderer;\r\n        };\r\n        /**\r\n          * Get a promise that resolves when the ui state is stable following animations.\r\n          */\r\n        ComponentFixture.prototype.whenRenderingDone = function () {\r\n            var renderer = this._getRenderer();\r\n            if (renderer && renderer.whenRenderingDone) {\r\n                return renderer.whenRenderingDone();\r\n            }\r\n            return this.whenStable();\r\n        };\r\n        /**\r\n         * Trigger component destruction.\r\n         */\r\n        ComponentFixture.prototype.destroy = function () {\r\n            if (!this._isDestroyed) {\r\n                this.componentRef.destroy();\r\n                if (this._onUnstableSubscription != null) {\r\n                    this._onUnstableSubscription.unsubscribe();\r\n                    this._onUnstableSubscription = null;\r\n                }\r\n                if (this._onStableSubscription != null) {\r\n                    this._onStableSubscription.unsubscribe();\r\n                    this._onStableSubscription = null;\r\n                }\r\n                if (this._onMicrotaskEmptySubscription != null) {\r\n                    this._onMicrotaskEmptySubscription.unsubscribe();\r\n                    this._onMicrotaskEmptySubscription = null;\r\n                }\r\n                if (this._onErrorSubscription != null) {\r\n                    this._onErrorSubscription.unsubscribe();\r\n                    this._onErrorSubscription = null;\r\n                }\r\n                this._isDestroyed = true;\r\n            }\r\n        };\r\n        return ComponentFixture;\r\n    }());\r\n    function scheduleMicroTask(fn) {\r\n        Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * fakeAsync has been moved to zone.js\r\n     * this file is for fallback in case old version of zone.js is used\r\n     */\r\n    var _Zone = typeof Zone !== 'undefined' ? Zone : null;\r\n    var FakeAsyncTestZoneSpec = _Zone && _Zone['FakeAsyncTestZoneSpec'];\r\n    var ProxyZoneSpec = _Zone && _Zone['ProxyZoneSpec'];\r\n    var _fakeAsyncTestZoneSpec = null;\r\n    /**\r\n     * Clears out the shared fake async zone for a test.\r\n     * To be called in a global `beforeEach`.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function resetFakeAsyncZoneFallback() {\r\n        _fakeAsyncTestZoneSpec = null;\r\n        // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\r\n        ProxyZoneSpec && ProxyZoneSpec.assertPresent().resetDelegate();\r\n    }\r\n    var _inFakeAsyncCall = false;\r\n    /**\r\n     * Wraps a function to be executed in the fakeAsync zone:\r\n     * - microtasks are manually executed by calling `flushMicrotasks()`,\r\n     * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\r\n     *\r\n     * If there are any pending timers at the end of the function, an exception will be thrown.\r\n     *\r\n     * Can be used to wrap inject() calls.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * {@example core/testing/ts/fake_async.ts region='basic'}\r\n     *\r\n     * @param fn\r\n     * @returns The function wrapped to be executed in the fakeAsync zone\r\n     *\r\n     * @publicApi\r\n     */\r\n    function fakeAsyncFallback(fn) {\r\n        // Not using an arrow function to preserve context passed from call site\r\n        return function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            var proxyZoneSpec = ProxyZoneSpec.assertPresent();\r\n            if (_inFakeAsyncCall) {\r\n                throw new Error('fakeAsync() calls can not be nested');\r\n            }\r\n            _inFakeAsyncCall = true;\r\n            try {\r\n                if (!_fakeAsyncTestZoneSpec) {\r\n                    if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\r\n                        throw new Error('fakeAsync() calls can not be nested');\r\n                    }\r\n                    _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\r\n                }\r\n                var res = void 0;\r\n                var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\r\n                proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\r\n                try {\r\n                    res = fn.apply(this, args);\r\n                    flushMicrotasksFallback();\r\n                }\r\n                finally {\r\n                    proxyZoneSpec.setDelegate(lastProxyZoneSpec);\r\n                }\r\n                if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\r\n                    throw new Error(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length + \" \" +\r\n                        \"periodic timer(s) still in the queue.\");\r\n                }\r\n                if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\r\n                    throw new Error(_fakeAsyncTestZoneSpec.pendingTimers.length + \" timer(s) still in the queue.\");\r\n                }\r\n                return res;\r\n            }\r\n            finally {\r\n                _inFakeAsyncCall = false;\r\n                resetFakeAsyncZoneFallback();\r\n            }\r\n        };\r\n    }\r\n    function _getFakeAsyncZoneSpec() {\r\n        if (_fakeAsyncTestZoneSpec == null) {\r\n            throw new Error('The code should be running in the fakeAsync zone to call this function');\r\n        }\r\n        return _fakeAsyncTestZoneSpec;\r\n    }\r\n    /**\r\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\r\n     *\r\n     * The microtasks queue is drained at the very start of this function and after any timer callback\r\n     * has been executed.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * {@example core/testing/ts/fake_async.ts region='basic'}\r\n     *\r\n     * @publicApi\r\n     */\r\n    function tickFallback(millis) {\r\n        if (millis === void 0) { millis = 0; }\r\n        _getFakeAsyncZoneSpec().tick(millis);\r\n    }\r\n    /**\r\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\r\n     * draining the macrotask queue until it is empty. The returned value is the milliseconds\r\n     * of time that would have been elapsed.\r\n     *\r\n     * @param maxTurns\r\n     * @returns The simulated time elapsed, in millis.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function flushFallback(maxTurns) {\r\n        return _getFakeAsyncZoneSpec().flush(maxTurns);\r\n    }\r\n    /**\r\n     * Discard all remaining periodic tasks.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function discardPeriodicTasksFallback() {\r\n        var zoneSpec = _getFakeAsyncZoneSpec();\r\n        zoneSpec.pendingPeriodicTimers.length = 0;\r\n    }\r\n    /**\r\n     * Flush any pending microtasks.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function flushMicrotasksFallback() {\r\n        _getFakeAsyncZoneSpec().flushMicrotasks();\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var _Zone$1 = typeof Zone !== 'undefined' ? Zone : null;\r\n    var fakeAsyncTestModule = _Zone$1 && _Zone$1[_Zone$1.__symbol__('fakeAsyncTest')];\r\n    /**\r\n     * Clears out the shared fake async zone for a test.\r\n     * To be called in a global `beforeEach`.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function resetFakeAsyncZone() {\r\n        if (fakeAsyncTestModule) {\r\n            return fakeAsyncTestModule.resetFakeAsyncZone();\r\n        }\r\n        else {\r\n            return resetFakeAsyncZoneFallback();\r\n        }\r\n    }\r\n    /**\r\n     * Wraps a function to be executed in the fakeAsync zone:\r\n     * - microtasks are manually executed by calling `flushMicrotasks()`,\r\n     * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\r\n     *\r\n     * If there are any pending timers at the end of the function, an exception will be thrown.\r\n     *\r\n     * Can be used to wrap inject() calls.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * {@example core/testing/ts/fake_async.ts region='basic'}\r\n     *\r\n     * @param fn\r\n     * @returns The function wrapped to be executed in the fakeAsync zone\r\n     *\r\n     * @publicApi\r\n     */\r\n    function fakeAsync(fn) {\r\n        if (fakeAsyncTestModule) {\r\n            return fakeAsyncTestModule.fakeAsync(fn);\r\n        }\r\n        else {\r\n            return fakeAsyncFallback(fn);\r\n        }\r\n    }\r\n    /**\r\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\r\n     *\r\n     * The microtasks queue is drained at the very start of this function and after any timer callback\r\n     * has been executed.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * {@example core/testing/ts/fake_async.ts region='basic'}\r\n     *\r\n     * @publicApi\r\n     */\r\n    function tick(millis) {\r\n        if (millis === void 0) { millis = 0; }\r\n        if (fakeAsyncTestModule) {\r\n            return fakeAsyncTestModule.tick(millis);\r\n        }\r\n        else {\r\n            return tickFallback(millis);\r\n        }\r\n    }\r\n    /**\r\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\r\n     * draining the macrotask queue until it is empty. The returned value is the milliseconds\r\n     * of time that would have been elapsed.\r\n     *\r\n     * @param maxTurns\r\n     * @returns The simulated time elapsed, in millis.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function flush(maxTurns) {\r\n        if (fakeAsyncTestModule) {\r\n            return fakeAsyncTestModule.flush(maxTurns);\r\n        }\r\n        else {\r\n            return flushFallback(maxTurns);\r\n        }\r\n    }\r\n    /**\r\n     * Discard all remaining periodic tasks.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function discardPeriodicTasks() {\r\n        if (fakeAsyncTestModule) {\r\n            return fakeAsyncTestModule.discardPeriodicTasks();\r\n        }\r\n        else {\r\n            discardPeriodicTasksFallback();\r\n        }\r\n    }\r\n    /**\r\n     * Flush any pending microtasks.\r\n     *\r\n     * @publicApi\r\n     */\r\n    function flushMicrotasks() {\r\n        if (fakeAsyncTestModule) {\r\n            return fakeAsyncTestModule.flushMicrotasks();\r\n        }\r\n        else {\r\n            return flushMicrotasksFallback();\r\n        }\r\n    }\r\n\r\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation. All rights reserved.\r\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n    this file except in compliance with the License. You may obtain a copy of the\r\n    License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n    MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n    and limitations under the License.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\r\n\r\n    function __rest(s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n                t[p[i]] = s[p[i]];\r\n        return t;\r\n    }\r\n\r\n    function __decorate(decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    }\r\n\r\n    function __param(paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    }\r\n\r\n    function __metadata(metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    }\r\n\r\n    function __awaiter(thisArg, _arguments, P, generator) {\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    }\r\n\r\n    function __generator(thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    }\r\n\r\n    function __exportStar(m, exports) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    }\r\n\r\n    function __values(o) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n        if (m) return m.call(o);\r\n        return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n    }\r\n\r\n    function __read(o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    }\r\n\r\n    function __spread() {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    }\r\n\r\n    function __await(v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    }\r\n\r\n    function __asyncGenerator(thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    }\r\n\r\n    function __asyncDelegator(o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n    }\r\n\r\n    function __asyncValues(o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator], i;\r\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n    }\r\n\r\n    function __makeTemplateObject(cooked, raw) {\r\n        if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n        return cooked;\r\n    };\r\n\r\n    function __importStar(mod) {\r\n        if (mod && mod.__esModule) return mod;\r\n        var result = {};\r\n        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n        result.default = mod;\r\n        return result;\r\n    }\r\n\r\n    function __importDefault(mod) {\r\n        return (mod && mod.__esModule) ? mod : { default: mod };\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Injectable completer that allows signaling completion of an asynchronous test. Used internally.\r\n     */\r\n    var AsyncTestCompleter = /** @class */ (function () {\r\n        function AsyncTestCompleter() {\r\n            var _this = this;\r\n            this._promise = new Promise(function (res, rej) {\r\n                _this._resolve = res;\r\n                _this._reject = rej;\r\n            });\r\n        }\r\n        AsyncTestCompleter.prototype.done = function (value) { this._resolve(value); };\r\n        AsyncTestCompleter.prototype.fail = function (error, stackTrace) { this._reject(error); };\r\n        Object.defineProperty(AsyncTestCompleter.prototype, \"promise\", {\r\n            get: function () { return this._promise; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return AsyncTestCompleter;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * An abstract class for inserting the root test component element in a platform independent way.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var TestComponentRenderer = /** @class */ (function () {\r\n        function TestComponentRenderer() {\r\n        }\r\n        TestComponentRenderer.prototype.insertRootElement = function (rootElementId) { };\r\n        return TestComponentRenderer;\r\n    }());\r\n    /**\r\n     * @publicApi\r\n     */\r\n    var ComponentFixtureAutoDetect = new core.InjectionToken('ComponentFixtureAutoDetect');\r\n    /**\r\n     * @publicApi\r\n     */\r\n    var ComponentFixtureNoNgZone = new core.InjectionToken('ComponentFixtureNoNgZone');\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    /**\r\n     * Used to resolve resource URLs on `@Component` when used with JIT compilation.\r\n     *\r\n     * Example:\r\n     * ```\r\n     * @Component({\r\n     *   selector: 'my-comp',\r\n     *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\r\n     * })\r\n     * class MyComponent{\r\n     * }\r\n     *\r\n     * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process\r\n     * // and `MyComponent`'s `@Component.templateUrl` needs to be resolved asynchronously.\r\n     *\r\n     * // Calling `resolveComponentResources()` will resolve `@Component.templateUrl` into\r\n     * // `@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.\r\n     *\r\n     * // Use browser's `fetch()` function as the default resource resolution strategy.\r\n     * resolveComponentResources(fetch).then(() => {\r\n     *   // After resolution all URLs have been converted into `template` strings.\r\n     *   renderComponent(MyComponent);\r\n     * });\r\n     *\r\n     * ```\r\n     *\r\n     * NOTE: In AOT the resolution happens during compilation, and so there should be no need\r\n     * to call this method outside JIT mode.\r\n     *\r\n     * @param resourceResolver a function which is responsible for returning a `Promise` to the\r\n     * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.\r\n     */\r\n    function resolveComponentResources(resourceResolver) {\r\n        // Store all promises which are fetching the resources.\r\n        var componentResolved = [];\r\n        // Cache so that we don't fetch the same resource more than once.\r\n        var urlMap = new Map();\r\n        function cachedResourceResolve(url) {\r\n            var promise = urlMap.get(url);\r\n            if (!promise) {\r\n                var resp = resourceResolver(url);\r\n                urlMap.set(url, promise = resp.then(unwrapResponse));\r\n            }\r\n            return promise;\r\n        }\r\n        componentResourceResolutionQueue.forEach(function (component, type) {\r\n            var promises = [];\r\n            if (component.templateUrl) {\r\n                promises.push(cachedResourceResolve(component.templateUrl).then(function (template) {\r\n                    component.template = template;\r\n                }));\r\n            }\r\n            var styleUrls = component.styleUrls;\r\n            var styles = component.styles || (component.styles = []);\r\n            var styleOffset = component.styles.length;\r\n            styleUrls && styleUrls.forEach(function (styleUrl, index) {\r\n                styles.push(''); // pre-allocate array.\r\n                promises.push(cachedResourceResolve(styleUrl).then(function (style) {\r\n                    styles[styleOffset + index] = style;\r\n                    styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\r\n                    if (styleUrls.length == 0) {\r\n                        component.styleUrls = undefined;\r\n                    }\r\n                }));\r\n            });\r\n            var fullyResolved = Promise.all(promises).then(function () { return componentDefResolved(type); });\r\n            componentResolved.push(fullyResolved);\r\n        });\r\n        clearResolutionOfComponentResourcesQueue();\r\n        return Promise.all(componentResolved).then(function () { return undefined; });\r\n    }\r\n    var componentResourceResolutionQueue = new Map();\r\n    // Track when existing ngComponentDef for a Type is waiting on resources.\r\n    var componentDefPendingResolution = new Set();\r\n    function maybeQueueResolutionOfComponentResources(type, metadata) {\r\n        if (componentNeedsResolution(metadata)) {\r\n            componentResourceResolutionQueue.set(type, metadata);\r\n            componentDefPendingResolution.add(type);\r\n        }\r\n    }\r\n    function isComponentDefPendingResolution(type) {\r\n        return componentDefPendingResolution.has(type);\r\n    }\r\n    function componentNeedsResolution(component) {\r\n        return !!((component.templateUrl && !component.hasOwnProperty('template')) ||\r\n            component.styleUrls && component.styleUrls.length);\r\n    }\r\n    function clearResolutionOfComponentResourcesQueue() {\r\n        var old = componentResourceResolutionQueue;\r\n        componentResourceResolutionQueue = new Map();\r\n        return old;\r\n    }\r\n    function restoreComponentResolutionQueue(queue) {\r\n        componentDefPendingResolution.clear();\r\n        queue.forEach(function (_, type) { return componentDefPendingResolution.add(type); });\r\n        componentResourceResolutionQueue = queue;\r\n    }\r\n    function isComponentResourceResolutionQueueEmpty() {\r\n        return componentResourceResolutionQueue.size === 0;\r\n    }\r\n    function unwrapResponse(response) {\r\n        return typeof response == 'string' ? response : response.text();\r\n    }\r\n    function componentDefResolved(type) {\r\n        componentDefPendingResolution.delete(type);\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var _nextReferenceId = 0;\r\n    var MetadataOverrider = /** @class */ (function () {\r\n        function MetadataOverrider() {\r\n            this._references = new Map();\r\n        }\r\n        /**\r\n         * Creates a new instance for the given metadata class\r\n         * based on an old instance and overrides.\r\n         */\r\n        MetadataOverrider.prototype.overrideMetadata = function (metadataClass, oldMetadata, override) {\r\n            var props = {};\r\n            if (oldMetadata) {\r\n                _valueProps(oldMetadata).forEach(function (prop) { return props[prop] = oldMetadata[prop]; });\r\n            }\r\n            if (override.set) {\r\n                if (override.remove || override.add) {\r\n                    throw new Error(\"Cannot set and add/remove \" + core.ɵstringify(metadataClass) + \" at the same time!\");\r\n                }\r\n                setMetadata(props, override.set);\r\n            }\r\n            if (override.remove) {\r\n                removeMetadata(props, override.remove, this._references);\r\n            }\r\n            if (override.add) {\r\n                addMetadata(props, override.add);\r\n            }\r\n            return new metadataClass(props);\r\n        };\r\n        return MetadataOverrider;\r\n    }());\r\n    function removeMetadata(metadata, remove, references) {\r\n        var removeObjects = new Set();\r\n        var _loop_1 = function (prop) {\r\n            var removeValue = remove[prop];\r\n            if (removeValue instanceof Array) {\r\n                removeValue.forEach(function (value) { removeObjects.add(_propHashKey(prop, value, references)); });\r\n            }\r\n            else {\r\n                removeObjects.add(_propHashKey(prop, removeValue, references));\r\n            }\r\n        };\r\n        for (var prop in remove) {\r\n            _loop_1(prop);\r\n        }\r\n        var _loop_2 = function (prop) {\r\n            var propValue = metadata[prop];\r\n            if (propValue instanceof Array) {\r\n                metadata[prop] = propValue.filter(function (value) { return !removeObjects.has(_propHashKey(prop, value, references)); });\r\n            }\r\n            else {\r\n                if (removeObjects.has(_propHashKey(prop, propValue, references))) {\r\n                    metadata[prop] = undefined;\r\n                }\r\n            }\r\n        };\r\n        for (var prop in metadata) {\r\n            _loop_2(prop);\r\n        }\r\n    }\r\n    function addMetadata(metadata, add) {\r\n        for (var prop in add) {\r\n            var addValue = add[prop];\r\n            var propValue = metadata[prop];\r\n            if (propValue != null && propValue instanceof Array) {\r\n                metadata[prop] = propValue.concat(addValue);\r\n            }\r\n            else {\r\n                metadata[prop] = addValue;\r\n            }\r\n        }\r\n    }\r\n    function setMetadata(metadata, set) {\r\n        for (var prop in set) {\r\n            metadata[prop] = set[prop];\r\n        }\r\n    }\r\n    function _propHashKey(propName, propValue, references) {\r\n        var replacer = function (key, value) {\r\n            if (typeof value === 'function') {\r\n                value = _serializeReference(value, references);\r\n            }\r\n            return value;\r\n        };\r\n        return propName + \":\" + JSON.stringify(propValue, replacer);\r\n    }\r\n    function _serializeReference(ref, references) {\r\n        var id = references.get(ref);\r\n        if (!id) {\r\n            id = \"\" + core.ɵstringify(ref) + _nextReferenceId++;\r\n            references.set(ref, id);\r\n        }\r\n        return id;\r\n    }\r\n    function _valueProps(obj) {\r\n        var props = [];\r\n        // regular public props\r\n        Object.keys(obj).forEach(function (prop) {\r\n            if (!prop.startsWith('_')) {\r\n                props.push(prop);\r\n            }\r\n        });\r\n        // getters\r\n        var proto = obj;\r\n        while (proto = Object.getPrototypeOf(proto)) {\r\n            Object.keys(proto).forEach(function (protoProp) {\r\n                var desc = Object.getOwnPropertyDescriptor(proto, protoProp);\r\n                if (!protoProp.startsWith('_') && desc && 'get' in desc) {\r\n                    props.push(protoProp);\r\n                }\r\n            });\r\n        }\r\n        return props;\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var reflection = new core.ɵReflectionCapabilities();\r\n    /**\r\n     * Allows to override ivy metadata for tests (via the `TestBed`).\r\n     */\r\n    var OverrideResolver = /** @class */ (function () {\r\n        function OverrideResolver() {\r\n            this.overrides = new Map();\r\n            this.resolved = new Map();\r\n        }\r\n        OverrideResolver.prototype.addOverride = function (type, override) {\r\n            var overrides = this.overrides.get(type) || [];\r\n            overrides.push(override);\r\n            this.overrides.set(type, overrides);\r\n            this.resolved.delete(type);\r\n        };\r\n        OverrideResolver.prototype.setOverrides = function (overrides) {\r\n            var _this = this;\r\n            this.overrides.clear();\r\n            overrides.forEach(function (_a) {\r\n                var _b = __read(_a, 2), type = _b[0], override = _b[1];\r\n                _this.addOverride(type, override);\r\n            });\r\n        };\r\n        OverrideResolver.prototype.getAnnotation = function (type) {\r\n            var annotations = reflection.annotations(type);\r\n            // Try to find the nearest known Type annotation and make sure that this annotation is an\r\n            // instance of the type we are looking for, so we can use it for resolution. Note: there might\r\n            // be multiple known annotations found due to the fact that Components can extend Directives (so\r\n            // both Directive and Component annotations would be present), so we always check if the known\r\n            // annotation has the right type.\r\n            for (var i = annotations.length - 1; i >= 0; i--) {\r\n                var annotation = annotations[i];\r\n                var isKnownType = annotation instanceof core.Directive || annotation instanceof core.Component ||\r\n                    annotation instanceof core.Pipe || annotation instanceof core.NgModule;\r\n                if (isKnownType) {\r\n                    return annotation instanceof this.type ? annotation : null;\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        OverrideResolver.prototype.resolve = function (type) {\r\n            var _this = this;\r\n            var resolved = this.resolved.get(type) || null;\r\n            if (!resolved) {\r\n                resolved = this.getAnnotation(type);\r\n                if (resolved) {\r\n                    var overrides = this.overrides.get(type);\r\n                    if (overrides) {\r\n                        var overrider_1 = new MetadataOverrider();\r\n                        overrides.forEach(function (override) {\r\n                            resolved = overrider_1.overrideMetadata(_this.type, resolved, override);\r\n                        });\r\n                    }\r\n                }\r\n                this.resolved.set(type, resolved);\r\n            }\r\n            return resolved;\r\n        };\r\n        return OverrideResolver;\r\n    }());\r\n    var DirectiveResolver = /** @class */ (function (_super) {\r\n        __extends(DirectiveResolver, _super);\r\n        function DirectiveResolver() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        Object.defineProperty(DirectiveResolver.prototype, \"type\", {\r\n            get: function () { return core.Directive; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return DirectiveResolver;\r\n    }(OverrideResolver));\r\n    var ComponentResolver = /** @class */ (function (_super) {\r\n        __extends(ComponentResolver, _super);\r\n        function ComponentResolver() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        Object.defineProperty(ComponentResolver.prototype, \"type\", {\r\n            get: function () { return core.Component; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return ComponentResolver;\r\n    }(OverrideResolver));\r\n    var PipeResolver = /** @class */ (function (_super) {\r\n        __extends(PipeResolver, _super);\r\n        function PipeResolver() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        Object.defineProperty(PipeResolver.prototype, \"type\", {\r\n            get: function () { return core.Pipe; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return PipeResolver;\r\n    }(OverrideResolver));\r\n    var NgModuleResolver = /** @class */ (function (_super) {\r\n        __extends(NgModuleResolver, _super);\r\n        function NgModuleResolver() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        Object.defineProperty(NgModuleResolver.prototype, \"type\", {\r\n            get: function () { return core.NgModule; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return NgModuleResolver;\r\n    }(OverrideResolver));\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var TestingModuleOverride;\r\n    (function (TestingModuleOverride) {\r\n        TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\r\n        TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\r\n    })(TestingModuleOverride || (TestingModuleOverride = {}));\r\n    function isTestingModuleOverride(value) {\r\n        return value === TestingModuleOverride.DECLARATION ||\r\n            value === TestingModuleOverride.OVERRIDE_TEMPLATE;\r\n    }\r\n    var R3TestBedCompiler = /** @class */ (function () {\r\n        function R3TestBedCompiler(platform, additionalModuleTypes) {\r\n            this.platform = platform;\r\n            this.additionalModuleTypes = additionalModuleTypes;\r\n            this.originalComponentResolutionQueue = null;\r\n            // Testing module configuration\r\n            this.declarations = [];\r\n            this.imports = [];\r\n            this.providers = [];\r\n            this.schemas = [];\r\n            // Queues of components/directives/pipes that should be recompiled.\r\n            this.pendingComponents = new Set();\r\n            this.pendingDirectives = new Set();\r\n            this.pendingPipes = new Set();\r\n            // Keep track of all components and directives, so we can patch Providers onto defs later.\r\n            this.seenComponents = new Set();\r\n            this.seenDirectives = new Set();\r\n            // Store resolved styles for Components that have template overrides present and `styleUrls`\r\n            // defined at the same time.\r\n            this.existingComponentStyles = new Map();\r\n            this.resolvers = initResolvers();\r\n            this.componentToModuleScope = new Map();\r\n            // Map that keeps initial version of component/directive/pipe defs in case\r\n            // we compile a Type again, thus overriding respective static fields. This is\r\n            // required to make sure we restore defs to their initial states between test runs\r\n            // TODO: we should support the case with multiple defs on a type\r\n            this.initialNgDefs = new Map();\r\n            // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\r\n            // defs in case TestBed makes changes to the originals.\r\n            this.defCleanupOps = [];\r\n            this._injector = null;\r\n            this.compilerProviders = null;\r\n            this.providerOverrides = [];\r\n            this.rootProviderOverrides = [];\r\n            this.providerOverridesByToken = new Map();\r\n            this.moduleProvidersOverridden = new Set();\r\n            this.testModuleRef = null;\r\n            var DynamicTestModule = /** @class */ (function () {\r\n                function DynamicTestModule() {\r\n                }\r\n                return DynamicTestModule;\r\n            }());\r\n            this.testModuleType = DynamicTestModule;\r\n        }\r\n        R3TestBedCompiler.prototype.setCompilerProviders = function (providers) {\r\n            this.compilerProviders = providers;\r\n            this._injector = null;\r\n        };\r\n        R3TestBedCompiler.prototype.configureTestingModule = function (moduleDef) {\r\n            var _a, _b, _c, _d;\r\n            // Enqueue any compilation tasks for the directly declared component.\r\n            if (moduleDef.declarations !== undefined) {\r\n                this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\r\n                (_a = this.declarations).push.apply(_a, __spread(moduleDef.declarations));\r\n            }\r\n            // Enqueue any compilation tasks for imported modules.\r\n            if (moduleDef.imports !== undefined) {\r\n                this.queueTypesFromModulesArray(moduleDef.imports);\r\n                (_b = this.imports).push.apply(_b, __spread(moduleDef.imports));\r\n            }\r\n            if (moduleDef.providers !== undefined) {\r\n                (_c = this.providers).push.apply(_c, __spread(moduleDef.providers));\r\n            }\r\n            if (moduleDef.schemas !== undefined) {\r\n                (_d = this.schemas).push.apply(_d, __spread(moduleDef.schemas));\r\n            }\r\n        };\r\n        R3TestBedCompiler.prototype.overrideModule = function (ngModule, override) {\r\n            // Compile the module right away.\r\n            this.resolvers.module.addOverride(ngModule, override);\r\n            var metadata = this.resolvers.module.resolve(ngModule);\r\n            if (metadata === null) {\r\n                throw new Error(ngModule.name + \" is not an @NgModule or is missing metadata\");\r\n            }\r\n            this.recompileNgModule(ngModule);\r\n            // At this point, the module has a valid .ngModuleDef, but the override may have introduced\r\n            // new declarations or imported modules. Ingest any possible new types and add them to the\r\n            // current queue.\r\n            this.queueTypesFromModulesArray([ngModule]);\r\n        };\r\n        R3TestBedCompiler.prototype.overrideComponent = function (component, override) {\r\n            this.resolvers.component.addOverride(component, override);\r\n            this.pendingComponents.add(component);\r\n        };\r\n        R3TestBedCompiler.prototype.overrideDirective = function (directive, override) {\r\n            this.resolvers.directive.addOverride(directive, override);\r\n            this.pendingDirectives.add(directive);\r\n        };\r\n        R3TestBedCompiler.prototype.overridePipe = function (pipe, override) {\r\n            this.resolvers.pipe.addOverride(pipe, override);\r\n            this.pendingPipes.add(pipe);\r\n        };\r\n        R3TestBedCompiler.prototype.overrideProvider = function (token, provider) {\r\n            var providerDef = provider.useFactory ?\r\n                {\r\n                    provide: token,\r\n                    useFactory: provider.useFactory,\r\n                    deps: provider.deps || [],\r\n                    multi: provider.multi,\r\n                } :\r\n                { provide: token, useValue: provider.useValue, multi: provider.multi };\r\n            var injectableDef;\r\n            var isRoot = (typeof token !== 'string' && (injectableDef = core.ɵgetInjectableDef(token)) &&\r\n                injectableDef.providedIn === 'root');\r\n            var overridesBucket = isRoot ? this.rootProviderOverrides : this.providerOverrides;\r\n            overridesBucket.push(providerDef);\r\n            // Keep overrides grouped by token as well for fast lookups using token\r\n            this.providerOverridesByToken.set(token, providerDef);\r\n        };\r\n        R3TestBedCompiler.prototype.overrideTemplateUsingTestingModule = function (type, template) {\r\n            var _this = this;\r\n            var def = type[core.ɵNG_COMPONENT_DEF];\r\n            var hasStyleUrls = function () {\r\n                var metadata = _this.resolvers.component.resolve(type);\r\n                return !!metadata.styleUrls && metadata.styleUrls.length > 0;\r\n            };\r\n            var overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls();\r\n            // In Ivy, compiling a component does not require knowing the module providing the\r\n            // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\r\n            // overrideComponent. Important: overriding template requires full Component re-compilation,\r\n            // which may fail in case styleUrls are also present (thus Component is considered as required\r\n            // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\r\n            // preserve current styles available on Component def and restore styles back once compilation\r\n            // is complete.\r\n            var override = overrideStyleUrls ? { template: template, styles: [], styleUrls: [] } : { template: template };\r\n            this.overrideComponent(type, { set: override });\r\n            if (overrideStyleUrls && def.styles && def.styles.length > 0) {\r\n                this.existingComponentStyles.set(type, def.styles);\r\n            }\r\n            // Set the component's scope to be the testing module.\r\n            this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\r\n        };\r\n        R3TestBedCompiler.prototype.compileComponents = function () {\r\n            return __awaiter(this, void 0, void 0, function () {\r\n                var needsAsyncResources, resourceLoader_1, resolver;\r\n                var _this = this;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            this.clearComponentResolutionQueue();\r\n                            needsAsyncResources = this.compileTypesSync();\r\n                            if (!needsAsyncResources) return [3 /*break*/, 2];\r\n                            resolver = function (url) {\r\n                                if (!resourceLoader_1) {\r\n                                    resourceLoader_1 = _this.injector.get(compiler.ResourceLoader);\r\n                                }\r\n                                return Promise.resolve(resourceLoader_1.get(url));\r\n                            };\r\n                            return [4 /*yield*/, resolveComponentResources(resolver)];\r\n                        case 1:\r\n                            _a.sent();\r\n                            _a.label = 2;\r\n                        case 2: return [2 /*return*/];\r\n                    }\r\n                });\r\n            });\r\n        };\r\n        R3TestBedCompiler.prototype.finalize = function () {\r\n            // One last compile\r\n            this.compileTypesSync();\r\n            // Create the testing module itself.\r\n            this.compileTestModule();\r\n            this.applyTransitiveScopes();\r\n            this.applyProviderOverrides();\r\n            // Patch previously stored `styles` Component values (taken from ngComponentDef), in case these\r\n            // Components have `styleUrls` fields defined and template override was requested.\r\n            this.patchComponentsWithExistingStyles();\r\n            // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\r\n            // every component.\r\n            this.componentToModuleScope.clear();\r\n            var parentInjector = this.platform.injector;\r\n            this.testModuleRef = new core.ɵRender3NgModuleRef(this.testModuleType, parentInjector);\r\n            // Set the locale ID, it can be overridden for the tests\r\n            var localeId = this.testModuleRef.injector.get(core.LOCALE_ID, core.ɵDEFAULT_LOCALE_ID);\r\n            core.ɵsetLocaleId(localeId);\r\n            // ApplicationInitStatus.runInitializers() is marked @internal to core.\r\n            // Cast it to any before accessing it.\r\n            this.testModuleRef.injector.get(core.ApplicationInitStatus).runInitializers();\r\n            return this.testModuleRef;\r\n        };\r\n        /**\r\n         * @internal\r\n         */\r\n        R3TestBedCompiler.prototype._compileNgModuleSync = function (moduleType) {\r\n            this.queueTypesFromModulesArray([moduleType]);\r\n            this.compileTypesSync();\r\n            this.applyProviderOverrides();\r\n            this.applyProviderOverridesToModule(moduleType);\r\n            this.applyTransitiveScopes();\r\n        };\r\n        /**\r\n         * @internal\r\n         */\r\n        R3TestBedCompiler.prototype._compileNgModuleAsync = function (moduleType) {\r\n            return __awaiter(this, void 0, void 0, function () {\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            this.queueTypesFromModulesArray([moduleType]);\r\n                            return [4 /*yield*/, this.compileComponents()];\r\n                        case 1:\r\n                            _a.sent();\r\n                            this.applyProviderOverrides();\r\n                            this.applyProviderOverridesToModule(moduleType);\r\n                            this.applyTransitiveScopes();\r\n                            return [2 /*return*/];\r\n                    }\r\n                });\r\n            });\r\n        };\r\n        /**\r\n         * @internal\r\n         */\r\n        R3TestBedCompiler.prototype._getModuleResolver = function () { return this.resolvers.module; };\r\n        /**\r\n         * @internal\r\n         */\r\n        R3TestBedCompiler.prototype._getComponentFactories = function (moduleType) {\r\n            var _this = this;\r\n            return maybeUnwrapFn(moduleType.ngModuleDef.declarations).reduce(function (factories, declaration) {\r\n                var componentDef = declaration.ngComponentDef;\r\n                componentDef && factories.push(new core.ɵRender3ComponentFactory(componentDef, _this.testModuleRef));\r\n                return factories;\r\n            }, []);\r\n        };\r\n        R3TestBedCompiler.prototype.compileTypesSync = function () {\r\n            var _this = this;\r\n            // Compile all queued components, directives, pipes.\r\n            var needsAsyncResources = false;\r\n            this.pendingComponents.forEach(function (declaration) {\r\n                needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);\r\n                var metadata = _this.resolvers.component.resolve(declaration);\r\n                _this.maybeStoreNgDef(core.ɵNG_COMPONENT_DEF, declaration);\r\n                core.ɵcompileComponent(declaration, metadata);\r\n            });\r\n            this.pendingComponents.clear();\r\n            this.pendingDirectives.forEach(function (declaration) {\r\n                var metadata = _this.resolvers.directive.resolve(declaration);\r\n                _this.maybeStoreNgDef(core.ɵNG_DIRECTIVE_DEF, declaration);\r\n                core.ɵcompileDirective(declaration, metadata);\r\n            });\r\n            this.pendingDirectives.clear();\r\n            this.pendingPipes.forEach(function (declaration) {\r\n                var metadata = _this.resolvers.pipe.resolve(declaration);\r\n                _this.maybeStoreNgDef(core.ɵNG_PIPE_DEF, declaration);\r\n                core.ɵcompilePipe(declaration, metadata);\r\n            });\r\n            this.pendingPipes.clear();\r\n            return needsAsyncResources;\r\n        };\r\n        R3TestBedCompiler.prototype.applyTransitiveScopes = function () {\r\n            var _this = this;\r\n            var moduleToScope = new Map();\r\n            var getScopeOfModule = function (moduleType) {\r\n                if (!moduleToScope.has(moduleType)) {\r\n                    var realType = isTestingModuleOverride(moduleType) ? _this.testModuleType : moduleType;\r\n                    moduleToScope.set(moduleType, core.ɵtransitiveScopesFor(realType));\r\n                }\r\n                return moduleToScope.get(moduleType);\r\n            };\r\n            this.componentToModuleScope.forEach(function (moduleType, componentType) {\r\n                var moduleScope = getScopeOfModule(moduleType);\r\n                _this.storeFieldOfDefOnType(componentType, core.ɵNG_COMPONENT_DEF, 'directiveDefs');\r\n                _this.storeFieldOfDefOnType(componentType, core.ɵNG_COMPONENT_DEF, 'pipeDefs');\r\n                core.ɵpatchComponentDefWithScope(componentType.ngComponentDef, moduleScope);\r\n            });\r\n            this.componentToModuleScope.clear();\r\n        };\r\n        R3TestBedCompiler.prototype.applyProviderOverrides = function () {\r\n            var _this = this;\r\n            var maybeApplyOverrides = function (field) { return function (type) {\r\n                var resolver = field === core.ɵNG_COMPONENT_DEF ? _this.resolvers.component : _this.resolvers.directive;\r\n                var metadata = resolver.resolve(type);\r\n                if (_this.hasProviderOverrides(metadata.providers)) {\r\n                    _this.patchDefWithProviderOverrides(type, field);\r\n                }\r\n            }; };\r\n            this.seenComponents.forEach(maybeApplyOverrides(core.ɵNG_COMPONENT_DEF));\r\n            this.seenDirectives.forEach(maybeApplyOverrides(core.ɵNG_DIRECTIVE_DEF));\r\n            this.seenComponents.clear();\r\n            this.seenDirectives.clear();\r\n        };\r\n        R3TestBedCompiler.prototype.applyProviderOverridesToModule = function (moduleType) {\r\n            var e_1, _a;\r\n            if (this.moduleProvidersOverridden.has(moduleType)) {\r\n                return;\r\n            }\r\n            this.moduleProvidersOverridden.add(moduleType);\r\n            var injectorDef = moduleType[core.ɵNG_INJECTOR_DEF];\r\n            if (this.providerOverridesByToken.size > 0) {\r\n                // Extract the list of providers from ModuleWithProviders, so we can define the final list of\r\n                // providers that might have overrides.\r\n                // Note: second `flatten` operation is needed to convert an array of providers\r\n                // (e.g. `[[], []]`) into one flat list, also eliminating empty arrays.\r\n                var providersFromModules = flatten(flatten(injectorDef.imports, function (imported) {\r\n                    return isModuleWithProviders(imported) ? imported.providers : [];\r\n                }));\r\n                var providers = __spread(providersFromModules, injectorDef.providers);\r\n                if (this.hasProviderOverrides(providers)) {\r\n                    this.maybeStoreNgDef(core.ɵNG_INJECTOR_DEF, moduleType);\r\n                    this.storeFieldOfDefOnType(moduleType, core.ɵNG_INJECTOR_DEF, 'providers');\r\n                    injectorDef.providers = this.getOverriddenProviders(providers);\r\n                }\r\n                // Apply provider overrides to imported modules recursively\r\n                var moduleDef = moduleType[core.ɵNG_MODULE_DEF];\r\n                try {\r\n                    for (var _b = __values(moduleDef.imports), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                        var importType = _c.value;\r\n                        this.applyProviderOverridesToModule(importType);\r\n                    }\r\n                }\r\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                    }\r\n                    finally { if (e_1) throw e_1.error; }\r\n                }\r\n            }\r\n        };\r\n        R3TestBedCompiler.prototype.patchComponentsWithExistingStyles = function () {\r\n            this.existingComponentStyles.forEach(function (styles, type) { return type[core.ɵNG_COMPONENT_DEF].styles = styles; });\r\n            this.existingComponentStyles.clear();\r\n        };\r\n        R3TestBedCompiler.prototype.queueTypeArray = function (arr, moduleType) {\r\n            var e_2, _a;\r\n            try {\r\n                for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {\r\n                    var value = arr_1_1.value;\r\n                    if (Array.isArray(value)) {\r\n                        this.queueTypeArray(value, moduleType);\r\n                    }\r\n                    else {\r\n                        this.queueType(value, moduleType);\r\n                    }\r\n                }\r\n            }\r\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n            finally {\r\n                try {\r\n                    if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);\r\n                }\r\n                finally { if (e_2) throw e_2.error; }\r\n            }\r\n        };\r\n        R3TestBedCompiler.prototype.recompileNgModule = function (ngModule) {\r\n            var metadata = this.resolvers.module.resolve(ngModule);\r\n            if (metadata === null) {\r\n                throw new Error(\"Unable to resolve metadata for NgModule: \" + ngModule.name);\r\n            }\r\n            // Cache the initial ngModuleDef as it will be overwritten.\r\n            this.maybeStoreNgDef(core.ɵNG_MODULE_DEF, ngModule);\r\n            this.maybeStoreNgDef(core.ɵNG_INJECTOR_DEF, ngModule);\r\n            core.ɵcompileNgModuleDefs(ngModule, metadata);\r\n        };\r\n        R3TestBedCompiler.prototype.queueType = function (type, moduleType) {\r\n            var component = this.resolvers.component.resolve(type);\r\n            if (component) {\r\n                // Check whether a give Type has respective NG def (ngComponentDef) and compile if def is\r\n                // missing. That might happen in case a class without any Angular decorators extends another\r\n                // class where Component/Directive/Pipe decorator is defined.\r\n                if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(core.ɵNG_COMPONENT_DEF)) {\r\n                    this.pendingComponents.add(type);\r\n                }\r\n                this.seenComponents.add(type);\r\n                // Keep track of the module which declares this component, so later the component's scope\r\n                // can be set correctly. If the component has already been recorded here, then one of several\r\n                // cases is true:\r\n                // * the module containing the component was imported multiple times (common).\r\n                // * the component is declared in multiple modules (which is an error).\r\n                // * the component was in 'declarations' of the testing module, and also in an imported module\r\n                //   in which case the module scope will be TestingModuleOverride.DECLARATION.\r\n                // * overrideTemplateUsingTestingModule was called for the component in which case the module\r\n                //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\r\n                //\r\n                // If the component was previously in the testing module's 'declarations' (meaning the\r\n                // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\r\n                // real module, which was imported. This pattern is understood to mean that the component\r\n                // should use its original scope, but that the testing module should also contain the\r\n                // component in its scope.\r\n                if (!this.componentToModuleScope.has(type) ||\r\n                    this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {\r\n                    this.componentToModuleScope.set(type, moduleType);\r\n                }\r\n                return;\r\n            }\r\n            var directive = this.resolvers.directive.resolve(type);\r\n            if (directive) {\r\n                if (!type.hasOwnProperty(core.ɵNG_DIRECTIVE_DEF)) {\r\n                    this.pendingDirectives.add(type);\r\n                }\r\n                this.seenDirectives.add(type);\r\n                return;\r\n            }\r\n            var pipe = this.resolvers.pipe.resolve(type);\r\n            if (pipe && !type.hasOwnProperty(core.ɵNG_PIPE_DEF)) {\r\n                this.pendingPipes.add(type);\r\n                return;\r\n            }\r\n        };\r\n        R3TestBedCompiler.prototype.queueTypesFromModulesArray = function (arr) {\r\n            var e_3, _a;\r\n            try {\r\n                for (var arr_2 = __values(arr), arr_2_1 = arr_2.next(); !arr_2_1.done; arr_2_1 = arr_2.next()) {\r\n                    var value = arr_2_1.value;\r\n                    if (Array.isArray(value)) {\r\n                        this.queueTypesFromModulesArray(value);\r\n                    }\r\n                    else if (hasNgModuleDef(value)) {\r\n                        var def = value.ngModuleDef;\r\n                        // Look through declarations, imports, and exports, and queue everything found there.\r\n                        this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\r\n                        this.queueTypesFromModulesArray(maybeUnwrapFn(def.imports));\r\n                        this.queueTypesFromModulesArray(maybeUnwrapFn(def.exports));\r\n                    }\r\n                }\r\n            }\r\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n            finally {\r\n                try {\r\n                    if (arr_2_1 && !arr_2_1.done && (_a = arr_2.return)) _a.call(arr_2);\r\n                }\r\n                finally { if (e_3) throw e_3.error; }\r\n            }\r\n        };\r\n        R3TestBedCompiler.prototype.maybeStoreNgDef = function (prop, type) {\r\n            if (!this.initialNgDefs.has(type)) {\r\n                var currentDef = Object.getOwnPropertyDescriptor(type, prop);\r\n                this.initialNgDefs.set(type, [prop, currentDef]);\r\n            }\r\n        };\r\n        R3TestBedCompiler.prototype.storeFieldOfDefOnType = function (type, defField, field) {\r\n            var def = type[defField];\r\n            var original = def[field];\r\n            this.defCleanupOps.push({ field: field, def: def, original: original });\r\n        };\r\n        /**\r\n         * Clears current components resolution queue, but stores the state of the queue, so we can\r\n         * restore it later. Clearing the queue is required before we try to compile components (via\r\n         * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\r\n         */\r\n        R3TestBedCompiler.prototype.clearComponentResolutionQueue = function () {\r\n            var _this = this;\r\n            if (this.originalComponentResolutionQueue === null) {\r\n                this.originalComponentResolutionQueue = new Map();\r\n            }\r\n            clearResolutionOfComponentResourcesQueue().forEach(function (value, key) { return _this.originalComponentResolutionQueue.set(key, value); });\r\n        };\r\n        /*\r\n         * Restores component resolution queue to the previously saved state. This operation is performed\r\n         * as a part of restoring the state after completion of the current set of tests (that might\r\n         * potentially mutate the state).\r\n         */\r\n        R3TestBedCompiler.prototype.restoreComponentResolutionQueue = function () {\r\n            if (this.originalComponentResolutionQueue !== null) {\r\n                restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\r\n                this.originalComponentResolutionQueue = null;\r\n            }\r\n        };\r\n        R3TestBedCompiler.prototype.restoreOriginalState = function () {\r\n            var e_4, _a;\r\n            try {\r\n                for (var _b = __values(this.defCleanupOps), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var op = _c.value;\r\n                    op.def[op.field] = op.original;\r\n                }\r\n            }\r\n            catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_4) throw e_4.error; }\r\n            }\r\n            // Restore initial component/directive/pipe defs\r\n            this.initialNgDefs.forEach(function (value, type) {\r\n                var _a = __read(value, 2), prop = _a[0], descriptor = _a[1];\r\n                if (!descriptor) {\r\n                    // Delete operations are generally undesirable since they have performance implications\r\n                    // on objects they were applied to. In this particular case, situations where this code\r\n                    // is invoked should be quite rare to cause any noticeable impact, since it's applied\r\n                    // only to some test cases (for example when class with no annotations extends some\r\n                    // @Component) when we need to clear 'ngComponentDef' field on a given class to restore\r\n                    // its original state (before applying overrides and running tests).\r\n                    delete type[prop];\r\n                }\r\n                else {\r\n                    Object.defineProperty(type, prop, descriptor);\r\n                }\r\n            });\r\n            this.initialNgDefs.clear();\r\n            this.moduleProvidersOverridden.clear();\r\n            this.restoreComponentResolutionQueue();\r\n            // Restore the locale ID to the default value, this shouldn't be necessary but we never know\r\n            core.ɵsetLocaleId(core.ɵDEFAULT_LOCALE_ID);\r\n        };\r\n        R3TestBedCompiler.prototype.compileTestModule = function () {\r\n            var _this = this;\r\n            var RootScopeModule = /** @class */ (function () {\r\n                function RootScopeModule() {\r\n                }\r\n                return RootScopeModule;\r\n            }());\r\n            core.ɵcompileNgModuleDefs(RootScopeModule, {\r\n                providers: __spread(this.rootProviderOverrides),\r\n            });\r\n            var ngZone = new core.NgZone({ enableLongStackTrace: true });\r\n            var providers = __spread([\r\n                { provide: core.NgZone, useValue: ngZone },\r\n                { provide: core.Compiler, useFactory: function () { return new R3TestCompiler(_this); } }\r\n            ], this.providers, this.providerOverrides);\r\n            var imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\r\n            // clang-format off\r\n            core.ɵcompileNgModuleDefs(this.testModuleType, {\r\n                declarations: this.declarations,\r\n                imports: imports,\r\n                schemas: this.schemas,\r\n                providers: providers,\r\n            }, /* allowDuplicateDeclarationsInRoot */ true);\r\n            // clang-format on\r\n            this.applyProviderOverridesToModule(this.testModuleType);\r\n        };\r\n        Object.defineProperty(R3TestBedCompiler.prototype, \"injector\", {\r\n            get: function () {\r\n                if (this._injector !== null) {\r\n                    return this._injector;\r\n                }\r\n                var providers = [];\r\n                var compilerOptions = this.platform.injector.get(core.COMPILER_OPTIONS);\r\n                compilerOptions.forEach(function (opts) {\r\n                    if (opts.providers) {\r\n                        providers.push(opts.providers);\r\n                    }\r\n                });\r\n                if (this.compilerProviders !== null) {\r\n                    providers.push.apply(providers, __spread(this.compilerProviders));\r\n                }\r\n                // TODO(ocombe): make this work with an Injector directly instead of creating a module for it\r\n                var CompilerModule = /** @class */ (function () {\r\n                    function CompilerModule() {\r\n                    }\r\n                    return CompilerModule;\r\n                }());\r\n                core.ɵcompileNgModuleDefs(CompilerModule, { providers: providers });\r\n                var CompilerModuleFactory = new core.ɵNgModuleFactory(CompilerModule);\r\n                this._injector = CompilerModuleFactory.create(this.platform.injector).injector;\r\n                return this._injector;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        // get overrides for a specific provider (if any)\r\n        R3TestBedCompiler.prototype.getSingleProviderOverrides = function (provider) {\r\n            var token = getProviderToken(provider);\r\n            return this.providerOverridesByToken.get(token) || null;\r\n        };\r\n        R3TestBedCompiler.prototype.getProviderOverrides = function (providers) {\r\n            var _this = this;\r\n            if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\r\n                return [];\r\n            // There are two flattening operations here. The inner flatten() operates on the metadata's\r\n            // providers and applies a mapping function which retrieves overrides for each incoming\r\n            // provider. The outer flatten() then flattens the produced overrides array. If this is not\r\n            // done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\r\n            // providers array and contaminate any error messages that might be generated.\r\n            return flatten(flatten(providers, function (provider) { return _this.getSingleProviderOverrides(provider) || []; }));\r\n        };\r\n        R3TestBedCompiler.prototype.getOverriddenProviders = function (providers) {\r\n            var _this = this;\r\n            if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\r\n                return [];\r\n            var overrides = this.getProviderOverrides(providers);\r\n            var hasMultiProviderOverrides = overrides.some(isMultiProvider);\r\n            var overriddenProviders = __spread(providers, overrides);\r\n            // No additional processing is required in case we have no multi providers to override\r\n            if (!hasMultiProviderOverrides) {\r\n                return overriddenProviders;\r\n            }\r\n            var final = [];\r\n            var seenMultiProviders = new Set();\r\n            // We iterate through the list of providers in reverse order to make sure multi provider\r\n            // overrides take precedence over the values defined in provider list. We also fiter out all\r\n            // multi providers that have overrides, keeping overridden values only.\r\n            forEachRight(overriddenProviders, function (provider) {\r\n                var token = getProviderToken(provider);\r\n                if (isMultiProvider(provider) && _this.providerOverridesByToken.has(token)) {\r\n                    if (!seenMultiProviders.has(token)) {\r\n                        seenMultiProviders.add(token);\r\n                        if (provider && provider.useValue && Array.isArray(provider.useValue)) {\r\n                            forEachRight(provider.useValue, function (value) {\r\n                                // Unwrap provider override array into individual providers in final set.\r\n                                final.unshift({ provide: token, useValue: value, multi: true });\r\n                            });\r\n                        }\r\n                        else {\r\n                            final.unshift(provider);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    final.unshift(provider);\r\n                }\r\n            });\r\n            return final;\r\n        };\r\n        R3TestBedCompiler.prototype.hasProviderOverrides = function (providers) {\r\n            return this.getProviderOverrides(providers).length > 0;\r\n        };\r\n        R3TestBedCompiler.prototype.patchDefWithProviderOverrides = function (declaration, field) {\r\n            var _this = this;\r\n            var def = declaration[field];\r\n            if (def && def.providersResolver) {\r\n                this.maybeStoreNgDef(field, declaration);\r\n                var resolver_1 = def.providersResolver;\r\n                var processProvidersFn_1 = function (providers) { return _this.getOverriddenProviders(providers); };\r\n                this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\r\n                def.providersResolver = function (ngDef) { return resolver_1(ngDef, processProvidersFn_1); };\r\n            }\r\n        };\r\n        return R3TestBedCompiler;\r\n    }());\r\n    function initResolvers() {\r\n        return {\r\n            module: new NgModuleResolver(),\r\n            component: new ComponentResolver(),\r\n            directive: new DirectiveResolver(),\r\n            pipe: new PipeResolver()\r\n        };\r\n    }\r\n    function hasNgModuleDef(value) {\r\n        return value.hasOwnProperty('ngModuleDef');\r\n    }\r\n    function maybeUnwrapFn(maybeFn) {\r\n        return maybeFn instanceof Function ? maybeFn() : maybeFn;\r\n    }\r\n    function flatten(values, mapFn) {\r\n        var out = [];\r\n        values.forEach(function (value) {\r\n            if (Array.isArray(value)) {\r\n                out.push.apply(out, __spread(flatten(value, mapFn)));\r\n            }\r\n            else {\r\n                out.push(mapFn ? mapFn(value) : value);\r\n            }\r\n        });\r\n        return out;\r\n    }\r\n    function getProviderField(provider, field) {\r\n        return provider && typeof provider === 'object' && provider[field];\r\n    }\r\n    function getProviderToken(provider) {\r\n        return getProviderField(provider, 'provide') || provider;\r\n    }\r\n    function isMultiProvider(provider) {\r\n        return !!getProviderField(provider, 'multi');\r\n    }\r\n    function isModuleWithProviders(value) {\r\n        return value.hasOwnProperty('ngModule');\r\n    }\r\n    function forEachRight(values, fn) {\r\n        for (var idx = values.length - 1; idx >= 0; idx--) {\r\n            fn(values[idx], idx);\r\n        }\r\n    }\r\n    var R3TestCompiler = /** @class */ (function () {\r\n        function R3TestCompiler(testBed) {\r\n            this.testBed = testBed;\r\n        }\r\n        R3TestCompiler.prototype.compileModuleSync = function (moduleType) {\r\n            this.testBed._compileNgModuleSync(moduleType);\r\n            return new core.ɵNgModuleFactory(moduleType);\r\n        };\r\n        R3TestCompiler.prototype.compileModuleAsync = function (moduleType) {\r\n            return __awaiter(this, void 0, void 0, function () {\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0: return [4 /*yield*/, this.testBed._compileNgModuleAsync(moduleType)];\r\n                        case 1:\r\n                            _a.sent();\r\n                            return [2 /*return*/, new core.ɵNgModuleFactory(moduleType)];\r\n                    }\r\n                });\r\n            });\r\n        };\r\n        R3TestCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {\r\n            var ngModuleFactory = this.compileModuleSync(moduleType);\r\n            var componentFactories = this.testBed._getComponentFactories(moduleType);\r\n            return new core.ModuleWithComponentFactories(ngModuleFactory, componentFactories);\r\n        };\r\n        R3TestCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {\r\n            return __awaiter(this, void 0, void 0, function () {\r\n                var ngModuleFactory, componentFactories;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0: return [4 /*yield*/, this.compileModuleAsync(moduleType)];\r\n                        case 1:\r\n                            ngModuleFactory = _a.sent();\r\n                            componentFactories = this.testBed._getComponentFactories(moduleType);\r\n                            return [2 /*return*/, new core.ModuleWithComponentFactories(ngModuleFactory, componentFactories)];\r\n                    }\r\n                });\r\n            });\r\n        };\r\n        R3TestCompiler.prototype.clearCache = function () { };\r\n        R3TestCompiler.prototype.clearCacheFor = function (type) { };\r\n        R3TestCompiler.prototype.getModuleId = function (moduleType) {\r\n            var meta = this.testBed._getModuleResolver().resolve(moduleType);\r\n            return meta && meta.id || undefined;\r\n        };\r\n        return R3TestCompiler;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var _nextRootElementId = 0;\r\n    var UNDEFINED = Symbol('UNDEFINED');\r\n    /**\r\n     * @description\r\n     * Configures and initializes environment for unit testing and provides methods for\r\n     * creating components and services in unit tests.\r\n     *\r\n     * TestBed is the primary api for writing unit tests for Angular applications and libraries.\r\n     *\r\n     * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\r\n     * according to the compiler used.\r\n     */\r\n    var TestBedRender3 = /** @class */ (function () {\r\n        function TestBedRender3() {\r\n            // Properties\r\n            this.platform = null;\r\n            this.ngModule = null;\r\n            this._compiler = null;\r\n            this._testModuleRef = null;\r\n            this._activeFixtures = [];\r\n            this._globalCompilationChecked = false;\r\n        }\r\n        /**\r\n         * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\r\n         * angular module. These are common to every test in the suite.\r\n         *\r\n         * This may only be called once, to set up the common providers for the current test\r\n         * suite on the current platform. If you absolutely need to change the providers,\r\n         * first use `resetTestEnvironment`.\r\n         *\r\n         * Test modules and platforms for individual platforms are available from\r\n         * '@angular/<platform_name>/testing'.\r\n         *\r\n         * @publicApi\r\n         */\r\n        TestBedRender3.initTestEnvironment = function (ngModule, platform, aotSummaries) {\r\n            var testBed = _getTestBedRender3();\r\n            testBed.initTestEnvironment(ngModule, platform, aotSummaries);\r\n            return testBed;\r\n        };\r\n        /**\r\n         * Reset the providers for the test injector.\r\n         *\r\n         * @publicApi\r\n         */\r\n        TestBedRender3.resetTestEnvironment = function () { _getTestBedRender3().resetTestEnvironment(); };\r\n        TestBedRender3.configureCompiler = function (config) {\r\n            _getTestBedRender3().configureCompiler(config);\r\n            return TestBedRender3;\r\n        };\r\n        /**\r\n         * Allows overriding default providers, directives, pipes, modules of the test injector,\r\n         * which are defined in test_injector.js\r\n         */\r\n        TestBedRender3.configureTestingModule = function (moduleDef) {\r\n            _getTestBedRender3().configureTestingModule(moduleDef);\r\n            return TestBedRender3;\r\n        };\r\n        /**\r\n         * Compile components with a `templateUrl` for the test's NgModule.\r\n         * It is necessary to call this function\r\n         * as fetching urls is asynchronous.\r\n         */\r\n        TestBedRender3.compileComponents = function () { return _getTestBedRender3().compileComponents(); };\r\n        TestBedRender3.overrideModule = function (ngModule, override) {\r\n            _getTestBedRender3().overrideModule(ngModule, override);\r\n            return TestBedRender3;\r\n        };\r\n        TestBedRender3.overrideComponent = function (component, override) {\r\n            _getTestBedRender3().overrideComponent(component, override);\r\n            return TestBedRender3;\r\n        };\r\n        TestBedRender3.overrideDirective = function (directive, override) {\r\n            _getTestBedRender3().overrideDirective(directive, override);\r\n            return TestBedRender3;\r\n        };\r\n        TestBedRender3.overridePipe = function (pipe, override) {\r\n            _getTestBedRender3().overridePipe(pipe, override);\r\n            return TestBedRender3;\r\n        };\r\n        TestBedRender3.overrideTemplate = function (component, template) {\r\n            _getTestBedRender3().overrideComponent(component, { set: { template: template, templateUrl: null } });\r\n            return TestBedRender3;\r\n        };\r\n        /**\r\n         * Overrides the template of the given component, compiling the template\r\n         * in the context of the TestingModule.\r\n         *\r\n         * Note: This works for JIT and AOTed components as well.\r\n         */\r\n        TestBedRender3.overrideTemplateUsingTestingModule = function (component, template) {\r\n            _getTestBedRender3().overrideTemplateUsingTestingModule(component, template);\r\n            return TestBedRender3;\r\n        };\r\n        TestBedRender3.overrideProvider = function (token, provider) {\r\n            _getTestBedRender3().overrideProvider(token, provider);\r\n            return TestBedRender3;\r\n        };\r\n        TestBedRender3.get = function (token, notFoundValue, flags) {\r\n            if (notFoundValue === void 0) { notFoundValue = core.Injector.THROW_IF_NOT_FOUND; }\r\n            if (flags === void 0) { flags = core.InjectFlags.Default; }\r\n            return _getTestBedRender3().get(token, notFoundValue);\r\n        };\r\n        TestBedRender3.createComponent = function (component) {\r\n            return _getTestBedRender3().createComponent(component);\r\n        };\r\n        TestBedRender3.resetTestingModule = function () {\r\n            _getTestBedRender3().resetTestingModule();\r\n            return TestBedRender3;\r\n        };\r\n        /**\r\n         * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\r\n         * angular module. These are common to every test in the suite.\r\n         *\r\n         * This may only be called once, to set up the common providers for the current test\r\n         * suite on the current platform. If you absolutely need to change the providers,\r\n         * first use `resetTestEnvironment`.\r\n         *\r\n         * Test modules and platforms for individual platforms are available from\r\n         * '@angular/<platform_name>/testing'.\r\n         *\r\n         * @publicApi\r\n         */\r\n        TestBedRender3.prototype.initTestEnvironment = function (ngModule, platform, aotSummaries) {\r\n            if (this.platform || this.ngModule) {\r\n                throw new Error('Cannot set base providers because it has already been called');\r\n            }\r\n            this.platform = platform;\r\n            this.ngModule = ngModule;\r\n            this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);\r\n        };\r\n        /**\r\n         * Reset the providers for the test injector.\r\n         *\r\n         * @publicApi\r\n         */\r\n        TestBedRender3.prototype.resetTestEnvironment = function () {\r\n            this.resetTestingModule();\r\n            this._compiler = null;\r\n            this.platform = null;\r\n            this.ngModule = null;\r\n        };\r\n        TestBedRender3.prototype.resetTestingModule = function () {\r\n            this.checkGlobalCompilationFinished();\r\n            core.ɵresetCompiledComponents();\r\n            if (this._compiler !== null) {\r\n                this.compiler.restoreOriginalState();\r\n            }\r\n            this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);\r\n            this._testModuleRef = null;\r\n            this.destroyActiveFixtures();\r\n        };\r\n        TestBedRender3.prototype.configureCompiler = function (config) {\r\n            if (config.useJit != null) {\r\n                throw new Error('the Render3 compiler JiT mode is not configurable !');\r\n            }\r\n            if (config.providers !== undefined) {\r\n                this.compiler.setCompilerProviders(config.providers);\r\n            }\r\n        };\r\n        TestBedRender3.prototype.configureTestingModule = function (moduleDef) {\r\n            this.assertNotInstantiated('R3TestBed.configureTestingModule', 'configure the test module');\r\n            this.compiler.configureTestingModule(moduleDef);\r\n        };\r\n        TestBedRender3.prototype.compileComponents = function () { return this.compiler.compileComponents(); };\r\n        TestBedRender3.prototype.get = function (token, notFoundValue, flags) {\r\n            if (notFoundValue === void 0) { notFoundValue = core.Injector.THROW_IF_NOT_FOUND; }\r\n            if (flags === void 0) { flags = core.InjectFlags.Default; }\r\n            if (token === TestBedRender3) {\r\n                return this;\r\n            }\r\n            var result = this.testModuleRef.injector.get(token, UNDEFINED, flags);\r\n            return result === UNDEFINED ? this.compiler.injector.get(token, notFoundValue, flags) : result;\r\n        };\r\n        TestBedRender3.prototype.execute = function (tokens, fn, context) {\r\n            var _this = this;\r\n            var params = tokens.map(function (t) { return _this.get(t); });\r\n            return fn.apply(context, params);\r\n        };\r\n        TestBedRender3.prototype.overrideModule = function (ngModule, override) {\r\n            this.assertNotInstantiated('overrideModule', 'override module metadata');\r\n            this.compiler.overrideModule(ngModule, override);\r\n        };\r\n        TestBedRender3.prototype.overrideComponent = function (component, override) {\r\n            this.assertNotInstantiated('overrideComponent', 'override component metadata');\r\n            this.compiler.overrideComponent(component, override);\r\n        };\r\n        TestBedRender3.prototype.overrideTemplateUsingTestingModule = function (component, template) {\r\n            this.assertNotInstantiated('R3TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\r\n            this.compiler.overrideTemplateUsingTestingModule(component, template);\r\n        };\r\n        TestBedRender3.prototype.overrideDirective = function (directive, override) {\r\n            this.assertNotInstantiated('overrideDirective', 'override directive metadata');\r\n            this.compiler.overrideDirective(directive, override);\r\n        };\r\n        TestBedRender3.prototype.overridePipe = function (pipe, override) {\r\n            this.assertNotInstantiated('overridePipe', 'override pipe metadata');\r\n            this.compiler.overridePipe(pipe, override);\r\n        };\r\n        /**\r\n         * Overwrites all providers for the given token with the given provider definition.\r\n         */\r\n        TestBedRender3.prototype.overrideProvider = function (token, provider) {\r\n            this.compiler.overrideProvider(token, provider);\r\n        };\r\n        TestBedRender3.prototype.createComponent = function (type) {\r\n            var _this = this;\r\n            var testComponentRenderer = this.get(TestComponentRenderer);\r\n            var rootElId = \"root-ng-internal-isolated-\" + _nextRootElementId++;\r\n            testComponentRenderer.insertRootElement(rootElId);\r\n            var componentDef = type.ngComponentDef;\r\n            if (!componentDef) {\r\n                throw new Error(\"It looks like '\" + core.ɵstringify(type) + \"' has not been IVY compiled - it has no 'ngComponentDef' field\");\r\n            }\r\n            // TODO: Don't cast as `any`, proper type is boolean[]\r\n            var noNgZone = this.get(ComponentFixtureNoNgZone, false);\r\n            // TODO: Don't cast as `any`, proper type is boolean[]\r\n            var autoDetect = this.get(ComponentFixtureAutoDetect, false);\r\n            var ngZone = noNgZone ? null : this.get(core.NgZone, null);\r\n            var componentFactory = new core.ɵRender3ComponentFactory(componentDef);\r\n            var initComponent = function () {\r\n                var componentRef = componentFactory.create(core.Injector.NULL, [], \"#\" + rootElId, _this.testModuleRef);\r\n                return new ComponentFixture(componentRef, ngZone, autoDetect);\r\n            };\r\n            var fixture = ngZone ? ngZone.run(initComponent) : initComponent();\r\n            this._activeFixtures.push(fixture);\r\n            return fixture;\r\n        };\r\n        Object.defineProperty(TestBedRender3.prototype, \"compiler\", {\r\n            get: function () {\r\n                if (this._compiler === null) {\r\n                    throw new Error(\"Need to call TestBed.initTestEnvironment() first\");\r\n                }\r\n                return this._compiler;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(TestBedRender3.prototype, \"testModuleRef\", {\r\n            get: function () {\r\n                if (this._testModuleRef === null) {\r\n                    this._testModuleRef = this.compiler.finalize();\r\n                }\r\n                return this._testModuleRef;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        TestBedRender3.prototype.assertNotInstantiated = function (methodName, methodDescription) {\r\n            if (this._testModuleRef !== null) {\r\n                throw new Error(\"Cannot \" + methodDescription + \" when the test module has already been instantiated. \" +\r\n                    (\"Make sure you are not using `inject` before `\" + methodName + \"`.\"));\r\n            }\r\n        };\r\n        /**\r\n         * Check whether the module scoping queue should be flushed, and flush it if needed.\r\n         *\r\n         * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\r\n         * in-progress module compilation. This creates a potential hazard - the very first time the\r\n         * TestBed is initialized (or if it's reset without being initialized), there may be pending\r\n         * compilations of modules declared in global scope. These compilations should be finished.\r\n         *\r\n         * To ensure that globally declared modules have their components scoped properly, this function\r\n         * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\r\n         * to any other operations, the scoping queue is flushed.\r\n         */\r\n        TestBedRender3.prototype.checkGlobalCompilationFinished = function () {\r\n            // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\r\n            // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\r\n            if (!this._globalCompilationChecked && this._testModuleRef === null) {\r\n                core.ɵflushModuleScopingQueueAsMuchAsPossible();\r\n            }\r\n            this._globalCompilationChecked = true;\r\n        };\r\n        TestBedRender3.prototype.destroyActiveFixtures = function () {\r\n            this._activeFixtures.forEach(function (fixture) {\r\n                try {\r\n                    fixture.destroy();\r\n                }\r\n                catch (e) {\r\n                    console.error('Error during cleanup of component', {\r\n                        component: fixture.componentInstance,\r\n                        stacktrace: e,\r\n                    });\r\n                }\r\n            });\r\n            this._activeFixtures = [];\r\n        };\r\n        return TestBedRender3;\r\n    }());\r\n    var testBed;\r\n    function _getTestBedRender3() {\r\n        return testBed = testBed || new TestBedRender3();\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    function unimplemented() {\r\n        throw Error('unimplemented');\r\n    }\r\n    /**\r\n     * Special interface to the compiler only used by testing\r\n     *\r\n     * @publicApi\r\n     */\r\n    var TestingCompiler = /** @class */ (function (_super) {\r\n        __extends(TestingCompiler, _super);\r\n        function TestingCompiler() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        Object.defineProperty(TestingCompiler.prototype, \"injector\", {\r\n            get: function () { throw unimplemented(); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        TestingCompiler.prototype.overrideModule = function (module, overrides) {\r\n            throw unimplemented();\r\n        };\r\n        TestingCompiler.prototype.overrideDirective = function (directive, overrides) {\r\n            throw unimplemented();\r\n        };\r\n        TestingCompiler.prototype.overrideComponent = function (component, overrides) {\r\n            throw unimplemented();\r\n        };\r\n        TestingCompiler.prototype.overridePipe = function (directive, overrides) {\r\n            throw unimplemented();\r\n        };\r\n        /**\r\n         * Allows to pass the compile summary from AOT compilation to the JIT compiler,\r\n         * so that it can use the code generated by AOT.\r\n         */\r\n        TestingCompiler.prototype.loadAotSummaries = function (summaries) { throw unimplemented(); };\r\n        /**\r\n         * Gets the component factory for the given component.\r\n         * This assumes that the component has been compiled before calling this call using\r\n         * `compileModuleAndAllComponents*`.\r\n         */\r\n        TestingCompiler.prototype.getComponentFactory = function (component) { throw unimplemented(); };\r\n        /**\r\n         * Returns the component type that is stored in the given error.\r\n         * This can be used for errors created by compileModule...\r\n         */\r\n        TestingCompiler.prototype.getComponentFromError = function (error) { throw unimplemented(); };\r\n        TestingCompiler = __decorate([\r\n            core.Injectable()\r\n        ], TestingCompiler);\r\n        return TestingCompiler;\r\n    }(core.Compiler));\r\n    /**\r\n     * A factory for creating a Compiler\r\n     *\r\n     * @publicApi\r\n     */\r\n    var TestingCompilerFactory = /** @class */ (function () {\r\n        function TestingCompilerFactory() {\r\n        }\r\n        return TestingCompilerFactory;\r\n    }());\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var UNDEFINED$1 = new Object();\r\n    var _nextRootElementId$1 = 0;\r\n    /**\r\n     * @description\r\n     * Configures and initializes environment for unit testing and provides methods for\r\n     * creating components and services in unit tests.\r\n     *\r\n     * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\r\n     *\r\n     * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\r\n     * according to the compiler used.\r\n     */\r\n    var TestBedViewEngine = /** @class */ (function () {\r\n        function TestBedViewEngine() {\r\n            this._instantiated = false;\r\n            this._compiler = null;\r\n            this._moduleRef = null;\r\n            this._moduleFactory = null;\r\n            this._compilerOptions = [];\r\n            this._moduleOverrides = [];\r\n            this._componentOverrides = [];\r\n            this._directiveOverrides = [];\r\n            this._pipeOverrides = [];\r\n            this._providers = [];\r\n            this._declarations = [];\r\n            this._imports = [];\r\n            this._schemas = [];\r\n            this._activeFixtures = [];\r\n            this._testEnvAotSummaries = function () { return []; };\r\n            this._aotSummaries = [];\r\n            this._templateOverrides = [];\r\n            this._isRoot = true;\r\n            this._rootProviderOverrides = [];\r\n            this.platform = null;\r\n            this.ngModule = null;\r\n        }\r\n        /**\r\n         * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\r\n         * angular module. These are common to every test in the suite.\r\n         *\r\n         * This may only be called once, to set up the common providers for the current test\r\n         * suite on the current platform. If you absolutely need to change the providers,\r\n         * first use `resetTestEnvironment`.\r\n         *\r\n         * Test modules and platforms for individual platforms are available from\r\n         * '@angular/<platform_name>/testing'.\r\n         */\r\n        TestBedViewEngine.initTestEnvironment = function (ngModule, platform, aotSummaries) {\r\n            var testBed = _getTestBedViewEngine();\r\n            testBed.initTestEnvironment(ngModule, platform, aotSummaries);\r\n            return testBed;\r\n        };\r\n        /**\r\n         * Reset the providers for the test injector.\r\n         */\r\n        TestBedViewEngine.resetTestEnvironment = function () { _getTestBedViewEngine().resetTestEnvironment(); };\r\n        TestBedViewEngine.resetTestingModule = function () {\r\n            _getTestBedViewEngine().resetTestingModule();\r\n            return TestBedViewEngine;\r\n        };\r\n        /**\r\n         * Allows overriding default compiler providers and settings\r\n         * which are defined in test_injector.js\r\n         */\r\n        TestBedViewEngine.configureCompiler = function (config) {\r\n            _getTestBedViewEngine().configureCompiler(config);\r\n            return TestBedViewEngine;\r\n        };\r\n        /**\r\n         * Allows overriding default providers, directives, pipes, modules of the test injector,\r\n         * which are defined in test_injector.js\r\n         */\r\n        TestBedViewEngine.configureTestingModule = function (moduleDef) {\r\n            _getTestBedViewEngine().configureTestingModule(moduleDef);\r\n            return TestBedViewEngine;\r\n        };\r\n        /**\r\n         * Compile components with a `templateUrl` for the test's NgModule.\r\n         * It is necessary to call this function\r\n         * as fetching urls is asynchronous.\r\n         */\r\n        TestBedViewEngine.compileComponents = function () { return getTestBed().compileComponents(); };\r\n        TestBedViewEngine.overrideModule = function (ngModule, override) {\r\n            _getTestBedViewEngine().overrideModule(ngModule, override);\r\n            return TestBedViewEngine;\r\n        };\r\n        TestBedViewEngine.overrideComponent = function (component, override) {\r\n            _getTestBedViewEngine().overrideComponent(component, override);\r\n            return TestBedViewEngine;\r\n        };\r\n        TestBedViewEngine.overrideDirective = function (directive, override) {\r\n            _getTestBedViewEngine().overrideDirective(directive, override);\r\n            return TestBedViewEngine;\r\n        };\r\n        TestBedViewEngine.overridePipe = function (pipe, override) {\r\n            _getTestBedViewEngine().overridePipe(pipe, override);\r\n            return TestBedViewEngine;\r\n        };\r\n        TestBedViewEngine.overrideTemplate = function (component, template) {\r\n            _getTestBedViewEngine().overrideComponent(component, { set: { template: template, templateUrl: null } });\r\n            return TestBedViewEngine;\r\n        };\r\n        /**\r\n         * Overrides the template of the given component, compiling the template\r\n         * in the context of the TestingModule.\r\n         *\r\n         * Note: This works for JIT and AOTed components as well.\r\n         */\r\n        TestBedViewEngine.overrideTemplateUsingTestingModule = function (component, template) {\r\n            _getTestBedViewEngine().overrideTemplateUsingTestingModule(component, template);\r\n            return TestBedViewEngine;\r\n        };\r\n        TestBedViewEngine.overrideProvider = function (token, provider) {\r\n            _getTestBedViewEngine().overrideProvider(token, provider);\r\n            return TestBedViewEngine;\r\n        };\r\n        TestBedViewEngine.get = function (token, notFoundValue, flags) {\r\n            if (notFoundValue === void 0) { notFoundValue = core.Injector.THROW_IF_NOT_FOUND; }\r\n            if (flags === void 0) { flags = core.InjectFlags.Default; }\r\n            return _getTestBedViewEngine().get(token, notFoundValue, flags);\r\n        };\r\n        TestBedViewEngine.createComponent = function (component) {\r\n            return _getTestBedViewEngine().createComponent(component);\r\n        };\r\n        /**\r\n         * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\r\n         * angular module. These are common to every test in the suite.\r\n         *\r\n         * This may only be called once, to set up the common providers for the current test\r\n         * suite on the current platform. If you absolutely need to change the providers,\r\n         * first use `resetTestEnvironment`.\r\n         *\r\n         * Test modules and platforms for individual platforms are available from\r\n         * '@angular/<platform_name>/testing'.\r\n         */\r\n        TestBedViewEngine.prototype.initTestEnvironment = function (ngModule, platform, aotSummaries) {\r\n            if (this.platform || this.ngModule) {\r\n                throw new Error('Cannot set base providers because it has already been called');\r\n            }\r\n            this.platform = platform;\r\n            this.ngModule = ngModule;\r\n            if (aotSummaries) {\r\n                this._testEnvAotSummaries = aotSummaries;\r\n            }\r\n        };\r\n        /**\r\n         * Reset the providers for the test injector.\r\n         */\r\n        TestBedViewEngine.prototype.resetTestEnvironment = function () {\r\n            this.resetTestingModule();\r\n            this.platform = null;\r\n            this.ngModule = null;\r\n            this._testEnvAotSummaries = function () { return []; };\r\n        };\r\n        TestBedViewEngine.prototype.resetTestingModule = function () {\r\n            core.ɵclearOverrides();\r\n            this._aotSummaries = [];\r\n            this._templateOverrides = [];\r\n            this._compiler = null;\r\n            this._moduleOverrides = [];\r\n            this._componentOverrides = [];\r\n            this._directiveOverrides = [];\r\n            this._pipeOverrides = [];\r\n            this._isRoot = true;\r\n            this._rootProviderOverrides = [];\r\n            this._moduleRef = null;\r\n            this._moduleFactory = null;\r\n            this._compilerOptions = [];\r\n            this._providers = [];\r\n            this._declarations = [];\r\n            this._imports = [];\r\n            this._schemas = [];\r\n            this._instantiated = false;\r\n            this._activeFixtures.forEach(function (fixture) {\r\n                try {\r\n                    fixture.destroy();\r\n                }\r\n                catch (e) {\r\n                    console.error('Error during cleanup of component', {\r\n                        component: fixture.componentInstance,\r\n                        stacktrace: e,\r\n                    });\r\n                }\r\n            });\r\n            this._activeFixtures = [];\r\n        };\r\n        TestBedViewEngine.prototype.configureCompiler = function (config) {\r\n            this._assertNotInstantiated('TestBed.configureCompiler', 'configure the compiler');\r\n            this._compilerOptions.push(config);\r\n        };\r\n        TestBedViewEngine.prototype.configureTestingModule = function (moduleDef) {\r\n            var _a, _b, _c, _d;\r\n            this._assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\r\n            if (moduleDef.providers) {\r\n                (_a = this._providers).push.apply(_a, __spread(moduleDef.providers));\r\n            }\r\n            if (moduleDef.declarations) {\r\n                (_b = this._declarations).push.apply(_b, __spread(moduleDef.declarations));\r\n            }\r\n            if (moduleDef.imports) {\r\n                (_c = this._imports).push.apply(_c, __spread(moduleDef.imports));\r\n            }\r\n            if (moduleDef.schemas) {\r\n                (_d = this._schemas).push.apply(_d, __spread(moduleDef.schemas));\r\n            }\r\n            if (moduleDef.aotSummaries) {\r\n                this._aotSummaries.push(moduleDef.aotSummaries);\r\n            }\r\n        };\r\n        TestBedViewEngine.prototype.compileComponents = function () {\r\n            var _this = this;\r\n            if (this._moduleFactory || this._instantiated) {\r\n                return Promise.resolve(null);\r\n            }\r\n            var moduleType = this._createCompilerAndModule();\r\n            return this._compiler.compileModuleAndAllComponentsAsync(moduleType)\r\n                .then(function (moduleAndComponentFactories) {\r\n                _this._moduleFactory = moduleAndComponentFactories.ngModuleFactory;\r\n            });\r\n        };\r\n        TestBedViewEngine.prototype._initIfNeeded = function () {\r\n            var e_1, _a;\r\n            if (this._instantiated) {\r\n                return;\r\n            }\r\n            if (!this._moduleFactory) {\r\n                try {\r\n                    var moduleType = this._createCompilerAndModule();\r\n                    this._moduleFactory =\r\n                        this._compiler.compileModuleAndAllComponentsSync(moduleType).ngModuleFactory;\r\n                }\r\n                catch (e) {\r\n                    var errorCompType = this._compiler.getComponentFromError(e);\r\n                    if (errorCompType) {\r\n                        throw new Error(\"This test module uses the component \" + core.ɵstringify(errorCompType) + \" which is using a \\\"templateUrl\\\" or \\\"styleUrls\\\", but they were never compiled. \" +\r\n                            \"Please call \\\"TestBed.compileComponents\\\" before your test.\");\r\n                    }\r\n                    else {\r\n                        throw e;\r\n                    }\r\n                }\r\n            }\r\n            try {\r\n                for (var _b = __values(this._templateOverrides), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var _d = _c.value, component = _d.component, templateOf = _d.templateOf;\r\n                    var compFactory = this._compiler.getComponentFactory(templateOf);\r\n                    core.ɵoverrideComponentView(component, compFactory);\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n            var ngZone = new core.NgZone({ enableLongStackTrace: true });\r\n            var providers = [{ provide: core.NgZone, useValue: ngZone }];\r\n            var ngZoneInjector = core.Injector.create({\r\n                providers: providers,\r\n                parent: this.platform.injector,\r\n                name: this._moduleFactory.moduleType.name\r\n            });\r\n            this._moduleRef = this._moduleFactory.create(ngZoneInjector);\r\n            // ApplicationInitStatus.runInitializers() is marked @internal to core. So casting to any\r\n            // before accessing it.\r\n            this._moduleRef.injector.get(core.ApplicationInitStatus).runInitializers();\r\n            this._instantiated = true;\r\n        };\r\n        TestBedViewEngine.prototype._createCompilerAndModule = function () {\r\n            var e_2, _a;\r\n            var _this = this;\r\n            var providers = this._providers.concat([{ provide: TestBed, useValue: this }]);\r\n            var declarations = __spread(this._declarations, this._templateOverrides.map(function (entry) { return entry.templateOf; }));\r\n            var rootScopeImports = [];\r\n            var rootProviderOverrides = this._rootProviderOverrides;\r\n            if (this._isRoot) {\r\n                var RootScopeModule = /** @class */ (function () {\r\n                    function RootScopeModule() {\r\n                    }\r\n                    RootScopeModule = __decorate([\r\n                        core.NgModule({\r\n                            providers: __spread(rootProviderOverrides),\r\n                            jit: true,\r\n                        })\r\n                    ], RootScopeModule);\r\n                    return RootScopeModule;\r\n                }());\r\n                rootScopeImports.push(RootScopeModule);\r\n            }\r\n            providers.push({ provide: core.ɵAPP_ROOT, useValue: this._isRoot });\r\n            var imports = [rootScopeImports, this.ngModule, this._imports];\r\n            var schemas = this._schemas;\r\n            var DynamicTestModule = /** @class */ (function () {\r\n                function DynamicTestModule() {\r\n                }\r\n                DynamicTestModule = __decorate([\r\n                    core.NgModule({ providers: providers, declarations: declarations, imports: imports, schemas: schemas, jit: true })\r\n                ], DynamicTestModule);\r\n                return DynamicTestModule;\r\n            }());\r\n            var compilerFactory = this.platform.injector.get(TestingCompilerFactory);\r\n            this._compiler = compilerFactory.createTestingCompiler(this._compilerOptions);\r\n            try {\r\n                for (var _b = __values(__spread([this._testEnvAotSummaries], this._aotSummaries)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var summary = _c.value;\r\n                    this._compiler.loadAotSummaries(summary);\r\n                }\r\n            }\r\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_2) throw e_2.error; }\r\n            }\r\n            this._moduleOverrides.forEach(function (entry) { return _this._compiler.overrideModule(entry[0], entry[1]); });\r\n            this._componentOverrides.forEach(function (entry) { return _this._compiler.overrideComponent(entry[0], entry[1]); });\r\n            this._directiveOverrides.forEach(function (entry) { return _this._compiler.overrideDirective(entry[0], entry[1]); });\r\n            this._pipeOverrides.forEach(function (entry) { return _this._compiler.overridePipe(entry[0], entry[1]); });\r\n            return DynamicTestModule;\r\n        };\r\n        TestBedViewEngine.prototype._assertNotInstantiated = function (methodName, methodDescription) {\r\n            if (this._instantiated) {\r\n                throw new Error(\"Cannot \" + methodDescription + \" when the test module has already been instantiated. \" +\r\n                    (\"Make sure you are not using `inject` before `\" + methodName + \"`.\"));\r\n            }\r\n        };\r\n        TestBedViewEngine.prototype.get = function (token, notFoundValue, flags) {\r\n            if (notFoundValue === void 0) { notFoundValue = core.Injector.THROW_IF_NOT_FOUND; }\r\n            if (flags === void 0) { flags = core.InjectFlags.Default; }\r\n            this._initIfNeeded();\r\n            if (token === TestBed) {\r\n                return this;\r\n            }\r\n            // Tests can inject things from the ng module and from the compiler,\r\n            // but the ng module can't inject things from the compiler and vice versa.\r\n            var result = this._moduleRef.injector.get(token, UNDEFINED$1, flags);\r\n            return result === UNDEFINED$1 ? this._compiler.injector.get(token, notFoundValue, flags) : result;\r\n        };\r\n        TestBedViewEngine.prototype.execute = function (tokens, fn, context) {\r\n            var _this = this;\r\n            this._initIfNeeded();\r\n            var params = tokens.map(function (t) { return _this.get(t); });\r\n            return fn.apply(context, params);\r\n        };\r\n        TestBedViewEngine.prototype.overrideModule = function (ngModule, override) {\r\n            this._assertNotInstantiated('overrideModule', 'override module metadata');\r\n            this._moduleOverrides.push([ngModule, override]);\r\n        };\r\n        TestBedViewEngine.prototype.overrideComponent = function (component, override) {\r\n            this._assertNotInstantiated('overrideComponent', 'override component metadata');\r\n            this._componentOverrides.push([component, override]);\r\n        };\r\n        TestBedViewEngine.prototype.overrideDirective = function (directive, override) {\r\n            this._assertNotInstantiated('overrideDirective', 'override directive metadata');\r\n            this._directiveOverrides.push([directive, override]);\r\n        };\r\n        TestBedViewEngine.prototype.overridePipe = function (pipe, override) {\r\n            this._assertNotInstantiated('overridePipe', 'override pipe metadata');\r\n            this._pipeOverrides.push([pipe, override]);\r\n        };\r\n        TestBedViewEngine.prototype.overrideProvider = function (token, provider) {\r\n            this.overrideProviderImpl(token, provider);\r\n        };\r\n        TestBedViewEngine.prototype.overrideProviderImpl = function (token, provider, deprecated) {\r\n            if (deprecated === void 0) { deprecated = false; }\r\n            var def = null;\r\n            if (typeof token !== 'string' && (def = core.ɵgetInjectableDef(token)) && def.providedIn === 'root') {\r\n                if (provider.useFactory) {\r\n                    this._rootProviderOverrides.push({ provide: token, useFactory: provider.useFactory, deps: provider.deps || [] });\r\n                }\r\n                else {\r\n                    this._rootProviderOverrides.push({ provide: token, useValue: provider.useValue });\r\n                }\r\n            }\r\n            var flags = 0;\r\n            var value;\r\n            if (provider.useFactory) {\r\n                flags |= 1024 /* TypeFactoryProvider */;\r\n                value = provider.useFactory;\r\n            }\r\n            else {\r\n                flags |= 256 /* TypeValueProvider */;\r\n                value = provider.useValue;\r\n            }\r\n            var deps = (provider.deps || []).map(function (dep) {\r\n                var depFlags = 0 /* None */;\r\n                var depToken;\r\n                if (Array.isArray(dep)) {\r\n                    dep.forEach(function (entry) {\r\n                        if (entry instanceof core.Optional) {\r\n                            depFlags |= 2 /* Optional */;\r\n                        }\r\n                        else if (entry instanceof core.SkipSelf) {\r\n                            depFlags |= 1 /* SkipSelf */;\r\n                        }\r\n                        else {\r\n                            depToken = entry;\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    depToken = dep;\r\n                }\r\n                return [depFlags, depToken];\r\n            });\r\n            core.ɵoverrideProvider({ token: token, flags: flags, deps: deps, value: value, deprecatedBehavior: deprecated });\r\n        };\r\n        TestBedViewEngine.prototype.overrideTemplateUsingTestingModule = function (component, template) {\r\n            this._assertNotInstantiated('overrideTemplateUsingTestingModule', 'override template');\r\n            var OverrideComponent = /** @class */ (function () {\r\n                function OverrideComponent() {\r\n                }\r\n                OverrideComponent = __decorate([\r\n                    core.Component({ selector: 'empty', template: template, jit: true })\r\n                ], OverrideComponent);\r\n                return OverrideComponent;\r\n            }());\r\n            this._templateOverrides.push({ component: component, templateOf: OverrideComponent });\r\n        };\r\n        TestBedViewEngine.prototype.createComponent = function (component) {\r\n            var _this = this;\r\n            this._initIfNeeded();\r\n            var componentFactory = this._compiler.getComponentFactory(component);\r\n            if (!componentFactory) {\r\n                throw new Error(\"Cannot create the component \" + core.ɵstringify(component) + \" as it was not imported into the testing module!\");\r\n            }\r\n            // TODO: Don't cast as `any`, proper type is boolean[]\r\n            var noNgZone = this.get(ComponentFixtureNoNgZone, false);\r\n            // TODO: Don't cast as `any`, proper type is boolean[]\r\n            var autoDetect = this.get(ComponentFixtureAutoDetect, false);\r\n            var ngZone = noNgZone ? null : this.get(core.NgZone, null);\r\n            var testComponentRenderer = this.get(TestComponentRenderer);\r\n            var rootElId = \"root\" + _nextRootElementId$1++;\r\n            testComponentRenderer.insertRootElement(rootElId);\r\n            var initComponent = function () {\r\n                var componentRef = componentFactory.create(core.Injector.NULL, [], \"#\" + rootElId, _this._moduleRef);\r\n                return new ComponentFixture(componentRef, ngZone, autoDetect);\r\n            };\r\n            var fixture = !ngZone ? initComponent() : ngZone.run(initComponent);\r\n            this._activeFixtures.push(fixture);\r\n            return fixture;\r\n        };\r\n        return TestBedViewEngine;\r\n    }());\r\n    /**\r\n     * @description\r\n     * Configures and initializes environment for unit testing and provides methods for\r\n     * creating components and services in unit tests.\r\n     *\r\n     * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\r\n     *\r\n     * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\r\n     * according to the compiler used.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var TestBed = core.ɵivyEnabled ? TestBedRender3 : TestBedViewEngine;\r\n    /**\r\n     * Returns a singleton of the applicable `TestBed`.\r\n     *\r\n     * It will be either an instance of `TestBedViewEngine` or `TestBedRender3`.\r\n     *\r\n     * @publicApi\r\n     */\r\n    var getTestBed = core.ɵivyEnabled ? _getTestBedRender3 : _getTestBedViewEngine;\r\n    var testBed$1;\r\n    function _getTestBedViewEngine() {\r\n        return testBed$1 = testBed$1 || new TestBedViewEngine();\r\n    }\r\n    /**\r\n     * Allows injecting dependencies in `beforeEach()` and `it()`.\r\n     *\r\n     * Example:\r\n     *\r\n     * ```\r\n     * beforeEach(inject([Dependency, AClass], (dep, object) => {\r\n     *   // some code that uses `dep` and `object`\r\n     *   // ...\r\n     * }));\r\n     *\r\n     * it('...', inject([AClass], (object) => {\r\n     *   object.doSomething();\r\n     *   expect(...);\r\n     * })\r\n     * ```\r\n     *\r\n     * Notes:\r\n     * - inject is currently a function because of some Traceur limitation the syntax should\r\n     * eventually\r\n     *   becomes `it('...', @Inject (object: AClass, async: AsyncTestCompleter) => { ... });`\r\n     *\r\n     * @publicApi\r\n     */\r\n    function inject(tokens, fn) {\r\n        var testBed = getTestBed();\r\n        if (tokens.indexOf(AsyncTestCompleter) >= 0) {\r\n            // Not using an arrow function to preserve context passed from call site\r\n            return function () {\r\n                var _this = this;\r\n                // Return an async test method that returns a Promise if AsyncTestCompleter is one of\r\n                // the injected tokens.\r\n                return testBed.compileComponents().then(function () {\r\n                    var completer = testBed.get(AsyncTestCompleter);\r\n                    testBed.execute(tokens, fn, _this);\r\n                    return completer.promise;\r\n                });\r\n            };\r\n        }\r\n        else {\r\n            // Not using an arrow function to preserve context passed from call site\r\n            return function () { return testBed.execute(tokens, fn, this); };\r\n        }\r\n    }\r\n    /**\r\n     * @publicApi\r\n     */\r\n    var InjectSetupWrapper = /** @class */ (function () {\r\n        function InjectSetupWrapper(_moduleDef) {\r\n            this._moduleDef = _moduleDef;\r\n        }\r\n        InjectSetupWrapper.prototype._addModule = function () {\r\n            var moduleDef = this._moduleDef();\r\n            if (moduleDef) {\r\n                getTestBed().configureTestingModule(moduleDef);\r\n            }\r\n        };\r\n        InjectSetupWrapper.prototype.inject = function (tokens, fn) {\r\n            var self = this;\r\n            // Not using an arrow function to preserve context passed from call site\r\n            return function () {\r\n                self._addModule();\r\n                return inject(tokens, fn).call(this);\r\n            };\r\n        };\r\n        return InjectSetupWrapper;\r\n    }());\r\n    function withModule(moduleDef, fn) {\r\n        if (fn) {\r\n            // Not using an arrow function to preserve context passed from call site\r\n            return function () {\r\n                var testBed = getTestBed();\r\n                if (moduleDef) {\r\n                    testBed.configureTestingModule(moduleDef);\r\n                }\r\n                return fn.apply(this);\r\n            };\r\n        }\r\n        return new InjectSetupWrapper(function () { return moduleDef; });\r\n    }\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    var _global$1 = (typeof window === 'undefined' ? global : window);\r\n    // Reset the test providers and the fake async zone before each test.\r\n    if (_global$1.beforeEach) {\r\n        _global$1.beforeEach(function () {\r\n            TestBed.resetTestingModule();\r\n            resetFakeAsyncZone();\r\n        });\r\n    }\r\n    // TODO(juliemr): remove this, only used because we need to export something to have compilation\r\n    // work.\r\n    var __core_private_testing_placeholder__ = '';\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n    // This file only reexports content of the `src` folder. Keep it that way.\r\n\r\n    /**\r\n     * @license\r\n     * Copyright Google Inc. All Rights Reserved.\r\n     *\r\n     * Use of this source code is governed by an MIT-style license that can be\r\n     * found in the LICENSE file at https://angular.io/license\r\n     */\r\n\r\n    /**\r\n     * Generated bundle index. Do not edit.\r\n     */\r\n\r\n    exports.ɵangular_packages_core_testing_testing_b = TestBedRender3;\r\n    exports.ɵangular_packages_core_testing_testing_c = _getTestBedRender3;\r\n    exports.ɵangular_packages_core_testing_testing_a = TestBedViewEngine;\r\n    exports.TestBed = TestBed;\r\n    exports.getTestBed = getTestBed;\r\n    exports.inject = inject;\r\n    exports.InjectSetupWrapper = InjectSetupWrapper;\r\n    exports.withModule = withModule;\r\n    exports.ɵMetadataOverrider = MetadataOverrider;\r\n    exports.async = async;\r\n    exports.ComponentFixture = ComponentFixture;\r\n    exports.resetFakeAsyncZone = resetFakeAsyncZone;\r\n    exports.fakeAsync = fakeAsync;\r\n    exports.tick = tick;\r\n    exports.flush = flush;\r\n    exports.discardPeriodicTasks = discardPeriodicTasks;\r\n    exports.flushMicrotasks = flushMicrotasks;\r\n    exports.TestComponentRenderer = TestComponentRenderer;\r\n    exports.ComponentFixtureAutoDetect = ComponentFixtureAutoDetect;\r\n    exports.ComponentFixtureNoNgZone = ComponentFixtureNoNgZone;\r\n    exports.__core_private_testing_placeholder__ = __core_private_testing_placeholder__;\r\n    exports.ɵTestingCompiler = TestingCompiler;\r\n    exports.ɵTestingCompilerFactory = TestingCompilerFactory;\r\n\r\n    Object.defineProperty(exports, '__esModule', { value: true });\r\n\r\n}));\r\n\r\n"]}