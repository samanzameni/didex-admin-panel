/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as tslib_1 from "tslib";
import { stringify } from '../util/stringify';
import { resolveForwardRef } from './forward_ref';
import { INJECTOR, NG_TEMP_TOKEN_PATH, NullInjector, THROW_IF_NOT_FOUND, USE_VALUE, catchInjectorError, formatError, ɵɵinject } from './injector_compatibility';
import { ɵɵdefineInjectable } from './interface/defs';
import { InjectFlags } from './interface/injector';
import { Inject, Optional, Self, SkipSelf } from './metadata';
import { createInjector } from './r3_injector';
export function INJECTOR_IMPL__PRE_R3__(providers, parent, name) {
    return new StaticInjector(providers, parent, name);
}
export function INJECTOR_IMPL__POST_R3__(providers, parent, name) {
    return createInjector({ name: name }, parent, providers, name);
}
export var INJECTOR_IMPL = INJECTOR_IMPL__POST_R3__;
/**
 * Concrete injectors implement this interface.
 *
 * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
 *
 * @usageNotes
 * ### Example
 *
 * {@example core/di/ts/injector_spec.ts region='Injector'}
 *
 * `Injector` returns itself when given `Injector` as a token:
 *
 * {@example core/di/ts/injector_spec.ts region='injectInjector'}
 *
 * @publicApi
 */
var Injector = /** @class */ (function () {
    function Injector() {
    }
    /**
     * Create a new Injector which is configure using `StaticProvider`s.
     *
     * @usageNotes
     * ### Example
     *
     * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}
     */
    Injector.create = function (options, parent) {
        if (Array.isArray(options)) {
            return INJECTOR_IMPL(options, parent, '');
        }
        else {
            return INJECTOR_IMPL(options.providers, options.parent, options.name || '');
        }
    };
    Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
    Injector.NULL = new NullInjector();
    /** @nocollapse */
    Injector.ngInjectableDef = ɵɵdefineInjectable({
        token: Injector,
        providedIn: 'any',
        factory: function () { return ɵɵinject(INJECTOR); },
    });
    /**
     * @internal
     * @nocollapse
     */
    Injector.__NG_ELEMENT_ID__ = -1;
    return Injector;
}());
export { Injector };
var IDENT = function (value) {
    return value;
};
var ɵ0 = IDENT;
var EMPTY = [];
var CIRCULAR = IDENT;
var MULTI_PROVIDER_FN = function () {
    return Array.prototype.slice.call(arguments);
};
var ɵ1 = MULTI_PROVIDER_FN;
var NO_NEW_LINE = 'ɵ';
var StaticInjector = /** @class */ (function () {
    function StaticInjector(providers, parent, source) {
        if (parent === void 0) { parent = Injector.NULL; }
        if (source === void 0) { source = null; }
        this.parent = parent;
        this.source = source;
        var records = this._records = new Map();
        records.set(Injector, { token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false });
        records.set(INJECTOR, { token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false });
        recursivelyProcessProviders(records, providers);
    }
    StaticInjector.prototype.get = function (token, notFoundValue, flags) {
        if (flags === void 0) { flags = InjectFlags.Default; }
        var record = this._records.get(token);
        try {
            return tryResolveToken(token, record, this._records, this.parent, notFoundValue, flags);
        }
        catch (e) {
            return catchInjectorError(e, token, 'StaticInjectorError', this.source);
        }
    };
    StaticInjector.prototype.toString = function () {
        var tokens = [], records = this._records;
        records.forEach(function (v, token) { return tokens.push(stringify(token)); });
        return "StaticInjector[" + tokens.join(', ') + "]";
    };
    return StaticInjector;
}());
export { StaticInjector };
function resolveProvider(provider) {
    var deps = computeDeps(provider);
    var fn = IDENT;
    var value = EMPTY;
    var useNew = false;
    var provide = resolveForwardRef(provider.provide);
    if (USE_VALUE in provider) {
        // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.
        value = provider.useValue;
    }
    else if (provider.useFactory) {
        fn = provider.useFactory;
    }
    else if (provider.useExisting) {
        // Just use IDENT
    }
    else if (provider.useClass) {
        useNew = true;
        fn = resolveForwardRef(provider.useClass);
    }
    else if (typeof provide == 'function') {
        useNew = true;
        fn = provide;
    }
    else {
        throw staticError('StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable', provider);
    }
    return { deps: deps, fn: fn, useNew: useNew, value: value };
}
function multiProviderMixError(token) {
    return staticError('Cannot mix multi providers and regular providers', token);
}
function recursivelyProcessProviders(records, provider) {
    if (provider) {
        provider = resolveForwardRef(provider);
        if (provider instanceof Array) {
            // if we have an array recurse into the array
            for (var i = 0; i < provider.length; i++) {
                recursivelyProcessProviders(records, provider[i]);
            }
        }
        else if (typeof provider === 'function') {
            // Functions were supported in ReflectiveInjector, but are not here. For safety give useful
            // error messages
            throw staticError('Function/Class not supported', provider);
        }
        else if (provider && typeof provider === 'object' && provider.provide) {
            // At this point we have what looks like a provider: {provide: ?, ....}
            var token = resolveForwardRef(provider.provide);
            var resolvedProvider = resolveProvider(provider);
            if (provider.multi === true) {
                // This is a multi provider.
                var multiProvider = records.get(token);
                if (multiProvider) {
                    if (multiProvider.fn !== MULTI_PROVIDER_FN) {
                        throw multiProviderMixError(token);
                    }
                }
                else {
                    // Create a placeholder factory which will look up the constituents of the multi provider.
                    records.set(token, multiProvider = {
                        token: provider.provide,
                        deps: [],
                        useNew: false,
                        fn: MULTI_PROVIDER_FN,
                        value: EMPTY
                    });
                }
                // Treat the provider as the token.
                token = provider;
                multiProvider.deps.push({ token: token, options: 6 /* Default */ });
            }
            var record = records.get(token);
            if (record && record.fn == MULTI_PROVIDER_FN) {
                throw multiProviderMixError(token);
            }
            records.set(token, resolvedProvider);
        }
        else {
            throw staticError('Unexpected provider', provider);
        }
    }
}
function tryResolveToken(token, record, records, parent, notFoundValue, flags) {
    try {
        return resolveToken(token, record, records, parent, notFoundValue, flags);
    }
    catch (e) {
        // ensure that 'e' is of type Error.
        if (!(e instanceof Error)) {
            e = new Error(e);
        }
        var path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
        path.unshift(token);
        if (record && record.value == CIRCULAR) {
            // Reset the Circular flag.
            record.value = EMPTY;
        }
        throw e;
    }
}
function resolveToken(token, record, records, parent, notFoundValue, flags) {
    var _a;
    var value;
    if (record && !(flags & InjectFlags.SkipSelf)) {
        // If we don't have a record, this implies that we don't own the provider hence don't know how
        // to resolve it.
        value = record.value;
        if (value == CIRCULAR) {
            throw Error(NO_NEW_LINE + 'Circular dependency');
        }
        else if (value === EMPTY) {
            record.value = CIRCULAR;
            var obj = undefined;
            var useNew = record.useNew;
            var fn = record.fn;
            var depRecords = record.deps;
            var deps = EMPTY;
            if (depRecords.length) {
                deps = [];
                for (var i = 0; i < depRecords.length; i++) {
                    var depRecord = depRecords[i];
                    var options = depRecord.options;
                    var childRecord = options & 2 /* CheckSelf */ ? records.get(depRecord.token) : undefined;
                    deps.push(tryResolveToken(
                    // Current Token to resolve
                    depRecord.token, 
                    // A record which describes how to resolve the token.
                    // If undefined, this means we don't have such a record
                    childRecord, 
                    // Other records we know about.
                    records, 
                    // If we don't know how to resolve dependency and we should not check parent for it,
                    // than pass in Null injector.
                    !childRecord && !(options & 4 /* CheckParent */) ? Injector.NULL : parent, options & 1 /* Optional */ ? null : Injector.THROW_IF_NOT_FOUND, InjectFlags.Default));
                }
            }
            record.value = value = useNew ? new ((_a = fn).bind.apply(_a, tslib_1.__spread([void 0], deps)))() : fn.apply(obj, deps);
        }
    }
    else if (!(flags & InjectFlags.Self)) {
        value = parent.get(token, notFoundValue, InjectFlags.Default);
    }
    return value;
}
function computeDeps(provider) {
    var deps = EMPTY;
    var providerDeps = provider.deps;
    if (providerDeps && providerDeps.length) {
        deps = [];
        for (var i = 0; i < providerDeps.length; i++) {
            var options = 6 /* Default */;
            var token = resolveForwardRef(providerDeps[i]);
            if (token instanceof Array) {
                for (var j = 0, annotations = token; j < annotations.length; j++) {
                    var annotation = annotations[j];
                    if (annotation instanceof Optional || annotation == Optional) {
                        options = options | 1 /* Optional */;
                    }
                    else if (annotation instanceof SkipSelf || annotation == SkipSelf) {
                        options = options & ~2 /* CheckSelf */;
                    }
                    else if (annotation instanceof Self || annotation == Self) {
                        options = options & ~4 /* CheckParent */;
                    }
                    else if (annotation instanceof Inject) {
                        token = annotation.token;
                    }
                    else {
                        token = resolveForwardRef(annotation);
                    }
                }
            }
            deps.push({ token: token, options: options });
        }
    }
    else if (provider.useExisting) {
        var token = resolveForwardRef(provider.useExisting);
        deps = [{ token: token, options: 6 /* Default */ }];
    }
    else if (!providerDeps && !(USE_VALUE in provider)) {
        // useValue & useExisting are the only ones which are exempt from deps all others need it.
        throw staticError('\'deps\' required', provider);
    }
    return deps;
}
function staticError(text, obj) {
    return new Error(formatError(text, obj, 'StaticInjectorError'));
}
export { ɵ0, ɵ1 };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9lc201L3NyYy9kaS9pbmplY3Rvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJCQXFCMkIsd0JBQXVCIiwiZmlsZSI6ImluamVjdG9yLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICcuLi91dGlsL3N0cmluZ2lmeSc7XHJcbmltcG9ydCB7IHJlc29sdmVGb3J3YXJkUmVmIH0gZnJvbSAnLi9mb3J3YXJkX3JlZic7XHJcbmltcG9ydCB7IElOSkVDVE9SLCBOR19URU1QX1RPS0VOX1BBVEgsIE51bGxJbmplY3RvciwgVEhST1dfSUZfTk9UX0ZPVU5ELCBVU0VfVkFMVUUsIGNhdGNoSW5qZWN0b3JFcnJvciwgZm9ybWF0RXJyb3IsIMm1ybVpbmplY3QgfSBmcm9tICcuL2luamVjdG9yX2NvbXBhdGliaWxpdHknO1xyXG5pbXBvcnQgeyDJtcm1ZGVmaW5lSW5qZWN0YWJsZSB9IGZyb20gJy4vaW50ZXJmYWNlL2RlZnMnO1xyXG5pbXBvcnQgeyBJbmplY3RGbGFncyB9IGZyb20gJy4vaW50ZXJmYWNlL2luamVjdG9yJztcclxuaW1wb3J0IHsgSW5qZWN0LCBPcHRpb25hbCwgU2VsZiwgU2tpcFNlbGYgfSBmcm9tICcuL21ldGFkYXRhJztcclxuaW1wb3J0IHsgY3JlYXRlSW5qZWN0b3IgfSBmcm9tICcuL3IzX2luamVjdG9yJztcclxuZXhwb3J0IGZ1bmN0aW9uIElOSkVDVE9SX0lNUExfX1BSRV9SM19fKHByb3ZpZGVycywgcGFyZW50LCBuYW1lKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0YXRpY0luamVjdG9yKHByb3ZpZGVycywgcGFyZW50LCBuYW1lKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gSU5KRUNUT1JfSU1QTF9fUE9TVF9SM19fKHByb3ZpZGVycywgcGFyZW50LCBuYW1lKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlSW5qZWN0b3IoeyBuYW1lOiBuYW1lIH0sIHBhcmVudCwgcHJvdmlkZXJzLCBuYW1lKTtcclxufVxyXG5leHBvcnQgdmFyIElOSkVDVE9SX0lNUEwgPSBJTkpFQ1RPUl9JTVBMX19QUkVfUjNfXztcclxuLyoqXHJcbiAqIENvbmNyZXRlIGluamVjdG9ycyBpbXBsZW1lbnQgdGhpcyBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB0aGUgW1wiRGVwZW5kZW5jeSBJbmplY3Rpb24gR3VpZGVcIl0oZ3VpZGUvZGVwZW5kZW5jeS1pbmplY3Rpb24pLlxyXG4gKlxyXG4gKiBAdXNhZ2VOb3Rlc1xyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiB7QGV4YW1wbGUgY29yZS9kaS90cy9pbmplY3Rvcl9zcGVjLnRzIHJlZ2lvbj0nSW5qZWN0b3InfVxyXG4gKlxyXG4gKiBgSW5qZWN0b3JgIHJldHVybnMgaXRzZWxmIHdoZW4gZ2l2ZW4gYEluamVjdG9yYCBhcyBhIHRva2VuOlxyXG4gKlxyXG4gKiB7QGV4YW1wbGUgY29yZS9kaS90cy9pbmplY3Rvcl9zcGVjLnRzIHJlZ2lvbj0naW5qZWN0SW5qZWN0b3InfVxyXG4gKlxyXG4gKiBAcHVibGljQXBpXHJcbiAqL1xyXG52YXIgSW5qZWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJbmplY3RvcigpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IEluamVjdG9yIHdoaWNoIGlzIGNvbmZpZ3VyZSB1c2luZyBgU3RhdGljUHJvdmlkZXJgcy5cclxuICAgICAqXHJcbiAgICAgKiBAdXNhZ2VOb3Rlc1xyXG4gICAgICogIyMjIEV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9kaS90cy9wcm92aWRlcl9zcGVjLnRzIHJlZ2lvbj0nQ29uc3RydWN0b3JQcm92aWRlcid9XHJcbiAgICAgKi9cclxuICAgIEluamVjdG9yLmNyZWF0ZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gSU5KRUNUT1JfSU1QTChvcHRpb25zLCBwYXJlbnQsICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBJTkpFQ1RPUl9JTVBMKG9wdGlvbnMucHJvdmlkZXJzLCBvcHRpb25zLnBhcmVudCwgb3B0aW9ucy5uYW1lIHx8ICcnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW5qZWN0b3IuVEhST1dfSUZfTk9UX0ZPVU5EID0gVEhST1dfSUZfTk9UX0ZPVU5EO1xyXG4gICAgSW5qZWN0b3IuTlVMTCA9IG5ldyBOdWxsSW5qZWN0b3IoKTtcclxuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xyXG4gICAgSW5qZWN0b3IubmdJbmplY3RhYmxlRGVmID0gybXJtWRlZmluZUluamVjdGFibGUoe1xyXG4gICAgICAgIHRva2VuOiBJbmplY3RvcixcclxuICAgICAgICBwcm92aWRlZEluOiAnYW55JyxcclxuICAgICAgICBmYWN0b3J5OiBmdW5jdGlvbiAoKSB7IHJldHVybiDJtcm1aW5qZWN0KElOSkVDVE9SKTsgfSxcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBub2NvbGxhcHNlXHJcbiAgICAgKi9cclxuICAgIEluamVjdG9yLl9fTkdfRUxFTUVOVF9JRF9fID0gLTE7XHJcbiAgICByZXR1cm4gSW5qZWN0b3I7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IEluamVjdG9yIH07XHJcbnZhciBJREVOVCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59O1xyXG52YXIgybUwID0gSURFTlQ7XHJcbnZhciBFTVBUWSA9IFtdO1xyXG52YXIgQ0lSQ1VMQVIgPSBJREVOVDtcclxudmFyIE1VTFRJX1BST1ZJREVSX0ZOID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbn07XHJcbnZhciDJtTEgPSBNVUxUSV9QUk9WSURFUl9GTjtcclxudmFyIE5PX05FV19MSU5FID0gJ8m1JztcclxudmFyIFN0YXRpY0luamVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3RhdGljSW5qZWN0b3IocHJvdmlkZXJzLCBwYXJlbnQsIHNvdXJjZSkge1xyXG4gICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkgeyBwYXJlbnQgPSBJbmplY3Rvci5OVUxMOyB9XHJcbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gdm9pZCAwKSB7IHNvdXJjZSA9IG51bGw7IH1cclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICB2YXIgcmVjb3JkcyA9IHRoaXMuX3JlY29yZHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgcmVjb3Jkcy5zZXQoSW5qZWN0b3IsIHsgdG9rZW46IEluamVjdG9yLCBmbjogSURFTlQsIGRlcHM6IEVNUFRZLCB2YWx1ZTogdGhpcywgdXNlTmV3OiBmYWxzZSB9KTtcclxuICAgICAgICByZWNvcmRzLnNldChJTkpFQ1RPUiwgeyB0b2tlbjogSU5KRUNUT1IsIGZuOiBJREVOVCwgZGVwczogRU1QVFksIHZhbHVlOiB0aGlzLCB1c2VOZXc6IGZhbHNlIH0pO1xyXG4gICAgICAgIHJlY3Vyc2l2ZWx5UHJvY2Vzc1Byb3ZpZGVycyhyZWNvcmRzLCBwcm92aWRlcnMpO1xyXG4gICAgfVxyXG4gICAgU3RhdGljSW5qZWN0b3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSwgZmxhZ3MpIHtcclxuICAgICAgICBpZiAoZmxhZ3MgPT09IHZvaWQgMCkgeyBmbGFncyA9IEluamVjdEZsYWdzLkRlZmF1bHQ7IH1cclxuICAgICAgICB2YXIgcmVjb3JkID0gdGhpcy5fcmVjb3Jkcy5nZXQodG9rZW4pO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnlSZXNvbHZlVG9rZW4odG9rZW4sIHJlY29yZCwgdGhpcy5fcmVjb3JkcywgdGhpcy5wYXJlbnQsIG5vdEZvdW5kVmFsdWUsIGZsYWdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhdGNoSW5qZWN0b3JFcnJvcihlLCB0b2tlbiwgJ1N0YXRpY0luamVjdG9yRXJyb3InLCB0aGlzLnNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFN0YXRpY0luamVjdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdG9rZW5zID0gW10sIHJlY29yZHMgPSB0aGlzLl9yZWNvcmRzO1xyXG4gICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAodiwgdG9rZW4pIHsgcmV0dXJuIHRva2Vucy5wdXNoKHN0cmluZ2lmeSh0b2tlbikpOyB9KTtcclxuICAgICAgICByZXR1cm4gXCJTdGF0aWNJbmplY3RvcltcIiArIHRva2Vucy5qb2luKCcsICcpICsgXCJdXCI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFN0YXRpY0luamVjdG9yO1xyXG59KCkpO1xyXG5leHBvcnQgeyBTdGF0aWNJbmplY3RvciB9O1xyXG5mdW5jdGlvbiByZXNvbHZlUHJvdmlkZXIocHJvdmlkZXIpIHtcclxuICAgIHZhciBkZXBzID0gY29tcHV0ZURlcHMocHJvdmlkZXIpO1xyXG4gICAgdmFyIGZuID0gSURFTlQ7XHJcbiAgICB2YXIgdmFsdWUgPSBFTVBUWTtcclxuICAgIHZhciB1c2VOZXcgPSBmYWxzZTtcclxuICAgIHZhciBwcm92aWRlID0gcmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXIucHJvdmlkZSk7XHJcbiAgICBpZiAoVVNFX1ZBTFVFIGluIHByb3ZpZGVyKSB7XHJcbiAgICAgICAgLy8gV2UgbmVlZCB0byB1c2UgVVNFX1ZBTFVFIGluIHByb3ZpZGVyIHNpbmNlIHByb3ZpZGVyLnVzZVZhbHVlIGNvdWxkIGJlIGRlZmluZWQgYXMgdW5kZWZpbmVkLlxyXG4gICAgICAgIHZhbHVlID0gcHJvdmlkZXIudXNlVmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwcm92aWRlci51c2VGYWN0b3J5KSB7XHJcbiAgICAgICAgZm4gPSBwcm92aWRlci51c2VGYWN0b3J5O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRXhpc3RpbmcpIHtcclxuICAgICAgICAvLyBKdXN0IHVzZSBJREVOVFxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvdmlkZXIudXNlQ2xhc3MpIHtcclxuICAgICAgICB1c2VOZXcgPSB0cnVlO1xyXG4gICAgICAgIGZuID0gcmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXIudXNlQ2xhc3MpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHByb3ZpZGUgPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHVzZU5ldyA9IHRydWU7XHJcbiAgICAgICAgZm4gPSBwcm92aWRlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgc3RhdGljRXJyb3IoJ1N0YXRpY1Byb3ZpZGVyIGRvZXMgbm90IGhhdmUgW3VzZVZhbHVlfHVzZUZhY3Rvcnl8dXNlRXhpc3Rpbmd8dXNlQ2xhc3NdIG9yIFtwcm92aWRlXSBpcyBub3QgbmV3YWJsZScsIHByb3ZpZGVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGRlcHM6IGRlcHMsIGZuOiBmbiwgdXNlTmV3OiB1c2VOZXcsIHZhbHVlOiB2YWx1ZSB9O1xyXG59XHJcbmZ1bmN0aW9uIG11bHRpUHJvdmlkZXJNaXhFcnJvcih0b2tlbikge1xyXG4gICAgcmV0dXJuIHN0YXRpY0Vycm9yKCdDYW5ub3QgbWl4IG11bHRpIHByb3ZpZGVycyBhbmQgcmVndWxhciBwcm92aWRlcnMnLCB0b2tlbik7XHJcbn1cclxuZnVuY3Rpb24gcmVjdXJzaXZlbHlQcm9jZXNzUHJvdmlkZXJzKHJlY29yZHMsIHByb3ZpZGVyKSB7XHJcbiAgICBpZiAocHJvdmlkZXIpIHtcclxuICAgICAgICBwcm92aWRlciA9IHJlc29sdmVGb3J3YXJkUmVmKHByb3ZpZGVyKTtcclxuICAgICAgICBpZiAocHJvdmlkZXIgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGFuIGFycmF5IHJlY3Vyc2UgaW50byB0aGUgYXJyYXlcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm92aWRlci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlQcm9jZXNzUHJvdmlkZXJzKHJlY29yZHMsIHByb3ZpZGVyW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcHJvdmlkZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgLy8gRnVuY3Rpb25zIHdlcmUgc3VwcG9ydGVkIGluIFJlZmxlY3RpdmVJbmplY3RvciwgYnV0IGFyZSBub3QgaGVyZS4gRm9yIHNhZmV0eSBnaXZlIHVzZWZ1bFxyXG4gICAgICAgICAgICAvLyBlcnJvciBtZXNzYWdlc1xyXG4gICAgICAgICAgICB0aHJvdyBzdGF0aWNFcnJvcignRnVuY3Rpb24vQ2xhc3Mgbm90IHN1cHBvcnRlZCcsIHByb3ZpZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIgJiYgdHlwZW9mIHByb3ZpZGVyID09PSAnb2JqZWN0JyAmJiBwcm92aWRlci5wcm92aWRlKSB7XHJcbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSB3aGF0IGxvb2tzIGxpa2UgYSBwcm92aWRlcjoge3Byb3ZpZGU6ID8sIC4uLi59XHJcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHJlc29sdmVGb3J3YXJkUmVmKHByb3ZpZGVyLnByb3ZpZGUpO1xyXG4gICAgICAgICAgICB2YXIgcmVzb2x2ZWRQcm92aWRlciA9IHJlc29sdmVQcm92aWRlcihwcm92aWRlcik7XHJcbiAgICAgICAgICAgIGlmIChwcm92aWRlci5tdWx0aSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG11bHRpIHByb3ZpZGVyLlxyXG4gICAgICAgICAgICAgICAgdmFyIG11bHRpUHJvdmlkZXIgPSByZWNvcmRzLmdldCh0b2tlbik7XHJcbiAgICAgICAgICAgICAgICBpZiAobXVsdGlQcm92aWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aVByb3ZpZGVyLmZuICE9PSBNVUxUSV9QUk9WSURFUl9GTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBtdWx0aVByb3ZpZGVyTWl4RXJyb3IodG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHBsYWNlaG9sZGVyIGZhY3Rvcnkgd2hpY2ggd2lsbCBsb29rIHVwIHRoZSBjb25zdGl0dWVudHMgb2YgdGhlIG11bHRpIHByb3ZpZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZHMuc2V0KHRva2VuLCBtdWx0aVByb3ZpZGVyID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogcHJvdmlkZXIucHJvdmlkZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZU5ldzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuOiBNVUxUSV9QUk9WSURFUl9GTixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IEVNUFRZXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUcmVhdCB0aGUgcHJvdmlkZXIgYXMgdGhlIHRva2VuLlxyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSBwcm92aWRlcjtcclxuICAgICAgICAgICAgICAgIG11bHRpUHJvdmlkZXIuZGVwcy5wdXNoKHsgdG9rZW46IHRva2VuLCBvcHRpb25zOiA2IC8qIERlZmF1bHQgKi8gfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlY29yZCA9IHJlY29yZHMuZ2V0KHRva2VuKTtcclxuICAgICAgICAgICAgaWYgKHJlY29yZCAmJiByZWNvcmQuZm4gPT0gTVVMVElfUFJPVklERVJfRk4pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG11bHRpUHJvdmlkZXJNaXhFcnJvcih0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVjb3Jkcy5zZXQodG9rZW4sIHJlc29sdmVkUHJvdmlkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgc3RhdGljRXJyb3IoJ1VuZXhwZWN0ZWQgcHJvdmlkZXInLCBwcm92aWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyeVJlc29sdmVUb2tlbih0b2tlbiwgcmVjb3JkLCByZWNvcmRzLCBwYXJlbnQsIG5vdEZvdW5kVmFsdWUsIGZsYWdzKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlVG9rZW4odG9rZW4sIHJlY29yZCwgcmVjb3JkcywgcGFyZW50LCBub3RGb3VuZFZhbHVlLCBmbGFncyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0ICdlJyBpcyBvZiB0eXBlIEVycm9yLlxyXG4gICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBFcnJvcikpIHtcclxuICAgICAgICAgICAgZSA9IG5ldyBFcnJvcihlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhdGggPSBlW05HX1RFTVBfVE9LRU5fUEFUSF0gPSBlW05HX1RFTVBfVE9LRU5fUEFUSF0gfHwgW107XHJcbiAgICAgICAgcGF0aC51bnNoaWZ0KHRva2VuKTtcclxuICAgICAgICBpZiAocmVjb3JkICYmIHJlY29yZC52YWx1ZSA9PSBDSVJDVUxBUikge1xyXG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgQ2lyY3VsYXIgZmxhZy5cclxuICAgICAgICAgICAgcmVjb3JkLnZhbHVlID0gRU1QVFk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IGU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZVRva2VuKHRva2VuLCByZWNvcmQsIHJlY29yZHMsIHBhcmVudCwgbm90Rm91bmRWYWx1ZSwgZmxhZ3MpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHZhciB2YWx1ZTtcclxuICAgIGlmIChyZWNvcmQgJiYgIShmbGFncyAmIEluamVjdEZsYWdzLlNraXBTZWxmKSkge1xyXG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSByZWNvcmQsIHRoaXMgaW1wbGllcyB0aGF0IHdlIGRvbid0IG93biB0aGUgcHJvdmlkZXIgaGVuY2UgZG9uJ3Qga25vdyBob3dcclxuICAgICAgICAvLyB0byByZXNvbHZlIGl0LlxyXG4gICAgICAgIHZhbHVlID0gcmVjb3JkLnZhbHVlO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBDSVJDVUxBUikge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihOT19ORVdfTElORSArICdDaXJjdWxhciBkZXBlbmRlbmN5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBFTVBUWSkge1xyXG4gICAgICAgICAgICByZWNvcmQudmFsdWUgPSBDSVJDVUxBUjtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdmFyIHVzZU5ldyA9IHJlY29yZC51c2VOZXc7XHJcbiAgICAgICAgICAgIHZhciBmbiA9IHJlY29yZC5mbjtcclxuICAgICAgICAgICAgdmFyIGRlcFJlY29yZHMgPSByZWNvcmQuZGVwcztcclxuICAgICAgICAgICAgdmFyIGRlcHMgPSBFTVBUWTtcclxuICAgICAgICAgICAgaWYgKGRlcFJlY29yZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBkZXBzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcFJlY29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVwUmVjb3JkID0gZGVwUmVjb3Jkc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGRlcFJlY29yZC5vcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZFJlY29yZCA9IG9wdGlvbnMgJiAyIC8qIENoZWNrU2VsZiAqLyA/IHJlY29yZHMuZ2V0KGRlcFJlY29yZC50b2tlbikgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKHRyeVJlc29sdmVUb2tlbihcclxuICAgICAgICAgICAgICAgICAgICAvLyBDdXJyZW50IFRva2VuIHRvIHJlc29sdmVcclxuICAgICAgICAgICAgICAgICAgICBkZXBSZWNvcmQudG9rZW4sIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcmVjb3JkIHdoaWNoIGRlc2NyaWJlcyBob3cgdG8gcmVzb2x2ZSB0aGUgdG9rZW4uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdW5kZWZpbmVkLCB0aGlzIG1lYW5zIHdlIGRvbid0IGhhdmUgc3VjaCBhIHJlY29yZFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkUmVjb3JkLCBcclxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlciByZWNvcmRzIHdlIGtub3cgYWJvdXQuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkcywgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3Qga25vdyBob3cgdG8gcmVzb2x2ZSBkZXBlbmRlbmN5IGFuZCB3ZSBzaG91bGQgbm90IGNoZWNrIHBhcmVudCBmb3IgaXQsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhbiBwYXNzIGluIE51bGwgaW5qZWN0b3IuXHJcbiAgICAgICAgICAgICAgICAgICAgIWNoaWxkUmVjb3JkICYmICEob3B0aW9ucyAmIDQgLyogQ2hlY2tQYXJlbnQgKi8pID8gSW5qZWN0b3IuTlVMTCA6IHBhcmVudCwgb3B0aW9ucyAmIDEgLyogT3B0aW9uYWwgKi8gPyBudWxsIDogSW5qZWN0b3IuVEhST1dfSUZfTk9UX0ZPVU5ELCBJbmplY3RGbGFncy5EZWZhdWx0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVjb3JkLnZhbHVlID0gdmFsdWUgPSB1c2VOZXcgPyBuZXcgKChfYSA9IGZuKS5iaW5kLmFwcGx5KF9hLCB0c2xpYl8xLl9fc3ByZWFkKFt2b2lkIDBdLCBkZXBzKSkpKCkgOiBmbi5hcHBseShvYmosIGRlcHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCEoZmxhZ3MgJiBJbmplY3RGbGFncy5TZWxmKSkge1xyXG4gICAgICAgIHZhbHVlID0gcGFyZW50LmdldCh0b2tlbiwgbm90Rm91bmRWYWx1ZSwgSW5qZWN0RmxhZ3MuRGVmYXVsdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZURlcHMocHJvdmlkZXIpIHtcclxuICAgIHZhciBkZXBzID0gRU1QVFk7XHJcbiAgICB2YXIgcHJvdmlkZXJEZXBzID0gcHJvdmlkZXIuZGVwcztcclxuICAgIGlmIChwcm92aWRlckRlcHMgJiYgcHJvdmlkZXJEZXBzLmxlbmd0aCkge1xyXG4gICAgICAgIGRlcHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3ZpZGVyRGVwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IDYgLyogRGVmYXVsdCAqLztcclxuICAgICAgICAgICAgdmFyIHRva2VuID0gcmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXJEZXBzW2ldKTtcclxuICAgICAgICAgICAgaWYgKHRva2VuIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBhbm5vdGF0aW9ucyA9IHRva2VuOyBqIDwgYW5ub3RhdGlvbnMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uIGluc3RhbmNlb2YgT3B0aW9uYWwgfHwgYW5ub3RhdGlvbiA9PSBPcHRpb25hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8IDEgLyogT3B0aW9uYWwgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFubm90YXRpb24gaW5zdGFuY2VvZiBTa2lwU2VsZiB8fCBhbm5vdGF0aW9uID09IFNraXBTZWxmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zICYgfjIgLyogQ2hlY2tTZWxmICovO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhbm5vdGF0aW9uIGluc3RhbmNlb2YgU2VsZiB8fCBhbm5vdGF0aW9uID09IFNlbGYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgJiB+NCAvKiBDaGVja1BhcmVudCAqLztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYW5ub3RhdGlvbiBpbnN0YW5jZW9mIEluamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGFubm90YXRpb24udG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHJlc29sdmVGb3J3YXJkUmVmKGFubm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZXBzLnB1c2goeyB0b2tlbjogdG9rZW4sIG9wdGlvbnM6IG9wdGlvbnMgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRXhpc3RpbmcpIHtcclxuICAgICAgICB2YXIgdG9rZW4gPSByZXNvbHZlRm9yd2FyZFJlZihwcm92aWRlci51c2VFeGlzdGluZyk7XHJcbiAgICAgICAgZGVwcyA9IFt7IHRva2VuOiB0b2tlbiwgb3B0aW9uczogNiAvKiBEZWZhdWx0ICovIH1dO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIXByb3ZpZGVyRGVwcyAmJiAhKFVTRV9WQUxVRSBpbiBwcm92aWRlcikpIHtcclxuICAgICAgICAvLyB1c2VWYWx1ZSAmIHVzZUV4aXN0aW5nIGFyZSB0aGUgb25seSBvbmVzIHdoaWNoIGFyZSBleGVtcHQgZnJvbSBkZXBzIGFsbCBvdGhlcnMgbmVlZCBpdC5cclxuICAgICAgICB0aHJvdyBzdGF0aWNFcnJvcignXFwnZGVwc1xcJyByZXF1aXJlZCcsIHByb3ZpZGVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkZXBzO1xyXG59XHJcbmZ1bmN0aW9uIHN0YXRpY0Vycm9yKHRleHQsIG9iaikge1xyXG4gICAgcmV0dXJuIG5ldyBFcnJvcihmb3JtYXRFcnJvcih0ZXh0LCBvYmosICdTdGF0aWNJbmplY3RvckVycm9yJykpO1xyXG59XHJcbmV4cG9ydCB7IMm1MCwgybUxIH07XHIiXX0=