{"version":3,"sources":["d:/Angular Project/Didex/didex-admin-panel/node_modules/@angular/http/src/http.js"],"names":[],"mappings":"AAAA;;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAqMM,AAGA;;;;;;;;;uNAKG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA6DH,AAGA;;;;;;;;;0GAKG","file":"http.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nimport { Injectable } from '@angular/core';\r\nimport { RequestOptions } from './base_request_options';\r\nimport { RequestMethod } from './enums';\r\nimport { ConnectionBackend } from './interfaces';\r\nimport { Request } from './static_request';\r\n/**\r\n * @param {?} backend\r\n * @param {?} request\r\n * @return {?}\r\n */\r\nfunction httpRequest(backend, request) {\r\n    return backend.createConnection(request).response;\r\n}\r\n/**\r\n * @param {?} defaultOpts\r\n * @param {?} providedOpts\r\n * @param {?} method\r\n * @param {?} url\r\n * @return {?}\r\n */\r\nfunction mergeOptions(defaultOpts, providedOpts, method, url) {\r\n    var /** @type {?} */ newOptions = defaultOpts;\r\n    if (providedOpts) {\r\n        // Hack so Dart can used named parameters\r\n        return newOptions.merge(new RequestOptions({\r\n            method: providedOpts.method || method,\r\n            url: providedOpts.url || url,\r\n            search: providedOpts.search,\r\n            headers: providedOpts.headers,\r\n            body: providedOpts.body,\r\n            withCredentials: providedOpts.withCredentials,\r\n            responseType: providedOpts.responseType\r\n        }));\r\n    }\r\n    return newOptions.merge(new RequestOptions({ method: method, url: url }));\r\n}\r\n/**\r\n * Performs http requests using `XMLHttpRequest` as the default backend.\r\n *\r\n * `Http` is available as an injectable class, with methods to perform http requests. Calling\r\n * `request` returns an `Observable` which will emit a single {\\@link Response} when a\r\n * response is received.\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import {Http, HTTP_PROVIDERS} from '\\@angular/http';\r\n * import 'rxjs/add/operator/map'\r\n * \\@Component({\r\n *   selector: 'http-app',\r\n *   viewProviders: [HTTP_PROVIDERS],\r\n *   templateUrl: 'people.html'\r\n * })\r\n * class PeopleComponent {\r\n *   constructor(http: Http) {\r\n *     http.get('people.json')\r\n *       // Call map on the response observable to get the parsed people object\r\n *       .map(res => res.json())\r\n *       // Subscribe to the observable to get the parsed people object and attach it to the\r\n *       // component\r\n *       .subscribe(people => this.people = people);\r\n *   }\r\n * }\r\n * ```\r\n *\r\n *\r\n * ### Example\r\n *\r\n * ```\r\n * http.get('people.json').subscribe((res:Response) => this.people = res.json());\r\n * ```\r\n *\r\n * The default construct used to perform requests, `XMLHttpRequest`, is abstracted as a \"Backend\" (\r\n * {\\@link XHRBackend} in this case), which could be mocked with dependency injection by replacing\r\n * the {\\@link XHRBackend} provider, as in the following example:\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import {BaseRequestOptions, Http} from '\\@angular/http';\r\n * import {MockBackend} from '\\@angular/http/testing';\r\n * var injector = Injector.resolveAndCreate([\r\n *   BaseRequestOptions,\r\n *   MockBackend,\r\n *   {provide: Http, useFactory:\r\n *       function(backend, defaultOptions) {\r\n *         return new Http(backend, defaultOptions);\r\n *       },\r\n *       deps: [MockBackend, BaseRequestOptions]}\r\n * ]);\r\n * var http = injector.get(Http);\r\n * http.get('request-from-mock-backend.json').subscribe((res:Response) => doSomething(res));\r\n * ```\r\n *\r\n * \\@experimental\r\n */\r\nexport var Http = (function () {\r\n    /**\r\n     * @param {?} _backend\r\n     * @param {?} _defaultOptions\r\n     */\r\n    function Http(_backend, _defaultOptions) {\r\n        this._backend = _backend;\r\n        this._defaultOptions = _defaultOptions;\r\n    }\r\n    /**\r\n     * Performs any type of http request. First argument is required, and can either be a url or\r\n     * a {\\@link Request} instance. If the first argument is a url, an optional {\\@link RequestOptions}\r\n     * object can be provided as the 2nd argument. The options object will be merged with the values\r\n     * of {\\@link BaseRequestOptions} before performing the request.\r\n     * @param {?} url\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    Http.prototype.request = function (url, options) {\r\n        var /** @type {?} */ responseObservable;\r\n        if (typeof url === 'string') {\r\n            responseObservable = httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, /** @type {?} */ (url))));\r\n        }\r\n        else if (url instanceof Request) {\r\n            responseObservable = httpRequest(this._backend, url);\r\n        }\r\n        else {\r\n            throw new Error('First argument must be a url string or Request instance.');\r\n        }\r\n        return responseObservable;\r\n    };\r\n    /**\r\n     * Performs a request with `get` http method.\r\n     * @param {?} url\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    Http.prototype.get = function (url, options) {\r\n        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, url)));\r\n    };\r\n    /**\r\n     * Performs a request with `post` http method.\r\n     * @param {?} url\r\n     * @param {?} body\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    Http.prototype.post = function (url, body, options) {\r\n        return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Post, url)));\r\n    };\r\n    /**\r\n     * Performs a request with `put` http method.\r\n     * @param {?} url\r\n     * @param {?} body\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    Http.prototype.put = function (url, body, options) {\r\n        return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Put, url)));\r\n    };\r\n    /**\r\n     * Performs a request with `delete` http method.\r\n     * @param {?} url\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    Http.prototype.delete = function (url, options) {\r\n        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Delete, url)));\r\n    };\r\n    /**\r\n     * Performs a request with `patch` http method.\r\n     * @param {?} url\r\n     * @param {?} body\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    Http.prototype.patch = function (url, body, options) {\r\n        return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Patch, url)));\r\n    };\r\n    /**\r\n     * Performs a request with `head` http method.\r\n     * @param {?} url\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    Http.prototype.head = function (url, options) {\r\n        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Head, url)));\r\n    };\r\n    /**\r\n     * Performs a request with `options` http method.\r\n     * @param {?} url\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    Http.prototype.options = function (url, options) {\r\n        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Options, url)));\r\n    };\r\n    Http.decorators = [\r\n        { type: Injectable },\r\n    ];\r\n    /** @nocollapse */\r\n    Http.ctorParameters = function () { return [\r\n        { type: ConnectionBackend, },\r\n        { type: RequestOptions, },\r\n    ]; };\r\n    return Http;\r\n}());\r\nfunction Http_tsickle_Closure_declarations() {\r\n    /** @type {?} */\r\n    Http.decorators;\r\n    /**\r\n     * @nocollapse\r\n     * @type {?}\r\n     */\r\n    Http.ctorParameters;\r\n    /** @type {?} */\r\n    Http.prototype._backend;\r\n    /** @type {?} */\r\n    Http.prototype._defaultOptions;\r\n}\r\n/**\r\n * \\@experimental\r\n */\r\nexport var Jsonp = (function (_super) {\r\n    __extends(Jsonp, _super);\r\n    /**\r\n     * @param {?} backend\r\n     * @param {?} defaultOptions\r\n     */\r\n    function Jsonp(backend, defaultOptions) {\r\n        _super.call(this, backend, defaultOptions);\r\n    }\r\n    /**\r\n     * Performs any type of http request. First argument is required, and can either be a url or\r\n     * a {\\@link Request} instance. If the first argument is a url, an optional {\\@link RequestOptions}\r\n     * object can be provided as the 2nd argument. The options object will be merged with the values\r\n     * of {\\@link BaseRequestOptions} before performing the request.\r\n     *\r\n     * \\@security Regular XHR is the safest alternative to JSONP for most applications, and is\r\n     * supported by all current browsers. Because JSONP creates a `<script>` element with\r\n     * contents retrieved from a remote source, attacker-controlled data introduced by an untrusted\r\n     * source could expose your application to XSS risks. Data exposed by JSONP may also be\r\n     * readable by malicious third-party websites. In addition, JSONP introduces potential risk for\r\n     * future security issues (e.g. content sniffing).  For more detail, see the\r\n     * [Security Guide](http://g.co/ng/security).\r\n     * @param {?} url\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\r\n    Jsonp.prototype.request = function (url, options) {\r\n        var /** @type {?} */ responseObservable;\r\n        if (typeof url === 'string') {\r\n            url =\r\n                new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, /** @type {?} */ (url)));\r\n        }\r\n        if (url instanceof Request) {\r\n            if (url.method !== RequestMethod.Get) {\r\n                throw new Error('JSONP requests must use GET request method.');\r\n            }\r\n            responseObservable = httpRequest(this._backend, url);\r\n        }\r\n        else {\r\n            throw new Error('First argument must be a url string or Request instance.');\r\n        }\r\n        return responseObservable;\r\n    };\r\n    Jsonp.decorators = [\r\n        { type: Injectable },\r\n    ];\r\n    /** @nocollapse */\r\n    Jsonp.ctorParameters = function () { return [\r\n        { type: ConnectionBackend, },\r\n        { type: RequestOptions, },\r\n    ]; };\r\n    return Jsonp;\r\n}(Http));\r\nfunction Jsonp_tsickle_Closure_declarations() {\r\n    /** @type {?} */\r\n    Jsonp.decorators;\r\n    /**\r\n     * @nocollapse\r\n     * @type {?}\r\n     */\r\n    Jsonp.ctorParameters;\r\n}\r\n"]}