{"version":3,"sources":["d:/Angular Project/Didex/didex-admin-panel/node_modules/@angular/common/fesm2015/testing.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;AAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuLC,ueAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4KD,kUAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkRD,kVAGC","file":"testing.js","sourcesContent":["/**\r\n * @license Angular v8.2.14\r\n * (c) 2010-2019 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { EventEmitter, Injectable, InjectionToken, Inject, Optional } from '@angular/core';\r\nimport { LocationStrategy } from '@angular/common';\r\nimport { Subject } from 'rxjs';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * A spy for {\\@link Location} that allows tests to fire simulated location events.\r\n *\r\n * \\@publicApi\r\n */\r\nclass SpyLocation {\r\n    constructor() {\r\n        this.urlChanges = [];\r\n        this._history = [new LocationState('', '', null)];\r\n        this._historyIndex = 0;\r\n        /**\r\n         * \\@internal\r\n         */\r\n        this._subject = new EventEmitter();\r\n        /**\r\n         * \\@internal\r\n         */\r\n        this._baseHref = '';\r\n        /**\r\n         * \\@internal\r\n         */\r\n        this._platformStrategy = (/** @type {?} */ (null));\r\n        /**\r\n         * \\@internal\r\n         */\r\n        this._platformLocation = (/** @type {?} */ (null));\r\n        /**\r\n         * \\@internal\r\n         */\r\n        this._urlChangeListeners = [];\r\n    }\r\n    /**\r\n     * @param {?} url\r\n     * @return {?}\r\n     */\r\n    setInitialPath(url) { this._history[this._historyIndex].path = url; }\r\n    /**\r\n     * @param {?} url\r\n     * @return {?}\r\n     */\r\n    setBaseHref(url) { this._baseHref = url; }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    path() { return this._history[this._historyIndex].path; }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    getState() { return this._history[this._historyIndex].state; }\r\n    /**\r\n     * @param {?} path\r\n     * @param {?=} query\r\n     * @return {?}\r\n     */\r\n    isCurrentPathEqualTo(path, query = '') {\r\n        /** @type {?} */\r\n        const givenPath = path.endsWith('/') ? path.substring(0, path.length - 1) : path;\r\n        /** @type {?} */\r\n        const currPath = this.path().endsWith('/') ? this.path().substring(0, this.path().length - 1) : this.path();\r\n        return currPath == givenPath + (query.length > 0 ? ('?' + query) : '');\r\n    }\r\n    /**\r\n     * @param {?} pathname\r\n     * @return {?}\r\n     */\r\n    simulateUrlPop(pathname) {\r\n        this._subject.emit({ 'url': pathname, 'pop': true, 'type': 'popstate' });\r\n    }\r\n    /**\r\n     * @param {?} pathname\r\n     * @return {?}\r\n     */\r\n    simulateHashChange(pathname) {\r\n        // Because we don't prevent the native event, the browser will independently update the path\r\n        this.setInitialPath(pathname);\r\n        this.urlChanges.push('hash: ' + pathname);\r\n        this._subject.emit({ 'url': pathname, 'pop': true, 'type': 'hashchange' });\r\n    }\r\n    /**\r\n     * @param {?} url\r\n     * @return {?}\r\n     */\r\n    prepareExternalUrl(url) {\r\n        if (url.length > 0 && !url.startsWith('/')) {\r\n            url = '/' + url;\r\n        }\r\n        return this._baseHref + url;\r\n    }\r\n    /**\r\n     * @param {?} path\r\n     * @param {?=} query\r\n     * @param {?=} state\r\n     * @return {?}\r\n     */\r\n    go(path, query = '', state = null) {\r\n        path = this.prepareExternalUrl(path);\r\n        if (this._historyIndex > 0) {\r\n            this._history.splice(this._historyIndex + 1);\r\n        }\r\n        this._history.push(new LocationState(path, query, state));\r\n        this._historyIndex = this._history.length - 1;\r\n        /** @type {?} */\r\n        const locationState = this._history[this._historyIndex - 1];\r\n        if (locationState.path == path && locationState.query == query) {\r\n            return;\r\n        }\r\n        /** @type {?} */\r\n        const url = path + (query.length > 0 ? ('?' + query) : '');\r\n        this.urlChanges.push(url);\r\n        this._subject.emit({ 'url': url, 'pop': false });\r\n    }\r\n    /**\r\n     * @param {?} path\r\n     * @param {?=} query\r\n     * @param {?=} state\r\n     * @return {?}\r\n     */\r\n    replaceState(path, query = '', state = null) {\r\n        path = this.prepareExternalUrl(path);\r\n        /** @type {?} */\r\n        const history = this._history[this._historyIndex];\r\n        if (history.path == path && history.query == query) {\r\n            return;\r\n        }\r\n        history.path = path;\r\n        history.query = query;\r\n        history.state = state;\r\n        /** @type {?} */\r\n        const url = path + (query.length > 0 ? ('?' + query) : '');\r\n        this.urlChanges.push('replace: ' + url);\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    forward() {\r\n        if (this._historyIndex < (this._history.length - 1)) {\r\n            this._historyIndex++;\r\n            this._subject.emit({ 'url': this.path(), 'state': this.getState(), 'pop': true });\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    back() {\r\n        if (this._historyIndex > 0) {\r\n            this._historyIndex--;\r\n            this._subject.emit({ 'url': this.path(), 'state': this.getState(), 'pop': true });\r\n        }\r\n    }\r\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    onUrlChange(fn) {\r\n        this._urlChangeListeners.push(fn);\r\n        this.subscribe((/**\r\n         * @param {?} v\r\n         * @return {?}\r\n         */\r\n        v => { this._notifyUrlChangeListeners(v.url, v.state); }));\r\n    }\r\n    /**\r\n     * \\@internal\r\n     * @param {?=} url\r\n     * @param {?=} state\r\n     * @return {?}\r\n     */\r\n    _notifyUrlChangeListeners(url = '', state) {\r\n        this._urlChangeListeners.forEach((/**\r\n         * @param {?} fn\r\n         * @return {?}\r\n         */\r\n        fn => fn(url, state)));\r\n    }\r\n    /**\r\n     * @param {?} onNext\r\n     * @param {?=} onThrow\r\n     * @param {?=} onReturn\r\n     * @return {?}\r\n     */\r\n    subscribe(onNext, onThrow, onReturn) {\r\n        return this._subject.subscribe({ next: onNext, error: onThrow, complete: onReturn });\r\n    }\r\n    /**\r\n     * @param {?} url\r\n     * @return {?}\r\n     */\r\n    normalize(url) { return (/** @type {?} */ (null)); }\r\n}\r\nSpyLocation.decorators = [\r\n    { type: Injectable }\r\n];\r\nif (false) {\r\n    /** @type {?} */\r\n    SpyLocation.prototype.urlChanges;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    SpyLocation.prototype._history;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    SpyLocation.prototype._historyIndex;\r\n    /**\r\n     * \\@internal\r\n     * @type {?}\r\n     */\r\n    SpyLocation.prototype._subject;\r\n    /**\r\n     * \\@internal\r\n     * @type {?}\r\n     */\r\n    SpyLocation.prototype._baseHref;\r\n    /**\r\n     * \\@internal\r\n     * @type {?}\r\n     */\r\n    SpyLocation.prototype._platformStrategy;\r\n    /**\r\n     * \\@internal\r\n     * @type {?}\r\n     */\r\n    SpyLocation.prototype._platformLocation;\r\n    /**\r\n     * \\@internal\r\n     * @type {?}\r\n     */\r\n    SpyLocation.prototype._urlChangeListeners;\r\n}\r\nclass LocationState {\r\n    /**\r\n     * @param {?} path\r\n     * @param {?} query\r\n     * @param {?} state\r\n     */\r\n    constructor(path, query, state) {\r\n        this.path = path;\r\n        this.query = query;\r\n        this.state = state;\r\n    }\r\n}\r\nif (false) {\r\n    /** @type {?} */\r\n    LocationState.prototype.path;\r\n    /** @type {?} */\r\n    LocationState.prototype.query;\r\n    /** @type {?} */\r\n    LocationState.prototype.state;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * A mock implementation of {\\@link LocationStrategy} that allows tests to fire simulated\r\n * location events.\r\n *\r\n * \\@publicApi\r\n */\r\nclass MockLocationStrategy extends LocationStrategy {\r\n    constructor() {\r\n        super();\r\n        this.internalBaseHref = '/';\r\n        this.internalPath = '/';\r\n        this.internalTitle = '';\r\n        this.urlChanges = [];\r\n        /**\r\n         * \\@internal\r\n         */\r\n        this._subject = new EventEmitter();\r\n        this.stateChanges = [];\r\n    }\r\n    /**\r\n     * @param {?} url\r\n     * @return {?}\r\n     */\r\n    simulatePopState(url) {\r\n        this.internalPath = url;\r\n        this._subject.emit(new _MockPopStateEvent(this.path()));\r\n    }\r\n    /**\r\n     * @param {?=} includeHash\r\n     * @return {?}\r\n     */\r\n    path(includeHash = false) { return this.internalPath; }\r\n    /**\r\n     * @param {?} internal\r\n     * @return {?}\r\n     */\r\n    prepareExternalUrl(internal) {\r\n        if (internal.startsWith('/') && this.internalBaseHref.endsWith('/')) {\r\n            return this.internalBaseHref + internal.substring(1);\r\n        }\r\n        return this.internalBaseHref + internal;\r\n    }\r\n    /**\r\n     * @param {?} ctx\r\n     * @param {?} title\r\n     * @param {?} path\r\n     * @param {?} query\r\n     * @return {?}\r\n     */\r\n    pushState(ctx, title, path, query) {\r\n        // Add state change to changes array\r\n        this.stateChanges.push(ctx);\r\n        this.internalTitle = title;\r\n        /** @type {?} */\r\n        const url = path + (query.length > 0 ? ('?' + query) : '');\r\n        this.internalPath = url;\r\n        /** @type {?} */\r\n        const externalUrl = this.prepareExternalUrl(url);\r\n        this.urlChanges.push(externalUrl);\r\n    }\r\n    /**\r\n     * @param {?} ctx\r\n     * @param {?} title\r\n     * @param {?} path\r\n     * @param {?} query\r\n     * @return {?}\r\n     */\r\n    replaceState(ctx, title, path, query) {\r\n        // Reset the last index of stateChanges to the ctx (state) object\r\n        this.stateChanges[(this.stateChanges.length || 1) - 1] = ctx;\r\n        this.internalTitle = title;\r\n        /** @type {?} */\r\n        const url = path + (query.length > 0 ? ('?' + query) : '');\r\n        this.internalPath = url;\r\n        /** @type {?} */\r\n        const externalUrl = this.prepareExternalUrl(url);\r\n        this.urlChanges.push('replace: ' + externalUrl);\r\n    }\r\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    onPopState(fn) { this._subject.subscribe({ next: fn }); }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    getBaseHref() { return this.internalBaseHref; }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    back() {\r\n        if (this.urlChanges.length > 0) {\r\n            this.urlChanges.pop();\r\n            this.stateChanges.pop();\r\n            /** @type {?} */\r\n            const nextUrl = this.urlChanges.length > 0 ? this.urlChanges[this.urlChanges.length - 1] : '';\r\n            this.simulatePopState(nextUrl);\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    forward() { throw 'not implemented'; }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    getState() { return this.stateChanges[(this.stateChanges.length || 1) - 1]; }\r\n}\r\nMockLocationStrategy.decorators = [\r\n    { type: Injectable }\r\n];\r\n/** @nocollapse */\r\nMockLocationStrategy.ctorParameters = () => [];\r\nif (false) {\r\n    /** @type {?} */\r\n    MockLocationStrategy.prototype.internalBaseHref;\r\n    /** @type {?} */\r\n    MockLocationStrategy.prototype.internalPath;\r\n    /** @type {?} */\r\n    MockLocationStrategy.prototype.internalTitle;\r\n    /** @type {?} */\r\n    MockLocationStrategy.prototype.urlChanges;\r\n    /**\r\n     * \\@internal\r\n     * @type {?}\r\n     */\r\n    MockLocationStrategy.prototype._subject;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MockLocationStrategy.prototype.stateChanges;\r\n}\r\nclass _MockPopStateEvent {\r\n    /**\r\n     * @param {?} newUrl\r\n     */\r\n    constructor(newUrl) {\r\n        this.newUrl = newUrl;\r\n        this.pop = true;\r\n        this.type = 'popstate';\r\n    }\r\n}\r\nif (false) {\r\n    /** @type {?} */\r\n    _MockPopStateEvent.prototype.pop;\r\n    /** @type {?} */\r\n    _MockPopStateEvent.prototype.type;\r\n    /** @type {?} */\r\n    _MockPopStateEvent.prototype.newUrl;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Parser from https://tools.ietf.org/html/rfc3986#appendix-B\r\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\r\n *  12            3  4          5       6  7        8 9\r\n *\r\n * Example: http://www.ics.uci.edu/pub/ietf/uri/#Related\r\n *\r\n * Results in:\r\n *\r\n * $1 = http:\r\n * $2 = http\r\n * $3 = //www.ics.uci.edu\r\n * $4 = www.ics.uci.edu\r\n * $5 = /pub/ietf/uri/\r\n * $6 = <undefined>\r\n * $7 = <undefined>\r\n * $8 = #Related\r\n * $9 = Related\r\n * @type {?}\r\n */\r\nconst urlParse = /^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\r\n/**\r\n * @param {?} urlStr\r\n * @param {?} baseHref\r\n * @return {?}\r\n */\r\nfunction parseUrl(urlStr, baseHref) {\r\n    /** @type {?} */\r\n    const verifyProtocol = /^((http[s]?|ftp):\\/\\/)/;\r\n    /** @type {?} */\r\n    let serverBase;\r\n    // URL class requires full URL. If the URL string doesn't start with protocol, we need to add\r\n    // an arbitrary base URL which can be removed afterward.\r\n    if (!verifyProtocol.test(urlStr)) {\r\n        serverBase = 'http://empty.com/';\r\n    }\r\n    /** @type {?} */\r\n    let parsedUrl;\r\n    try {\r\n        parsedUrl = new URL(urlStr, serverBase);\r\n    }\r\n    catch (e) {\r\n        /** @type {?} */\r\n        const result = urlParse.exec(serverBase || '' + urlStr);\r\n        if (!result) {\r\n            throw new Error(`Invalid URL: ${urlStr} with base: ${baseHref}`);\r\n        }\r\n        /** @type {?} */\r\n        const hostSplit = result[4].split(':');\r\n        parsedUrl = {\r\n            protocol: result[1],\r\n            hostname: hostSplit[0],\r\n            port: hostSplit[1] || '',\r\n            pathname: result[5],\r\n            search: result[6],\r\n            hash: result[8],\r\n        };\r\n    }\r\n    if (parsedUrl.pathname && parsedUrl.pathname.indexOf(baseHref) === 0) {\r\n        parsedUrl.pathname = parsedUrl.pathname.substring(baseHref.length);\r\n    }\r\n    return {\r\n        hostname: !serverBase && parsedUrl.hostname || '',\r\n        protocol: !serverBase && parsedUrl.protocol || '',\r\n        port: !serverBase && parsedUrl.port || '',\r\n        pathname: parsedUrl.pathname || '/',\r\n        search: parsedUrl.search || '',\r\n        hash: parsedUrl.hash || '',\r\n    };\r\n}\r\n/**\r\n * Mock platform location config\r\n *\r\n * \\@publicApi\r\n * @record\r\n */\r\nfunction MockPlatformLocationConfig() { }\r\nif (false) {\r\n    /** @type {?|undefined} */\r\n    MockPlatformLocationConfig.prototype.startUrl;\r\n    /** @type {?|undefined} */\r\n    MockPlatformLocationConfig.prototype.appBaseHref;\r\n}\r\n/**\r\n * Provider for mock platform location config\r\n *\r\n * \\@publicApi\r\n * @type {?}\r\n */\r\nconst MOCK_PLATFORM_LOCATION_CONFIG = new InjectionToken('MOCK_PLATFORM_LOCATION_CONFIG');\r\n/**\r\n * Mock implementation of URL state.\r\n *\r\n * \\@publicApi\r\n */\r\nclass MockPlatformLocation {\r\n    /**\r\n     * @param {?=} config\r\n     */\r\n    constructor(config) {\r\n        this.baseHref = '';\r\n        this.hashUpdate = new Subject();\r\n        this.urlChanges = [{ hostname: '', protocol: '', port: '', pathname: '/', search: '', hash: '', state: null }];\r\n        if (config) {\r\n            this.baseHref = config.appBaseHref || '';\r\n            /** @type {?} */\r\n            const parsedChanges = this.parseChanges(null, config.startUrl || 'http://<empty>/', this.baseHref);\r\n            this.urlChanges[0] = Object.assign({}, parsedChanges);\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get hostname() { return this.urlChanges[0].hostname; }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get protocol() { return this.urlChanges[0].protocol; }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get port() { return this.urlChanges[0].port; }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get pathname() { return this.urlChanges[0].pathname; }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get search() { return this.urlChanges[0].search; }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get hash() { return this.urlChanges[0].hash; }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get state() { return this.urlChanges[0].state; }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    getBaseHrefFromDOM() { return this.baseHref; }\r\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    onPopState(fn) {\r\n        // No-op: a state stack is not implemented, so\r\n        // no events will ever come.\r\n    }\r\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    onHashChange(fn) { this.hashUpdate.subscribe(fn); }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get href() {\r\n        /** @type {?} */\r\n        let url = `${this.protocol}//${this.hostname}${this.port ? ':' + this.port : ''}`;\r\n        url += `${this.pathname === '/' ? '' : this.pathname}${this.search}${this.hash}`;\r\n        return url;\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get url() { return `${this.pathname}${this.search}${this.hash}`; }\r\n    /**\r\n     * @private\r\n     * @param {?} state\r\n     * @param {?} url\r\n     * @param {?=} baseHref\r\n     * @return {?}\r\n     */\r\n    parseChanges(state, url, baseHref = '') {\r\n        // When the `history.state` value is stored, it is always copied.\r\n        state = JSON.parse(JSON.stringify(state));\r\n        return Object.assign({}, parseUrl(url, baseHref), { state });\r\n    }\r\n    /**\r\n     * @param {?} state\r\n     * @param {?} title\r\n     * @param {?} newUrl\r\n     * @return {?}\r\n     */\r\n    replaceState(state, title, newUrl) {\r\n        const { pathname, search, state: parsedState, hash } = this.parseChanges(state, newUrl);\r\n        this.urlChanges[0] = Object.assign({}, this.urlChanges[0], { pathname, search, hash, state: parsedState });\r\n    }\r\n    /**\r\n     * @param {?} state\r\n     * @param {?} title\r\n     * @param {?} newUrl\r\n     * @return {?}\r\n     */\r\n    pushState(state, title, newUrl) {\r\n        const { pathname, search, state: parsedState, hash } = this.parseChanges(state, newUrl);\r\n        this.urlChanges.unshift(Object.assign({}, this.urlChanges[0], { pathname, search, hash, state: parsedState }));\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    forward() { throw new Error('Not implemented'); }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    back() {\r\n        /** @type {?} */\r\n        const oldUrl = this.url;\r\n        /** @type {?} */\r\n        const oldHash = this.hash;\r\n        this.urlChanges.shift();\r\n        /** @type {?} */\r\n        const newHash = this.hash;\r\n        if (oldHash !== newHash) {\r\n            scheduleMicroTask((/**\r\n             * @return {?}\r\n             */\r\n            () => this.hashUpdate.next((/** @type {?} */ ({\r\n                type: 'hashchange', state: null, oldUrl, newUrl: this.url\r\n            })))));\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    getState() { return this.state; }\r\n}\r\nMockPlatformLocation.decorators = [\r\n    { type: Injectable }\r\n];\r\n/** @nocollapse */\r\nMockPlatformLocation.ctorParameters = () => [\r\n    { type: undefined, decorators: [{ type: Inject, args: [MOCK_PLATFORM_LOCATION_CONFIG,] }, { type: Optional }] }\r\n];\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MockPlatformLocation.prototype.baseHref;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MockPlatformLocation.prototype.hashUpdate;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MockPlatformLocation.prototype.urlChanges;\r\n}\r\n/**\r\n * @param {?} cb\r\n * @return {?}\r\n */\r\nfunction scheduleMicroTask(cb) {\r\n    Promise.resolve(null).then(cb);\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { SpyLocation, MockLocationStrategy, MOCK_PLATFORM_LOCATION_CONFIG, MockPlatformLocation };\r\n\r\n"]}