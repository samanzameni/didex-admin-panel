/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as tslib_1 from "tslib";
import { Injectable, KeyValueDiffers, Pipe } from '@angular/core';
import * as ɵngcc0 from '@angular/core';
function makeKeyValuePair(key, value) {
    return { key: key, value: value };
}
/**
 * @ngModule CommonModule
 * @description
 *
 * Transforms Object or Map into an array of key value pairs.
 *
 * The output array will be ordered by keys.
 * By default the comparator will be by Unicode point value.
 * You can optionally pass a compareFn if your keys are complex types.
 *
 * @usageNotes
 * ### Examples
 *
 * This examples show how an Object or a Map can be iterated by ngFor with the use of this keyvalue
 * pipe.
 *
 * {@example common/pipes/ts/keyvalue_pipe.ts region='KeyValuePipe'}
 *
 * @publicApi
 */
var KeyValuePipe = /** @class */ (function () {
    function KeyValuePipe(differs) {
        this.differs = differs;
        this.keyValues = [];
    }
    KeyValuePipe.prototype.transform = function (input, compareFn) {
        var _this = this;
        if (compareFn === void 0) { compareFn = defaultComparator; }
        if (!input || (!(input instanceof Map) && typeof input !== 'object')) {
            return null;
        }
        if (!this.differ) {
            // make a differ for whatever type we've been passed in
            this.differ = this.differs.find(input).create();
        }
        var differChanges = this.differ.diff(input);
        if (differChanges) {
            this.keyValues = [];
            differChanges.forEachItem(function (r) {
                _this.keyValues.push(makeKeyValuePair(r.key, r.currentValue));
            });
            this.keyValues.sort(compareFn);
        }
        return this.keyValues;
    };
    KeyValuePipe = tslib_1.__decorate([
        tslib_1.__metadata("design:paramtypes", [KeyValueDiffers])
    ], KeyValuePipe);
KeyValuePipe.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: KeyValuePipe, factory: function KeyValuePipe_Factory(t) { return new (t || KeyValuePipe)(ɵngcc0.ɵɵinject(KeyValueDiffers)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(KeyValuePipe, [{
        type: Injectable
    }, {
        type: Pipe,
        args: [{ name: 'keyvalue', pure: false }]
    }], function () { return [{ type: KeyValueDiffers }]; }, { differs: [], keyValues: [], transform: [], differ: [] });
KeyValuePipe.ngPipeDef = ɵngcc0.ɵɵdefinePipe({ name: "keyvalue", type: KeyValuePipe, factory: function KeyValuePipe_Factory(t) { return new (t || KeyValuePipe)(ɵngcc0.ɵɵdirectiveInject(KeyValueDiffers)); }, pure: false });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(KeyValuePipe, [{
        type: Injectable
    }, {
        type: Pipe,
        args: [{ name: 'keyvalue', pure: false }]
    }], function () { return [{ type: KeyValueDiffers }]; }, { differs: [], keyValues: [], transform: [], differ: [] });
    return KeyValuePipe;
}());
export { KeyValuePipe };
export function defaultComparator(keyValueA, keyValueB) {
    var a = keyValueA.key;
    var b = keyValueB.key;
    // if same exit with 0;
    if (a === b)
        return 0;
    // make sure that undefined are at the end of the sort.
    if (a === undefined)
        return 1;
    if (b === undefined)
        return -1;
    // make sure that nulls are at the end of the sort.
    if (a === null)
        return 1;
    if (b === null)
        return -1;
    if (typeof a == 'string' && typeof b == 'string') {
        return a < b ? -1 : 1;
    }
    if (typeof a == 'number' && typeof b == 'number') {
        return a - b;
    }
    if (typeof a == 'boolean' && typeof b == 'boolean') {
        return a < b ? -1 : 1;
    }
    // `a` and `b` are of different types. Compare their string values.
    var aString = String(a);
    var bString = String(b);
    return aString == bString ? 0 : aString < bString ? -1 : 1;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL2VzbTUvc3JjL3BpcGVzL2tleXZhbHVlX3BpcGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VDQWdEdUMsQUFFUzs7Ozs7Ozs7Ozs7Ozs7Ozt3SEFFM0IiLCJmaWxlIjoia2V5dmFsdWVfcGlwZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgSW5qZWN0YWJsZSwgS2V5VmFsdWVEaWZmZXJzLCBQaXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmZ1bmN0aW9uIG1ha2VLZXlWYWx1ZVBhaXIoa2V5LCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9O1xyXG59XHJcbi8qKlxyXG4gKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBUcmFuc2Zvcm1zIE9iamVjdCBvciBNYXAgaW50byBhbiBhcnJheSBvZiBrZXkgdmFsdWUgcGFpcnMuXHJcbiAqXHJcbiAqIFRoZSBvdXRwdXQgYXJyYXkgd2lsbCBiZSBvcmRlcmVkIGJ5IGtleXMuXHJcbiAqIEJ5IGRlZmF1bHQgdGhlIGNvbXBhcmF0b3Igd2lsbCBiZSBieSBVbmljb2RlIHBvaW50IHZhbHVlLlxyXG4gKiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyBhIGNvbXBhcmVGbiBpZiB5b3VyIGtleXMgYXJlIGNvbXBsZXggdHlwZXMuXHJcbiAqXHJcbiAqIEB1c2FnZU5vdGVzXHJcbiAqICMjIyBFeGFtcGxlc1xyXG4gKlxyXG4gKiBUaGlzIGV4YW1wbGVzIHNob3cgaG93IGFuIE9iamVjdCBvciBhIE1hcCBjYW4gYmUgaXRlcmF0ZWQgYnkgbmdGb3Igd2l0aCB0aGUgdXNlIG9mIHRoaXMga2V5dmFsdWVcclxuICogcGlwZS5cclxuICpcclxuICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9rZXl2YWx1ZV9waXBlLnRzIHJlZ2lvbj0nS2V5VmFsdWVQaXBlJ31cclxuICpcclxuICogQHB1YmxpY0FwaVxyXG4gKi9cclxudmFyIEtleVZhbHVlUGlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEtleVZhbHVlUGlwZShkaWZmZXJzKSB7XHJcbiAgICAgICAgdGhpcy5kaWZmZXJzID0gZGlmZmVycztcclxuICAgICAgICB0aGlzLmtleVZhbHVlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgS2V5VmFsdWVQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoaW5wdXQsIGNvbXBhcmVGbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGNvbXBhcmVGbiA9PT0gdm9pZCAwKSB7IGNvbXBhcmVGbiA9IGRlZmF1bHRDb21wYXJhdG9yOyB9XHJcbiAgICAgICAgaWYgKCFpbnB1dCB8fCAoIShpbnB1dCBpbnN0YW5jZW9mIE1hcCkgJiYgdHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5kaWZmZXIpIHtcclxuICAgICAgICAgICAgLy8gbWFrZSBhIGRpZmZlciBmb3Igd2hhdGV2ZXIgdHlwZSB3ZSd2ZSBiZWVuIHBhc3NlZCBpblxyXG4gICAgICAgICAgICB0aGlzLmRpZmZlciA9IHRoaXMuZGlmZmVycy5maW5kKGlucHV0KS5jcmVhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRpZmZlckNoYW5nZXMgPSB0aGlzLmRpZmZlci5kaWZmKGlucHV0KTtcclxuICAgICAgICBpZiAoZGlmZmVyQ2hhbmdlcykge1xyXG4gICAgICAgICAgICB0aGlzLmtleVZhbHVlcyA9IFtdO1xyXG4gICAgICAgICAgICBkaWZmZXJDaGFuZ2VzLmZvckVhY2hJdGVtKGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5rZXlWYWx1ZXMucHVzaChtYWtlS2V5VmFsdWVQYWlyKHIua2V5LCByLmN1cnJlbnRWYWx1ZSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5rZXlWYWx1ZXMuc29ydChjb21wYXJlRm4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5rZXlWYWx1ZXM7XHJcbiAgICB9O1xyXG4gICAgS2V5VmFsdWVQaXBlID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBJbmplY3RhYmxlKCksXHJcbiAgICAgICAgUGlwZSh7IG5hbWU6ICdrZXl2YWx1ZScsIHB1cmU6IGZhbHNlIH0pLFxyXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtLZXlWYWx1ZURpZmZlcnNdKVxyXG4gICAgXSwgS2V5VmFsdWVQaXBlKTtcclxuICAgIHJldHVybiBLZXlWYWx1ZVBpcGU7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IEtleVZhbHVlUGlwZSB9O1xyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdENvbXBhcmF0b3Ioa2V5VmFsdWVBLCBrZXlWYWx1ZUIpIHtcclxuICAgIHZhciBhID0ga2V5VmFsdWVBLmtleTtcclxuICAgIHZhciBiID0ga2V5VmFsdWVCLmtleTtcclxuICAgIC8vIGlmIHNhbWUgZXhpdCB3aXRoIDA7XHJcbiAgICBpZiAoYSA9PT0gYilcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHVuZGVmaW5lZCBhcmUgYXQgdGhlIGVuZCBvZiB0aGUgc29ydC5cclxuICAgIGlmIChhID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IG51bGxzIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSBzb3J0LlxyXG4gICAgaWYgKGEgPT09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICBpZiAoYiA9PT0gbnVsbClcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICBpZiAodHlwZW9mIGEgPT0gJ3N0cmluZycgJiYgdHlwZW9mIGIgPT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IDE7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGEgPT0gJ251bWJlcicgJiYgdHlwZW9mIGIgPT0gJ251bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gYSAtIGI7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGEgPT0gJ2Jvb2xlYW4nICYmIHR5cGVvZiBiID09ICdib29sZWFuJykge1xyXG4gICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogMTtcclxuICAgIH1cclxuICAgIC8vIGBhYCBhbmQgYGJgIGFyZSBvZiBkaWZmZXJlbnQgdHlwZXMuIENvbXBhcmUgdGhlaXIgc3RyaW5nIHZhbHVlcy5cclxuICAgIHZhciBhU3RyaW5nID0gU3RyaW5nKGEpO1xyXG4gICAgdmFyIGJTdHJpbmcgPSBTdHJpbmcoYik7XHJcbiAgICByZXR1cm4gYVN0cmluZyA9PSBiU3RyaW5nID8gMCA6IGFTdHJpbmcgPCBiU3RyaW5nID8gLTEgOiAxO1xyXG59XHIiXX0=