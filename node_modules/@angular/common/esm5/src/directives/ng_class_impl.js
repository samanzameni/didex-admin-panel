import * as tslib_1 from "tslib";
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ElementRef, Injectable, IterableDiffers, KeyValueDiffers, Renderer2, ɵisListLikeIterable as isListLikeIterable, ɵstringify as stringify } from '@angular/core';
import { StylingDiffer } from './styling_differ';
/**
 * Used as a token for an injected service within the NgClass directive.
 *
 * NgClass behaves differenly whether or not VE is being used or not. If
 * present then the legacy ngClass diffing algorithm will be used as an
 * injected service. Otherwise the new diffing algorithm (which delegates
 * to the `[class]` binding) will be used. This toggle behavior is done so
 * via the ivy_switch mechanism.
 */
import * as ɵngcc0 from '@angular/core';
var NgClassImpl = /** @class */ (function () {
    function NgClassImpl() {
    }
    return NgClassImpl;
}());
export { NgClassImpl };
var NgClassR2Impl = /** @class */ (function () {
    function NgClassR2Impl(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
        this._iterableDiffers = _iterableDiffers;
        this._keyValueDiffers = _keyValueDiffers;
        this._ngEl = _ngEl;
        this._renderer = _renderer;
        this._initialClasses = [];
    }
    NgClassR2Impl.prototype.getValue = function () { return null; };
    NgClassR2Impl.prototype.setClass = function (value) {
        this._removeClasses(this._initialClasses);
        this._initialClasses = typeof value === 'string' ? value.split(/\s+/) : [];
        this._applyClasses(this._initialClasses);
        this._applyClasses(this._rawClass);
    };
    NgClassR2Impl.prototype.setNgClass = function (value) {
        this._removeClasses(this._rawClass);
        this._applyClasses(this._initialClasses);
        this._iterableDiffer = null;
        this._keyValueDiffer = null;
        this._rawClass = typeof value === 'string' ? value.split(/\s+/) : value;
        if (this._rawClass) {
            if (isListLikeIterable(this._rawClass)) {
                this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create();
            }
            else {
                this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create();
            }
        }
    };
    NgClassR2Impl.prototype.applyChanges = function () {
        if (this._iterableDiffer) {
            var iterableChanges = this._iterableDiffer.diff(this._rawClass);
            if (iterableChanges) {
                this._applyIterableChanges(iterableChanges);
            }
        }
        else if (this._keyValueDiffer) {
            var keyValueChanges = this._keyValueDiffer.diff(this._rawClass);
            if (keyValueChanges) {
                this._applyKeyValueChanges(keyValueChanges);
            }
        }
    };
    NgClassR2Impl.prototype._applyKeyValueChanges = function (changes) {
        var _this = this;
        changes.forEachAddedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });
        changes.forEachChangedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });
        changes.forEachRemovedItem(function (record) {
            if (record.previousValue) {
                _this._toggleClass(record.key, false);
            }
        });
    };
    NgClassR2Impl.prototype._applyIterableChanges = function (changes) {
        var _this = this;
        changes.forEachAddedItem(function (record) {
            if (typeof record.item === 'string') {
                _this._toggleClass(record.item, true);
            }
            else {
                throw new Error("NgClass can only toggle CSS classes expressed as strings, got " + stringify(record.item));
            }
        });
        changes.forEachRemovedItem(function (record) { return _this._toggleClass(record.item, false); });
    };
    /**
     * Applies a collection of CSS classes to the DOM element.
     *
     * For argument of type Set and Array CSS class names contained in those collections are always
     * added.
     * For argument of type Map CSS class name in the map's key is toggled based on the value (added
     * for truthy and removed for falsy).
     */
    NgClassR2Impl.prototype._applyClasses = function (rawClassVal) {
        var _this = this;
        if (rawClassVal) {
            if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
                rawClassVal.forEach(function (klass) { return _this._toggleClass(klass, true); });
            }
            else {
                Object.keys(rawClassVal).forEach(function (klass) { return _this._toggleClass(klass, !!rawClassVal[klass]); });
            }
        }
    };
    /**
     * Removes a collection of CSS classes from the DOM element. This is mostly useful for cleanup
     * purposes.
     */
    NgClassR2Impl.prototype._removeClasses = function (rawClassVal) {
        var _this = this;
        if (rawClassVal) {
            if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
                rawClassVal.forEach(function (klass) { return _this._toggleClass(klass, false); });
            }
            else {
                Object.keys(rawClassVal).forEach(function (klass) { return _this._toggleClass(klass, false); });
            }
        }
    };
    NgClassR2Impl.prototype._toggleClass = function (klass, enabled) {
        var _this = this;
        klass = klass.trim();
        if (klass) {
            klass.split(/\s+/g).forEach(function (klass) {
                if (enabled) {
                    _this._renderer.addClass(_this._ngEl.nativeElement, klass);
                }
                else {
                    _this._renderer.removeClass(_this._ngEl.nativeElement, klass);
                }
            });
        }
    };
    NgClassR2Impl = tslib_1.__decorate([
        tslib_1.__metadata("design:paramtypes", [IterableDiffers, KeyValueDiffers,
            ElementRef, Renderer2])
    ], NgClassR2Impl);
NgClassR2Impl.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: NgClassR2Impl, factory: function NgClassR2Impl_Factory(t) { return new (t || NgClassR2Impl)(ɵngcc0.ɵɵinject(IterableDiffers), ɵngcc0.ɵɵinject(KeyValueDiffers), ɵngcc0.ɵɵinject(ElementRef), ɵngcc0.ɵɵinject(Renderer2)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgClassR2Impl, [{
        type: Injectable
    }], function () { return [{ type: IterableDiffers }, { type: KeyValueDiffers }, { type: ElementRef }, { type: Renderer2 }]; }, { _iterableDiffers: [], _keyValueDiffers: [], _ngEl: [], _renderer: [], _initialClasses: [], getValue: [], setClass: [], setNgClass: [], _iterableDiffer: [], _keyValueDiffer: [], _rawClass: [], applyChanges: [], _applyKeyValueChanges: [], _applyIterableChanges: [], _applyClasses: [], _removeClasses: [], _toggleClass: [] });
    return NgClassR2Impl;
}());
export { NgClassR2Impl };
var NgClassR3Impl = /** @class */ (function () {
    function NgClassR3Impl() {
        this._value = null;
        this._ngClassDiffer = new StylingDiffer('NgClass', 1 /* TrimProperties */ |
            2 /* AllowSubKeys */ |
            4 /* AllowStringValue */ | 16 /* ForceAsMap */);
        this._classStringDiffer = null;
    }
    NgClassR3Impl.prototype.getValue = function () { return this._value; };
    NgClassR3Impl.prototype.setClass = function (value) {
        // early exit incase the binding gets emitted as an empty value which
        // means there is no reason to instantiate and diff the values...
        if (!value && !this._classStringDiffer)
            return;
        this._classStringDiffer = this._classStringDiffer ||
            new StylingDiffer('class', 4 /* AllowStringValue */ | 16 /* ForceAsMap */);
        this._classStringDiffer.setValue(value);
    };
    NgClassR3Impl.prototype.setNgClass = function (value) {
        this._ngClassDiffer.setValue(value);
    };
    NgClassR3Impl.prototype.applyChanges = function () {
        var classChanged = this._classStringDiffer ? this._classStringDiffer.hasValueChanged() : false;
        var ngClassChanged = this._ngClassDiffer.hasValueChanged();
        if (classChanged || ngClassChanged) {
            var value = this._ngClassDiffer.value;
            if (this._classStringDiffer) {
                var classValue = this._classStringDiffer.value;
                if (classValue) {
                    value = value ? tslib_1.__assign({}, classValue, value) : classValue;
                }
            }
            this._value = value;
        }
    };
NgClassR3Impl.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: NgClassR3Impl, factory: function NgClassR3Impl_Factory(t) { return new (t || NgClassR3Impl)(); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgClassR3Impl, [{
        type: Injectable
    }], function () { return []; }, { _value: [], _ngClassDiffer: [], _classStringDiffer: [], getValue: [], setClass: [], setNgClass: [], applyChanges: [] });
    return NgClassR3Impl;
}());
export { NgClassR3Impl };
// the implementation for both NgStyleR2Impl and NgStyleR3Impl are
// not ivy_switch'd away, instead they are only hooked up into the
// DI via NgStyle's directive's provider property.
export var NgClassImplProvider__PRE_R3__ = {
    provide: NgClassImpl,
    useClass: NgClassR2Impl
};
export var NgClassImplProvider__POST_R3__ = {
    provide: NgClassImpl,
    useClass: NgClassR3Impl
};
export var NgClassImplProvider = NgClassImplProvider__POST_R3__;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL2VzbTUvc3JjL2RpcmVjdGl2ZXMvbmdfY2xhc3NfaW1wbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3Q0F3SHdDLEFBQ25COzs7Ozs7O3djQUdDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQXNDaEI7Ozs7OEpBR2dCOzs7Ozs7Ozs7Ozs7Ozs7aUNBZVcsOEJBQTZCIiwiZmlsZSI6Im5nX2NsYXNzX2ltcGwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xyXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7IEVsZW1lbnRSZWYsIEluamVjdGFibGUsIEl0ZXJhYmxlRGlmZmVycywgS2V5VmFsdWVEaWZmZXJzLCBSZW5kZXJlcjIsIMm1aXNMaXN0TGlrZUl0ZXJhYmxlIGFzIGlzTGlzdExpa2VJdGVyYWJsZSwgybVzdHJpbmdpZnkgYXMgc3RyaW5naWZ5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN0eWxpbmdEaWZmZXIgfSBmcm9tICcuL3N0eWxpbmdfZGlmZmVyJztcclxuLyoqXHJcbiAqIFVzZWQgYXMgYSB0b2tlbiBmb3IgYW4gaW5qZWN0ZWQgc2VydmljZSB3aXRoaW4gdGhlIE5nQ2xhc3MgZGlyZWN0aXZlLlxyXG4gKlxyXG4gKiBOZ0NsYXNzIGJlaGF2ZXMgZGlmZmVyZW5seSB3aGV0aGVyIG9yIG5vdCBWRSBpcyBiZWluZyB1c2VkIG9yIG5vdC4gSWZcclxuICogcHJlc2VudCB0aGVuIHRoZSBsZWdhY3kgbmdDbGFzcyBkaWZmaW5nIGFsZ29yaXRobSB3aWxsIGJlIHVzZWQgYXMgYW5cclxuICogaW5qZWN0ZWQgc2VydmljZS4gT3RoZXJ3aXNlIHRoZSBuZXcgZGlmZmluZyBhbGdvcml0aG0gKHdoaWNoIGRlbGVnYXRlc1xyXG4gKiB0byB0aGUgYFtjbGFzc11gIGJpbmRpbmcpIHdpbGwgYmUgdXNlZC4gVGhpcyB0b2dnbGUgYmVoYXZpb3IgaXMgZG9uZSBzb1xyXG4gKiB2aWEgdGhlIGl2eV9zd2l0Y2ggbWVjaGFuaXNtLlxyXG4gKi9cclxudmFyIE5nQ2xhc3NJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmdDbGFzc0ltcGwoKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTmdDbGFzc0ltcGw7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IE5nQ2xhc3NJbXBsIH07XHJcbnZhciBOZ0NsYXNzUjJJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmdDbGFzc1IySW1wbChfaXRlcmFibGVEaWZmZXJzLCBfa2V5VmFsdWVEaWZmZXJzLCBfbmdFbCwgX3JlbmRlcmVyKSB7XHJcbiAgICAgICAgdGhpcy5faXRlcmFibGVEaWZmZXJzID0gX2l0ZXJhYmxlRGlmZmVycztcclxuICAgICAgICB0aGlzLl9rZXlWYWx1ZURpZmZlcnMgPSBfa2V5VmFsdWVEaWZmZXJzO1xyXG4gICAgICAgIHRoaXMuX25nRWwgPSBfbmdFbDtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcclxuICAgICAgICB0aGlzLl9pbml0aWFsQ2xhc3NlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgTmdDbGFzc1IySW1wbC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xyXG4gICAgTmdDbGFzc1IySW1wbC5wcm90b3R5cGUuc2V0Q2xhc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9yZW1vdmVDbGFzc2VzKHRoaXMuX2luaXRpYWxDbGFzc2VzKTtcclxuICAgICAgICB0aGlzLl9pbml0aWFsQ2xhc3NlcyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZS5zcGxpdCgvXFxzKy8pIDogW107XHJcbiAgICAgICAgdGhpcy5fYXBwbHlDbGFzc2VzKHRoaXMuX2luaXRpYWxDbGFzc2VzKTtcclxuICAgICAgICB0aGlzLl9hcHBseUNsYXNzZXModGhpcy5fcmF3Q2xhc3MpO1xyXG4gICAgfTtcclxuICAgIE5nQ2xhc3NSMkltcGwucHJvdG90eXBlLnNldE5nQ2xhc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9yZW1vdmVDbGFzc2VzKHRoaXMuX3Jhd0NsYXNzKTtcclxuICAgICAgICB0aGlzLl9hcHBseUNsYXNzZXModGhpcy5faW5pdGlhbENsYXNzZXMpO1xyXG4gICAgICAgIHRoaXMuX2l0ZXJhYmxlRGlmZmVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9rZXlWYWx1ZURpZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fcmF3Q2xhc3MgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUuc3BsaXQoL1xccysvKSA6IHZhbHVlO1xyXG4gICAgICAgIGlmICh0aGlzLl9yYXdDbGFzcykge1xyXG4gICAgICAgICAgICBpZiAoaXNMaXN0TGlrZUl0ZXJhYmxlKHRoaXMuX3Jhd0NsYXNzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXRlcmFibGVEaWZmZXIgPSB0aGlzLl9pdGVyYWJsZURpZmZlcnMuZmluZCh0aGlzLl9yYXdDbGFzcykuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXlWYWx1ZURpZmZlciA9IHRoaXMuX2tleVZhbHVlRGlmZmVycy5maW5kKHRoaXMuX3Jhd0NsYXNzKS5jcmVhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBOZ0NsYXNzUjJJbXBsLnByb3RvdHlwZS5hcHBseUNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2l0ZXJhYmxlRGlmZmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBpdGVyYWJsZUNoYW5nZXMgPSB0aGlzLl9pdGVyYWJsZURpZmZlci5kaWZmKHRoaXMuX3Jhd0NsYXNzKTtcclxuICAgICAgICAgICAgaWYgKGl0ZXJhYmxlQ2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlJdGVyYWJsZUNoYW5nZXMoaXRlcmFibGVDaGFuZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLl9rZXlWYWx1ZURpZmZlcikge1xyXG4gICAgICAgICAgICB2YXIga2V5VmFsdWVDaGFuZ2VzID0gdGhpcy5fa2V5VmFsdWVEaWZmZXIuZGlmZih0aGlzLl9yYXdDbGFzcyk7XHJcbiAgICAgICAgICAgIGlmIChrZXlWYWx1ZUNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5S2V5VmFsdWVDaGFuZ2VzKGtleVZhbHVlQ2hhbmdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTmdDbGFzc1IySW1wbC5wcm90b3R5cGUuX2FwcGx5S2V5VmFsdWVDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaEFkZGVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLmtleSwgcmVjb3JkLmN1cnJlbnRWYWx1ZSk7IH0pO1xyXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaENoYW5nZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHsgcmV0dXJuIF90aGlzLl90b2dnbGVDbGFzcyhyZWNvcmQua2V5LCByZWNvcmQuY3VycmVudFZhbHVlKTsgfSk7XHJcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgICAgICBpZiAocmVjb3JkLnByZXZpb3VzVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl90b2dnbGVDbGFzcyhyZWNvcmQua2V5LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBOZ0NsYXNzUjJJbXBsLnByb3RvdHlwZS5fYXBwbHlJdGVyYWJsZUNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZWNvcmQuaXRlbSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl90b2dnbGVDbGFzcyhyZWNvcmQuaXRlbSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZ0NsYXNzIGNhbiBvbmx5IHRvZ2dsZSBDU1MgY2xhc3NlcyBleHByZXNzZWQgYXMgc3RyaW5ncywgZ290IFwiICsgc3RyaW5naWZ5KHJlY29yZC5pdGVtKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjaGFuZ2VzLmZvckVhY2hSZW1vdmVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLml0ZW0sIGZhbHNlKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIGEgY29sbGVjdGlvbiBvZiBDU1MgY2xhc3NlcyB0byB0aGUgRE9NIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGFyZ3VtZW50IG9mIHR5cGUgU2V0IGFuZCBBcnJheSBDU1MgY2xhc3MgbmFtZXMgY29udGFpbmVkIGluIHRob3NlIGNvbGxlY3Rpb25zIGFyZSBhbHdheXNcclxuICAgICAqIGFkZGVkLlxyXG4gICAgICogRm9yIGFyZ3VtZW50IG9mIHR5cGUgTWFwIENTUyBjbGFzcyBuYW1lIGluIHRoZSBtYXAncyBrZXkgaXMgdG9nZ2xlZCBiYXNlZCBvbiB0aGUgdmFsdWUgKGFkZGVkXHJcbiAgICAgKiBmb3IgdHJ1dGh5IGFuZCByZW1vdmVkIGZvciBmYWxzeSkuXHJcbiAgICAgKi9cclxuICAgIE5nQ2xhc3NSMkltcGwucHJvdG90eXBlLl9hcHBseUNsYXNzZXMgPSBmdW5jdGlvbiAocmF3Q2xhc3NWYWwpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChyYXdDbGFzc1ZhbCkge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyYXdDbGFzc1ZhbCkgfHwgcmF3Q2xhc3NWYWwgaW5zdGFuY2VvZiBTZXQpIHtcclxuICAgICAgICAgICAgICAgIHJhd0NsYXNzVmFsLmZvckVhY2goZnVuY3Rpb24gKGtsYXNzKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3Moa2xhc3MsIHRydWUpOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJhd0NsYXNzVmFsKS5mb3JFYWNoKGZ1bmN0aW9uIChrbGFzcykgeyByZXR1cm4gX3RoaXMuX3RvZ2dsZUNsYXNzKGtsYXNzLCAhIXJhd0NsYXNzVmFsW2tsYXNzXSk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIGNvbGxlY3Rpb24gb2YgQ1NTIGNsYXNzZXMgZnJvbSB0aGUgRE9NIGVsZW1lbnQuIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBmb3IgY2xlYW51cFxyXG4gICAgICogcHVycG9zZXMuXHJcbiAgICAgKi9cclxuICAgIE5nQ2xhc3NSMkltcGwucHJvdG90eXBlLl9yZW1vdmVDbGFzc2VzID0gZnVuY3Rpb24gKHJhd0NsYXNzVmFsKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAocmF3Q2xhc3NWYWwpIHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmF3Q2xhc3NWYWwpIHx8IHJhd0NsYXNzVmFsIGluc3RhbmNlb2YgU2V0KSB7XHJcbiAgICAgICAgICAgICAgICByYXdDbGFzc1ZhbC5mb3JFYWNoKGZ1bmN0aW9uIChrbGFzcykgeyByZXR1cm4gX3RoaXMuX3RvZ2dsZUNsYXNzKGtsYXNzLCBmYWxzZSk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocmF3Q2xhc3NWYWwpLmZvckVhY2goZnVuY3Rpb24gKGtsYXNzKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3Moa2xhc3MsIGZhbHNlKTsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTmdDbGFzc1IySW1wbC5wcm90b3R5cGUuX3RvZ2dsZUNsYXNzID0gZnVuY3Rpb24gKGtsYXNzLCBlbmFibGVkKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBrbGFzcyA9IGtsYXNzLnRyaW0oKTtcclxuICAgICAgICBpZiAoa2xhc3MpIHtcclxuICAgICAgICAgICAga2xhc3Muc3BsaXQoL1xccysvZykuZm9yRWFjaChmdW5jdGlvbiAoa2xhc3MpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbmRlcmVyLmFkZENsYXNzKF90aGlzLl9uZ0VsLm5hdGl2ZUVsZW1lbnQsIGtsYXNzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW5kZXJlci5yZW1vdmVDbGFzcyhfdGhpcy5fbmdFbC5uYXRpdmVFbGVtZW50LCBrbGFzcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBOZ0NsYXNzUjJJbXBsID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBJbmplY3RhYmxlKCksXHJcbiAgICAgICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0l0ZXJhYmxlRGlmZmVycywgS2V5VmFsdWVEaWZmZXJzLFxyXG4gICAgICAgICAgICBFbGVtZW50UmVmLCBSZW5kZXJlcjJdKVxyXG4gICAgXSwgTmdDbGFzc1IySW1wbCk7XHJcbiAgICByZXR1cm4gTmdDbGFzc1IySW1wbDtcclxufSgpKTtcclxuZXhwb3J0IHsgTmdDbGFzc1IySW1wbCB9O1xyXG52YXIgTmdDbGFzc1IzSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5nQ2xhc3NSM0ltcGwoKSB7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX25nQ2xhc3NEaWZmZXIgPSBuZXcgU3R5bGluZ0RpZmZlcignTmdDbGFzcycsIDEgLyogVHJpbVByb3BlcnRpZXMgKi8gfFxyXG4gICAgICAgICAgICAyIC8qIEFsbG93U3ViS2V5cyAqLyB8XHJcbiAgICAgICAgICAgIDQgLyogQWxsb3dTdHJpbmdWYWx1ZSAqLyB8IDE2IC8qIEZvcmNlQXNNYXAgKi8pO1xyXG4gICAgICAgIHRoaXMuX2NsYXNzU3RyaW5nRGlmZmVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIE5nQ2xhc3NSM0ltcGwucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH07XHJcbiAgICBOZ0NsYXNzUjNJbXBsLnByb3RvdHlwZS5zZXRDbGFzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIC8vIGVhcmx5IGV4aXQgaW5jYXNlIHRoZSBiaW5kaW5nIGdldHMgZW1pdHRlZCBhcyBhbiBlbXB0eSB2YWx1ZSB3aGljaFxyXG4gICAgICAgIC8vIG1lYW5zIHRoZXJlIGlzIG5vIHJlYXNvbiB0byBpbnN0YW50aWF0ZSBhbmQgZGlmZiB0aGUgdmFsdWVzLi4uXHJcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiAhdGhpcy5fY2xhc3NTdHJpbmdEaWZmZXIpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLl9jbGFzc1N0cmluZ0RpZmZlciA9IHRoaXMuX2NsYXNzU3RyaW5nRGlmZmVyIHx8XHJcbiAgICAgICAgICAgIG5ldyBTdHlsaW5nRGlmZmVyKCdjbGFzcycsIDQgLyogQWxsb3dTdHJpbmdWYWx1ZSAqLyB8IDE2IC8qIEZvcmNlQXNNYXAgKi8pO1xyXG4gICAgICAgIHRoaXMuX2NsYXNzU3RyaW5nRGlmZmVyLnNldFZhbHVlKHZhbHVlKTtcclxuICAgIH07XHJcbiAgICBOZ0NsYXNzUjNJbXBsLnByb3RvdHlwZS5zZXROZ0NsYXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fbmdDbGFzc0RpZmZlci5zZXRWYWx1ZSh2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgTmdDbGFzc1IzSW1wbC5wcm90b3R5cGUuYXBwbHlDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjbGFzc0NoYW5nZWQgPSB0aGlzLl9jbGFzc1N0cmluZ0RpZmZlciA/IHRoaXMuX2NsYXNzU3RyaW5nRGlmZmVyLmhhc1ZhbHVlQ2hhbmdlZCgpIDogZmFsc2U7XHJcbiAgICAgICAgdmFyIG5nQ2xhc3NDaGFuZ2VkID0gdGhpcy5fbmdDbGFzc0RpZmZlci5oYXNWYWx1ZUNoYW5nZWQoKTtcclxuICAgICAgICBpZiAoY2xhc3NDaGFuZ2VkIHx8IG5nQ2xhc3NDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX25nQ2xhc3NEaWZmZXIudmFsdWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbGFzc1N0cmluZ0RpZmZlcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzVmFsdWUgPSB0aGlzLl9jbGFzc1N0cmluZ0RpZmZlci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChjbGFzc1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA/IHRzbGliXzEuX19hc3NpZ24oe30sIGNsYXNzVmFsdWUsIHZhbHVlKSA6IGNsYXNzVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTmdDbGFzc1IzSW1wbCA9IHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5qZWN0YWJsZSgpXHJcbiAgICBdLCBOZ0NsYXNzUjNJbXBsKTtcclxuICAgIHJldHVybiBOZ0NsYXNzUjNJbXBsO1xyXG59KCkpO1xyXG5leHBvcnQgeyBOZ0NsYXNzUjNJbXBsIH07XHJcbi8vIHRoZSBpbXBsZW1lbnRhdGlvbiBmb3IgYm90aCBOZ1N0eWxlUjJJbXBsIGFuZCBOZ1N0eWxlUjNJbXBsIGFyZVxyXG4vLyBub3QgaXZ5X3N3aXRjaCdkIGF3YXksIGluc3RlYWQgdGhleSBhcmUgb25seSBob29rZWQgdXAgaW50byB0aGVcclxuLy8gREkgdmlhIE5nU3R5bGUncyBkaXJlY3RpdmUncyBwcm92aWRlciBwcm9wZXJ0eS5cclxuZXhwb3J0IHZhciBOZ0NsYXNzSW1wbFByb3ZpZGVyX19QUkVfUjNfXyA9IHtcclxuICAgIHByb3ZpZGU6IE5nQ2xhc3NJbXBsLFxyXG4gICAgdXNlQ2xhc3M6IE5nQ2xhc3NSMkltcGxcclxufTtcclxuZXhwb3J0IHZhciBOZ0NsYXNzSW1wbFByb3ZpZGVyX19QT1NUX1IzX18gPSB7XHJcbiAgICBwcm92aWRlOiBOZ0NsYXNzSW1wbCxcclxuICAgIHVzZUNsYXNzOiBOZ0NsYXNzUjNJbXBsXHJcbn07XHJcbmV4cG9ydCB2YXIgTmdDbGFzc0ltcGxQcm92aWRlciA9IE5nQ2xhc3NJbXBsUHJvdmlkZXJfX1BSRV9SM19fO1xyIl19