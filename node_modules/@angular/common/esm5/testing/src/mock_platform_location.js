/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as tslib_1 from "tslib";
import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { Subject } from 'rxjs';
/**
 * Parser from https://tools.ietf.org/html/rfc3986#appendix-B
 * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
 *  12            3  4          5       6  7        8 9
 *
 * Example: http://www.ics.uci.edu/pub/ietf/uri/#Related
 *
 * Results in:
 *
 * $1 = http:
 * $2 = http
 * $3 = //www.ics.uci.edu
 * $4 = www.ics.uci.edu
 * $5 = /pub/ietf/uri/
 * $6 = <undefined>
 * $7 = <undefined>
 * $8 = #Related
 * $9 = Related
 */
import * as ɵngcc0 from '@angular/core';
var urlParse = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
function parseUrl(urlStr, baseHref) {
    var verifyProtocol = /^((http[s]?|ftp):\/\/)/;
    var serverBase;
    // URL class requires full URL. If the URL string doesn't start with protocol, we need to add
    // an arbitrary base URL which can be removed afterward.
    if (!verifyProtocol.test(urlStr)) {
        serverBase = 'http://empty.com/';
    }
    var parsedUrl;
    try {
        parsedUrl = new URL(urlStr, serverBase);
    }
    catch (e) {
        var result = urlParse.exec(serverBase || '' + urlStr);
        if (!result) {
            throw new Error("Invalid URL: " + urlStr + " with base: " + baseHref);
        }
        var hostSplit = result[4].split(':');
        parsedUrl = {
            protocol: result[1],
            hostname: hostSplit[0],
            port: hostSplit[1] || '',
            pathname: result[5],
            search: result[6],
            hash: result[8],
        };
    }
    if (parsedUrl.pathname && parsedUrl.pathname.indexOf(baseHref) === 0) {
        parsedUrl.pathname = parsedUrl.pathname.substring(baseHref.length);
    }
    return {
        hostname: !serverBase && parsedUrl.hostname || '',
        protocol: !serverBase && parsedUrl.protocol || '',
        port: !serverBase && parsedUrl.port || '',
        pathname: parsedUrl.pathname || '/',
        search: parsedUrl.search || '',
        hash: parsedUrl.hash || '',
    };
}
/**
 * Provider for mock platform location config
 *
 * @publicApi
 */
export var MOCK_PLATFORM_LOCATION_CONFIG = new InjectionToken('MOCK_PLATFORM_LOCATION_CONFIG');
/**
 * Mock implementation of URL state.
 *
 * @publicApi
 */
var MockPlatformLocation = /** @class */ (function () {
    function MockPlatformLocation(config) {
        this.baseHref = '';
        this.hashUpdate = new Subject();
        this.urlChanges = [{ hostname: '', protocol: '', port: '', pathname: '/', search: '', hash: '', state: null }];
        if (config) {
            this.baseHref = config.appBaseHref || '';
            var parsedChanges = this.parseChanges(null, config.startUrl || 'http://<empty>/', this.baseHref);
            this.urlChanges[0] = tslib_1.__assign({}, parsedChanges);
        }
    }
    Object.defineProperty(MockPlatformLocation.prototype, "hostname", {
        get: function () { return this.urlChanges[0].hostname; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockPlatformLocation.prototype, "protocol", {
        get: function () { return this.urlChanges[0].protocol; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockPlatformLocation.prototype, "port", {
        get: function () { return this.urlChanges[0].port; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockPlatformLocation.prototype, "pathname", {
        get: function () { return this.urlChanges[0].pathname; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockPlatformLocation.prototype, "search", {
        get: function () { return this.urlChanges[0].search; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockPlatformLocation.prototype, "hash", {
        get: function () { return this.urlChanges[0].hash; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockPlatformLocation.prototype, "state", {
        get: function () { return this.urlChanges[0].state; },
        enumerable: true,
        configurable: true
    });
    MockPlatformLocation.prototype.getBaseHrefFromDOM = function () { return this.baseHref; };
    MockPlatformLocation.prototype.onPopState = function (fn) {
        // No-op: a state stack is not implemented, so
        // no events will ever come.
    };
    MockPlatformLocation.prototype.onHashChange = function (fn) { this.hashUpdate.subscribe(fn); };
    Object.defineProperty(MockPlatformLocation.prototype, "href", {
        get: function () {
            var url = this.protocol + "//" + this.hostname + (this.port ? ':' + this.port : '');
            url += "" + (this.pathname === '/' ? '' : this.pathname) + this.search + this.hash;
            return url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockPlatformLocation.prototype, "url", {
        get: function () { return "" + this.pathname + this.search + this.hash; },
        enumerable: true,
        configurable: true
    });
    MockPlatformLocation.prototype.parseChanges = function (state, url, baseHref) {
        if (baseHref === void 0) { baseHref = ''; }
        // When the `history.state` value is stored, it is always copied.
        state = JSON.parse(JSON.stringify(state));
        return tslib_1.__assign({}, parseUrl(url, baseHref), { state: state });
    };
    MockPlatformLocation.prototype.replaceState = function (state, title, newUrl) {
        var _a = this.parseChanges(state, newUrl), pathname = _a.pathname, search = _a.search, parsedState = _a.state, hash = _a.hash;
        this.urlChanges[0] = tslib_1.__assign({}, this.urlChanges[0], { pathname: pathname, search: search, hash: hash, state: parsedState });
    };
    MockPlatformLocation.prototype.pushState = function (state, title, newUrl) {
        var _a = this.parseChanges(state, newUrl), pathname = _a.pathname, search = _a.search, parsedState = _a.state, hash = _a.hash;
        this.urlChanges.unshift(tslib_1.__assign({}, this.urlChanges[0], { pathname: pathname, search: search, hash: hash, state: parsedState }));
    };
    MockPlatformLocation.prototype.forward = function () { throw new Error('Not implemented'); };
    MockPlatformLocation.prototype.back = function () {
        var _this = this;
        var oldUrl = this.url;
        var oldHash = this.hash;
        this.urlChanges.shift();
        var newHash = this.hash;
        if (oldHash !== newHash) {
            scheduleMicroTask(function () { return _this.hashUpdate.next({
                type: 'hashchange', state: null, oldUrl: oldUrl, newUrl: _this.url
            }); });
        }
    };
    MockPlatformLocation.prototype.getState = function () { return this.state; };
    MockPlatformLocation = tslib_1.__decorate([
        tslib_1.__param(0, Inject(MOCK_PLATFORM_LOCATION_CONFIG)), tslib_1.__param(0, Optional()),
        tslib_1.__metadata("design:paramtypes", [Object])
    ], MockPlatformLocation);
MockPlatformLocation.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: MockPlatformLocation, factory: function MockPlatformLocation_Factory(t) { return new (t || MockPlatformLocation)(ɵngcc0.ɵɵinject(MOCK_PLATFORM_LOCATION_CONFIG, 8)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MockPlatformLocation, [{
        type: Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [MOCK_PLATFORM_LOCATION_CONFIG]
            }, {
                type: Optional
            }] }]; }, { baseHref: [], hashUpdate: [], urlChanges: [], hostname: [], protocol: [], port: [], pathname: [], search: [], hash: [], state: [], getBaseHrefFromDOM: [], onPopState: [], onHashChange: [], href: [], url: [], parseChanges: [], replaceState: [], pushState: [], forward: [], back: [], getState: [] });
    return MockPlatformLocation;
}());
export { MockPlatformLocation };
export function scheduleMicroTask(cb) {
    Promise.resolve(null).then(cb);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL2VzbTUvdGVzdGluZy9zcmMvbW9ja19wbGF0Zm9ybV9sb2NhdGlvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytDQWlKK0MsQUFDMUI7Ozs7Ozs7Ozs7OztrVUFHUSIsImZpbGUiOiJtb2NrX3BsYXRmb3JtX2xvY2F0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcbi8qKlxyXG4gKiBQYXJzZXIgZnJvbSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNhcHBlbmRpeC1CXHJcbiAqIF4oKFteOi8/I10rKTopPygvLyhbXi8/I10qKSk/KFtePyNdKikoXFw/KFteI10qKSk/KCMoLiopKT9cclxuICogIDEyICAgICAgICAgICAgMyAgNCAgICAgICAgICA1ICAgICAgIDYgIDcgICAgICAgIDggOVxyXG4gKlxyXG4gKiBFeGFtcGxlOiBodHRwOi8vd3d3Lmljcy51Y2kuZWR1L3B1Yi9pZXRmL3VyaS8jUmVsYXRlZFxyXG4gKlxyXG4gKiBSZXN1bHRzIGluOlxyXG4gKlxyXG4gKiAkMSA9IGh0dHA6XHJcbiAqICQyID0gaHR0cFxyXG4gKiAkMyA9IC8vd3d3Lmljcy51Y2kuZWR1XHJcbiAqICQ0ID0gd3d3Lmljcy51Y2kuZWR1XHJcbiAqICQ1ID0gL3B1Yi9pZXRmL3VyaS9cclxuICogJDYgPSA8dW5kZWZpbmVkPlxyXG4gKiAkNyA9IDx1bmRlZmluZWQ+XHJcbiAqICQ4ID0gI1JlbGF0ZWRcclxuICogJDkgPSBSZWxhdGVkXHJcbiAqL1xyXG52YXIgdXJsUGFyc2UgPSAvXigoW146XFwvPyNdKyk6KT8oXFwvXFwvKFteXFwvPyNdKikpPyhbXj8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/LztcclxuZnVuY3Rpb24gcGFyc2VVcmwodXJsU3RyLCBiYXNlSHJlZikge1xyXG4gICAgdmFyIHZlcmlmeVByb3RvY29sID0gL14oKGh0dHBbc10/fGZ0cCk6XFwvXFwvKS87XHJcbiAgICB2YXIgc2VydmVyQmFzZTtcclxuICAgIC8vIFVSTCBjbGFzcyByZXF1aXJlcyBmdWxsIFVSTC4gSWYgdGhlIFVSTCBzdHJpbmcgZG9lc24ndCBzdGFydCB3aXRoIHByb3RvY29sLCB3ZSBuZWVkIHRvIGFkZFxyXG4gICAgLy8gYW4gYXJiaXRyYXJ5IGJhc2UgVVJMIHdoaWNoIGNhbiBiZSByZW1vdmVkIGFmdGVyd2FyZC5cclxuICAgIGlmICghdmVyaWZ5UHJvdG9jb2wudGVzdCh1cmxTdHIpKSB7XHJcbiAgICAgICAgc2VydmVyQmFzZSA9ICdodHRwOi8vZW1wdHkuY29tLyc7XHJcbiAgICB9XHJcbiAgICB2YXIgcGFyc2VkVXJsO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybFN0ciwgc2VydmVyQmFzZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB1cmxQYXJzZS5leGVjKHNlcnZlckJhc2UgfHwgJycgKyB1cmxTdHIpO1xyXG4gICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgVVJMOiBcIiArIHVybFN0ciArIFwiIHdpdGggYmFzZTogXCIgKyBiYXNlSHJlZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBob3N0U3BsaXQgPSByZXN1bHRbNF0uc3BsaXQoJzonKTtcclxuICAgICAgICBwYXJzZWRVcmwgPSB7XHJcbiAgICAgICAgICAgIHByb3RvY29sOiByZXN1bHRbMV0sXHJcbiAgICAgICAgICAgIGhvc3RuYW1lOiBob3N0U3BsaXRbMF0sXHJcbiAgICAgICAgICAgIHBvcnQ6IGhvc3RTcGxpdFsxXSB8fCAnJyxcclxuICAgICAgICAgICAgcGF0aG5hbWU6IHJlc3VsdFs1XSxcclxuICAgICAgICAgICAgc2VhcmNoOiByZXN1bHRbNl0sXHJcbiAgICAgICAgICAgIGhhc2g6IHJlc3VsdFs4XSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHBhcnNlZFVybC5wYXRobmFtZSAmJiBwYXJzZWRVcmwucGF0aG5hbWUuaW5kZXhPZihiYXNlSHJlZikgPT09IDApIHtcclxuICAgICAgICBwYXJzZWRVcmwucGF0aG5hbWUgPSBwYXJzZWRVcmwucGF0aG5hbWUuc3Vic3RyaW5nKGJhc2VIcmVmLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGhvc3RuYW1lOiAhc2VydmVyQmFzZSAmJiBwYXJzZWRVcmwuaG9zdG5hbWUgfHwgJycsXHJcbiAgICAgICAgcHJvdG9jb2w6ICFzZXJ2ZXJCYXNlICYmIHBhcnNlZFVybC5wcm90b2NvbCB8fCAnJyxcclxuICAgICAgICBwb3J0OiAhc2VydmVyQmFzZSAmJiBwYXJzZWRVcmwucG9ydCB8fCAnJyxcclxuICAgICAgICBwYXRobmFtZTogcGFyc2VkVXJsLnBhdGhuYW1lIHx8ICcvJyxcclxuICAgICAgICBzZWFyY2g6IHBhcnNlZFVybC5zZWFyY2ggfHwgJycsXHJcbiAgICAgICAgaGFzaDogcGFyc2VkVXJsLmhhc2ggfHwgJycsXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBQcm92aWRlciBmb3IgbW9jayBwbGF0Zm9ybSBsb2NhdGlvbiBjb25maWdcclxuICpcclxuICogQHB1YmxpY0FwaVxyXG4gKi9cclxuZXhwb3J0IHZhciBNT0NLX1BMQVRGT1JNX0xPQ0FUSU9OX0NPTkZJRyA9IG5ldyBJbmplY3Rpb25Ub2tlbignTU9DS19QTEFURk9STV9MT0NBVElPTl9DT05GSUcnKTtcclxuLyoqXHJcbiAqIE1vY2sgaW1wbGVtZW50YXRpb24gb2YgVVJMIHN0YXRlLlxyXG4gKlxyXG4gKiBAcHVibGljQXBpXHJcbiAqL1xyXG52YXIgTW9ja1BsYXRmb3JtTG9jYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNb2NrUGxhdGZvcm1Mb2NhdGlvbihjb25maWcpIHtcclxuICAgICAgICB0aGlzLmJhc2VIcmVmID0gJyc7XHJcbiAgICAgICAgdGhpcy5oYXNoVXBkYXRlID0gbmV3IFN1YmplY3QoKTtcclxuICAgICAgICB0aGlzLnVybENoYW5nZXMgPSBbeyBob3N0bmFtZTogJycsIHByb3RvY29sOiAnJywgcG9ydDogJycsIHBhdGhuYW1lOiAnLycsIHNlYXJjaDogJycsIGhhc2g6ICcnLCBzdGF0ZTogbnVsbCB9XTtcclxuICAgICAgICBpZiAoY29uZmlnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFzZUhyZWYgPSBjb25maWcuYXBwQmFzZUhyZWYgfHwgJyc7XHJcbiAgICAgICAgICAgIHZhciBwYXJzZWRDaGFuZ2VzID0gdGhpcy5wYXJzZUNoYW5nZXMobnVsbCwgY29uZmlnLnN0YXJ0VXJsIHx8ICdodHRwOi8vPGVtcHR5Pi8nLCB0aGlzLmJhc2VIcmVmKTtcclxuICAgICAgICAgICAgdGhpcy51cmxDaGFuZ2VzWzBdID0gdHNsaWJfMS5fX2Fzc2lnbih7fSwgcGFyc2VkQ2hhbmdlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vY2tQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJob3N0bmFtZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnVybENoYW5nZXNbMF0uaG9zdG5hbWU7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vY2tQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJwcm90b2NvbFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnVybENoYW5nZXNbMF0ucHJvdG9jb2w7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vY2tQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJwb3J0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudXJsQ2hhbmdlc1swXS5wb3J0OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2NrUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUsIFwicGF0aG5hbWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy51cmxDaGFuZ2VzWzBdLnBhdGhuYW1lOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2NrUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUsIFwic2VhcmNoXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudXJsQ2hhbmdlc1swXS5zZWFyY2g7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vY2tQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJoYXNoXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudXJsQ2hhbmdlc1swXS5oYXNoOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2NrUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUsIFwic3RhdGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy51cmxDaGFuZ2VzWzBdLnN0YXRlOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE1vY2tQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5nZXRCYXNlSHJlZkZyb21ET00gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmJhc2VIcmVmOyB9O1xyXG4gICAgTW9ja1BsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLm9uUG9wU3RhdGUgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAvLyBOby1vcDogYSBzdGF0ZSBzdGFjayBpcyBub3QgaW1wbGVtZW50ZWQsIHNvXHJcbiAgICAgICAgLy8gbm8gZXZlbnRzIHdpbGwgZXZlciBjb21lLlxyXG4gICAgfTtcclxuICAgIE1vY2tQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5vbkhhc2hDaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5oYXNoVXBkYXRlLnN1YnNjcmliZShmbik7IH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9ja1BsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcImhyZWZcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsID0gdGhpcy5wcm90b2NvbCArIFwiLy9cIiArIHRoaXMuaG9zdG5hbWUgKyAodGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJycpO1xyXG4gICAgICAgICAgICB1cmwgKz0gXCJcIiArICh0aGlzLnBhdGhuYW1lID09PSAnLycgPyAnJyA6IHRoaXMucGF0aG5hbWUpICsgdGhpcy5zZWFyY2ggKyB0aGlzLmhhc2g7XHJcbiAgICAgICAgICAgIHJldHVybiB1cmw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9ja1BsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcInVybFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBcIlwiICsgdGhpcy5wYXRobmFtZSArIHRoaXMuc2VhcmNoICsgdGhpcy5oYXNoOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE1vY2tQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5wYXJzZUNoYW5nZXMgPSBmdW5jdGlvbiAoc3RhdGUsIHVybCwgYmFzZUhyZWYpIHtcclxuICAgICAgICBpZiAoYmFzZUhyZWYgPT09IHZvaWQgMCkgeyBiYXNlSHJlZiA9ICcnOyB9XHJcbiAgICAgICAgLy8gV2hlbiB0aGUgYGhpc3Rvcnkuc3RhdGVgIHZhbHVlIGlzIHN0b3JlZCwgaXQgaXMgYWx3YXlzIGNvcGllZC5cclxuICAgICAgICBzdGF0ZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcclxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgcGFyc2VVcmwodXJsLCBiYXNlSHJlZiksIHsgc3RhdGU6IHN0YXRlIH0pO1xyXG4gICAgfTtcclxuICAgIE1vY2tQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCBuZXdVcmwpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnBhcnNlQ2hhbmdlcyhzdGF0ZSwgbmV3VXJsKSwgcGF0aG5hbWUgPSBfYS5wYXRobmFtZSwgc2VhcmNoID0gX2Euc2VhcmNoLCBwYXJzZWRTdGF0ZSA9IF9hLnN0YXRlLCBoYXNoID0gX2EuaGFzaDtcclxuICAgICAgICB0aGlzLnVybENoYW5nZXNbMF0gPSB0c2xpYl8xLl9fYXNzaWduKHt9LCB0aGlzLnVybENoYW5nZXNbMF0sIHsgcGF0aG5hbWU6IHBhdGhuYW1lLCBzZWFyY2g6IHNlYXJjaCwgaGFzaDogaGFzaCwgc3RhdGU6IHBhcnNlZFN0YXRlIH0pO1xyXG4gICAgfTtcclxuICAgIE1vY2tQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5wdXNoU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCBuZXdVcmwpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnBhcnNlQ2hhbmdlcyhzdGF0ZSwgbmV3VXJsKSwgcGF0aG5hbWUgPSBfYS5wYXRobmFtZSwgc2VhcmNoID0gX2Euc2VhcmNoLCBwYXJzZWRTdGF0ZSA9IF9hLnN0YXRlLCBoYXNoID0gX2EuaGFzaDtcclxuICAgICAgICB0aGlzLnVybENoYW5nZXMudW5zaGlmdCh0c2xpYl8xLl9fYXNzaWduKHt9LCB0aGlzLnVybENoYW5nZXNbMF0sIHsgcGF0aG5hbWU6IHBhdGhuYW1lLCBzZWFyY2g6IHNlYXJjaCwgaGFzaDogaGFzaCwgc3RhdGU6IHBhcnNlZFN0YXRlIH0pKTtcclxuICAgIH07XHJcbiAgICBNb2NrUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTsgfTtcclxuICAgIE1vY2tQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG9sZFVybCA9IHRoaXMudXJsO1xyXG4gICAgICAgIHZhciBvbGRIYXNoID0gdGhpcy5oYXNoO1xyXG4gICAgICAgIHRoaXMudXJsQ2hhbmdlcy5zaGlmdCgpO1xyXG4gICAgICAgIHZhciBuZXdIYXNoID0gdGhpcy5oYXNoO1xyXG4gICAgICAgIGlmIChvbGRIYXNoICE9PSBuZXdIYXNoKSB7XHJcbiAgICAgICAgICAgIHNjaGVkdWxlTWljcm9UYXNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmhhc2hVcGRhdGUubmV4dCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGFzaGNoYW5nZScsIHN0YXRlOiBudWxsLCBvbGRVcmw6IG9sZFVybCwgbmV3VXJsOiBfdGhpcy51cmxcclxuICAgICAgICAgICAgfSk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb2NrUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnN0YXRlOyB9O1xyXG4gICAgTW9ja1BsYXRmb3JtTG9jYXRpb24gPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEluamVjdGFibGUoKSxcclxuICAgICAgICB0c2xpYl8xLl9fcGFyYW0oMCwgSW5qZWN0KE1PQ0tfUExBVEZPUk1fTE9DQVRJT05fQ09ORklHKSksIHRzbGliXzEuX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcclxuICAgICAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcclxuICAgIF0sIE1vY2tQbGF0Zm9ybUxvY2F0aW9uKTtcclxuICAgIHJldHVybiBNb2NrUGxhdGZvcm1Mb2NhdGlvbjtcclxufSgpKTtcclxuZXhwb3J0IHsgTW9ja1BsYXRmb3JtTG9jYXRpb24gfTtcclxuZXhwb3J0IGZ1bmN0aW9uIHNjaGVkdWxlTWljcm9UYXNrKGNiKSB7XHJcbiAgICBQcm9taXNlLnJlc29sdmUobnVsbCkudGhlbihjYik7XHJcbn1cciJdfQ==