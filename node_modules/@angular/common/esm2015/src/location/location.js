/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { EventEmitter, Injectable } from '@angular/core';
import { LocationStrategy } from './location_strategy';
import { PlatformLocation } from './platform_location';
/**
 * \@publicApi
 * @record
 */
import * as ɵngcc0 from '@angular/core';
export function PopStateEvent() { }
if (false) {
    /** @type {?|undefined} */
    PopStateEvent.prototype.pop;
    /** @type {?|undefined} */
    PopStateEvent.prototype.state;
    /** @type {?|undefined} */
    PopStateEvent.prototype.type;
    /** @type {?|undefined} */
    PopStateEvent.prototype.url;
}
/**
 * \@description
 *
 * A service that applications can use to interact with a browser's URL.
 *
 * Depending on the `LocationStrategy` used, `Location` persists
 * to the URL's path or the URL's hash segment.
 *
 * \@usageNotes
 *
 * It's better to use the `Router#navigate` service to trigger route changes. Use
 * `Location` only if you need to interact with or create normalized URLs outside of
 * routing.
 *
 * `Location` is responsible for normalizing the URL against the application's base href.
 * A normalized URL is absolute from the URL host, includes the application's base href, and has no
 * trailing slash:
 * - `/my/app/user/123` is normalized
 * - `my/app/user/123` **is not** normalized
 * - `/my/app/user/123/` **is not** normalized
 *
 * ### Example
 *
 * <code-example path='common/location/ts/path_location_component.ts'
 * region='LocationComponent'></code-example>
 *
 * \@publicApi
 */
export class Location {
    /**
     * @param {?} platformStrategy
     * @param {?} platformLocation
     */
    constructor(platformStrategy, platformLocation) {
        /**
         * \@internal
         */
        this._subject = new EventEmitter();
        /**
         * \@internal
         */
        this._urlChangeListeners = [];
        this._platformStrategy = platformStrategy;
        /** @type {?} */
        const browserBaseHref = this._platformStrategy.getBaseHref();
        this._platformLocation = platformLocation;
        this._baseHref = Location.stripTrailingSlash(_stripIndexHtml(browserBaseHref));
        this._platformStrategy.onPopState((/**
         * @param {?} ev
         * @return {?}
         */
        (ev) => {
            this._subject.emit({
                'url': this.path(true),
                'pop': true,
                'state': ev.state,
                'type': ev.type,
            });
        }));
    }
    /**
     * Normalizes the URL path for this location.
     *
     * @param {?=} includeHash True to include an anchor fragment in the path.
     *
     * @return {?} The normalized URL path.
     */
    // TODO: vsavkin. Remove the boolean flag and always include hash once the deprecated router is
    // removed.
    path(includeHash = false) {
        return this.normalize(this._platformStrategy.path(includeHash));
    }
    /**
     * Reports the current state of the location history.
     * @return {?} The current value of the `history.state` object.
     */
    getState() { return this._platformLocation.getState(); }
    /**
     * Normalizes the given path and compares to the current normalized path.
     *
     * @param {?} path The given URL path.
     * @param {?=} query Query parameters.
     *
     * @return {?} True if the given URL path is equal to the current normalized path, false
     * otherwise.
     */
    isCurrentPathEqualTo(path, query = '') {
        return this.path() == this.normalize(path + Location.normalizeQueryParams(query));
    }
    /**
     * Normalizes a URL path by stripping any trailing slashes.
     *
     * @param {?} url String representing a URL.
     *
     * @return {?} The normalized URL string.
     */
    normalize(url) {
        return Location.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));
    }
    /**
     * Normalizes an external URL path.
     * If the given URL doesn't begin with a leading slash (`'/'`), adds one
     * before normalizing. Adds a hash if `HashLocationStrategy` is
     * in use, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.
     *
     * @param {?} url String representing a URL.
     *
     * @return {?} A normalized platform-specific URL.
     */
    prepareExternalUrl(url) {
        if (url && url[0] !== '/') {
            url = '/' + url;
        }
        return this._platformStrategy.prepareExternalUrl(url);
    }
    // TODO: rename this method to pushState
    /**
     * Changes the browser's URL to a normalized version of a given URL, and pushes a
     * new item onto the platform's history.
     *
     * @param {?} path  URL path to normalize.
     * @param {?=} query Query parameters.
     * @param {?=} state Location history state.
     *
     * @return {?}
     */
    go(path, query = '', state = null) {
        this._platformStrategy.pushState(state, '', path, query);
        this._notifyUrlChangeListeners(this.prepareExternalUrl(path + Location.normalizeQueryParams(query)), state);
    }
    /**
     * Changes the browser's URL to a normalized version of the given URL, and replaces
     * the top item on the platform's history stack.
     *
     * @param {?} path  URL path to normalize.
     * @param {?=} query Query parameters.
     * @param {?=} state Location history state.
     * @return {?}
     */
    replaceState(path, query = '', state = null) {
        this._platformStrategy.replaceState(state, '', path, query);
        this._notifyUrlChangeListeners(this.prepareExternalUrl(path + Location.normalizeQueryParams(query)), state);
    }
    /**
     * Navigates forward in the platform's history.
     * @return {?}
     */
    forward() { this._platformStrategy.forward(); }
    /**
     * Navigates back in the platform's history.
     * @return {?}
     */
    back() { this._platformStrategy.back(); }
    /**
     * Registers a URL change listener. Use to catch updates performed by the Angular
     * framework that are not detectible through "popstate" or "hashchange" events.
     *
     * @param {?} fn The change handler function, which take a URL and a location history state.
     * @return {?}
     */
    onUrlChange(fn) {
        this._urlChangeListeners.push(fn);
        this.subscribe((/**
         * @param {?} v
         * @return {?}
         */
        v => { this._notifyUrlChangeListeners(v.url, v.state); }));
    }
    /**
     * \@internal
     * @param {?=} url
     * @param {?=} state
     * @return {?}
     */
    _notifyUrlChangeListeners(url = '', state) {
        this._urlChangeListeners.forEach((/**
         * @param {?} fn
         * @return {?}
         */
        fn => fn(url, state)));
    }
    /**
     * Subscribes to the platform's `popState` events.
     *
     * @param {?} onNext
     * @param {?=} onThrow
     * @param {?=} onReturn
     * @return {?} Subscribed events.
     */
    subscribe(onNext, onThrow, onReturn) {
        return this._subject.subscribe({ next: onNext, error: onThrow, complete: onReturn });
    }
    /**
     * Normalizes URL parameters by prepending with `?` if needed.
     *
     * @param {?} params String of URL parameters.
     *
     * @return {?} The normalized URL parameters string.
     */
    static normalizeQueryParams(params) {
        return params && params[0] !== '?' ? '?' + params : params;
    }
    /**
     * Joins two parts of a URL with a slash if needed.
     *
     * @param {?} start  URL string
     * @param {?} end    URL string
     *
     *
     * @return {?} The joined URL string.
     */
    static joinWithSlash(start, end) {
        if (start.length == 0) {
            return end;
        }
        if (end.length == 0) {
            return start;
        }
        /** @type {?} */
        let slashes = 0;
        if (start.endsWith('/')) {
            slashes++;
        }
        if (end.startsWith('/')) {
            slashes++;
        }
        if (slashes == 2) {
            return start + end.substring(1);
        }
        if (slashes == 1) {
            return start + end;
        }
        return start + '/' + end;
    }
    /**
     * Removes a trailing slash from a URL string if needed.
     * Looks for the first occurrence of either `#`, `?`, or the end of the
     * line as `/` characters and removes the trailing slash if one exists.
     *
     * @param {?} url URL string.
     *
     * @return {?} The URL string, modified if needed.
     */
    static stripTrailingSlash(url) {
        /** @type {?} */
        const match = url.match(/#|\?|$/);
        /** @type {?} */
        const pathEndIdx = match && match.index || url.length;
        /** @type {?} */
        const droppedSlashIdx = pathEndIdx - (url[pathEndIdx - 1] === '/' ? 1 : 0);
        return url.slice(0, droppedSlashIdx) + url.slice(pathEndIdx);
    }
}
Location.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: Location, factory: function Location_Factory(t) { return new (t || Location)(ɵngcc0.ɵɵinject(LocationStrategy), ɵngcc0.ɵɵinject(PlatformLocation)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(Location, [{
        type: Injectable
    }], function () { return [{ type: LocationStrategy }, { type: PlatformLocation }]; }, { constructor: [], _subject: [], _urlChangeListeners: [], _platformStrategy: [], _platformLocation: [], _baseHref: [], path: [], getState: [], isCurrentPathEqualTo: [], normalize: [], prepareExternalUrl: [], go: [], replaceState: [], forward: [], back: [], onUrlChange: [], _notifyUrlChangeListeners: [], subscribe: [] });
/** @nocollapse */
Location.ctorParameters = () => [
    { type: LocationStrategy },
    { type: PlatformLocation }
];
if (false) {
    /**
     * \@internal
     * @type {?}
     */
    Location.prototype._subject;
    /**
     * \@internal
     * @type {?}
     */
    Location.prototype._baseHref;
    /**
     * \@internal
     * @type {?}
     */
    Location.prototype._platformStrategy;
    /**
     * \@internal
     * @type {?}
     */
    Location.prototype._platformLocation;
    /**
     * \@internal
     * @type {?}
     */
    Location.prototype._urlChangeListeners;
}
/**
 * @param {?} baseHref
 * @param {?} url
 * @return {?}
 */
function _stripBaseHref(baseHref, url) {
    return baseHref && url.startsWith(baseHref) ? url.substring(baseHref.length) : url;
}
/**
 * @param {?} url
 * @return {?}
 */
function _stripIndexHtml(url) {
    return url.replace(/\/index.html$/, '');
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL2VzbTIwMTUvc3JjL2xvY2F0aW9uL2xvY2F0aW9uLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1UUMsMlpBR0MiLCJmaWxlIjoibG9jYXRpb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IExvY2F0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL2xvY2F0aW9uX3N0cmF0ZWd5JztcclxuaW1wb3J0IHsgUGxhdGZvcm1Mb2NhdGlvbiB9IGZyb20gJy4vcGxhdGZvcm1fbG9jYXRpb24nO1xyXG4vKipcclxuICogXFxAcHVibGljQXBpXHJcbiAqIEByZWNvcmRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBQb3BTdGF0ZUV2ZW50KCkgeyB9XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqIEB0eXBlIHs/fHVuZGVmaW5lZH0gKi9cclxuICAgIFBvcFN0YXRlRXZlbnQucHJvdG90eXBlLnBvcDtcclxuICAgIC8qKiBAdHlwZSB7P3x1bmRlZmluZWR9ICovXHJcbiAgICBQb3BTdGF0ZUV2ZW50LnByb3RvdHlwZS5zdGF0ZTtcclxuICAgIC8qKiBAdHlwZSB7P3x1bmRlZmluZWR9ICovXHJcbiAgICBQb3BTdGF0ZUV2ZW50LnByb3RvdHlwZS50eXBlO1xyXG4gICAgLyoqIEB0eXBlIHs/fHVuZGVmaW5lZH0gKi9cclxuICAgIFBvcFN0YXRlRXZlbnQucHJvdG90eXBlLnVybDtcclxufVxyXG4vKipcclxuICogXFxAZGVzY3JpcHRpb25cclxuICpcclxuICogQSBzZXJ2aWNlIHRoYXQgYXBwbGljYXRpb25zIGNhbiB1c2UgdG8gaW50ZXJhY3Qgd2l0aCBhIGJyb3dzZXIncyBVUkwuXHJcbiAqXHJcbiAqIERlcGVuZGluZyBvbiB0aGUgYExvY2F0aW9uU3RyYXRlZ3lgIHVzZWQsIGBMb2NhdGlvbmAgcGVyc2lzdHNcclxuICogdG8gdGhlIFVSTCdzIHBhdGggb3IgdGhlIFVSTCdzIGhhc2ggc2VnbWVudC5cclxuICpcclxuICogXFxAdXNhZ2VOb3Rlc1xyXG4gKlxyXG4gKiBJdCdzIGJldHRlciB0byB1c2UgdGhlIGBSb3V0ZXIjbmF2aWdhdGVgIHNlcnZpY2UgdG8gdHJpZ2dlciByb3V0ZSBjaGFuZ2VzLiBVc2VcclxuICogYExvY2F0aW9uYCBvbmx5IGlmIHlvdSBuZWVkIHRvIGludGVyYWN0IHdpdGggb3IgY3JlYXRlIG5vcm1hbGl6ZWQgVVJMcyBvdXRzaWRlIG9mXHJcbiAqIHJvdXRpbmcuXHJcbiAqXHJcbiAqIGBMb2NhdGlvbmAgaXMgcmVzcG9uc2libGUgZm9yIG5vcm1hbGl6aW5nIHRoZSBVUkwgYWdhaW5zdCB0aGUgYXBwbGljYXRpb24ncyBiYXNlIGhyZWYuXHJcbiAqIEEgbm9ybWFsaXplZCBVUkwgaXMgYWJzb2x1dGUgZnJvbSB0aGUgVVJMIGhvc3QsIGluY2x1ZGVzIHRoZSBhcHBsaWNhdGlvbidzIGJhc2UgaHJlZiwgYW5kIGhhcyBub1xyXG4gKiB0cmFpbGluZyBzbGFzaDpcclxuICogLSBgL215L2FwcC91c2VyLzEyM2AgaXMgbm9ybWFsaXplZFxyXG4gKiAtIGBteS9hcHAvdXNlci8xMjNgICoqaXMgbm90Kiogbm9ybWFsaXplZFxyXG4gKiAtIGAvbXkvYXBwL3VzZXIvMTIzL2AgKippcyBub3QqKiBub3JtYWxpemVkXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIDxjb2RlLWV4YW1wbGUgcGF0aD0nY29tbW9uL2xvY2F0aW9uL3RzL3BhdGhfbG9jYXRpb25fY29tcG9uZW50LnRzJ1xyXG4gKiByZWdpb249J0xvY2F0aW9uQ29tcG9uZW50Jz48L2NvZGUtZXhhbXBsZT5cclxuICpcclxuICogXFxAcHVibGljQXBpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTG9jYXRpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHBsYXRmb3JtU3RyYXRlZ3lcclxuICAgICAqIEBwYXJhbSB7P30gcGxhdGZvcm1Mb2NhdGlvblxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwbGF0Zm9ybVN0cmF0ZWd5LCBwbGF0Zm9ybUxvY2F0aW9uKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogXFxAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9zdWJqZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFxcQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fdXJsQ2hhbmdlTGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5fcGxhdGZvcm1TdHJhdGVneSA9IHBsYXRmb3JtU3RyYXRlZ3k7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIGNvbnN0IGJyb3dzZXJCYXNlSHJlZiA9IHRoaXMuX3BsYXRmb3JtU3RyYXRlZ3kuZ2V0QmFzZUhyZWYoKTtcclxuICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uID0gcGxhdGZvcm1Mb2NhdGlvbjtcclxuICAgICAgICB0aGlzLl9iYXNlSHJlZiA9IExvY2F0aW9uLnN0cmlwVHJhaWxpbmdTbGFzaChfc3RyaXBJbmRleEh0bWwoYnJvd3NlckJhc2VIcmVmKSk7XHJcbiAgICAgICAgdGhpcy5fcGxhdGZvcm1TdHJhdGVneS5vblBvcFN0YXRlKCgvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IGV2XHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICAoZXYpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fc3ViamVjdC5lbWl0KHtcclxuICAgICAgICAgICAgICAgICd1cmwnOiB0aGlzLnBhdGgodHJ1ZSksXHJcbiAgICAgICAgICAgICAgICAncG9wJzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICdzdGF0ZSc6IGV2LnN0YXRlLFxyXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiBldi50eXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE5vcm1hbGl6ZXMgdGhlIFVSTCBwYXRoIGZvciB0aGlzIGxvY2F0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Pz19IGluY2x1ZGVIYXNoIFRydWUgdG8gaW5jbHVkZSBhbiBhbmNob3IgZnJhZ21lbnQgaW4gdGhlIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7P30gVGhlIG5vcm1hbGl6ZWQgVVJMIHBhdGguXHJcbiAgICAgKi9cclxuICAgIC8vIFRPRE86IHZzYXZraW4uIFJlbW92ZSB0aGUgYm9vbGVhbiBmbGFnIGFuZCBhbHdheXMgaW5jbHVkZSBoYXNoIG9uY2UgdGhlIGRlcHJlY2F0ZWQgcm91dGVyIGlzXHJcbiAgICAvLyByZW1vdmVkLlxyXG4gICAgcGF0aChpbmNsdWRlSGFzaCA9IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKHRoaXMuX3BsYXRmb3JtU3RyYXRlZ3kucGF0aChpbmNsdWRlSGFzaCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBvcnRzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBsb2NhdGlvbiBoaXN0b3J5LlxyXG4gICAgICogQHJldHVybiB7P30gVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGBoaXN0b3J5LnN0YXRlYCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGdldFN0YXRlKCkgeyByZXR1cm4gdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5nZXRTdGF0ZSgpOyB9XHJcbiAgICAvKipcclxuICAgICAqIE5vcm1hbGl6ZXMgdGhlIGdpdmVuIHBhdGggYW5kIGNvbXBhcmVzIHRvIHRoZSBjdXJyZW50IG5vcm1hbGl6ZWQgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gez99IHBhdGggVGhlIGdpdmVuIFVSTCBwYXRoLlxyXG4gICAgICogQHBhcmFtIHs/PX0gcXVlcnkgUXVlcnkgcGFyYW1ldGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHs/fSBUcnVlIGlmIHRoZSBnaXZlbiBVUkwgcGF0aCBpcyBlcXVhbCB0byB0aGUgY3VycmVudCBub3JtYWxpemVkIHBhdGgsIGZhbHNlXHJcbiAgICAgKiBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIGlzQ3VycmVudFBhdGhFcXVhbFRvKHBhdGgsIHF1ZXJ5ID0gJycpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoKCkgPT0gdGhpcy5ub3JtYWxpemUocGF0aCArIExvY2F0aW9uLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHF1ZXJ5KSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE5vcm1hbGl6ZXMgYSBVUkwgcGF0aCBieSBzdHJpcHBpbmcgYW55IHRyYWlsaW5nIHNsYXNoZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHs/fSB1cmwgU3RyaW5nIHJlcHJlc2VudGluZyBhIFVSTC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgbm9ybWFsaXplZCBVUkwgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBub3JtYWxpemUodXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIExvY2F0aW9uLnN0cmlwVHJhaWxpbmdTbGFzaChfc3RyaXBCYXNlSHJlZih0aGlzLl9iYXNlSHJlZiwgX3N0cmlwSW5kZXhIdG1sKHVybCkpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTm9ybWFsaXplcyBhbiBleHRlcm5hbCBVUkwgcGF0aC5cclxuICAgICAqIElmIHRoZSBnaXZlbiBVUkwgZG9lc24ndCBiZWdpbiB3aXRoIGEgbGVhZGluZyBzbGFzaCAoYCcvJ2ApLCBhZGRzIG9uZVxyXG4gICAgICogYmVmb3JlIG5vcm1hbGl6aW5nLiBBZGRzIGEgaGFzaCBpZiBgSGFzaExvY2F0aW9uU3RyYXRlZ3lgIGlzXHJcbiAgICAgKiBpbiB1c2UsIG9yIHRoZSBgQVBQX0JBU0VfSFJFRmAgaWYgdGhlIGBQYXRoTG9jYXRpb25TdHJhdGVneWAgaXMgaW4gdXNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7P30gdXJsIFN0cmluZyByZXByZXNlbnRpbmcgYSBVUkwuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7P30gQSBub3JtYWxpemVkIHBsYXRmb3JtLXNwZWNpZmljIFVSTC5cclxuICAgICAqL1xyXG4gICAgcHJlcGFyZUV4dGVybmFsVXJsKHVybCkge1xyXG4gICAgICAgIGlmICh1cmwgJiYgdXJsWzBdICE9PSAnLycpIHtcclxuICAgICAgICAgICAgdXJsID0gJy8nICsgdXJsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcGxhdGZvcm1TdHJhdGVneS5wcmVwYXJlRXh0ZXJuYWxVcmwodXJsKTtcclxuICAgIH1cclxuICAgIC8vIFRPRE86IHJlbmFtZSB0aGlzIG1ldGhvZCB0byBwdXNoU3RhdGVcclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgYnJvd3NlcidzIFVSTCB0byBhIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiBhIGdpdmVuIFVSTCwgYW5kIHB1c2hlcyBhXHJcbiAgICAgKiBuZXcgaXRlbSBvbnRvIHRoZSBwbGF0Zm9ybSdzIGhpc3RvcnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHs/fSBwYXRoICBVUkwgcGF0aCB0byBub3JtYWxpemUuXHJcbiAgICAgKiBAcGFyYW0gez89fSBxdWVyeSBRdWVyeSBwYXJhbWV0ZXJzLlxyXG4gICAgICogQHBhcmFtIHs/PX0gc3RhdGUgTG9jYXRpb24gaGlzdG9yeSBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBnbyhwYXRoLCBxdWVyeSA9ICcnLCBzdGF0ZSA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLl9wbGF0Zm9ybVN0cmF0ZWd5LnB1c2hTdGF0ZShzdGF0ZSwgJycsIHBhdGgsIHF1ZXJ5KTtcclxuICAgICAgICB0aGlzLl9ub3RpZnlVcmxDaGFuZ2VMaXN0ZW5lcnModGhpcy5wcmVwYXJlRXh0ZXJuYWxVcmwocGF0aCArIExvY2F0aW9uLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHF1ZXJ5KSksIHN0YXRlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgYnJvd3NlcidzIFVSTCB0byBhIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gVVJMLCBhbmQgcmVwbGFjZXNcclxuICAgICAqIHRoZSB0b3AgaXRlbSBvbiB0aGUgcGxhdGZvcm0ncyBoaXN0b3J5IHN0YWNrLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7P30gcGF0aCAgVVJMIHBhdGggdG8gbm9ybWFsaXplLlxyXG4gICAgICogQHBhcmFtIHs/PX0gcXVlcnkgUXVlcnkgcGFyYW1ldGVycy5cclxuICAgICAqIEBwYXJhbSB7Pz19IHN0YXRlIExvY2F0aW9uIGhpc3Rvcnkgc3RhdGUuXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICByZXBsYWNlU3RhdGUocGF0aCwgcXVlcnkgPSAnJywgc3RhdGUgPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5fcGxhdGZvcm1TdHJhdGVneS5yZXBsYWNlU3RhdGUoc3RhdGUsICcnLCBwYXRoLCBxdWVyeSk7XHJcbiAgICAgICAgdGhpcy5fbm90aWZ5VXJsQ2hhbmdlTGlzdGVuZXJzKHRoaXMucHJlcGFyZUV4dGVybmFsVXJsKHBhdGggKyBMb2NhdGlvbi5ub3JtYWxpemVRdWVyeVBhcmFtcyhxdWVyeSkpLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE5hdmlnYXRlcyBmb3J3YXJkIGluIHRoZSBwbGF0Zm9ybSdzIGhpc3RvcnkuXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmb3J3YXJkKCkgeyB0aGlzLl9wbGF0Zm9ybVN0cmF0ZWd5LmZvcndhcmQoKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBOYXZpZ2F0ZXMgYmFjayBpbiB0aGUgcGxhdGZvcm0ncyBoaXN0b3J5LlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgYmFjaygpIHsgdGhpcy5fcGxhdGZvcm1TdHJhdGVneS5iYWNrKCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGEgVVJMIGNoYW5nZSBsaXN0ZW5lci4gVXNlIHRvIGNhdGNoIHVwZGF0ZXMgcGVyZm9ybWVkIGJ5IHRoZSBBbmd1bGFyXHJcbiAgICAgKiBmcmFtZXdvcmsgdGhhdCBhcmUgbm90IGRldGVjdGlibGUgdGhyb3VnaCBcInBvcHN0YXRlXCIgb3IgXCJoYXNoY2hhbmdlXCIgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7P30gZm4gVGhlIGNoYW5nZSBoYW5kbGVyIGZ1bmN0aW9uLCB3aGljaCB0YWtlIGEgVVJMIGFuZCBhIGxvY2F0aW9uIGhpc3Rvcnkgc3RhdGUuXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBvblVybENoYW5nZShmbikge1xyXG4gICAgICAgIHRoaXMuX3VybENoYW5nZUxpc3RlbmVycy5wdXNoKGZuKTtcclxuICAgICAgICB0aGlzLnN1YnNjcmliZSgoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICB2ID0+IHsgdGhpcy5fbm90aWZ5VXJsQ2hhbmdlTGlzdGVuZXJzKHYudXJsLCB2LnN0YXRlKTsgfSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBcXEBpbnRlcm5hbFxyXG4gICAgICogQHBhcmFtIHs/PX0gdXJsXHJcbiAgICAgKiBAcGFyYW0gez89fSBzdGF0ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgX25vdGlmeVVybENoYW5nZUxpc3RlbmVycyh1cmwgPSAnJywgc3RhdGUpIHtcclxuICAgICAgICB0aGlzLl91cmxDaGFuZ2VMaXN0ZW5lcnMuZm9yRWFjaCgoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZm4gPT4gZm4odXJsLCBzdGF0ZSkpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlcyB0byB0aGUgcGxhdGZvcm0ncyBgcG9wU3RhdGVgIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gez99IG9uTmV4dFxyXG4gICAgICogQHBhcmFtIHs/PX0gb25UaHJvd1xyXG4gICAgICogQHBhcmFtIHs/PX0gb25SZXR1cm5cclxuICAgICAqIEByZXR1cm4gez99IFN1YnNjcmliZWQgZXZlbnRzLlxyXG4gICAgICovXHJcbiAgICBzdWJzY3JpYmUob25OZXh0LCBvblRocm93LCBvblJldHVybikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJqZWN0LnN1YnNjcmliZSh7IG5leHQ6IG9uTmV4dCwgZXJyb3I6IG9uVGhyb3csIGNvbXBsZXRlOiBvblJldHVybiB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTm9ybWFsaXplcyBVUkwgcGFyYW1ldGVycyBieSBwcmVwZW5kaW5nIHdpdGggYD9gIGlmIG5lZWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtcyBTdHJpbmcgb2YgVVJMIHBhcmFtZXRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7P30gVGhlIG5vcm1hbGl6ZWQgVVJMIHBhcmFtZXRlcnMgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgbm9ybWFsaXplUXVlcnlQYXJhbXMocGFyYW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcyAmJiBwYXJhbXNbMF0gIT09ICc/JyA/ICc/JyArIHBhcmFtcyA6IHBhcmFtcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSm9pbnMgdHdvIHBhcnRzIG9mIGEgVVJMIHdpdGggYSBzbGFzaCBpZiBuZWVkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHs/fSBzdGFydCAgVVJMIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHs/fSBlbmQgICAgVVJMIHN0cmluZ1xyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgam9pbmVkIFVSTCBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBqb2luV2l0aFNsYXNoKHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICBpZiAoc3RhcnQubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuZC5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICBsZXQgc2xhc2hlcyA9IDA7XHJcbiAgICAgICAgaWYgKHN0YXJ0LmVuZHNXaXRoKCcvJykpIHtcclxuICAgICAgICAgICAgc2xhc2hlcysrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kLnN0YXJ0c1dpdGgoJy8nKSkge1xyXG4gICAgICAgICAgICBzbGFzaGVzKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzbGFzaGVzID09IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0ICsgZW5kLnN1YnN0cmluZygxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNsYXNoZXMgPT0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhcnQgKyBlbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdGFydCArICcvJyArIGVuZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIHRyYWlsaW5nIHNsYXNoIGZyb20gYSBVUkwgc3RyaW5nIGlmIG5lZWRlZC5cclxuICAgICAqIExvb2tzIGZvciB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBlaXRoZXIgYCNgLCBgP2AsIG9yIHRoZSBlbmQgb2YgdGhlXHJcbiAgICAgKiBsaW5lIGFzIGAvYCBjaGFyYWN0ZXJzIGFuZCByZW1vdmVzIHRoZSB0cmFpbGluZyBzbGFzaCBpZiBvbmUgZXhpc3RzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7P30gdXJsIFVSTCBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7P30gVGhlIFVSTCBzdHJpbmcsIG1vZGlmaWVkIGlmIG5lZWRlZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHN0cmlwVHJhaWxpbmdTbGFzaCh1cmwpIHtcclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2goLyN8XFw/fCQvKTtcclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgY29uc3QgcGF0aEVuZElkeCA9IG1hdGNoICYmIG1hdGNoLmluZGV4IHx8IHVybC5sZW5ndGg7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIGNvbnN0IGRyb3BwZWRTbGFzaElkeCA9IHBhdGhFbmRJZHggLSAodXJsW3BhdGhFbmRJZHggLSAxXSA9PT0gJy8nID8gMSA6IDApO1xyXG4gICAgICAgIHJldHVybiB1cmwuc2xpY2UoMCwgZHJvcHBlZFNsYXNoSWR4KSArIHVybC5zbGljZShwYXRoRW5kSWR4KTtcclxuICAgIH1cclxufVxyXG5Mb2NhdGlvbi5kZWNvcmF0b3JzID0gW1xyXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH1cclxuXTtcclxuLyoqIEBub2NvbGxhcHNlICovXHJcbkxvY2F0aW9uLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xyXG4gICAgeyB0eXBlOiBMb2NhdGlvblN0cmF0ZWd5IH0sXHJcbiAgICB7IHR5cGU6IFBsYXRmb3JtTG9jYXRpb24gfVxyXG5dO1xyXG5pZiAoZmFsc2UpIHtcclxuICAgIC8qKlxyXG4gICAgICogXFxAaW50ZXJuYWxcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBMb2NhdGlvbi5wcm90b3R5cGUuX3N1YmplY3Q7XHJcbiAgICAvKipcclxuICAgICAqIFxcQGludGVybmFsXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTG9jYXRpb24ucHJvdG90eXBlLl9iYXNlSHJlZjtcclxuICAgIC8qKlxyXG4gICAgICogXFxAaW50ZXJuYWxcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBMb2NhdGlvbi5wcm90b3R5cGUuX3BsYXRmb3JtU3RyYXRlZ3k7XHJcbiAgICAvKipcclxuICAgICAqIFxcQGludGVybmFsXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTG9jYXRpb24ucHJvdG90eXBlLl9wbGF0Zm9ybUxvY2F0aW9uO1xyXG4gICAgLyoqXHJcbiAgICAgKiBcXEBpbnRlcm5hbFxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIExvY2F0aW9uLnByb3RvdHlwZS5fdXJsQ2hhbmdlTGlzdGVuZXJzO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IGJhc2VIcmVmXHJcbiAqIEBwYXJhbSB7P30gdXJsXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBfc3RyaXBCYXNlSHJlZihiYXNlSHJlZiwgdXJsKSB7XHJcbiAgICByZXR1cm4gYmFzZUhyZWYgJiYgdXJsLnN0YXJ0c1dpdGgoYmFzZUhyZWYpID8gdXJsLnN1YnN0cmluZyhiYXNlSHJlZi5sZW5ndGgpIDogdXJsO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHVybFxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gX3N0cmlwSW5kZXhIdG1sKHVybCkge1xyXG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC9cXC9pbmRleC5odG1sJC8sICcnKTtcclxufVxyIl19