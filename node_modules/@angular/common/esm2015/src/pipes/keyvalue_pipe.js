/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Injectable, KeyValueDiffers, Pipe } from '@angular/core';
/**
 * @template K, V
 * @param {?} key
 * @param {?} value
 * @return {?}
 */
import * as ɵngcc0 from '@angular/core';
function makeKeyValuePair(key, value) {
    return { key: key, value: value };
}
/**
 * A key value pair.
 * Usually used to represent the key value pairs from a Map or Object.
 *
 * \@publicApi
 * @record
 * @template K, V
 */
export function KeyValue() { }
if (false) {
    /** @type {?} */
    KeyValue.prototype.key;
    /** @type {?} */
    KeyValue.prototype.value;
}
/**
 * \@ngModule CommonModule
 * \@description
 *
 * Transforms Object or Map into an array of key value pairs.
 *
 * The output array will be ordered by keys.
 * By default the comparator will be by Unicode point value.
 * You can optionally pass a compareFn if your keys are complex types.
 *
 * \@usageNotes
 * ### Examples
 *
 * This examples show how an Object or a Map can be iterated by ngFor with the use of this keyvalue
 * pipe.
 *
 * {\@example common/pipes/ts/keyvalue_pipe.ts region='KeyValuePipe'}
 *
 * \@publicApi
 */
export class KeyValuePipe {
    /**
     * @param {?} differs
     */
    constructor(differs) {
        this.differs = differs;
        this.keyValues = [];
    }
    /**
     * @template K, V
     * @param {?} input
     * @param {?=} compareFn
     * @return {?}
     */
    transform(input, compareFn = defaultComparator) {
        if (!input || (!(input instanceof Map) && typeof input !== 'object')) {
            return null;
        }
        if (!this.differ) {
            // make a differ for whatever type we've been passed in
            this.differ = this.differs.find(input).create();
        }
        /** @type {?} */
        const differChanges = this.differ.diff((/** @type {?} */ (input)));
        if (differChanges) {
            this.keyValues = [];
            differChanges.forEachItem((/**
             * @param {?} r
             * @return {?}
             */
            (r) => {
                this.keyValues.push(makeKeyValuePair(r.key, (/** @type {?} */ (r.currentValue))));
            }));
            this.keyValues.sort(compareFn);
        }
        return this.keyValues;
    }
}
KeyValuePipe.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: KeyValuePipe, factory: function KeyValuePipe_Factory(t) { return new (t || KeyValuePipe)(ɵngcc0.ɵɵinject(KeyValueDiffers)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(KeyValuePipe, [{
        type: Injectable
    }, {
        type: Pipe,
        args: [{ name: 'keyvalue', pure: false }]
    }], function () { return [{ type: KeyValueDiffers }]; }, { constructor: [], differs: [], keyValues: [], transform: [], differ: [] });
KeyValuePipe.ngPipeDef = ɵngcc0.ɵɵdefinePipe({ name: "keyvalue", type: KeyValuePipe, factory: function KeyValuePipe_Factory(t) { return new (t || KeyValuePipe)(ɵngcc0.ɵɵdirectiveInject(KeyValueDiffers)); }, pure: false });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(KeyValuePipe, [{
        type: Injectable
    }, {
        type: Pipe,
        args: [{ name: 'keyvalue', pure: false }]
    }], function () { return [{ type: KeyValueDiffers }]; }, { constructor: [], differs: [], keyValues: [], transform: [], differ: [] });
/** @nocollapse */
KeyValuePipe.ctorParameters = () => [
    { type: KeyValueDiffers }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    KeyValuePipe.prototype.differ;
    /**
     * @type {?}
     * @private
     */
    KeyValuePipe.prototype.keyValues;
    /**
     * @type {?}
     * @private
     */
    KeyValuePipe.prototype.differs;
}
/**
 * @template K, V
 * @param {?} keyValueA
 * @param {?} keyValueB
 * @return {?}
 */
export function defaultComparator(keyValueA, keyValueB) {
    /** @type {?} */
    const a = keyValueA.key;
    /** @type {?} */
    const b = keyValueB.key;
    // if same exit with 0;
    if (a === b)
        return 0;
    // make sure that undefined are at the end of the sort.
    if (a === undefined)
        return 1;
    if (b === undefined)
        return -1;
    // make sure that nulls are at the end of the sort.
    if (a === null)
        return 1;
    if (b === null)
        return -1;
    if (typeof a == 'string' && typeof b == 'string') {
        return a < b ? -1 : 1;
    }
    if (typeof a == 'number' && typeof b == 'number') {
        return a - b;
    }
    if (typeof a == 'boolean' && typeof b == 'boolean') {
        return a < b ? -1 : 1;
    }
    // `a` and `b` are of different types. Compare their string values.
    /** @type {?} */
    const aString = String(a);
    /** @type {?} */
    const bString = String(b);
    return aString == bString ? 0 : aString < bString ? -1 : 1;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L0FuZ3VsYXIgUHJvamVjdC9EaWRleC9kaWRleC1hZG1pbi1wYW5lbC9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL2VzbTIwMTUvc3JjL3BpcGVzL2tleXZhbHVlX3BpcGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMkVDLHdJQUlDIiwiZmlsZSI6ImtleXZhbHVlX3BpcGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHsgSW5qZWN0YWJsZSwgS2V5VmFsdWVEaWZmZXJzLCBQaXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbi8qKlxyXG4gKiBAdGVtcGxhdGUgSywgVlxyXG4gKiBAcGFyYW0gez99IGtleVxyXG4gKiBAcGFyYW0gez99IHZhbHVlXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlS2V5VmFsdWVQYWlyKGtleSwgdmFsdWUpIHtcclxuICAgIHJldHVybiB7IGtleToga2V5LCB2YWx1ZTogdmFsdWUgfTtcclxufVxyXG4vKipcclxuICogQSBrZXkgdmFsdWUgcGFpci5cclxuICogVXN1YWxseSB1c2VkIHRvIHJlcHJlc2VudCB0aGUga2V5IHZhbHVlIHBhaXJzIGZyb20gYSBNYXAgb3IgT2JqZWN0LlxyXG4gKlxyXG4gKiBcXEBwdWJsaWNBcGlcclxuICogQHJlY29yZFxyXG4gKiBAdGVtcGxhdGUgSywgVlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEtleVZhbHVlKCkgeyB9XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgS2V5VmFsdWUucHJvdG90eXBlLmtleTtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIEtleVZhbHVlLnByb3RvdHlwZS52YWx1ZTtcclxufVxyXG4vKipcclxuICogXFxAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXHJcbiAqIFxcQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIFRyYW5zZm9ybXMgT2JqZWN0IG9yIE1hcCBpbnRvIGFuIGFycmF5IG9mIGtleSB2YWx1ZSBwYWlycy5cclxuICpcclxuICogVGhlIG91dHB1dCBhcnJheSB3aWxsIGJlIG9yZGVyZWQgYnkga2V5cy5cclxuICogQnkgZGVmYXVsdCB0aGUgY29tcGFyYXRvciB3aWxsIGJlIGJ5IFVuaWNvZGUgcG9pbnQgdmFsdWUuXHJcbiAqIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGEgY29tcGFyZUZuIGlmIHlvdXIga2V5cyBhcmUgY29tcGxleCB0eXBlcy5cclxuICpcclxuICogXFxAdXNhZ2VOb3Rlc1xyXG4gKiAjIyMgRXhhbXBsZXNcclxuICpcclxuICogVGhpcyBleGFtcGxlcyBzaG93IGhvdyBhbiBPYmplY3Qgb3IgYSBNYXAgY2FuIGJlIGl0ZXJhdGVkIGJ5IG5nRm9yIHdpdGggdGhlIHVzZSBvZiB0aGlzIGtleXZhbHVlXHJcbiAqIHBpcGUuXHJcbiAqXHJcbiAqIHtcXEBleGFtcGxlIGNvbW1vbi9waXBlcy90cy9rZXl2YWx1ZV9waXBlLnRzIHJlZ2lvbj0nS2V5VmFsdWVQaXBlJ31cclxuICpcclxuICogXFxAcHVibGljQXBpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgS2V5VmFsdWVQaXBlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBkaWZmZXJzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGRpZmZlcnMpIHtcclxuICAgICAgICB0aGlzLmRpZmZlcnMgPSBkaWZmZXJzO1xyXG4gICAgICAgIHRoaXMua2V5VmFsdWVzID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEB0ZW1wbGF0ZSBLLCBWXHJcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XHJcbiAgICAgKiBAcGFyYW0gez89fSBjb21wYXJlRm5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIHRyYW5zZm9ybShpbnB1dCwgY29tcGFyZUZuID0gZGVmYXVsdENvbXBhcmF0b3IpIHtcclxuICAgICAgICBpZiAoIWlucHV0IHx8ICghKGlucHV0IGluc3RhbmNlb2YgTWFwKSAmJiB0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmRpZmZlcikge1xyXG4gICAgICAgICAgICAvLyBtYWtlIGEgZGlmZmVyIGZvciB3aGF0ZXZlciB0eXBlIHdlJ3ZlIGJlZW4gcGFzc2VkIGluXHJcbiAgICAgICAgICAgIHRoaXMuZGlmZmVyID0gdGhpcy5kaWZmZXJzLmZpbmQoaW5wdXQpLmNyZWF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgY29uc3QgZGlmZmVyQ2hhbmdlcyA9IHRoaXMuZGlmZmVyLmRpZmYoKC8qKiBAdHlwZSB7P30gKi8gKGlucHV0KSkpO1xyXG4gICAgICAgIGlmIChkaWZmZXJDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMua2V5VmFsdWVzID0gW107XHJcbiAgICAgICAgICAgIGRpZmZlckNoYW5nZXMuZm9yRWFjaEl0ZW0oKC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IHJcclxuICAgICAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIChyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmtleVZhbHVlcy5wdXNoKG1ha2VLZXlWYWx1ZVBhaXIoci5rZXksICgvKiogQHR5cGUgez99ICovIChyLmN1cnJlbnRWYWx1ZSkpKSk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgdGhpcy5rZXlWYWx1ZXMuc29ydChjb21wYXJlRm4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5rZXlWYWx1ZXM7XHJcbiAgICB9XHJcbn1cclxuS2V5VmFsdWVQaXBlLmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcclxuICAgIHsgdHlwZTogUGlwZSwgYXJnczogW3sgbmFtZTogJ2tleXZhbHVlJywgcHVyZTogZmFsc2UgfSxdIH1cclxuXTtcclxuLyoqIEBub2NvbGxhcHNlICovXHJcbktleVZhbHVlUGlwZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcclxuICAgIHsgdHlwZTogS2V5VmFsdWVEaWZmZXJzIH1cclxuXTtcclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgS2V5VmFsdWVQaXBlLnByb3RvdHlwZS5kaWZmZXI7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgS2V5VmFsdWVQaXBlLnByb3RvdHlwZS5rZXlWYWx1ZXM7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgS2V5VmFsdWVQaXBlLnByb3RvdHlwZS5kaWZmZXJzO1xyXG59XHJcbi8qKlxyXG4gKiBAdGVtcGxhdGUgSywgVlxyXG4gKiBAcGFyYW0gez99IGtleVZhbHVlQVxyXG4gKiBAcGFyYW0gez99IGtleVZhbHVlQlxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRDb21wYXJhdG9yKGtleVZhbHVlQSwga2V5VmFsdWVCKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBjb25zdCBhID0ga2V5VmFsdWVBLmtleTtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIGNvbnN0IGIgPSBrZXlWYWx1ZUIua2V5O1xyXG4gICAgLy8gaWYgc2FtZSBleGl0IHdpdGggMDtcclxuICAgIGlmIChhID09PSBiKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgdW5kZWZpbmVkIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSBzb3J0LlxyXG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZClcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIGlmIChiID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgbnVsbHMgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIHNvcnQuXHJcbiAgICBpZiAoYSA9PT0gbnVsbClcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIGlmIChiID09PSBudWxsKVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIGlmICh0eXBlb2YgYSA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgYiA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogMTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgYSA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgYiA9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiBhIC0gYjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgYSA9PSAnYm9vbGVhbicgJiYgdHlwZW9mIGIgPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xyXG4gICAgfVxyXG4gICAgLy8gYGFgIGFuZCBgYmAgYXJlIG9mIGRpZmZlcmVudCB0eXBlcy4gQ29tcGFyZSB0aGVpciBzdHJpbmcgdmFsdWVzLlxyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgY29uc3QgYVN0cmluZyA9IFN0cmluZyhhKTtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIGNvbnN0IGJTdHJpbmcgPSBTdHJpbmcoYik7XHJcbiAgICByZXR1cm4gYVN0cmluZyA9PSBiU3RyaW5nID8gMCA6IGFTdHJpbmcgPCBiU3RyaW5nID8gLTEgOiAxO1xyXG59XHIiXX0=