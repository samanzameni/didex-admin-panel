{"version":3,"sources":["d:/Angular Project/Didex/didex-admin-panel/node_modules/@angular/animations/fesm2015/browser/testing.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA","file":"testing.js","sourcesContent":["/**\r\n * @license Angular v8.2.14\r\n * (c) 2010-2019 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { NoopAnimationPlayer, AUTO_STYLE } from '@angular/animations';\r\nimport { ɵvalidateStyleProperty, ɵmatchesElement, ɵcontainsElement, ɵinvokeQuery, ɵallowPreviousPlayerStylesMerge } from '@angular/animations/browser';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * \\@publicApi\r\n */\r\nclass MockAnimationDriver {\r\n    /**\r\n     * @param {?} prop\r\n     * @return {?}\r\n     */\r\n    validateStyleProperty(prop) { return ɵvalidateStyleProperty(prop); }\r\n    /**\r\n     * @param {?} element\r\n     * @param {?} selector\r\n     * @return {?}\r\n     */\r\n    matchesElement(element, selector) {\r\n        return ɵmatchesElement(element, selector);\r\n    }\r\n    /**\r\n     * @param {?} elm1\r\n     * @param {?} elm2\r\n     * @return {?}\r\n     */\r\n    containsElement(elm1, elm2) { return ɵcontainsElement(elm1, elm2); }\r\n    /**\r\n     * @param {?} element\r\n     * @param {?} selector\r\n     * @param {?} multi\r\n     * @return {?}\r\n     */\r\n    query(element, selector, multi) {\r\n        return ɵinvokeQuery(element, selector, multi);\r\n    }\r\n    /**\r\n     * @param {?} element\r\n     * @param {?} prop\r\n     * @param {?=} defaultValue\r\n     * @return {?}\r\n     */\r\n    computeStyle(element, prop, defaultValue) {\r\n        return defaultValue || '';\r\n    }\r\n    /**\r\n     * @param {?} element\r\n     * @param {?} keyframes\r\n     * @param {?} duration\r\n     * @param {?} delay\r\n     * @param {?} easing\r\n     * @param {?=} previousPlayers\r\n     * @return {?}\r\n     */\r\n    animate(element, keyframes, duration, delay, easing, previousPlayers = []) {\r\n        /** @type {?} */\r\n        const player = new MockAnimationPlayer(element, keyframes, duration, delay, easing, previousPlayers);\r\n        MockAnimationDriver.log.push((/** @type {?} */ (player)));\r\n        return player;\r\n    }\r\n}\r\nMockAnimationDriver.log = [];\r\nif (false) {\r\n    /** @type {?} */\r\n    MockAnimationDriver.log;\r\n}\r\n/**\r\n * \\@publicApi\r\n */\r\nclass MockAnimationPlayer extends NoopAnimationPlayer {\r\n    /**\r\n     * @param {?} element\r\n     * @param {?} keyframes\r\n     * @param {?} duration\r\n     * @param {?} delay\r\n     * @param {?} easing\r\n     * @param {?} previousPlayers\r\n     */\r\n    constructor(element, keyframes, duration, delay, easing, previousPlayers) {\r\n        super(duration, delay);\r\n        this.element = element;\r\n        this.keyframes = keyframes;\r\n        this.duration = duration;\r\n        this.delay = delay;\r\n        this.easing = easing;\r\n        this.previousPlayers = previousPlayers;\r\n        this.__finished = false;\r\n        this.__started = false;\r\n        this.previousStyles = {};\r\n        this._onInitFns = [];\r\n        this.currentSnapshot = {};\r\n        if (ɵallowPreviousPlayerStylesMerge(duration, delay)) {\r\n            previousPlayers.forEach((/**\r\n             * @param {?} player\r\n             * @return {?}\r\n             */\r\n            player => {\r\n                if (player instanceof MockAnimationPlayer) {\r\n                    /** @type {?} */\r\n                    const styles = player.currentSnapshot;\r\n                    Object.keys(styles).forEach((/**\r\n                     * @param {?} prop\r\n                     * @return {?}\r\n                     */\r\n                    prop => this.previousStyles[prop] = styles[prop]));\r\n                }\r\n            }));\r\n        }\r\n    }\r\n    /* @internal */\r\n    /**\r\n     * @param {?} fn\r\n     * @return {?}\r\n     */\r\n    onInit(fn) { this._onInitFns.push(fn); }\r\n    /* @internal */\r\n    /**\r\n     * @return {?}\r\n     */\r\n    init() {\r\n        super.init();\r\n        this._onInitFns.forEach((/**\r\n         * @param {?} fn\r\n         * @return {?}\r\n         */\r\n        fn => fn()));\r\n        this._onInitFns = [];\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    finish() {\r\n        super.finish();\r\n        this.__finished = true;\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    destroy() {\r\n        super.destroy();\r\n        this.__finished = true;\r\n    }\r\n    /* @internal */\r\n    /**\r\n     * @return {?}\r\n     */\r\n    triggerMicrotask() { }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    play() {\r\n        super.play();\r\n        this.__started = true;\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    hasStarted() { return this.__started; }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    beforeDestroy() {\r\n        /** @type {?} */\r\n        const captures = {};\r\n        Object.keys(this.previousStyles).forEach((/**\r\n         * @param {?} prop\r\n         * @return {?}\r\n         */\r\n        prop => {\r\n            captures[prop] = this.previousStyles[prop];\r\n        }));\r\n        if (this.hasStarted()) {\r\n            // when assembling the captured styles, it's important that\r\n            // we build the keyframe styles in the following order:\r\n            // {other styles within keyframes, ... previousStyles }\r\n            this.keyframes.forEach((/**\r\n             * @param {?} kf\r\n             * @return {?}\r\n             */\r\n            kf => {\r\n                Object.keys(kf).forEach((/**\r\n                 * @param {?} prop\r\n                 * @return {?}\r\n                 */\r\n                prop => {\r\n                    if (prop != 'offset') {\r\n                        captures[prop] = this.__finished ? kf[prop] : AUTO_STYLE;\r\n                    }\r\n                }));\r\n            }));\r\n        }\r\n        this.currentSnapshot = captures;\r\n    }\r\n}\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MockAnimationPlayer.prototype.__finished;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MockAnimationPlayer.prototype.__started;\r\n    /** @type {?} */\r\n    MockAnimationPlayer.prototype.previousStyles;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MockAnimationPlayer.prototype._onInitFns;\r\n    /** @type {?} */\r\n    MockAnimationPlayer.prototype.currentSnapshot;\r\n    /** @type {?} */\r\n    MockAnimationPlayer.prototype.element;\r\n    /** @type {?} */\r\n    MockAnimationPlayer.prototype.keyframes;\r\n    /** @type {?} */\r\n    MockAnimationPlayer.prototype.duration;\r\n    /** @type {?} */\r\n    MockAnimationPlayer.prototype.delay;\r\n    /** @type {?} */\r\n    MockAnimationPlayer.prototype.easing;\r\n    /** @type {?} */\r\n    MockAnimationPlayer.prototype.previousPlayers;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { MockAnimationDriver, MockAnimationPlayer };\r\n\r\n"]}